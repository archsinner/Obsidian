# The Julia Language

### The Julia Project

### February 8, 2022
## Contents
-   I Manual Contents ii
-   1 Julia 1.7 Documentation
-   2 Getting Started
    -   2.1 Resources
-   3 Variables
    -   3.1 Allowed Variable Names.
    -   3.2 Stylistic Conventions
-   4 Integers and Floating-Point Numbers
    -   4.1 Integers
    -   4.2 Floating-Point Numbers
    -   4.3 Arbitrary Precision Arithmetic.
    -   4.4 Numeric Literal Coefficients.
    -   4.5 Literal zero and one
-   5 Mathematical Operations and Elementary Functions
    -   5.1 Arithmetic Operators
    -   5.2 Boolean Operators.
    -   5.3 Bitwise Operators
    -   5.4 Updating operators
    -   5.5 Vectorized"dot" operators.
    -   5.6 Numeric Comparisons.
    -   5.7 Operator Precedence and Associativity
    -   5.8 Numerical Conversions
-   6 Complex and Rational Numbers
    -   6.1 Complex Numbers.
    -   6.2 Rational Numbers
-   7 Strings
    -   7.1 Characters.
    -   7.2 String Basics.
    -   7.3 Unicode and UTF-8
    -   7.4 Concatenation.
    -   7.5 Interpolation.
    -   7.6 Triple-Quoted String Literals. CONTENTS iii
    -   7.7 Common Operations.
    -   7.8 Non-Standard String Literals.
    -   7.9 Regular Expressions.
    -   7.10 Byte Array Literals.
    -   7.11 Version Number Literals.
    -   7.12 Raw String Literals.
-   8 Functions
    -   8.1 Argument Passing Behavior
    -   8.2 Argument-type declarations.
    -   8.3 ThereturnKeyword.
    -   8.4 Operators Are Functions.
    -   8.5 Operators With Special Names
    -   8.6 Anonymous Functions.
    -   8.7 Tuples
    -   8.8 Named Tuples
    -   8.9 Destructuring Assignment and Multiple Return Values
    -   8.10 Argument destructuring.
    -   8.11 Varargs Functions
    -   8.12 Optional Arguments.
    -   8.13 Keyword Arguments.
    -   8.14 Evaluation Scope of Default Values
    -   8.15 Do-Block Syntax for Function Arguments
    -   8.16 Function composition and piping
    -   8.17 Dot Syntax for Vectorizing Functions
    -   8.18 Further Reading
-   9 Control Flow
    -   9.1 Compound Expressions
    -   9.2 Conditional Evaluation.
    -   9.3 Short-Circuit Evaluation
    -   9.4 Repeated Evaluation: Loops.
    -   9.5 Exception Handling
    -   9.6 Tasks (aka Coroutines).
-   10 Scope of Variables
    -   10.1 Global Scope.
    -   10.2 Local Scope
    -   10.3 Constants
-   11 Types
    -   11.1 Type Declarations
    -   11.2 Abstract Types.
    -   11.3 Primitive Types.
    -   11.4 Composite Types.
    -   11.5 Mutable Composite Types.
    -   11.6 Declared Types
    -   11.7 Type Unions
    -   11.8 Parametric Types
    -   11.9 UnionAll Types.
    -   11.10Singleton types
    -   11.11Type{T}type selectors CONTENTS iv
    -   11.12Type Aliases
    -   11.13Operations on Types.
    -   11.14Custom pretty-printing
    -   11.15"Value types"
-   12 Methods
    -   12.1 Defining Methods
    -   12.2 Method Ambiguities
    -   12.3 Parametric Methods
    -   12.4 Redefining Methods
    -   12.5 Design Patterns with Parametric Methods.
    -   12.6 Parametrically-constrained Varargs methods
    -   12.7 Note on Optional and keyword Arguments
    -   12.8 Function-like objects.
    -   12.9 Empty generic functions.
    -   12.10Method design and the avoidance of ambiguities.
-   13 Constructors
    -   13.1 Outer Constructor Methods
    -   13.2 Inner Constructor Methods
    -   13.3 Incomplete Initialization.
    -   13.4 Parametric Constructors.
    -   13.5 Case Study: Rational
    -   13.6 Outer-only constructors
-   14 Conversion and Promotion
    -   14.1 Conversion.
    -   14.2 Promotion
-   15 Interfaces
    -   15.1 Iteration
    -   15.2 Indexing.
    -   15.3 Abstract Arrays
    -   15.4 Strided Arrays
    -   15.5 Customizing broadcasting.
-   16 Modules
    -   16.1 Namespace management.
    -   16.2 Submodules and relative paths
-   17 Documentation
    -   17.1 Accessing Documentation.
    -   17.2 Functions & Methods
    -   17.3 Advanced Usage.
    -   17.4 Syntax Guide
-   18 Metaprogramming
    -   18.1 Program representation
    -   18.2 Expressions and evaluation
    -   18.3 Macros.
    -   18.4 Code Generation.
    -   18.5 Non-Standard String Literals.
    -   18.6 Generated functions. CONTENTS v
-   19 Multi-dimensional Arrays
    -   19.1 Basic Functions
    -   19.2 Construction and Initialization.
    -   19.3 Array literals.
    -   19.4 Comprehensions.
    -   19.5 Generator Expressions.
    -   19.6 Indexing.
    -   19.7 Indexed Assignment.
    -   19.8 Supported index types.
    -   19.9 Iteration
    -   19.10Array traits.
    -   19.11Array and Vectorized Operators and Functions
    -   19.12Broadcasting.
    -   19.13Implementation
-   20 Missing Values
    -   20.1 Propagation of Missing Values.
    -   20.2 Equality and Comparison Operators.
    -   20.3 Logical operators
    -   20.4 Control Flow and Short-Circuiting Operators
    -   20.5 Arrays With Missing Values
    -   20.6 Skipping Missing Values.
    -   20.7 Logical Operations on Arrays
-   21 Networking and Streams
    -   21.1 Basic Stream I/O.
    -   21.2 Text I/O
    -   21.3 IO Output Contextual Properties.
    -   21.4 Working with Files
    -   21.5 A simple TCP example.
    -   21.6 Resolving IP Addresses
    -   21.7 Asynchronous I/O
-   22 Parallel Computing
-   23 Asynchronous Programming
    -   23.1 BasicTaskoperations.
    -   23.2 Communicating with Channels
    -   23.3 More task operations
    -   23.4 Tasks and events
-   24 Multi-Threading
    -   24.1 Starting Julia with multiple threads
    -   24.2 Data-race freedom.
    -   24.3 The@threadsMacro.
    -   24.4 Atomic Operations.
    -   24.5 Per-field atomics.
    -   24.6 Side effects and mutable function arguments.
    -   24.7 @threadcall
    -   24.8 Caveats
    -   24.9 Safe use of Finalizers
-   25 Multi-processing and Distributed Computing CONTENTS vi
    -   25.1 Code Availability and Loading Packages.
    -   25.2 Starting and managing worker processes.
    -   25.3 Data Movement
    -   25.4 Global variables
    -   25.5 Parallel Map and Loops
    -   25.6 Remote References and AbstractChannels
    -   25.7 Channels and RemoteChannels
    -   25.8 Local invocations
    -   25.9 Shared Arrays
    -   25.10ClusterManagers.
    -   25.11Specifying Network Topology (Experimental)
    -   25.12Noteworthy external packages
-   26 Running External Programs
    -   26.1 Interpolation.
    -   26.2 Quoting
    -   26.3 Pipelines.
    -   26.4 CmdObjects
-   27 Calling C and Fortran Code
    -   27.1 Creating C-Compatible Julia Function Pointers.
    -   27.2 Mapping C Types to Julia.
    -   27.3 Mapping C Functions to Julia.
    -   27.4 C Wrapper Examples
    -   27.5 Fortran Wrapper Example.
    -   27.6 Garbage Collection Safety.
    -   27.7 Non-constant Function Specifications
    -   27.8 Indirect Calls.
    -   27.9 Closure cfunctions.
    -   27.10Closing a Library.
    -   27.11Calling Convention.
    -   27.12Accessing Global Variables
    -   27.13Accessing Data through a Pointer.
    -   27.14Thread-safety
    -   27.15More About Callbacks
    -   27.16C++.
-   28 Handling Operating System Variation
-   29 Environment Variables
    -   29.1 File locations.
    -   29.2 External applications
    -   29.3 Parallelization
    -   29.4 REPL formatting
    -   29.5 Debugging and profiling.
-   30 Embedding Julia
    -   30.1 High-Level Embedding.
    -   30.2 High-Level Embedding on Windows with Visual Studio
    -   30.3 Converting Types
    -   30.4 Calling Julia Functions.
    -   30.5 Memory Management. CONTENTS vii
    -   30.6 Working with Arrays.
    -   30.7 Exceptions.
-   31 Code Loading
    -   31.1 Definitions.
    -   31.2 Federation of packages
    -   31.3 Environments
    -   31.4 Conclusion.
-   32 Profiling
    -   32.1 Basic usage
    -   32.2 Accumulation and clearing
    -   32.3 Options for controlling the display of profile results.
    -   32.4 Configuration
    -   32.5 Memory allocation analysis
    -   32.6 External Profiling.
-   33 Stack Traces
    -   33.1 Viewing a stack trace
    -   33.2 Extracting useful information
    -   33.3 Error handling
    -   33.4 Exception stacks andcurrent_exceptions.
    -   33.5 Comparison withbacktrace.
-   34 Performance Tips
    -   34.1 Performance critical code should be inside a function.
    -   34.2 Avoid global variables.
    -   34.3 Measure performance with@timeand pay attention to memory allocation.
    -   34.4 Tools.
    -   34.5 Avoid containers with abstract type parameters
    -   34.6 Type declarations
    -   34.7 Break functions into multiple definitions
    -   34.8 Write"type-stable" functions
    -   34.9 Avoid changing the type of a variable.
    -   34.10Separate kernel functions (aka, function barriers).
    -   34.11Types with values-as-parameters
    -   34.12The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)
    -   34.13Access arrays in memory order, along columns.
    -   34.14Pre-allocating outputs.
    -   34.15More dots: Fuse vectorized operations
    -   34.16Consider using views for slices
    -   34.17Copying data is not always bad
    -   34.18Consider StaticArrays.jl for small fixed-size vector/matrix operations.
    -   34.19Avoid string interpolation for I/O.
    -   34.20Optimize network I/O during parallel execution
    -   34.21Fix deprecation warnings
    -   34.22Tweaks.
    -   34.23Performance Annotations
    -   34.24Treat Subnormal Numbers as Zeros
    -   34.25@code_warntype.
    -   34.26Performance of captured variable.
-   35 Workflow Tips CONTENTS viii
    -   35.1 REPL-based workflow
    -   35.2 Browser-based workflow.
    -   35.3 Revise-based workflows.
-   36 Style Guide
    -   36.1 Indentation
    -   36.2 Write functions, not just scripts
    -   36.3 Avoid writing overly-specific types
    -   36.4 Handle excess argument diversity in the caller
    -   36.5 Append!to names of functions that modify their arguments
    -   36.6 Avoid strange typeUnions
    -   36.7 Avoid elaborate container types.
    -   36.8 Prefer exported methods over direct field access.
    -   36.9 Use naming conventions consistent with Juliabase/
    -   36.10Write functions with argument ordering similar to Julia Base
    -   36.11Don't overuse try-catch
    -   36.12Don't parenthesize conditions.
    -   36.13Don't overuse...
    -   36.14Don't use unnecessary static parameters.
    -   36.15Avoid confusion about whether something is an instance or a type.
    -   36.16Don't overuse macros.
    -   36.17Don't expose unsafe operations at the interface level
    -   36.18Don't overload methods of base container types
    -   36.19Avoid type piracy
    -   36.20Be careful with type equality
    -   36.21Do not writex->f(x)
    -   36.22Avoid using floats for numeric literals in generic code when possible.
-   37 Frequently Asked Questions
    -   37.1 General
    -   37.2 Public API
    -   37.3 Sessions and the REPL.
    -   37.4 Scripting.
    -   37.5 Functions
    -   37.6 Types, type declarations, and constructors
    -   37.7 Troubleshooting"method not matched": parametric type invariance andMethodErrors
    -   37.8 Packages and Modules.
    -   37.9 Nothingness and missing values
    -   37.10Memory
    -   37.11Asynchronous IO and concurrent synchronous writes.
    -   37.12Arrays
    -   37.13Computing cluster.
    -   37.14Julia Releases
-   38 Noteworthy Differences from other Languages
    -   38.1 Noteworthy differences from MATLAB.
    -   38.2 Noteworthy differences from R
    -   38.3 Noteworthy differences from Python
    -   38.4 Noteworthy differences from C/C++
    -   38.5 Noteworthy differences from Common Lisp
-   39 Unicode Input CONTENTS ix
-   40 Command-line Options
-   II Base
-   41 Essentials
    -   41.1 Introduction
    -   41.2 Getting Around
    -   41.3 Keywords
    -   41.4 Standard Modules
    -   41.5 Base Submodules
    -   41.6 All Objects.
    -   41.7 Properties of Types
    -   41.8 Special Types
    -   41.9 Generic Functions
    -   41.10Syntax.
    -   41.11Missing Values.
    -   41.12System.
    -   41.13Versioning
    -   41.14Errors
    -   41.15Events
    -   41.16Reflection
    -   41.17Internals.
    -   41.18Meta.
-   42 Collections and Data Structures
    -   42.1 Iteration
    -   42.2 Constructors and Types
    -   42.3 General Collections
    -   42.4 Iterable Collections
    -   42.5 Indexable Collections
    -   42.6 Dictionaries
    -   42.7 Set-Like Collections
    -   42.8 Dequeues
    -   42.9 Utility Collections
-   43 Mathematics
    -   43.1 Mathematical Operators.
    -   43.2 Mathematical Functions
-   44 Examples
    -   44.1 Customizable binary operators
-   45 Numbers
    -   45.1 Standard Numeric Types.
    -   45.2 Data Formats
    -   45.3 General Number Functions and Constants
    -   45.4 BigFloats and BigInts
-   46 Strings
-   47 Arrays CONTENTS x
    -   47.1 Constructors and Types
    -   47.2 Basic functions
    -   47.3 Broadcast and vectorization.
    -   47.4 Indexing and assignment
    -   47.5 Views (SubArrays and other view types)
    -   47.6 Concatenation and permutation.
    -   47.7 Array functions
    -   47.8 Combinatorics.
-   48 Tasks
    -   48.1 Scheduling.
    -   48.2 Synchronization
    -   48.3 Channels.
-   49 Multi-Threading
    -   49.1 Synchronization
    -   49.2 Atomic operations
    -   49.3 ccall using a threadpool (Experimental).
    -   49.4 Low-level synchronization primitives
-   50 Constants
-   51 Filesystem
-   52 I/O and Network
    -   52.1 General I/O
    -   52.2 Text I/O
    -   52.3 Multimedia I/O.
    -   52.4 Network I/O
-   53 Punctuation
-   54 Sorting and Related Functions
    -   54.1 Sorting Functions
    -   54.2 Order-Related Functions.
    -   54.3 Sorting Algorithms.
    -   54.4 Alternate orderings
-   55 Iteration utilities
-   56 C Interface
-   57 LLVM Interface
-   58 C Standard Library
-   59 StackTraces
-   60 SIMD Support
-   III Standard Library CONTENTS xi
-   61 Artifacts
-   62 Base64
-   63 CRC32c
-   64 Dates
    -   64.1 Constructors.
    -   64.2 Durations/Comparisons
    -   64.3 Accessor Functions
    -   64.4 Query Functions.
    -   64.5 TimeType-Period Arithmetic
    -   64.6 Adjuster Functions.
    -   64.7 Period Types.
    -   64.8 Rounding
-   65 API reference
    -   65.1 Dates and Time Types.
    -   65.2 Dates Functions
-   66 Delimited Files
-   67 Distributed Computing
    -   67.1 Cluster Manager Interface.
-   68 Downloads
-   69 File Events
-   70 Future
-   71 Interactive Utilities
-   72 Lazy Artifacts
-   73 LibGit2
-   74 Dynamic Linker
-   75 Linear Algebra
    -   75.1 Special matrices.
    -   75.2 Matrix factorizations.
    -   75.3 Standard functions
    -   75.4 Low-level matrix operations.
    -   75.5 BLAS functions.
    -   75.6 LAPACK functions
-   76 Logging
    -   76.1 Log event structure
    -   76.2 Processing log events
    -   76.3 Testing log events
    -   76.4 Environment variables.
    -   76.5 Examples CONTENTS xii
    -   76.6 Reference
-   77 Markdown
    -   77.1 Inline elements
    -   77.2 Toplevel elements
    -   77.3 Markdown Syntax Extensions
-   78 Memory-mapped I/O
-   79 Pkg
-   80 Printf
-   81 Profiling
-   82 The Julia REPL
    -   82.1 The different prompt modes.
    -   82.2 Key bindings.
    -   82.3 Tab completion
    -   82.4 Customizing Colors
    -   82.5 TerminalMenus.
    -   82.6 References.
-   83 Random Numbers
    -   83.1 Random numbers module.
    -   83.2 Random generation functions.
    -   83.3 Subsequences, permutations and shuffling
    -   83.4 Generators (creation and seeding)
    -   83.5 Hooking into theRandomAPI
-   84 Reproducibility
-   85 SHA
-   86 Serialization
-   87 Shared Arrays
-   88 Sockets
-   89 Sparse Arrays
    -   89.1 Compressed Sparse Column (CSC) Sparse Matrix Storage
    -   89.2 Sparse Vector Storage.
    -   89.3 Sparse Vector and Matrix Constructors
    -   89.4 Sparse matrix operations
    -   89.5 Correspondence of dense and sparse methods
-   90 Sparse Arrays
-   91 Statistics
-   92 Sparse Linear Algebra
-   93 TOML CONTENTS xiii
    -   93.1 Parsing TOML data.
    -   93.2 Exporting data to TOML file
    -   93.3 References.
-   94 Unit Testing
    -   94.1 Testing Base Julia
    -   94.2 Basic Unit Tests
    -   94.3 Working with Test Sets.
    -   94.4 Other Test Macros
    -   94.5 Broken Tests.
    -   94.6 Creating CustomAbstractTestSetTypes
    -   94.7 Test utilities
-   95 UUIDs
-   96 Unicode
-   IV Developer Documentation
-   97 Reflection and introspection
    -   97.1 Module bindings.
    -   97.2 DataType fields
    -   97.3 Subtypes.
    -   97.4 DataType layout.
    -   97.5 Function methods
    -   97.6 Expansion and lowering.
    -   97.7 Intermediate and compiled representations.
-   98 Documentation of Julia’s Internals
    -   98.1 Initialization of the Julia runtime.
    -   98.2 Julia ASTs.
    -   98.3 More about types
    -   98.4 Memory layout of Julia Objects
    -   98.5 Eval of Julia code
    -   98.6 Calling Conventions
    -   98.7 High-level Overview of the Native-Code Generation Process
    -   98.8 Julia Functions
    -   98.9 Base.Cartesian.
    -   98.10Talking to the compiler (the:metamechanism).
    -   98.11SubArrays
    -   98.12isbits Union Optimizations.
    -   98.13System Image Building
    -   98.14Working with LLVM.
    -   98.15printf() and stdio in the Julia runtime
    -   98.16Bounds checking
    -   98.17Proper maintenance and care of multi-threading locks
    -   98.18Arrays with custom indices
    -   98.19Module loading
    -   98.20Inference.
    -   98.21Julia SSA-form IR.
    -   98.22Static analyzer annotations for GC correctness in C code. CONTENTS xiv
-   99 Developing/debugging Julia’s C code
    -   99.1 Reporting and analyzing crashes (segfaults)
    -   99.2 gdb debugging tips
    -   99.3 Using Valgrind with Julia.
    -   99.4 Sanitizer support
-   V Julia v1.7 Release Notes
-   100New language features
-   101Language changes
-   102Compiler/Runtime improvements
-   103Command-line option changes
-   104Multi-threading changes
-   105Build system changes
-   106New library functions
-   107New library features
-   108Standard library changes
-   109Deprecated or removed
-   110External dependencies
-   111Tooling Improvements

**Part I**

**Manual**

#### 1

**Chapter 1**

**Julia 1.7 Documentation**

Welcome to the documentation for Julia 1.7.

Please read therelease notesto see what has changed since the last release.

```
Note
The documentation is also available in PDF format:julia-1.7.2.pdf.
```

### Introduction

Scientific computing has traditionally required the highest performance, yet domain experts have largely  
movedtoslowerdynamiclanguagesfordailywork. Webelievetherearemanygoodreasonstopreferdynamic  
languagesfortheseapplications,andwedonotexpecttheirusetodiminish. Fortunately,modernlanguagede-  
sign and compiler techniques make it possible to mostly eliminate the performance trade-off and provide a sin-  
gle environment productive enough for prototyping and efficient enough for deploying performance-intensive  
applications. The Julia programming language fills this role: it is a flexible dynamic language, appropriate for  
scientific and numerical computing, with performance comparable to traditional statically-typed languages.

Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find  
that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading  
through thePerformance Tipssection before trying anything else. Once you understand how Julia works, it's  
easy to write code that's nearly as fast as C.

Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and  
just-in-time (JIT) compilation, implemented usingLLVM. It is multi-paradigm, combining features of imperative,  
functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical  
computing, in the same way as languages such as R, MATLAB, and Python, but also supports general program-  
ming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows  
much from popular dynamic languages, includingLisp, Perl , Python, Lua , and Ruby.

The most significant departures of Julia from typical dynamic languages are:

-   The core language imposes very little; Julia Base and the standard library are written in Julia itself,  
    including primitive operations like integer arithmetic
-   A rich language of types for constructing and describing objects, that can also optionally be used to  
    make type declarations
-   Theabilitytodefinefunctionbehavioracrossmanycombinationsofargumenttypesviamultipledispatch
-   Automatic generation of efficient, specialized code for different argument types

#### 2

#### CHAPTER 1. JULIA 1.7 DOCUMENTATION 3

-   Good performance, approaching that of statically-compiled languages like C

Although one sometimes speaks of dynamic languages as being"typeless", they are definitely not: every  
object, whetherprimitiveoruser-defined, hasatype. Thelackoftypedeclarationsinmostdynamiclanguages,  
however, means that one cannot instruct the compiler about the types of values, and often cannot explicitly  
talk about types at all. In static languages, on the other hand, while one can – and usually must – annotate  
types for the compiler, types exist only at compile time and cannot be manipulated or expressed at run time.  
In Julia, types are themselves run-time objects, and can also be used to convey information to the compiler.

While the casual programmer need not explicitly use types or multiple dispatch, they are the core unifying  
featuresofJulia: functionsaredefinedondifferentcombinationsofargumenttypes,andappliedbydispatching  
to the most specific matching definition. This model is a good fit for mathematical programming, where it is  
unnatural for the first argument to"own" an operation as in traditional object-oriented dispatch. Operators  
are just functions with special notation – to extend addition to new user-defined data types, you define new  
methods for the+function. Existing code then seamlessly applies to the new data types.

Partly because of run-time type inference (augmented by optional type annotations), and partly because of a  
strong focus on performance from the inception of the project, Julia's computational efficiency exceeds that  
of other dynamic languages, and even rivals that of statically-compiled languages. For large scale numerical  
problems, speed always has been, continues to be, and probably always will be crucial: the amount of data  
being processed has easily kept pace with Moore's Law over the past decades.

Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language.  
In addition to the above, some advantages of Julia over comparable systems include:

-   Free and open source (MIT licensed)
-   User-defined types are as fast and compact as built-ins
-   No need to vectorize code for performance; devectorized code is fast
-   Designed for parallelism and distributed computation
-   Lightweight"green " threading (coroutines)
-   Unobtrusive yet powerful type system
-   Elegant and extensible conversions and promotions for numeric and other types
-   Efficient support forUnicode, including but not limited toUTF-
-   Call C functions directly (no wrappers or special APIs needed)
-   Powerful shell-like capabilities for managing other processes
-   Lisp-like macros and other metaprogramming facilities

**Chapter 2**

**Getting Started**

Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download  
and install Julia by following the instructions athttps://julialang.org/downloads/.

If you are coming to Julia from one of the following languages, then you should start by reading the section  
on noteworthy differences fromMATLAB, R, Python, C/C++or Common Lisp. This will help you avoid some  
common pitfalls since Julia differs from those languages in many subtle ways.

The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-  
eval-print loop or"REPL") by double-clicking the Julia executable or runningjuliafrom the command line:

```
$ julia
```

```
_
_ _ _(_)_ | Documentation: https://docs.julialang.org
(_) | (_) (_) |
_ _ _| |_ __ _ | Type "?" for help, "]?" for Pkg help.
| | | | | | |/ _` | |
| | |_| | | | (_| | | Version 1.7.2 (2022-02-06)
_/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release
|__/ |
```

```
julia> 1 + 2
3
```

```
julia> ans
3
```

To exit the interactive session, typeCTRL-D(press the Control/^key together with thedkey), or typeexit().  
When run in interactive mode,juliadisplays a banner and prompts the user for input. Once the user has  
entered a complete expression, such as1 + 2, and hits enter, the interactive session evaluates the expression  
and shows its value. If an expression is entered into an interactive session with a trailing semicolon, its value  
is not shown. The variableansis bound to the value of the last evaluated expression whether it is shown or  
not. Theansvariable is only bound in interactive sessions, not when Julia code is run in other ways.

To evaluate expressions written in a source filefile.jl, writeinclude("file.jl").

To run code in a file non-interactively, you can give it as the first argument to thejuliacommand:

```
$ julia script.jl arg1 arg2...
```

As the example implies, the following command-line arguments tojuliaare interpreted as command-line  
arguments to the programscript.jl, passed in the global constantARGS. The name of the script itself is

#### 4

#### CHAPTER 2. GETTING STARTED 5

passed in as the globalPROGRAM_FILE. Note thatARGSis also set when a Julia expression is given using the-e  
option on the command line (see thejuliahelp output below) butPROGRAM_FILEwill be empty. For example,  
to just print the arguments given to a script, you could do this:

```
$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar
```

```
foo
bar
```

Or you could put that code into a script and run it:

```
$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl
$ julia script.jl foo bar
script.jl
foo
bar
```

The--delimiter can be used to separate command-line arguments intended for the script file from arguments  
intended for Julia:

```
$ julia --color=yes -O -- script.jl arg1 arg2..
```

See alsoScriptingfor more information on writing Julia scripts.

Julia can be started in parallel mode with either the-por the--machine-fileoptions.-p nwill launch an  
additionalnworker processes, while--machine-file filewill launch a worker for each line in filefile.  
The machines defined infilemust be accessible via a password-lesssshlogin, with Julia installed at the  
same location as the current host. Each machine definition takes the form[count*][user@]host[:port]  
[bind_addr[:port]].userdefaults to current user,portto the standard ssh port.countis the number of  
workers to spawn on the node, and defaults to 1. The optionalbind-to bind_addr[:port]specifies the IP  
address and port that other workers should use to connect to this worker.

IfyouhavecodethatyouwantexecutedwheneverJuliaisrun,youcanputitin~/.julia/config/startup.jl:

```
$ echo 'println("Greetings!! ?")' > ~/.julia/config/startup.jl
$ julia
Greetings!!?
```

Note that although you should have a~/.juliadirectory once you've run Julia for the first time, you may need  
to create the~/.julia/configfolder and the~/.julia/config/startup.jlfile if you use it.

There are various ways to run Julia code and provide options, similar to those available for theperlandruby  
programs:

```
julia [switches] -- [programfile] [args...]
```

A detailed list of all the available switches can be found atCommand-line Options.

### 2.1 Resources

A curated list of useful learning resources to help new users get started can be found on thelearningpage of  
the main Julia web site.

If you already know Julia a bit, you might want to peek ahead atPerformance Tipsand Workflow Tips.

**Chapter 3**

**Variables**

A variable, in Julia, is a name associated (or bound) to a value. It's useful when you want to store a value (that  
you obtained after some math, for example) for later use. For example:

```
# Assign the value 10 to the variable x
julia> x = 10
10
```

```
# Doing math with x's value
julia> x + 1
11
```

```
# Reassign x's value
julia> x = 1 + 1
2
```

```
# You can assign values of other types, like strings of text
julia> x = "Hello World!"
"Hello World!"
```

Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have  
no semantic meaning (that is, the language will not treat variables differently based on their names).

```
julia> x = 1.
1.
```

```
julia> y = -
```

```
julia> Z = "My string"
"My string"
```

```
julia> customary_phrase= "Hello world!"
"Hello world!"
```

```
julia> UniversalDeclarationOfHumanRightsStart= ""
""
```

Unicode names (in UTF-8 encoding) are allowed:

#### 6

#### CHAPTER 3. VARIABLES 7

```
julia> δ = 0.00001
1.0e-5
```

```
julia> = "Hello"
"Hello"
```

In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by  
typing the backslashed LaTeX symbol name followed by tab. For example, the variable nameδcan be entered  
by typing\delta-tab, or evenα̂⁽²⁾by\alpha-tab-\hat- tab-^(2)-tab. (If you find a symbol somewhere, e.g.  
in someone else's code, that you don't know how to type, the REPL help will tell you: just type?and then  
paste the symbol.)

Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to  
avoid potential confusions):

```
julia> pi = 3
3
```

```
julia> pi
3
```

```
julia> sqrt= 4
4
```

However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:

```
julia> pi
π = 3.1415926535897...
```

```
julia> pi = 3
ERROR: cannot assign a value to variable MathConstants.pi from module Main
```

```
julia> sqrt(100)
10.0
```

```
julia> sqrt= 4
ERROR: cannot assign a value to variable Base.sqrt from module Main
```

### 3.1 Allowed Variable Names.

Variable names must begin with a letter (A-Z or a-z), underscore, or a subset of Unicode code points greater  
than 00A0; in particular,Unicode character categoriesLu/Ll/Lt/Lm/Lo/Nl (letters), Sc/So (currency and other  
symbols), and a few other letter-like characters (e.g. a subset of the Sm math symbols) are allowed. Sub-  
sequent characters may also include! and digits (0-9 and other characters in categories Nd/No), as well as  
other Unicode code points: diacritics and other modifying marks (categories Mn/Mc/Me/Sk), some punctuation  
connectors (category Pc), primes, and a few other characters.

Operatorslike+arealsovalididentifiers, butareparsedspecially. Insomecontexts, operatorscanbeusedjust  
like variables; for example(+)refers to the addition function, and(+) = fwill reassign it. Most of the Unicode  
infix operators (in category Sm), such as⊕, are parsed as infix operators and are available for user-defined  
methods (e.g. you can useconst ⊗ = kronto define⊗as an infix Kronecker product). Operators can also  
be suffixed with modifying marks, primes, and sub/superscripts, e.g.+̂ₐ′′is parsed as an infix operator with  
the same precedence as+. A space is required between an operator that ends with a subscript/superscript

#### CHAPTER 3. VARIABLES 8

letter and a subsequent variable name. For example, if+ᵃis an operator, then+ᵃxmust be written as+ᵃ xto  
distinguish it from+ ᵃxwhereᵃxis the variable name.

A particular class of variable names is one that contains only underscores. These identifiers can only be  
assigned values but cannot be used to assign values to other variables. More technically, they can only be  
used as anL-value, but not as anR-value:

```
julia> x, ___= size([2 2; 1 1])
(2, 2)
```

```
julia> y = ___
ERROR: syntax: all-underscore identifier used as rvalue
```

The only explicitly disallowed names for variables are the names of the built-inKeywords:

```
julia>else = false
ERROR: syntax: unexpected "else"
```

```
julia>try = "No"
ERROR: syntax: unexpected "="
```

Some Unicode characters are considered to be equivalent in identifiers. Different ways of entering Unicode  
combiningcharacters(e.g.,accents)aretreatedasequivalent(specifically,JuliaidentifiersareNFC-normalized).  
Julia also includes a few non-standard equivalences for characters that are visually similar and are easily en-  
tered by some input methods. The Unicode charactersɛ(U+025B: Latin small letter open e) andμ(U+00B5:  
micro sign) are treated as equivalent to the corresponding Greek letters. The middle dot·(U+00B7) and the  
Greek interpunct·(U+0387) are both treated as the mathematical dot operator⋅(U+22C5). The minus sign  
−(U+2212) is treated as equivalent to the hyphen-minus sign-(U+002D).

### 3.2 Stylistic Conventions

While Julia imposes few restrictions on valid names, it has become useful to adopt the following conventions:

-   Names of variables are in lower case.
-   Word separation can be indicated by underscores ('_'), but use of underscores is discouraged unless  
    the name would be hard to read otherwise.
-   Names ofTypes andModules begin with a capital letter and word separation is shown with upper camel  
    case instead of underscores.
-   Names offunctions andmacros are in lower case, without underscores.
-   Functions that write to their arguments have names that end in!. These are sometimes called"mutat-  
    ing" or "in-place" functions because they are intended to produce changes in their arguments after the  
    function is called, not just return a value.

For more information about stylistic conventions, see theStyle Guide.

**Chapter 4**

**Integers and Floating-Point Numbers**

Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in repre-  
sentations of such values are called numeric primitives, while representations of integers and floating-point  
numbers as immediate values in code are known as numeric literals. For example, 1 is an integer literal, while  
1.0is a floating-point literal; their binary in-memory representations as objects are numeric primitives.

Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise opera-  
tors as well as standardmathematical functions are defined over them. These map directly onto numeric types  
and operations that are natively supported on modern computers, thus allowing Julia to take full advantage  
of computational resources. Additionally, Julia provides software support forArbitrary Precision Arithmetic,  
which can handle operations on numeric values that cannot be represented effectively in native hardware  
representations, but at the cost of relatively slower performance.

The following are Julia's primitive numeric types:

-   **Integer types:**

```
Type Signed? Number of bits Smallest value Largest value
Int8 ✓ 8 -2^7 2^7 - 1
UInt8 8 0 2^8 - 1
Int16 ✓ 16 -2^15 2^15 - 1
UInt16 16 0 2^16 - 1
Int32 ✓ 32 -2^31 2^31 - 1
UInt32 32 0 2^32 - 1
Int64 ✓ 64 -2^63 2^63 - 1
UInt64 64 0 2^64 - 1
Int128 ✓ 128 -2^127 2^127 - 1
UInt128 128 0 2^128 - 1
Bool N/A 8 false(0) true(1)
```

-   **Floating-point types:**

Additionally, full support forComplex and Rational Numbersis built on top of these primitive numeric types.  
All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensibletype  
promotion system.

#### 9

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 10

```
Type Precision Number of bits
Float16 half 16
Float32 single 32
Float64 double 64
```

### 4.1 Integers

Literal integers are represented in the standard manner:

```
julia> 1
1
```

```
julia> 1234
1234
```

The default type for an integer literal depends on whether the target system has a 32-bit architecture or a  
64-bit architecture:

```
# 32-bit system:
julia> typeof(1)
Int32
```

```
# 64-bit system:
julia> typeof(1)
Int64
```

The Julia internal variableSys.WORD_SIZEindicates whether the target system is 32-bit or 64-bit:

```
# 32-bit system:
julia> Sys.WORD_SIZE
32
```

```
# 64-bit system:
julia> Sys.WORD_SIZE
64
```

JuliaalsodefinesthetypesIntandUInt, whicharealiasesforthesystem'ssignedandunsignednativeinteger  
types respectively:

```
# 32-bit system:
julia>Int
Int32
julia>UInt
UInt32
```

```
# 64-bit system:
julia>Int
Int64
julia>UInt
UInt64
```

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 11

Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always  
create 64-bit integers, regardless of the system type:

```
# 32-bit or 64-bit system:
julia> typeof( 3000000000 )
Int64
```

Unsigned integers are input and output using the0xprefix and hexadecimal (base 16) digits0-9a-f(the  
capitalized digitsA-Falso work for input). The size of the unsigned value is determined by the number of hex  
digits used:

```
julia> x = 0x1
0x01
```

```
julia> typeof(x)
UInt8
```

```
julia> x = 0x123
0x0123
```

```
julia> typeof(x)
UInt16
```

```
julia> x = 0x1234567
0x01234567
```

```
julia> typeof(x)
UInt32
```

```
julia> x = 0x123456789abcdef
0x0123456789abcdef
```

```
julia> typeof(x)
UInt64
```

```
julia> x = 0x11112222333344445555666677778888
0x11112222333344445555666677778888
```

```
julia> typeof(x)
UInt128
```

This behavior is based on the observation that when one uses unsigned hex literals for integer values, one  
typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.

Binary and octal literals are also supported:

```
julia> x = 0b10
0x02
```

```
julia> typeof(x)
UInt8
```

```
julia> x = 0o010
0x08
```

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 12

```
julia> typeof(x)
UInt8
```

```
julia> x = 0x00000000000000001111222233334444
0x00000000000000001111222233334444
```

```
julia> typeof(x)
UInt128
```

As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary  
data item is the minimal needed size, if the leading digit of the literal is not 0. In the case of leading zeros,  
the size is determined by the minimal needed size for a literal, which has the same length but leading digit 1.  
That allows the user to control the size. Values which cannot be stored inUInt128cannot be written as such  
literals.

Binary, octal, and hexadecimal literals may be signed by a-immediately preceding the unsigned literal. They  
produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of  
the value:

```
julia> -0x2
0xfe
```

```
julia> -0x0002
0xfffe
```

The minimum and maximum representable values of primitive numeric types such as integers are given by  
thetypeminandtypemaxfunctions:

```
julia> (typemin( Int32 ), typemax( Int32 ))
(-2147483648, 2147483647)
```

```
julia>for T in [ Int8 , Int16 , Int32 , Int64 , Int128 , UInt8 , UInt16 , UInt32 , UInt64 , UInt128 ]
println(" $ (lpad(T,7)): [ $ (typemin(T)), $ (typemax(T))]")
end
Int8: [-128,127]
Int16: [-32768,32767]
Int32: [-2147483648,2147483647]
Int64: [-9223372036854775808,9223372036854775807]
Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
UInt8: [0,255]
UInt16: [0,65535]
UInt32: [0,4294967295]
UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
```

The values returned bytypeminandtypemaxare always of the given argument type. (The above expression  
uses several features that have yet to be introduced, includingfor loops, Strings, and Interpolation, but should  
be easy enough to understand for users with some existing programming experience.)

### Overflow behavior

In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 13

```
julia> x = typemax( Int64 )
9223372036854775807
```

```
julia> x + 1
-9223372036854775808
```

```
julia> x + 1 == typemin( Int64 )
true
```

Thus, arithmetic with Julia integers is actually a form ofmodular arithmetic. This reflects the characteristics of  
the underlying arithmetic of integers as implemented on modern computers. In applications where overflow  
is possible, explicit checking for wraparound produced by overflow is essential; otherwise, theBigInttype in  
Arbitrary Precision Arithmeticis recommended instead.

An example of overflow behavior and how to potentially resolve it is as follows:

```
julia> 10^19
-8446744073709551616
```

```
julia> big(10)^19
10000000000000000000
```

### Division errors

Integerdivision(thedivfunction)hastwoexceptionalcases: dividingbyzero, anddividingthelowestnegative  
number (typemin) by -1. Both of these cases throw aDivideError. The remainder and modulus functions  
(remandmod) throw aDivideErrorwhen their second argument is zero.

### 4.2 Floating-Point Numbers

Literal floating-point numbers are represented in the standard formats, usingE-notationwhen necessary:

```
julia> 1.0
1.0
```

```
julia> 1.
1.0
```

```
julia> 0.5
0.5
```

```
julia> .5
0.5
```

```
julia> -1.23
-1.23
```

```
julia> 1e10
1.0e10
```

```
julia> 2.5e-4
0.00025
```

The above results are allFloat64values. LiteralFloat32values can be entered by writing anfin place ofe:

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 14

```
julia> x = 0.5f0
0.5f0
```

```
julia> typeof(x)
Float32
```

```
julia> 2.5f-4
0.00025f0
```

Values can be converted toFloat32easily:

```
julia> x = Float32 (-1.5)
-1.5f0
```

```
julia> typeof(x)
Float32
```

Hexadecimal floating-point literals are also valid, but only asFloat64values, withppreceding the base-2  
exponent:

```
julia> 0x1p0
1.0
```

```
julia> 0x1.8p3
12.0
```

```
julia> x = 0x.4p-1
0.125
```

```
julia> typeof(x)
Float64
```

Half-precision floating-point numbers are also supported (Float16), but they are implemented in software and  
useFloat32for calculations.

```
julia> sizeof( Float16 (4.))
2
```

```
julia> 2* Float16 (4.)
Float16(8.0)
```

The underscore_can be used as digit separator:

```
julia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
```

### Floating-point zero

Floating-point numbers havetwo zeros, positive zero and negative zero. They are equal to each other but have  
different binary representations, as can be seen using thebitstringfunction:

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 15

```
julia> 0.0 == -0.0
true
```

```
julia> bitstring(0.0)
"0000000000000000000000000000000000000000000000000000000000000000"
```

```
julia> bitstring(-0.0)
"1000000000000000000000000000000000000000000000000000000000000000"
```

### Special floating-point values

There are three specified standard floating-point values that do not correspond to any point on the real number  
line:

```
Float16 Float32 Float64 Name Description
Inf16 Inf32 Inf positive infinity a value greater than all finite floating-point values
-Inf16 -Inf32 -Inf negative
infinity
```

```
a value less than all finite floating-point values
```

```
NaN16 NaN32 NaN not a number a value not==to any floating-point value (including
itself)
```

For further discussion of how these non-finite floating-point values are ordered with respect to each other and  
other floats, seeNumeric Comparisons. By theIEEE 754 standard, these floating-point values are the results  
of certain arithmetic operations:

```
julia> 1/Inf
0.0
```

```
julia> 1/0
Inf
```

```
julia> -5/0
-Inf
```

```
julia> 0.000001/0
Inf
```

```
julia> 0/0
NaN
```

```
julia> 500 + Inf
Inf
```

```
julia> 500 - Inf
-Inf
```

```
julia> Inf + Inf
Inf
```

```
julia> Inf - Inf
NaN
```

```
julia> Inf * Inf
Inf
```

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 16

```
julia> Inf / Inf
NaN
```

```
julia> 0 * Inf
NaN
```

```
julia> NaN == NaN
false
```

```
julia> NaN != NaN
true
```

```
julia> NaN < NaN
false
```

```
julia> NaN > NaN
false
```

Thetypeminandtypemaxfunctions also apply to floating-point types:

```
julia> (typemin( Float16 ),typemax( Float16 ))
(-Inf16, Inf16)
```

```
julia> (typemin( Float32 ),typemax( Float32 ))
(-Inf32, Inf32)
```

```
julia> (typemin( Float64 ),typemax( Float64 ))
(-Inf, Inf)
```

### Machine epsilon

Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it  
is important to know the distance between two adjacent representable floating-point numbers, which is often  
known asmachine epsilon.

Juliaprovideseps,whichgivesthedistancebetween1.0andthenextlargerrepresentablefloating-pointvalue:

```
julia> eps( Float32 )
1.1920929f-7
```

```
julia> eps( Float64 )
2.220446049250313e-16
```

```
julia> eps()# same as eps(Float64)
2.220446049250313e-16
```

These values are2.0^-23and2.0^-52asFloat32andFloat64values, respectively. Theepsfunction can  
also take a floating-point value as an argument, and gives the absolute difference between that value and the  
next representable floating point value. That is,eps(x)yields a value of the same type asxsuch thatx +  
eps(x)is the next representable floating-point value larger thanx:

```
julia> eps(1.0)
2.220446049250313e-16
```

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 17

```
julia> eps(1000.)
1.1368683772161603e-13
```

```
julia> eps(1e-27)
1.793662034335766e-43
```

```
julia> eps(0.0)
5.0e-324
```

The distance between two adjacent representable floating-point numbers is not constant, but is smaller for  
smaller values and larger for larger values. In other words, the representable floating-point numbers are  
densest in the real number line near zero, and grow sparser exponentially as one moves farther away from  
zero. By definition,eps(1.0)is the same aseps(Float64)since1.0is a 64-bit floating-point value.

Julia also provides thenextfloatandprevfloatfunctions which return the next largest or smallest repre-  
sentable floating-point number to the argument respectively:

```
julia> x = 1.25f0
1.25f0
```

```
julia> nextfloat(x)
1.2500001f0
```

```
julia> prevfloat(x)
1.2499999f0
```

```
julia> bitstring(prevfloat(x))
"00111111100111111111111111111111"
```

```
julia> bitstring(x)
"00111111101000000000000000000000"
```

```
julia> bitstring(nextfloat(x))
"00111111101000000000000000000001"
```

This example highlights the general principle that the adjacent representable floating-point numbers also have  
adjacent binary integer representations.

### Rounding modes

If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate repre-  
sentable value. However, the manner in which this rounding is done can be changed if required according to  
the rounding modes presented in theIEEE 754 standard.

The default mode used is alwaysRoundNearest, which rounds to the nearest representable value, with ties  
rounded towards the nearest value with an even least significant bit.

### Background and References

Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the  
low-level implementation details. However, these subtleties are described in detail in most books on scientific  
computation, and also in the following references:

-   The definitive guide to floating point arithmetic is theIEEE 754-2008 Standard; however, it is not avail-  
    able for free online.

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 18

-   For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's  
    articleonthesubjectaswellashisintroductiontosomeoftheissuesarisingfromhowthisrepresentation  
    differs in behavior from the idealized abstraction of real numbers.
-   Also recommended is Bruce Dawson's series of blog posts on floating-point numbers.
-   Foranexcellent, in-depthdiscussionoffloating-pointnumbersandissuesofnumericalaccuracyencoun-  
    tered when computing with them, see David Goldberg's paperWhat Every Computer Scientist Should  
    Know About Floating-Point Arithmetic.
-   For even more extensive documentation of the history of, rationale for, and issues with floating-point  
    numbers, as well as discussion of many other topics in numerical computing, see thecollected writings  
    of William Kahan, commonly known as the"Father of Floating-Point". Of particular interest may beAn  
    Interview with the Old Man of Floating-Point.

### 4.3 Arbitrary Precision Arithmetic.

Toallowcomputationswitharbitrary-precisionintegersandfloatingpointnumbers,JuliawrapstheGNUMultiple  
Precision Arithmetic Library (GMP)and theGNU MPFR Library, respectively. TheBigIntandBigFloattypes  
are available in Julia for arbitrary precision integer and floating point numbers respectively.

Constructors exist to create these types from primitive numerical types, and thestring literal@big_stror  
parsecan be used to construct them fromAbstractStrings.BigInts can also be input as integer literals  
when they are too big for other built-in integer types. Note that as there is no unsigned arbitrary-precision  
integer type inBase(BigIntis sufficient in most cases), hexadecimal, octal and binary literals can be used (in  
addition to decimal literals).

Once created, they participate in arithmetic with all other numeric types thanks to Julia's type promotion and  
conversion mechanism:

```
julia>BigInt (typemax( Int64 )) + 1
9223372036854775808
```

```
julia> big"123456789012345678901234567890"+ 1
123456789012345678901234567891
```

```
julia> parse( BigInt , "123456789012345678901234567890") + 1
123456789012345678901234567891
```

```
julia> string(big"2"^200, base=16)
"100000000000000000000000000000000000000000000000000"
```

```
julia> 0x100000000000000000000000000000000-1 == typemax( UInt128 )
true
```

```
julia> 0x000000000000000000000000000000000
0
```

```
julia> typeof(ans)
BigInt
```

```
julia> big"1.23456789012345678901"
1.234567890123456789010000000000000000000000000000000000000000000000000000000004
```

```
julia> parse( BigFloat , "1.23456789012345678901")
```

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 19

```
1.234567890123456789010000000000000000000000000000000000000000000000000000000004
```

```
julia>BigFloat (2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19
```

```
julia> factorial( BigInt (40))
815915283247897734345611269596115894272000000000
```

However, type promotion between the primitive types above andBigInt/BigFloatis not automatic and must  
be explicitly stated.

```
julia> x = typemin( Int64 )
-9223372036854775808
```

```
julia> x = x - 1
9223372036854775807
```

```
julia> typeof(x)
Int64
```

```
julia> y = BigInt (typemin( Int64 ))
-9223372036854775808
```

```
julia> y = y - 1
-9223372036854775809
```

```
julia> typeof(y)
BigInt
```

The default precision (in number of bits of the significand) and rounding mode ofBigFloatoperations can  
be changed globally by callingsetprecisionandsetrounding, and all further calculations will take these  
changes in account. Alternatively, the precision or the rounding can be changed only within the execution of  
a particular block of code by using the same functions with adoblock:

```
julia> setrounding( BigFloat , RoundUp) do
BigFloat (1) + parse( BigFloat , "0.1")
end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003
```

```
julia> setrounding( BigFloat , RoundDown) do
BigFloat (1) + parse( BigFloat , "0.1")
end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986
```

```
julia> setprecision(40) do
BigFloat (1) + parse( BigFloat , "0.1")
end
1.1000000000004
```

### 4.4 Numeric Literal Coefficients.

To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded  
by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 20

```
julia> x = 3
3
```

```
julia> 2x^2 - 3x + 1
10
```

```
julia> 1.5x^2 - .5x + 1
13.0
```

It also makes writing exponential functions more elegant:

```
julia> 2^2x
64
```

The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation.  
So-2xis parsed as(-2) * xand√2xis parsed as(√2) * x. However, numeric literal coefficients parse  
similarly to unary operators when combined with exponentiation. For example2^3xis parsed as2^(3x), and  
2x^3is parsed as2*(x^3).

Numeric literals also work as coefficients to parenthesized expressions:

```
julia> 2(x-1)^2 - 3(x-1) + 1
3
```

```
Note
The precedence of numeric literal coefficients used for implicit multiplication is higher than other
binary operators such as multiplication (*), and division (/,\, and//). This means, for example,
that1 / 2imequals-0.5imand6 // 2(2 + 1)equals1 // 1.
```

Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the  
expression by the variable:

```
julia> (x-1)x
6
```

Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expres-  
sion, however, can be used to imply multiplication:

```
julia> (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable
```

```
julia> x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
```

Both expressions are interpreted as function application: any expression that is not a numeric literal, when  
immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see  
Functionsfor more about functions). Thus, in both of these cases, an error occurs since the left-hand value is  
not a function.

The above syntactic enhancements significantly reduce the visual noise incurred when writing common math-  
ematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier  
or parenthesized expression which it multiplies.

#### CHAPTER 4. INTEGERS AND FLOATING-POINT NUMBERS 21

### Syntax Conflicts

Juxtaposed literal coefficient syntax may conflict with some numeric literal syntaxes: hexadecimal, octal and  
binary integer literals and engineering notation for floating-point literals. Here are some situations where  
syntactic conflicts arise:

-   The hexadecimal integer literal expression0xffcould be interpreted as the numeric literal 0 multiplied  
    by the variablexff. Similar ambiguities arise with octal and binary literals like0o777or0b01001010.
-   The floating-point literal expression1e10could be interpreted as the numeric literal 1 multiplied by the  
    variablee10, and similarly with the equivalentEform.
-   The 32-bit floating-point literal expression1.5f22could be interpreted as the numeric literal1.5multi-  
    plied by the variablef22.

In all cases the ambiguity is resolved in favor of interpretation as numeric literals:

-   Expressions starting with0x/0o/0bare always hexadecimal/octal/binary literals.
-   Expressions starting with a numeric literal followed byeorEare always floating-point literals.
-   Expressions starting with a numeric literal followed byfare always 32-bit floating-point literals.

UnlikeE, which is equivalent toein numeric literals for historical reasons,Fis just another letter and does  
not behave likefin numeric literals. Hence, expressions starting with a numeric literal followed byFare  
interpreted as the numerical literal multiplied by a variable, which means that, for example,1.5F22is equal  
to1.5 * F22.

### 4.5 Literal zero and one

Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given  
variable.

```
Function Description
zero(x) Literal zero of typexor type of variablex
one(x) Literal one of typexor type of variablex
```

These functions are useful inNumeric Comparisonsto avoid overhead from unnecessarytype conversion.

Examples:

```
julia> zero( Float32 )
0.0f0
```

```
julia> zero(1.0)
0.0
```

```
julia> one( Int32 )
1
```

```
julia> one( BigFloat )
1.0
```

**Chapter 5**

**Mathematical Operations and Elementary**

**Functions**

Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primi-  
tive types, as well as providing portable, efficient implementations of a comprehensive collection of standard  
mathematical functions.

### 5.1 Arithmetic Operators

The followingarithmetic operatorsare supported on all primitive numeric types:

```
Expression Name Description
+x unary plus the identity operation
-x unary minus maps values to their additive inverses
x + y binary plus performs addition
x - y binary minus performs subtraction
x * y times performs multiplication
x / y divide performs division
x ÷ y integer divide x / y, truncated to an integer
x \ y inverse divide equivalent toy / x
x ^ y power raisesxto theyth power
x % y remainder equivalent torem(x,y)
```

A numeric literal placed directly before an identifier or parentheses, e.g.2xor2(x+y), is treated as a mul-  
tiplication, except with higher precedence than other binary operations. SeeNumeric Literal Coefficientsfor  
details.

Julia's promotion system makes arithmetic operations on mixtures of argument types"just work" naturally and  
automatically. SeeConversion and Promotionfor details of the promotion system.

The ÷ sign can be conveniently typed by writing\divto the REPL or Julia IDE. See themanual section  
on Unicode inputfor more information.

Here are some simple examples using arithmetic operators:

```
julia> 1 + 2 + 3
6
```

```
julia> 1 - 2
```

#### 22

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 23

```
-1
```

```
julia> 3*2/12
0.5
```

(By convention, we tend to space operators more tightly if they get applied before other nearby operators.  
For instance, we would generally write-x + 2to reflect that firstxgets negated, and then 2 is added to that  
result.)

When used in multiplication,falseacts as a strong zero:

```
julia> NaN * false
0.0
```

```
julia>false * Inf
0.0
```

This is useful for preventing the propagation ofNaNvalues in quantities that are known to be zero. SeeKnuth  
(1992)for motivation.

### 5.2 Boolean Operators.

The followingBoolean operatorsare supported onBooltypes:

```
Expression Name
!x negation
x && y short-circuiting and
x || y short-circuiting or
```

Negation changestruetofalseand vice versa. The short-circuiting opeations are explained on the linked  
page.

Note thatBoolis an integer type and all the usual promotion rules and numeric operators are also defined on  
it.

### 5.3 Bitwise Operators

The followingbitwise operatorsare supported on all primitive integer types:

```
Expression Name
~x bitwise not
x & y bitwise and
x | y bitwise or
x⊻y bitwise xor (exclusive or)
x y bitwise nand (not and)
x y bitwise nor (not or)
x >>> y logical shiftright
x >> y arithmetic shiftright
x << y logical/arithmetic shift left
```

Here are some examples with bitwise operators:

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 24

```
julia> ~123
-124
```

```
julia> 123 & 234
106
```

```
julia> 123 | 234
251
```

```
julia> 123 ⊻ 234
145
```

```
julia> xor(123, 234)
145
```

```
julia> nand(123, 123)
-124
```

```
julia> 123 123
-124
```

```
julia> nor(123, 124)
-128
```

```
julia> 123 124
-128
```

```
julia> ~ UInt32 (123)
0xffffff84
```

```
julia> ~ UInt8 (123)
0x84
```

### 5.4 Updating operators

Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the opera-  
tionbackintoitsleftoperand. Theupdatingversionofthebinaryoperatorisformedbyplacinga=immediately  
after the operator. For example, writingx += 3is equivalent to writingx = x + 3:

```
julia> x = 1
1
```

```
julia> x += 3
4
```

```
julia> x
4
```

The updating versions of all the binary arithmetic and bitwise operators are:

```
+= -= *= /= \= ÷= %= ^= &= |= ⊻= >>>= >>= <<=
```

```
Note
Anupdatingoperatorrebindsthevariableontheleft-handside. Asaresult,thetypeofthevariable
may change.
```

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 25

```
julia> x = 0x01; typeof(x)
UInt8
```

```
julia> x *= 2 # Same as x = x * 2
2
```

```
julia> typeof(x)
Int64
```

### 5.5 Vectorized"dot" operators.

For every binary operation like^, there is a corresponding"dot" operation.^that is automatically defined to  
perform^element-by-element on arrays. For example,[1,2,3] ^ 3is not defined, since there is no stan-  
dard mathematical meaning to"cubing" a (non-square) array, but[1,2,3] .^ 3is defined as computing the  
elementwise (or"vectorized") result[1^3, 2^3, 3^3]. Similarly for unary operators like!or√, there is a  
corresponding.√that applies the operator elementwise.

```
julia> [1,2,3] .^ 3
3-element Vector{Int64}:
1
8
27
```

More specifically,a .^ bis parsed as the"dot" call(^).(a,b), which performs abroadcastoperation: it  
can combine arrays and scalars, arrays of the same size (performing the operation elementwise), and even  
arrays of different shapes (e.g. combining row and column vectors to produce a matrix). Moreover, like all  
vectorized"dot calls," these "dot operators" are fusing. For example, if you compute2 .* A.^2 .+ sin.(A)  
(or equivalently@. 2A^2 + sin(A), using the@. macro) for an arrayA, it performs a single loop overA,  
computing2a^2 + sin(a)for each elementaofA. In particular, nested dot calls likef.(g.(x))are fused,  
and "adjacent" binary operators likex .+ 3 .* x.^2are equivalent to nested dot calls(+).(x, (*).(3,  
(^).(x, 2))).

Furthermore,"dotted" updating operators likea .+= b(or@. a += b) are parsed asa .= a .+ b, where.=  
is a fused in-place assignment operation (see thedot syntax documentation).

Notethedotsyntaxisalsoapplicabletouser-definedoperators. Forexample,ifyoudefine⊗(A,B) = kron(A,B)  
to give a convenient infix syntaxA ⊗ Bfor Kronecker products (kron), then[A,B] .⊗ [C,D]will compute  
[A⊗C, B⊗D]with no additional coding.

Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether1.+x  
means1. + xor1 .+ x. Therefore this syntax is disallowed, and spaces must be used around the operator  
in such cases.

### 5.6 Numeric Comparisons.

Standard comparison operations are defined for all the primitive numeric types:

Here are some simple examples:

```
julia> 1 == 1
true
```

```
julia> 1 == 2
false
```

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 26

```
Operator Name
== equality
!=,≠ inequality
< less than
<=,≤ less than or equal to
> greater than
>=,≥ greater than or equal to
```

```
julia> 1 != 2
true
```

```
julia> 1 == 1.0
true
```

```
julia> 1 < 2
true
```

```
julia> 1.0 > 3
false
```

```
julia> 1 >= 1.0
true
```

```
julia> -1 <= 1
true
```

```
julia> -1 <= -1
true
```

```
julia> -1 <= -2
false
```

```
julia> 3 < -0.5
false
```

Integers are compared in the standard manner – by comparison of bits. Floating-point numbers are compared  
according to theIEEE 754 standard:

-   Finite numbers are ordered in the usual manner.
-   Positive zero is equal but not greater than negative zero.
-   Infis equal to itself and greater than everything else exceptNaN.
-   -Infis equal to itself and less than everything else exceptNaN.
-   NaNis not equal to, not less than, and not greater than anything, including itself.

The last point is potentially surprising and thus worth noting:

```
julia> NaN == NaN
false
```

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 27

```
julia> NaN != NaN
true
```

```
julia> NaN < NaN
false
```

```
julia> NaN > NaN
false
```

and can cause headaches when working witharrays :

```
julia> [1 NaN] == [1 NaN]
false
```

Julia provides additional functions to test numbers for special values, which can be useful in situations like hash  
key comparisons:

```
Function Tests if
isequal(x, y) xandyare identical
isfinite(x) xis a finite number
isinf(x) xis infinite
isnan(x) xis not a number
```

isequalconsidersNaNs equal to each other:

```
julia> isequal(NaN, NaN)
true
```

```
julia> isequal([1 NaN], [ 1 NaN])
true
```

```
julia> isequal(NaN, NaN32)
true
```

isequalcan also be used to distinguish signed zeros:

```
julia> -0.0 == 0.0
true
```

```
julia> isequal(-0.0, 0.0)
false
```

Mixed-type comparisons between signed integers, unsigned integers, and floats can be tricky. A great deal of  
care has been taken to ensure that Julia does them correctly.

For other types,isequaldefaults to calling==, so if you want to define equality for your own types then  
you only need to add a==method. If you define your own equality function, you should probably define a  
correspondinghashmethod to ensure thatisequal(x,y)implieshash(x) == hash(y).

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 28

### Chaining comparisons

Unlike most languages, with thenotable exception of Python, comparisons can be arbitrarily chained:

```
julia> 1 < 2 <= 2 < 3 == 3 > 2 >= 1 == 1 < 3 != 5
true
```

Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the&&operator  
for scalar comparisons, and the&operator for elementwise comparisons, which allows them to work on arrays.  
For example,0 .< A .< 1gives a boolean array whose entries are true where the corresponding elements of  
Aare between 0 and 1.

Note the evaluation behavior of chained comparisons:

```
julia> v(x)= (println(x); x)
v (generic function with 1 method)
```

```
julia> v(1) < v(2) <= v(3)
2
1
3
true
```

```
julia> v(1) > v(2) <= v(3)
2
1
false
```

The middle expression is only evaluated once, rather than twice as it would be if the expression were written as  
v(1) < v(2) && v(2) <= v(3). However, the order of evaluations in a chained comparison is undefined. It  
is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If  
side effects are required, the short-circuit&&operator should be used explicitly (seeShort-Circuit Evaluation).

### Elementary Functions

Julia provides a comprehensive collection of mathematical functions and operators. These mathematical oper-  
ations are defined over as broad a class of numerical values as permit sensible definitions, including integers,  
floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.

Moreover, these functions (like any Julia function) can be applied in"vectorized" fashion to arrays and other  
collections with thedot syntaxf.(A), e.g.sin.(A)will compute the sine of each element of an arrayA.

### 5.7 Operator Precedence and Associativity

Julia applies the following order and associativity of operations, from highest precedence to lowest:

For a complete list of every Julia operator's precedence, see the top of this file:src/julia-parser.scm. Note  
that some of the operators there are not defined in theBasemodule but may be given definitions by standard  
libraries, packages or user code.

(^1) The unary operators+and-require explicit parentheses around their argument to disambiguate them from the operator++, etc.  
Other compositions of unary operators are parsed with right-associativity, e. g.,√√-aas√(√(-a)).  
(^2) The operators+,++and_are non-associative.a + b + cis parsed as+(a, b, c)not+(+(a, b), c). However, the fallback  
methods for+(a, b, c, d...)and_(a, b, c, d...)both default to left-associative evaluation.

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 29

```
Category Operators Associativity
Syntax .followed by:: Left
Exponentiation ^ Right
Unary + - √ Right^1
Bitshifts << >> >>> Left
Fractions // Left
Multiplication * / % & \ ÷ Left^2
Addition + - |⊻ Left^2
Syntax : .. Left
Syntax |> Left
Syntax <| Right
Comparisons > < >= <= == === != !== <: Non-associative
Control flow &&followed by||followed by? Right
Pair => Right
Assignments = += -= *= /= //= \= ^= ÷= %= |= &=⊻= <<= >>= >>>= Right
```

Youcanalsofindthenumericalprecedenceforanygivenoperatorviathebuilt-infunctionBase.operator_precedence,  
where higher numbers take precedence:

```
julia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)
```

```
julia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))
↪→ # (Note the necessary parens on `:(=)`)
(0, 1, 1)
```

Asymbolrepresentingtheoperatorassociativitycanalsobefoundbycallingthebuilt-infunctionBase.operator_associativity:

```
julia> Base.operator_associativity(:-), Base.operator_associativity(:+),
↪→ Base.operator_associativity(:^)
(:left, :none, :right)
```

```
julia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin),
↪→ Base.operator_associativity(:→)
(:left, :none, :right)
```

Notethatsymbolssuchas:sinreturnprecedence 0. Thisvaluerepresentsinvalidoperatorsandnotoperators  
of lowest precedence. Similarly, such operators are assigned associativity:none.

Numeric literal coefficients, e.g. 2x, are treated as multiplications with higher precedence than any other  
binary operation, with the exception of^where they have higher precedence only as the exponent.

```
julia> x = 3; 2x^2
18
```

```
julia> x = 3; 2^2x
64
```

Juxtaposition parses like a unary operator, which has the same natural asymmetry around exponents:-x^y  
and2x^yparse as-(x^y)and2(x^y)whereasx^-yandx^2yparse asx^(-y)andx^(2y).

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 30

### 5.8 Numerical Conversions

Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.

-   The notationT(x)orconvert(T,x)convertsxto a value of typeT.  
    **-** IfTis a floating-point type, the result is the nearest representable value, which could be positive  
    or negative infinity.  
    **-** IfTis an integer type, anInexactErroris raised ifxis not representable byT.
-   x % Tconverts an integerxto a value of integer typeTcongruent toxmodulo2^n, wherenis the  
    number of bits inT. In other words, the binary representation is truncated to fit.
-   The Rounding functionstake a typeTas an optional argument. For example,round(Int,x)is a short-  
    hand forInt(round(x)).

The following examples show the different forms.

```
julia>Int8 (127)
127
```

```
julia>Int8 (128)
ERROR: InexactError: trunc(Int8, 128)
Stacktrace:
[...]
```

```
julia>Int8 (127.0)
127
```

```
julia>Int8 (3.14)
ERROR: InexactError: Int8(3.14)
Stacktrace:
[...]
```

```
julia>Int8 (128.0)
ERROR: InexactError: Int8(128.0)
Stacktrace:
[...]
```

```
julia> 127 % Int8
127
```

```
julia> 128 % Int8
-128
```

```
julia> round( Int8 ,127.4)
127
```

```
julia> round( Int8 ,127.6)
ERROR: InexactError: trunc(Int8, 128.0)
Stacktrace:
[...]
```

See Conversion and Promotionfor how to define your own conversions and promotions.

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 31

### Rounding functions

```
Function Description Return type
round(x) roundxto the nearest integer typeof(x)
round(T, x) roundxto the nearest integer T
floor(x) roundxtowards-Inf typeof(x)
floor(T, x) roundxtowards-Inf T
ceil(x) roundxtowards+Inf typeof(x)
ceil(T, x) roundxtowards+Inf T
trunc(x) roundxtowards zero typeof(x)
trunc(T, x) roundxtowards zero T
```

### Division functions

```
Function Description
div(x,y),
x÷y
```

```
truncated division; quotient rounded towards zero
```

```
fld(x,y) floored division; quotient rounded towards-Inf
cld(x,y) ceiling division; quotient rounded towards+Inf
rem(x,y) remainder; satisfiesx == div(x,y)*y + rem(x,y); sign matchesx
mod(x,y) modulus; satisfiesx == fld(x,y)*y + mod(x,y); sign matchesy
mod1(x,y) modwith offset 1; returnsr∈(0,y]fory>0orr∈[y,0)fory<0, wheremod(r, y) ==
mod(x, y)
mod2pi(x) modulus with respect to 2pi;0 <= mod2pi(x) < 2pi
divrem(x,y) returns(div(x,y),rem(x,y))
fldmod(x,y) returns(fld(x,y),mod(x,y))
gcd(x,y...) greatest positive common divisor ofx,y,...
lcm(x,y...) least positive common multiple ofx,y,...
```

### Sign and absolute value functions

```
Function Description
abs(x) a positive value with the magnitude ofx
abs2(x) the squared magnitude ofx
sign(x) indicates the sign ofx, returning -1, 0, or +1
signbit(x) indicates whether the sign bit is on (true) or off (false)
copysign(x,y) a value with the magnitude ofxand the sign ofy
flipsign(x,y) a value with the magnitude ofxand the sign ofx*y
```

### Powers, logs and roots

For an overview of why functions likehypot,expm1, andlog1pare necessary and useful, see John D. Cook's  
excellent pair of blog posts on the subject:expm1, log1p, erfc, and hypot.

### Trigonometric and hyperbolic functions

All the standard trigonometric and hyperbolic functions are also defined:

```
sin cos tan cot sec csc
```

#### CHAPTER 5. MATHEMATICAL OPERATIONS AND ELEMENTARY FUNCTIONS 32

```
Function Description
sqrt(x),√x square root ofx
cbrt(x),∛x cube root ofx
hypot(x,y) hypotenuse of right-angled triangle with other sides of lengthxandy
exp(x) natural exponential function atx
expm1(x) accurateexp(x)-1forxnear zero
ldexp(x,n) x*2^ncomputed efficiently for integer values ofn
log(x) natural logarithm ofx
log(b,x) baseblogarithm ofx
log2(x) base 2 logarithm ofx
log10(x) base 10 logarithm ofx
log1p(x) accuratelog(1+x)forxnear zero
exponent(x) binary exponent ofx
significand(x) binary significand (a.k.a. mantissa) of a floating-point numberx
```

```
sinh cosh tanh coth sech csch
asin acos atan acot asec acsc
asinh acosh atanh acoth asech acsch
sinc cosc
```

Theseareallsingle-argumentfunctions, withatanalsoacceptingtwoargumentscorrespondingtoatraditional  
atan2function.

Additionally,sinpi(x)andcospi(x)areprovidedformoreaccuratecomputationsofsin(pi_x)andcos(pi_x)  
respectively.

In order to compute trigonometric functions with degrees instead of radians, suffix the function withd. For  
example,sind(x)computes the sine ofxwherexis specified in degrees. The complete list of trigonometric  
functions with degree variants is:

```
sind cosd tand cotd secd cscd
asind acosd atand acotd asecd acscd
```

### Special functions

Many other special mathematical functions are provided by the packageSpecialFunctions.jl.

**Chapter 6**

**Complex and Rational Numbers**

Juliaincludespredefinedtypesforbothcomplexandrationalnumbers,andsupportsallthestandardMathemat-  
ical Operations and Elementary Functionson them.Conversion and Promotionare defined so that operations  
on any combination of predefined numeric types, whether primitive or composite, behave as expected.

### 6.1 Complex Numbers.

The global constantimis bound to the complex number i, representing the principal square root of -1. (Using  
mathematicians'ior engineers'jfor this global constant was rejected since they are such popular index  
variablenames.) SinceJuliaallowsnumericliteralstobejuxtaposedwithidentifiersascoefficients, thisbinding  
suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:

```
julia> 1+2im
1 + 2im
```

You can perform all the standard arithmetic operations with complex numbers:

```
julia> (1 + 2im)*(2 - 3im)
8 + 1im
```

```
julia> (1 + 2im)/(1 - 2im)
-0.6 + 0.8im
```

```
julia> (1 + 2im) + (1 - 2im)
2 + 0im
```

```
julia> (-3 + 2im) - (5 - 1im)
-8 + 3im
```

```
julia> (-1 + 2im)^2
-3 - 4im
```

```
julia> (-1 + 2im)^2.5
2.729624464784009 - 6.9606644595719im
```

```
julia> (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im
```

```
julia> 3(2 - 5im)
```

#### 33

#### CHAPTER 6. COMPLEX AND RATIONAL NUMBERS 34

```
6 - 15im
```

```
julia> 3(2 - 5im)^2
-63 - 60im
```

```
julia> 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
```

The promotion mechanism ensures that combinations of operands of different types just work:

```
julia> 2(1 - 1im)
2 - 2im
```

```
julia> (2 + 3im) - 1
1 + 3im
```

```
julia> (1 + 2im) + 0.5
1.5 + 2.0im
```

```
julia> (2 + 3im) - 0.5im
2.0 + 2.5im
```

```
julia> 0.75(1 + 2im)
0.75 + 1.5im
```

```
julia> (2 + 3im) / 2
1.0 + 1.5im
```

```
julia> (1 - 3im) / (2 + 2im)
-0.5 - 1.0im
```

```
julia> 2im^2
-2 + 0im
```

```
julia> 1 + 3/4im
1.0 - 0.75im
```

Note that3/4im == 3/(4_im) == -(3/4_im), since a literal coefficient binds more tightly than division.

Standard functions to manipulate complex values are provided:

```
julia> z = 1 + 2im
1 + 2im
```

```
julia> real(1 + 2im) # real part of z
1
```

```
julia> imag(1 + 2im) # imaginary part of z
2
```

```
julia> conj(1 + 2im) # complex conjugate of z
1 - 2im
```

```
julia> abs(1 + 2im) # absolute value of z
2.23606797749979
```

#### CHAPTER 6. COMPLEX AND RATIONAL NUMBERS 35

```
julia> abs2(1 + 2im) # squared absolute value
5
```

```
julia> angle(1 + 2im) # phase angle in radians
1.1071487177940904
```

As usual, the absolute value (abs) of a complex number is its distance from zero.abs2gives the square of the  
absolute value, and is of particular use for complex numbers since it avoids taking a square root.anglereturns  
the phase angle in radians (also known as the argument or arg function). The full gamut of otherElementary  
Functionsis also defined for complex numbers:

```
julia> sqrt(1im)
0.7071067811865476 + 0.7071067811865475im
```

```
julia> sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im
```

```
julia> cos(1 + 2im)
2.0327230070196656 - 3.0518977991517997im
```

```
julia> exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im
```

```
julia> sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
```

Notethatmathematicalfunctionstypicallyreturnrealvalueswhenappliedtorealnumbersandcomplexvalues  
whenappliedtocomplexnumbers. Forexample,sqrtbehavesdifferentlywhenappliedto-1versus-1 + 0im  
even though-1 == -1 + 0im:

```
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
```

```
julia> sqrt(-1 + 0im)
0.0 + 1.0im
```

The literal numeric coefficient notationdoes not work when constructing a complex number from variables.  
Instead, the multiplication must be explicitly written out:

```
julia> a = 1; b = 2; a + b*im
1 + 2im
```

However, this is not recommended. Instead, use the more efficientcomplexfunction to construct a complex  
value directly from its real and imaginary parts:

```
julia> a = 1; b = 2; complex(a, b)
1 + 2im
```

#### CHAPTER 6. COMPLEX AND RATIONAL NUMBERS 36

This construction avoids the multiplication and addition operations.

InfandNaNpropagate through complex numbers in the real and imaginary parts of a complex number as  
described in theSpecial floating-point valuessection:

```
julia> 1 + Inf*im
1.0 + Inf*im
```

```
julia> 1 + NaN*im
1.0 + NaN*im
```

### 6.2 Rational Numbers

Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the//  
operator:

```
julia> 2//3
2//3
```

If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such  
that the denominator is non-negative:

```
julia> 6//9
2//3
```

```
julia> -4//8
-1//2
```

```
julia> 5//-15
-1//3
```

```
julia> -4//-12
1//3
```

This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking  
for equality of the numerator and denominator. The standardized numerator and denominator of a rational  
value can be extracted using thenumeratoranddenominatorfunctions:

```
julia> numerator(2//3)
2
```

```
julia> denominator(2//3)
3
```

Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic  
and comparison operations are defined for rational values:

```
julia> 2//3 == 6//9
true
```

```
julia> 2//3 == 9//27
false
```

#### CHAPTER 6. COMPLEX AND RATIONAL NUMBERS 37

```
julia> 3//7 < 1//2
true
```

```
julia> 3//4 > 2//3
true
```

```
julia> 2//4 + 1//6
2//3
```

```
julia> 5//12 - 1//4
1//6
```

```
julia> 5//8 * 3//12
5//32
```

```
julia> 6//5 / 10//7
21//25
```

Rationals can easily be converted to floating-point numbers:

```
julia> float(3//4)
0.75
```

Conversion from rational to floating-point respects the following identity for any integral values ofaandb, with  
the exception of the casea == 0andb == 0:

```
julia> a = 1; b = 2;
```

```
julia> isequal(float(a//b), a/b)
true
```

Constructing infinite rational values is acceptable:

```
julia> 5//0
1//0
```

```
julia> x = -3//0
-1//0
```

```
julia> typeof(x)
Rational{Int64}
```

Trying to construct aNaNrational value, however, is invalid:

```
julia> 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
Stacktrace:
[...]
```

As usual, the promotion system makes interactions with other numeric types effortless:

#### CHAPTER 6. COMPLEX AND RATIONAL NUMBERS 38

```
julia> 3//5 + 1
8//5
```

```
julia> 3//5 - 0.5
0.09999999999999998
```

```
julia> 2//7 * (1 + 2im)
2//7 + 4//7*im
```

```
julia> 2//7 * (1.5 + 2im)
0.42857142857142855 + 0.5714285714285714im
```

```
julia> 3//2 / (1 + 2im)
3//10 - 3//5*im
```

```
julia> 1//2 + 2im
1//2 + 2//1*im
```

```
julia> 1 + 2//3im
1//1 - 2//3*im
```

```
julia> 0.5 == 1//2
true
```

```
julia> 0.33== 1//3
false
```

```
julia> 0.33< 1//3
true
```

```
julia> 1//3 - 0.33
0.0033333333333332993
```

**Chapter 7**

**Strings**

Stringsarefinitesequencesofcharacters. Ofcourse, therealtroublecomeswhenoneaskswhatacharacteris.  
The characters that English speakers are familiar with are the lettersA,B,C, etc., together with numerals and  
common punctuation symbols. These characters are standardized together with a mapping to integer values  
between 0 and 127 by theASCII standard. There are, of course, many other characters used in non-English  
languages, including variantsof theASCII characterswith accentsand othermodifications, relatedscriptssuch  
asCyrillicandGreek, andscriptscompletelyunrelatedtoASCIIandEnglish, includingArabic, Chinese, Hebrew,  
Hindi, Japanese, and Korean. TheUnicodestandard tackles the complexities of what exactly a character is,  
and is generally accepted as the definitive standard addressing this problem. Depending on your needs, you  
can either ignore these complexities entirely and just pretend that only ASCII characters exist, or you can write  
code that can handle any of the characters or encodings that one may encounter when handling non-ASCII  
text. Julia makes dealing with plain ASCII text simple and efficient, and handling Unicode is as simple and  
efficient as possible. In particular, you can write C-style string code to process ASCII strings, and they will  
work as expected, both in terms of performance and semantics. If such code encounters non-ASCII text, it will  
gracefully fail with a clear error message, rather than silently introducing corrupt results. When this happens,  
modifying the code to handle non-ASCII data is straightforward.

There are a few noteworthy high-level features about Julia's strings:

-   The built-in concrete type used for strings (and string literals) in Julia isString. This supports the full  
    range ofUnicodecharacters via theUTF-8encoding. (Atranscodefunction is provided to convert  
    to/from other Unicode encodings.)
-   All string types are subtypes of the abstract typeAbstractString, and external packages define addi-  
    tionalAbstractStringsubtypes (e.g. for other encodings). If you define a function expecting a string  
    argument, you should declare the type asAbstractStringin order to accept any string type.
-   Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single  
    character, calledAbstractChar. The built-inCharsubtype ofAbstractCharis a 32-bit primitive type  
    that can represent any Unicode character (and which is based on the UTF-8 encoding).
-   As in Java, strings are immutable: the value of anAbstractStringobject cannot be changed. To con-  
    struct a different string value, you construct a new string from parts of other strings.
-   Conceptually,astringisapartialfunctionfromindicestocharacters: forsomeindexvalues,nocharacter  
    valueisreturned, andinsteadanexceptionisthrown. Thisallowsforefficientindexingintostringsbythe  
    byteindexofanencodedrepresentationratherthanbyacharacterindex, whichcannotbeimplemented  
    both efficiently and simply for variable-width encodings of Unicode strings.

#### 39

#### CHAPTER 7. STRINGS 40

### 7.1 Characters.

ACharvalue represents a single character: it is just a 32-bit primitive type with a special literal representation  
and appropriate arithmetic behaviors, and which can be converted to a numeric value representing aUnicode  
code point. (Julia packages may define other subtypes ofAbstractChar, e.g. to optimize operations for other  
text encodings.) Here is howCharvalues are input and shown:

```
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
```

```
julia> typeof(c)
Char
```

You can easily convert aCharto its integer value, i.e. code point:

```
julia> c = Int ('x')
120
```

```
julia> typeof(c)
Int64
```

On 32-bit architectures,typeof(c)will beInt32. You can convert an integer value back to aCharjust as  
easily:

```
julia>Char (120)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
```

Not all integer values are valid Unicode code points, but for performance, theCharconversion does not check  
that every character value is valid. If you want to check that each converted value is a valid code point, use  
theisvalidfunction:

```
julia>Char (0x110000)
'\U110000': Unicode U+110000 (category In: Invalid, too high)
```

```
julia> isvalid( Char , 0x110000)
false
```

As of this writing, the valid Unicode code points areU+0000throughU+D7FFandU+E000throughU+10FFFF.  
These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applica-  
tions, but all of these values are considered to be valid Unicode characters.

You can input any Unicode character in single quotes using\ufollowed by up to four hexadecimal digits or\U  
followed by up to eight hexadecimal digits (the longest valid value only requires six):

```
julia> '\u0'
'\0': ASCII/Unicode U+0000 (category Cc: Other, control)
```

```
julia> '\u78'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
```

```
julia> '\u2200'
'∀': Unicode U+2200 (category Sm: Symbol, math)
```

#### CHAPTER 7. STRINGS 41

```
julia> '\U10ffff'
'\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)
```

Julia uses your system's locale and language settings to determine which characters can be printed as-is and  
which must be output using the generic, escaped\uor\Uinput forms. In addition to these Unicode escape  
forms, all ofC's traditional escaped input formscan also be used:

```
julia>Int ('\0')
0
```

```
julia>Int ('\t')
9
```

```
julia>Int ('\n')
10
```

```
julia>Int ('\e')
27
```

```
julia>Int ('\x7f')
127
```

```
julia>Int ('\177')
127
```

You can do comparisons and a limited amount of arithmetic withCharvalues:

```
julia> 'A' < 'a'
true
```

```
julia> 'A' <= 'a' <= 'Z'
false
```

```
julia> 'A' <= 'X' <= 'Z'
true
```

```
julia> 'x' - 'a'
23
```

```
julia> 'A' + 1
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
```

### 7.2 String Basics.

String literals are delimited by double quotes or triple double quotes:

```
julia> str = "Hello, world. \n "
"Hello, world.\n"
```

```
julia> """Contains "quote" characters"""
"Contains \"quote\" characters"
```

#### CHAPTER 7. STRINGS 42

Long lines in strings can be broken up by preceding the newline with a backslash ():

```
julia> "This is a long \
line"
"This is a long line"
```

If you want to extract a character from a string, you index into it:

```
julia> str[ begin ]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)
```

```
julia> str[1]
'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)
```

```
julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)
```

```
julia> str[ end ]
'\n': ASCII/Unicode U+000A (category Cc: Other, control)
```

Many Julia objects, including strings, can be indexed with integers. The index of the first element (the first  
character of a string) is returned byfirstindex(str), and the index of the last element (character) with  
lastindex(str). The keywordsbeginandendcan be used inside an indexing operation as shorthand for  
the first and last indices, respectively, along the given dimension. String indexing, like most indexing in  
Julia, is 1-based: firstindexalways returns 1 for anyAbstractString. As we will see below, however,  
lastindex(str)is not in general the same aslength(str)for a string, because some Unicode characters  
can occupy multiple"code units".

You can perform arithmetic and other operations withend, just like a normal value:

```
julia> str[ end -1]
'.': ASCII/Unicode U+002E (category Po: Punctuation, other)
```

```
julia> str[ end ÷2]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
```

Using an index less thanbegin( 1 ) or greater thanendraises an error:

```
julia> str[ begin -1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [0]
[...]
```

```
julia> str[ end +1]
ERROR: BoundsError: attempt to access 14-codeunit String at index [15]
[...]
```

You can also extract a substring using range indexing:

```
julia> str[4:9]
"lo, wo"
```

Notice that the expressionsstr[k]andstr[k:k]do not give the same result:

#### CHAPTER 7. STRINGS 43

```
julia> str[6]
',': ASCII/Unicode U+002C (category Po: Punctuation, other)
```

```
julia> str[6:6]
","
```

The former is a single character value of typeChar, while the latter is a string value that happens to contain  
only a single character. In Julia these are very different things.

Range indexing makes a copy of the selected part of the original string. Alternatively, it is possible to create a  
view into a string using the typeSubString, for example:

```
julia> str = "long string"
"long string"
```

```
julia> substr= SubString (str,1, 4)
"long"
```

```
julia> typeof(substr)
SubString{String}
```

Several standard functions likechop,chomporstripreturn aSubString.

### 7.3 Unicode and UTF-8

Julia fully supports Unicode characters and strings. Asdiscussed above, in character literals, Unicode code  
points can be represented using Unicode\uand\Uescape sequences, as well as all the standard C escape  
sequences. These can likewise be used to write string literals:

```
julia> s = " \u2200 x \u2203 y"
"∀ x ∃ y"
```

Whether these Unicode characters are displayed as escapes or shown as special characters depends on your  
terminal's locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding.  
UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes  
("code units"). In UTF-8, ASCII characters — i.e. those with code points less than 0x80 (128) – are encoded as  
they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes —  
up to four per character.

String indices in Julia refer to code units (= bytes for UTF-8), the fixed-width building blocks that are used to  
encode arbitrary characters (code points). This means that not every index into aStringis necessarily a valid  
index for a character. If you index into a string at such an invalid byte index, an error is thrown:

```
julia> s[1]
'∀': Unicode U+2200 (category Sm: Symbol, math)
```

```
julia> s[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]
```

```
julia> s[3]
```

#### CHAPTER 7. STRINGS 44

```
ERROR: StringIndexError: invalid index [3], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]
```

```
julia> s[4]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
```

In this case, the character∀is a three-byte character, so the indices 2 and 3 are invalid and the next char-  
acter's index is 4; this next valid index can be computed bynextind(s,1), and the next index after that by  
nextind(s,4)and so on.

Sinceendis always the last valid index into a collection,end-1references an invalid byte index if the second-  
to-last character is multibyte.

```
julia> s[ end -1]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
```

```
julia> s[ end -2]
ERROR: StringIndexError: invalid index [9], valid nearby indices [7]=>'∃', [10]=>' '
Stacktrace:
[...]
```

```
julia> s[prevind(s, end , 2)]
'∃': Unicode U+2203 (category Sm: Symbol, math)
```

The first case works, because the last characteryand the space are one-byte characters, whereasend-2  
indexes into the middle of the∃multibyte representation. The correct way for this case is usingprevind(s,  
lastindex(s), 2)or, if you're using that value to index intosyou can writes[prevind(s, end, 2)]and  
endexpands tolastindex(s).

Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:

```
julia> s[1:1]
"∀"
```

```
julia> s[1:2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '
Stacktrace:
[...]
```

```
julia> s[1:4]
"∀ "
```

Because of variable-length encodings, the number of characters in a string (given bylength(s)) is not always  
the same as the last index. If you iterate through the indices 1 throughlastindex(s)and index intos, the  
sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string  
s. Thuslength(s) <= lastindex(s), since each character in a string must have its own index. The following  
is an inefficient and verbose way to iterate through the characters ofs:

```
julia>for i = firstindex(s):lastindex(s)
try
println(s[i])
catch
```

#### CHAPTER 7. STRINGS 45

```

# ignore the index error
end
end
∀
```

```
x
```

```
∃
```

```
y
```

The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for  
iterating through the characters in a string, since you can just use the string as an iterable object, no exception  
handling required:

```
julia>for c in s
println(c)
end
∀
```

```
x
```

```
∃
```

```
y
```

If you need to obtain valid indices for a string, you can use thenextindandprevindfunctions to incremen-  
t/decrement to the next/previous valid index, as mentioned above. You can also use theeachindexfunction  
to iterate over the valid character indices:

```
julia> collect(eachindex(s))
7-element Vector{Int64}:
1
4
5
6
7
10
11
```

To access the raw code units (bytes for UTF-8) of the encoding, you can use thecodeunit(s,i)function,  
where the indexiruns consecutively from 1 toncodeunits(s). Thecodeunits(s)function returns an  
AbstractVector{UInt8}wrapper that lets you access these raw codeunits (bytes) as an array.

Strings in Julia can contain invalid UTF-8 code unit sequences. This convention allows to treat any byte se-  
quence as aString. In such situations a rule is that when parsing a sequence of code units from left to right  
charactersareformedbythelongestsequenceof8-bitcodeunitsthatmatchesthestartofoneofthefollowing  
bit patterns (eachxcan be 0 or 1 ):

-   0xxxxxxx;
-   110xxxxx 10xxxxxx;
-   1110xxxx 10xxxxxx 10xxxxxx;

#### CHAPTER 7. STRINGS 46

-   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx;
-   10xxxxxx;
-   11111xxx.

In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as  
a single invalid character rather than multiple invalid characters. This rule may be best explained with an  
example:

```
julia> s = " \xc0\xa0\xe2\x88\xe2 |"
"\xc0\xa0\xe2\x88\xe2|"
```

```
julia> foreach(display, s)
'\xc0\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)
'\xe2\x88': Malformed UTF-8 (category Ma: Malformed, bad data)
'\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)
'|': ASCII/Unicode U+007C (category Sm: Symbol, math)
```

```
julia> isvalid.(collect(s))
4-element BitArray{1}:
0
0
0
1
```

```
julia> s2 = " \xf7\xbf\xbf\xbf "
"\U1fffff"
```

```
julia> foreach(display, s2)
'\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)
```

We can see that the first two code units in the stringsform an overlong encoding of space character. It is  
invalid, but is accepted in a string as a single character. The next two code units form a valid start of a three-  
byte UTF-8 sequence. However, the fifth code unit\xe2is not its valid continuation. Therefore code units 3  
and 4 are also interpreted as malformed characters in this string. Similarly code unit 5 forms a malformed  
character because|is not a valid continuation to it. Finally the strings2contains one too high code point.

Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For ex-  
ample, theLegacyStrings.jlpackage implementsUTF16StringandUTF32Stringtypes. Additional discussion  
of other encodings and how to implement support for them is beyond the scope of this document for the  
time being. For further discussion of UTF-8 encoding issues, see the section below onbyte array literals. The  
transcodefunction is provided to convert data between the various UTF-xx encodings, primarily for working  
with external data and libraries.

### 7.4 Concatenation.

One of the most common and useful string operations is concatenation:

```
julia> greet= "Hello"
"Hello"
```

```
julia> whom= "world"
```

#### CHAPTER 7. STRINGS 47

```
"world"
```

```
julia> string(greet,", " , whom,". \n ")
"Hello, world.\n"
```

It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings.  
The resulting string may contain different characters than the input strings, and its number of characters may  
be lower than sum of numbers of characters of the concatenated strings, e.g.:

```
julia> a, b= " \xe2\x88 ", " \x80 "
("\xe2\x88", "\x80")
```

```
julia> c = a*b
"∀"
```

```
julia> collect.([a, b, c])
3-element Array{Array{Char,1},1}:
['\xe2\x88']
['\x80']
['∀']
```

```
julia> length.([a, b, c])
3-element Array{Int64,1}:
1
1
1
```

This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all  
characters in strings and additivity of string lengths.

Julia also provides*for string concatenation:

```
julia> greet* ", "* whom* ". \n "
"Hello, world.\n"
```

While_may seem like a surprising choice to users of languages that provide+for string concatenation, this  
use of_has precedent in mathematics, particularly in abstract algebra.

In mathematics,+usually denotes a commutative operation, where the order of the operands does not matter.  
An example of this is matrix addition, whereA + B == B + Afor any matricesAandBthat have the same  
shape. In contrast,_typically denotes a noncommutative operation, where the order of the operands does  
matter. An example of this is matrix multiplication, where in generalA * B != B * A. As with matrix mul-  
tiplication, string concatenation is noncommutative:greet * whom != whom * greet. As such,_is a more  
natural choice for an infix string concatenation operator, consistent with common mathematical use.

More precisely, the set of all finite-length strings S together with the string concatenation operator_forms a  
free monoid(S,_). The identity element of this set is the empty string,"". Whenever a free monoid is not  
commutative, the operation is typically represented as\cdot,*, or a similar symbol, rather than+, which as  
stated usually implies commutativity.

### 7.5 Interpolation.

Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for  
these verbose calls tostringor repeated multiplications, Julia allows interpolation into string literals using$,  
as in Perl:

#### CHAPTER 7. STRINGS 48

```
julia> " $greet , $whom. \n "
"Hello, world.\n"
```

This is more readable and convenient and equivalent to the above string concatenation – the system rewrites  
this apparent single string literal into the callstring(greet, ", ", whom, ".\n").

The shortest complete expression after the$is taken as the expression whose value is to be interpolated into  
the string. Thus, you can interpolate any expression into a string using parentheses:

```
julia> "1 + 2 = $ (1 + 2)"
"1 + 2 = 3"
```

Both concatenation and string interpolation callstringto convert objects into string form. However,string  
actuallyjustreturnsthe outputofprint, sonew types should add methodstoprintorshowinsteadofstring.

Most non-AbstractStringobjects are converted to strings closely corresponding to how they are entered as  
literal expressions:

```
julia> v = [1,2,3]
3-element Vector{Int64}:
1
2
3
```

```
julia> "v: $v "
"v: [1, 2, 3]"
```

stringis the identity forAbstractStringandAbstractCharvalues, so these are interpolated into strings as  
themselves, unquoted and unescaped:

```
julia> c = 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
```

```
julia> "hi, $c "
"hi, x"
```

To include a literal$in a string literal, escape it with a backslash:

```
julia> print("I have \$ 100 in my account. \n ")
I have $100 in my account.
```

### 7.6 Triple-Quoted String Literals

When strings are created using triple-quotes ("""...""") they have some special behavior that can be useful  
for creating longer blocks of text.

First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining  
strings within code that is indented. For example:

```
julia> str = """
Hello,
world.
"""
" Hello,\n world.\n"
```

#### CHAPTER 7. STRINGS 49

In this case the final (empty) line before the closing"""sets the indentation level.

The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines,  
excluding the line following the opening"""and lines containing only spaces or tabs (the line containing the  
closing"""is always included). Then for all lines, excluding the text following the opening""", the common  
starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence),  
e.g.:

```
julia> """ This
is
a test"""
" This\nis\n a test"
```

Next, if the opening"""is followed by a newline, the newline is stripped from the resulting string.

```
"""hello"""
```

is equivalent to

```
"""
hello"""
```

but

```
"""
```

```
hello"""
```

will contain a literal newline at the beginning.

Stripping of the newline is performed after the dedentation. For example:

```
julia> """
Hello,
world."""
"Hello,\nworld."
```

If the newline is removed using a backslash, dedentation will be respected as well:

```
julia> """
Averylong\
word"""
"Averylongword"
```

Trailing whitespace is left unaltered.

Triple-quoted string literals can contain"characters without escaping.

Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character\nin  
the string, even if your editor uses a carriage return\r(CR) or CRLF combination to end lines. To include a CR  
in a string, use an explicitescape\r; for example, you can enter the literal string"a CRLF line ending\r\n".

#### CHAPTER 7. STRINGS 50

### 7.7 Common Operations.

You can lexicographically compare strings using the standard comparison operators:

```
julia> "abracadabra"< "xylophone"
true
```

```
julia> "abracadabra"== "xylophone"
false
```

```
julia> "Hello, world."!= "Goodbye, world."
true
```

```
julia> "1 + 2 = 3"== "1 + 2 = $ (1 + 2)"
true
```

You can search for the index of a particular character using thefindfirstandfindlastfunctions:

```
julia> findfirst(isequal('o'), "xylophone")
4
```

```
julia> findlast(isequal('o'), "xylophone")
7
```

```
julia> findfirst(isequal('z'), "xylophone")
```

You can start the search for a character at a given offset by using the functionsfindnextandfindprev:

```
julia> findnext(isequal('o'), "xylophone", 1)
4
```

```
julia> findnext(isequal('o'), "xylophone", 5)
7
```

```
julia> findprev(isequal('o'), "xylophone", 5)
4
```

```
julia> findnext(isequal('o'), "xylophone", 8)
```

You can use theoccursinfunction to check if a substring is found within a string:

```
julia> occursin("world", "Hello, world.")
true
```

```
julia> occursin("o", "Xylophon")
true
```

```
julia> occursin("a", "Xylophon")
false
```

```
julia> occursin('o', "Xylophon")
true
```

#### CHAPTER 7. STRINGS 51

The last example shows thatoccursincan also look for a character literal.

Two other handy string functions arerepeatandjoin:

```
julia> repeat(".:Z:.", 10)
".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:."
```

```
julia> join(["apples", "bananas", "pineapples"], ", " , " and ")
"apples, bananas and pineapples"
```

Some other useful functions include:

-   firstindex(str)givestheminimal(byte)indexthatcanbeusedtoindexintostr(always1forstrings,  
    not necessarily true for other containers).
-   lastindex(str)gives the maximal (byte) index that can be used to index intostr.
-   length(str)the number of characters instr.
-   length(str, i, j)the number of valid character indices instrfromitoj.
-   ncodeunits(str)number ofcode unitsin a string.
-   codeunit(str, i)gives the code unit value in the stringstrat indexi.
-   thisind(str, i)given an arbitrary index into a string find the first index of the character into which  
    the index points.
-   nextind(str, i, n=1)find the start of thenth character starting after indexi.
-   prevind(str, i, n=1)find the start of thenth character starting before indexi.

### 7.8 Non-Standard String Literals.

There are situations when you want to construct a string or use string semantics, but the behavior of the  
standard string construct is not quite what is needed. For these kinds of situations, Julia provides non-standard  
string literals. A non-standard string literal looks like a regular double-quoted string literal, but is immediately  
prefixed by an identifier, and may behave differently from a normal string literal.

Regular expressions, byte array literals, and version number literals, as described below, are some examples  
of non-standard string literals. Users and packages may also define new non-standard string literals. Further  
documentation is given in theMetaprogrammingsection.

### 7.9 Regular Expressions.

Julia has Perl-compatible regular expressions (regexes), as provided by thePCRE library (a description of the  
syntax can be foundhere ). Regular expressions are related to strings in two ways: the obvious connection is  
that regular expressions are used to find regular patterns in strings; the other connection is that regular ex-  
pressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently  
search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed  
with various identifiers beginning withr. The most basic regular expression literal without any options turned  
on just usesr"...":

#### CHAPTER 7. STRINGS 52

```
julia> re = r"^\s*(?:#|$)"
r"^\s*(?:#|$)"
```

```
julia> typeof(re)
Regex
```

To check if a regex matches a string, useoccursin:

```
julia> occursin(r"^\s*(?:#|$)", "not a comment")
false
```

```
julia> occursin(r"^\s*(?:#|$)", "# a comment")
true
```

As one can see here,occursinsimply returns true or false, indicating whether a match for the given regex  
occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also how  
it matched. To capture this information about a match, use thematchfunction instead:

```
julia> match(r"^\s*(?:#|$)", "not a comment")
```

```
julia> match(r"^\s*(?:#|$)", "# a comment")
RegexMatch("#")
```

If the regular expression does not match the given string,matchreturnsnothing– a special value that does  
not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you  
can test for it programmatically:

```
m = match(r"^\s*(?:#|$)", line)
if m === nothing
println("not a comment")
else
println("blank or comment")
end
```

If a regular expression does match, the value returned bymatchis aRegexMatchobject. These objects record  
how the expression matches, including the substring that the pattern matches and any captured substrings, if  
there are any. This example only captures the portion of the substring that matches, but perhaps we want to  
capture any non-blank text after the comment character. We could do the following:

```
julia> m = match(r"^\s*(?:#\s*(.*?)\s*$|$)", "# a comment ")
RegexMatch("# a comment ", 1="a comment")
```

When callingmatch, you have the option to specify an index at which to start the search. For example:

```
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",1)
RegexMatch("1")
```

```
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",6)
RegexMatch("2")
```

```
julia> m = match(r"[0-9]","aaaa1aaaa2aaaa3",11)
RegexMatch("3")
```

#### CHAPTER 7. STRINGS 53

You can extract the following info from aRegexMatchobject:

-   the entire substring matched:m.match
-   the captured substrings as an array of strings:m.captures
-   the offset at which the whole match begins:m.offset
-   the offsets of the captured substrings as a vector:m.offsets

For when a capture doesn't match, instead of a substring,m.capturescontainsnothingin that position, and  
m.offsetshas a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid).  
Here is a pair of somewhat contrived examples:

```
julia> m = match(r"(a|b)(c)?(d)", "acd")
RegexMatch("acd", 1="a", 2="c", 3="d")
```

```
julia> m.match
"acd"
```

```
julia> m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
"a"
"c"
"d"
```

```
julia> m.offset
1
```

```
julia> m.offsets
3-element Vector{Int64}:
1
2
3
```

```
julia> m = match(r"(a|b)(c)?(d)", "ad")
RegexMatch("ad", 1="a", 2=nothing, 3="d")
```

```
julia> m.match
"ad"
```

```
julia> m.captures
3-element Vector{Union{Nothing, SubString{String}}}:
"a"
nothing
"d"
```

```
julia> m.offset
1
```

```
julia> m.offsets
3-element Vector{Int64}:
1
0
2
```

#### CHAPTER 7. STRINGS 54

It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them  
to local variables. As a convinience, theRegexMatchobject implements iterator methods that pass through to  
thecapturesfield, so you can destructure the match object directly:

```
julia> first, second, third= m; first
"a"
```

Captures can also be accessed by indexing theRegexMatchobject with the number or name of the capture  
group:

```
julia> m=match(r"(?<hour>\d+):(?<minute>\d+)","12:45")
RegexMatch("12:45", hour="12", minute="45")
```

```
julia> m[:minute]
"45"
```

```
julia> m[2]
"45"
```

Captures can be referenced in a substitution string when usingreplaceby using\nto refer to the nth capture  
group and prefixing the substitution string withs. Capture group 0 refers to the entire match object. Named  
capture groups can be referenced in the substitution with\g. For example:

```
julia> replace("first second", r"(\w+) (?<agroup>\w+)"=> s"\g<agroup> \1 ")
"second first"
```

Numbered capture groups can also be referenced as\gfor disambiguation, as in:

```
julia> replace("a", r"."=> s"\g<0>1")
"a1"
```

You can modify the behavior of regular expressions by some combination of the flagsi,m,s, andxafter the  
closing double quote mark. These flags have the same meaning as they do in Perl, as explained in this excerpt  
from theperlre manpage:

```
i Do case-insensitive pattern matching.
```

```
If locale matching rules are in effect, the case map is taken
from the current locale for code points less than 255, and
from Unicode rules for larger code points. However, matches
that would cross the Unicode rules/non-Unicode rules boundary
(ords 255/256) will not succeed.
```

```
m Treat string as multiple lines. That is, change "^" and "$"
from matching the start or end of the string to matching the
start or end of any line anywhere within the string.
```

```
s Treat string as single line. That is, change "." to match any
character whatsoever, even a newline, which normally it would
not match.
```

```
Used together, as r""ms, they let the "." match any character
```

#### CHAPTER 7. STRINGS 55

```
whatsoever, while still allowing "^" and "$" to match,
respectively, just after and just before newlines within the
string.
```

```
x Tells the regular expression parser to ignore most whitespace
that is neither backslashed nor within a character class. You
can use this to break up your regular expression into
(slightly) more readable parts. The '#' character is also
treated as a metacharacter introducing a comment, just as in
ordinary code.
```

For example, the following regex has all three flags turned on:

```
julia> r"a+.*b+.*?d$"ism
r"a+.*b+.*?d$"ims
```

```
julia> match(r"a+.*b+.*?d$"ism,"Goodbye, \n Oh, angry, \n Bad world \n ")
RegexMatch("angry,\nBad world")
```

Ther"..."literal is constructed without interpolation and unescaping (except for quotation mark"which still  
has to be escaped). Here is an example showing the difference from standard string literals:

```
julia> x = 10
10
```

```
julia> r"$x"
r"$x"
```

```
julia> " $x "
"10"
```

```
julia> r"\x"
r"\x"
```

```
julia> "\x"
ERROR: syntax: invalid escape sequence
```

Triple-quoted regex strings, of the formr"""...""", are also supported (and may be convenient for regular  
expressions containing quotation marks or newlines).

TheRegex()constructor may be used to create a valid regex string programmatically. This permits using the  
contents of string variables and other string operations when constructing the regex string. Any of the regex  
codes above can be used within the single string argument toRegex(). Here are some examples:

```
julia>using Dates
```

```
julia> d = Date (1962,7,10)
1962-07-10
```

```
julia> regex_d= Regex ("Day "* string(day(d)))
r"Day 10"
```

```
julia> match(regex_d,"It happened on Day 10")
RegexMatch("Day 10")
```

#### CHAPTER 7. STRINGS 56

```
julia> name= "Jon"
"Jon"
```

```
julia> regex_name= Regex ("[ \" ( ] \\ Q $name\\ E[ \" ) ]" ) # interpolate value of name
r"[\"( ]\QJon\E[\") ]"
```

```
julia> match(regex_name," Jon ")
RegexMatch(" Jon ")
```

```
julia> match(regex_name,"[Jon]") === nothing
true
```

Note the use of the\Q...\Eescape sequence. All characters between the\Qand the\Eare interpreted as  
literal characters (after string interpolation). This escape sequence can be useful when interpolating, possibly  
malicious, user input.

### 7.10 Byte Array Literals.

Another useful non-standard string literal is the byte-array string literal:b"...". This form lets you use string  
notation to express read only literal byte arrays – i.e. arrays ofUInt8values. The type of those objects is  
CodeUnits{UInt8, String}. The rules for byte array literals are the following:

-   ASCII characters and ASCII escapes produce a single byte.
-   \xand octal escape sequences produce the byte corresponding to the escape value.
-   Unicode escape sequences produce a sequence of bytes encoding that code point in UTF-8.

There is some overlap between these rules since the behavior of\xand octal escapes less than 0x80 (128) are  
covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use  
ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example  
using all three:

```
julia> b"DATA \xff\u2200 "
8-element Base.CodeUnits{UInt8, String}:
0x44
0x41
0x54
0x41
0xff
0xe2
0x88
0x80
```

The ASCII string"DATA " corresponds to the bytes 68, 65, 84, 65.\xffproduces the single byte 255. The  
Unicode escape\u2200is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte  
array does not correspond to a valid UTF-8 string:

```
julia> isvalid("DATA \xff\u2200 ")
false
```

#### CHAPTER 7. STRINGS 57

As it was mentionedCodeUnits{UInt8, String}type behaves like read only array ofUInt8and if you need  
a standard vector you can convert it usingVector{UInt8}:

```
julia> x = b"123"
3-element Base.CodeUnits{UInt8, String}:
0x31
0x32
0x33
```

```
julia> x[1]
0x31
```

```
julia> x[1] = 0x32
ERROR: setindex! not defined for Base.CodeUnits{UInt8, String}
[...]
```

```
julia>Vector { UInt8 }(x)
3-element Vector{UInt8}:
0x31
0x32
0x33
```

Also observe the significant distinction between\xffand\uff: the former escape sequence encodes the  
byte 255, whereas the latter escape sequence represents the code point 255, which is encoded as two bytes  
in UTF-8:

```
julia> b" \xff "
1-element Base.CodeUnits{UInt8, String}:
0xff
```

```
julia> b" \uff "
2-element Base.CodeUnits{UInt8, String}:
0xc3
0xbf
```

Character literals use the same behavior.

For code points less than\u80, it happens that the UTF-8 encoding of each code point is just the single byte  
produced by the corresponding\xescape, so the distinction can safely be ignored. For the escapes\x80  
through\xffas compared to\u80through\uff, however, there is a major difference: the former escapes  
all encode single bytes, which – unless followed by very specific continuation bytes – do not form valid UTF-8  
data, whereas the latter escapes all represent Unicode code points with two-byte encodings.

If this is all extremely confusing, try reading"The Absolute Minimum Every Software Developer Absolutely,  
Positively Must Know About Unicode and Character Sets". It 's an excellent introduction to Unicode and UTF-8,  
and may help alleviate some confusion regarding the matter.

### 7.11 Version Number Literals.

Version numbers can easily be expressed with non-standard string literals of the formv"...". Version number  
literals createVersionNumberobjects which follow the specifications ofsemantic versioning, and therefore  
are composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric  
annotations. For example,v"0.2.1-rc1+win64"is broken into major version 0 , minor version 2 , patch version

#### CHAPTER 7. STRINGS 58

1 , pre-releaserc1and buildwin64. When entering a version literal, everything except the major version  
numberisoptional,thereforee.g.v"0.2"isequivalenttov"0.2.0"(withemptypre-release/buildannotations),  
v"2"is equivalent tov"2.0.0", and so on.

VersionNumberobjects are mostly useful to easily and correctly compare two (or more) versions. For example,  
the constantVERSIONholds Julia version number as aVersionNumberobject, and therefore one can define  
some version-specific behavior using simple statements as:

```
if v"0.2"<= VERSION< v"0.3-"
# do something specific to 0.2 release series
end
```

Note that in the above example the non-standard version numberv"0.3-"is used, with a trailing-: this  
notation is a Julia extension of the standard, and it's used to indicate a version which is lower than any0.3  
release, including all of its pre-releases. So in the above example the code would only run with stable0.2  
versions, and exclude such versions asv"0.3.0-rc1". In order to also allow for unstable (i.e. pre-release)0.2  
versions, the lower bound check should be modified like this:v"0.2-" <= VERSION.

Another non-standard version specification extension allows one to use a trailing+to express an upper limit  
on build versions, e.g.VERSION > v"0.2-rc1+"can be used to mean any version above0.2-rc1and any of  
its builds: it will returnfalsefor versionv"0.2-rc1+win64"andtrueforv"0.2-rc2".

It is good practice to use such special versions in comparisons (particularly, the trailing-should always be  
used on upper bounds unless there's a good reason not to), but they must not be used as the actual version  
number of anything, as they are invalid in the semantic versioning scheme.

Besides being used for theVERSIONconstant,VersionNumberobjects are widely used in thePkgmodule, to  
specify packages versions and their dependencies.

### 7.12 Raw String Literals.

Raw strings without interpolation or unescaping can be expressed with non-standard string literals of the form  
raw"...". Raw string literals create ordinaryStringobjects which contain the enclosed contents exactly as  
entered with no interpolation or unescaping. This is useful for strings which contain code or markup in other  
languages which use$or\as special characters.

The exception is that quotation marks still must be escaped, e.g.raw"""is equivalent to""". To make it  
possible to express all strings, backslashes then also must be escaped, but only when appearing right before  
a quote character:

```
julia> println(raw" \\ \\\" ")
\\ \"
```

Notice that the first two backslashes appear verbatim in the output, since they do not precede a quote char-  
acter. However, the next backslash character escapes the backslash that follows it, and the last backslash  
escapes a quote, since these backslashes appear before a quote.

**Chapter 8**

**Functions**

In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not  
pure mathematical functions, because they can alter and be affected by the global state of the program. The  
basic syntax for defining functions in Julia is:

```
julia>function f(x,y)
x + y
end
f (generic function with 1 method)
```

This function accepts two argumentsxandyand returns the value of the last expression evaluated, which is  
x + y.

There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax  
demonstrated above is equivalent to the following compact"assignment form":

```
julia> f(x,y)= x + y
f (generic function with 1 method)
```

In the assignment form, the body of the function must be a single expression, although it can be a compound  
expression (seeCompound Expressions). Short, simple function definitions are common in Julia. The short  
function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.

A function is called using the traditional parenthesis syntax:

```
julia> f(2,3)
5
```

Without parentheses, the expressionfrefers to the function object, and can be passed around like any other  
value:

```
julia> g = f;
```

```
julia> g(2,3)
5
```

As with variables, Unicode can also be used for function names:

#### 59

#### CHAPTER 8. FUNCTIONS 60

```
julia> ∑(x,y)= x + y
∑ (generic function with 1 method)
```

```
julia> ∑(2, 3)
5
```

### 8.1 Argument Passing Behavior

Julia function arguments follow a convention sometimes called"pass-by-sharing", which means that values are  
not copied when they are passed to functions. Function arguments themselves act as new variable bindings  
(new locations that can refer to values), but the values they refer to are identical to the passed values. Mod-  
ifications to mutable values (such asArrays) made within a function will be visible to the caller. This is the  
same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.

### 8.2 Argument-type declarations.

You can declare the types of function arguments by appending::TypeNameto the argument name, as usual  
for Type Declarationsin Julia. For example, the following function computesFibonacci numbersrecursively:

```
fib(n::Integer) = n ≤ 2? one(n) : fib(n-1) + fib(n-2)
```

and the::Integerspecification means that it will only be callable whennis a subtype of theabstractInteger  
type.

Argument-typedeclarations **normally have no impact on performance** : regardlessofwhatargumenttypes  
(if any) are declared, Julia compiles a specialized version of the function for the actual argument types passed  
by the caller. For example, callingfib(1)will trigger the compilation of specialized version offiboptimized  
specificallyforIntarguments,whichisthenre-usediffib(7)orfib(15)arecalled. (Therearerareexceptions  
whenanargument-typedeclarationcantriggeradditionalcompilerspecializations; see:BeawareofwhenJulia  
avoids specializing.) The most common reasons to declare argument types in Julia are, instead:

-   **Dispatch:** As explained inMethods, you can have different versions ("methods") of a function for dif-  
    ferent argument types, in which case the argument types are used to determine which implementation  
    is called for which arguments. For example, you might implement a completely different algorithm  
    fib(x::Number) = ...that works for anyNumbertype by usingBinet's formulato extend it to non-  
    integer values.
-   **Correctness:** Type declarations can be useful if your function only returns correct results for certain  
    argument types. For example, if we omitted argument types and wrotefib(n) = n ≤ 2? one(n) :  
    fib(n-1) + fib(n-2), thenfib(1.5)would silently give us the nonsensical answer1.0.
-   **Clarity:** Type declarations can serve as a form of documentation about the expected arguments.

However, it is a **common mistake to overly restrict the argument types** , which can unnecessarily limit  
the applicability of the function and prevent it from being re-used in circumstances you did not anticipate. For  
example, thefib(n::Integer)function above works equally well forIntarguments (machine integers) and  
BigIntarbitrary-precision integers (seeBigFloats and BigInts), which is especially useful because Fibonacci  
numbers grow exponentially rapidly and will quickly overflow any fixed-precision type likeInt(see Overflow  
behavior). If we had declared our function asfib(n::Int), however, the application toBigIntwould have  
been prevented for no reason. In general, you should use the most general applicable abstract types for argu-  
ments, and **when in doubt, omit the argument types**. You can always add argument-type specifications  
later if they become necessary, and you don't sacrifice performance or functionality by omitting them.

#### CHAPTER 8. FUNCTIONS 61

### 8.3 ThereturnKeyword.

The value returned by a function is the value of the last expression evaluated, which, by default, is the last  
expression in the body of the function definition. In the example function,f, from the previous section this is  
the value of the expressionx + y. As an alternative, as in many other languages, thereturnkeyword causes  
a function to return immediately, providing an expression whose value is returned:

```
function g(x,y)
return x * y
x + y
end
```

Since function definitions can be entered into interactive sessions, it is easy to compare these definitions:

```
julia> f(x,y)= x + y
f (generic function with 1 method)
```

```
julia>function g(x,y)
return x * y
x + y
end
g (generic function with 1 method)
```

```
julia> f(2,3)
5
```

```
julia> g(2,3)
6
```

Of course, in a purely linear function body likeg, the usage ofreturnis pointless since the expressionx + y  
is never evaluated and we could simply makex * ythe last expression in the function and omit thereturn.  
In conjunction with other control flow, however,returnis of real use. Here, for example, is a function that  
computes the hypotenuse length of a right triangle with sides of lengthxandy, avoiding overflow:

```
julia>function hypot(x,y)
x = abs(x)
y = abs(y)
if x > y
r = y/x
return x*sqrt(1+r*r)
end
if y == 0
return zero(x)
end
r = x/y
return y*sqrt(1+r*r)
end
hypot (generic function with 1 method)
```

```
julia> hypot(3, 4)
5.0
```

There are three possible points of return from this function, returning the values of three different expressions,  
depending on the values ofxandy. Thereturnon the last line could be omitted since it is the last expression.

#### CHAPTER 8. FUNCTIONS 62

### Return type

A return type can be specified in the function declaration using the::operator. This converts the return value  
to the specified type.

```
julia>function g(x, y):: Int8
return x * y
end ;
```

```
julia> typeof(g(1, 2))
Int8
```

This function will always return anInt8regardless of the types ofxandy. See Type Declarationsfor more on  
return types.

Return type declarations are **rarely used** in Julia: in general, you should instead write"type-stable" functions  
in which Julia's compiler can automatically infer the return type. For more information, see thePerformance  
Tips chapter.

### Returning nothing

For functions that do not need to return a value (functions used only for some side effects), the Julia convention  
is to return the valuenothing:

```
function printx(x)
println("x = $x ")
return nothing
end
```

ThisisaconventioninthesensethatnothingisnotaJuliakeywordbutaonlysingletonobjectoftypeNothing.  
Also, you may notice that theprintxfunction example above is contrived, becauseprintlnalready returns  
nothing, so that thereturnline is redundant.

There are two possible shortened forms for thereturn nothingexpression. On the one hand, thereturn  
keywordimplicitlyreturnsnothing, soitcanbeusedalone. Ontheotherhand, sincefunctionsimplicitlyreturn  
their last expression evaluated,nothingcan be used alone when it's the last expression. The preference for  
the expressionreturn nothingas opposed toreturnornothingalone is a matter of coding style.

### 8.4 Operators Are Functions.

In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with  
specialevaluationsemanticslike&&and||. TheseoperatorscannotbefunctionssinceShort-CircuitEvaluation  
requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also  
apply them using parenthesized argument lists, just as you would any other function:

```
julia> 1 + 2 + 3
6
```

```
julia> +(1,2,3)
6
```

The infix form is exactly equivalent to the function application form – in fact the former is parsed to produce  
the function call internally. This also means that you can assign and pass around operators such as+and*  
just like you would with other function values:

#### CHAPTER 8. FUNCTIONS 63

```
julia> f = +;
```

```
julia> f(1,2,3)
6
```

Under the namef, the function does not support infix notation, however.

### 8.5 Operators With Special Names

A few special expressions correspond to calls to functions with non-obvious names. These are:

```
Expression Calls
[A B C ...] hcat
[A; B; C; ...] vcat
[A B; C D; ...] hvcat
A' adjoint
A[i] getindex
A[i] = x setindex!
A.n getproperty
A.n = x setproperty!
```

### 8.6 Anonymous Functions.

Functions in Julia arefirst-class objects: they can be assigned to variables, and called using the standard  
function call syntax from the variable they have been assigned to. They can be used as arguments, and they  
can be returned as values. They can also be created anonymously, without being given a name, using either  
of these syntaxes:

```
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
```

```
julia>function (x)
x^2 + 2x - 1
end
#3 (generic function with 1 method)
```

This creates a function taking one argumentxand returning the value of the polynomialx^2 + 2x - 1at that  
value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive  
numbering.

Theprimaryuseforanonymousfunctionsispassingthemtofunctionswhichtakeotherfunctionsasarguments.  
A classic example ismap, which applies a function to each value of an array and returns a new array containing  
the resulting values:

```
julia> map(round, [1.2, 3.5, 1.7])
3-element Vector{Float64}:
1.0
4.0
2.0
```

#### CHAPTER 8. FUNCTIONS 64

This is fine if a named function effecting the transform already exists to pass as the first argument tomap.  
Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function  
construct allows easy creation of a single-use function object without needing a name:

```
julia> map(x-> x^2 + 2x - 1, [ 1, 3, -1])
3-element Vector{Int64}:
2
14
-2
```

An anonymous function accepting multiple arguments can be written using the syntax(x,y,z)->2x+y-z. A  
zero-argument anonymous function is written as()->3. The idea of a function with no arguments may seem  
strange,butisusefulfor"delaying"acomputation. Inthisusage,ablockofcodeiswrappedinazero-argument  
function, which is later invoked by calling it asf.

As an example, consider this call toget:

```
get(dict, key) do

# default value calculated here
time()
end
```

The code above is equivalent to callinggetwith an anonymous function containing the code enclosed between  
doandend, like so:

```
get(()->time(), dict, key)
```

The call totimeis delayed by wrapping it in a 0-argument anonymous function that is called only when the  
requested key is absent fromdict.

### 8.7 Tuples

Julia has a built-in data structure called a tuple that is closely related to function arguments and return values.  
A tuple is a fixed-length container that can hold any values, but cannot be modified (it is immutable). Tuples  
are constructed with commas and parentheses, and can be accessed via indexing:

```
julia> (1, 1+1)
(1, 2)
```

```
julia> (1,)
(1,)
```

```
julia> x = (0.0, "hello", 6*7)
(0.0, "hello", 42)
```

```
julia> x[2]
"hello"
```

Notice that a length-1 tuple must be written with a comma,(1,), since(1)would just be a parenthesized  
value.()represents the empty (length-0) tuple.

#### CHAPTER 8. FUNCTIONS 65

### 8.8 Named Tuples

The components of tuples can optionally be named, in which case a named tuple is constructed:

```
julia> x = (a=2, b =1+2)
(a = 2, b = 3)
```

```
julia> x[1]
2
```

```
julia> x.a
2
```

Named tuples are very similar to tuples, except that fields can additionally be accessed by name using dot  
syntax (x.a) in addition to the regular indexing syntax (x[1]).

### 8.9 Destructuring Assignment and Multiple Return Values

A comma-separated list of variables (optionally wrapped in parentheses) can appear on the left side of an  
assignment: the value on the right side is destructured by iterating over and assigning to each variable in  
turn:

```
julia> (a,b,c)= 1:3
1:3
```

```
julia> b
2
```

The value on the right should be an iterator (seeIteration interface) at least as long as the number of variables  
on the left (any excess elements of the iterator are ignored).

This can be used to return multiple values from functions by returning a tuple or other iterable value. For  
example, the following function returns two values:

```
julia>function foo(a,b)
a+b, a *b
end
foo (generic function with 1 method)
```

If you call it in an interactive session without assigning the return value anywhere, you will see the tuple  
returned:

```
julia> foo(2,3)
(5, 6)
```

Destructuring assignment extracts each value into a variable:

```
julia> x, y= foo(2,3)
(5, 6)
```

```
julia> x
```

#### CHAPTER 8. FUNCTIONS 66

```
5
```

```
julia> y
6
```

Another common use is for swapping variables:

```
julia> y, x= x, y
(5, 6)
```

```
julia> x
6
```

```
julia> y
5
```

Ifonlyasubsetoftheelementsoftheiteratorarerequired, acommonconventionistoassignignoredelements  
toavariableconsistingofonlyunderscores_(whichisanotherwiseinvalidvariablename,seeAllowedVariable  
Names):

```
julia> _, _, _, d= 1:10
1:10
```

```
julia> d
4
```

Othervalidleft-handsideexpressionscanbeusedaselementsoftheassignmentlist, whichwillcallsetindex!  
orsetproperty!, or recursively destructure individual elements of the iterator:

```
julia> X = zeros(3);
```

```
julia> X[1], (a,b)= (1, ( 2, 3))
(1, (2, 3))
```

```
julia> X
3-element Vector{Float64}:
1.0
0.0
0.0
```

```
julia> a
2
```

```
julia> b
3
```

```
Julia 1.6
...with assignment requires Julia 1.6
```

If the last symbol in the assignment list is suffixed by... (known as slurping), then it will be assigned a  
collection or lazy iterator of the remaining elements of the right-hand side iterator:

#### CHAPTER 8. FUNCTIONS 67

```
julia> a, b ... = "hello"
"hello"
```

```
julia> a
'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)
```

```
julia> b
"ello"
```

```
julia> a, b ... = Iterators.map(abs2,1:4)
Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4)
```

```
julia> a
1
```

```
julia> b
Base.Iterators.Rest{Base.Generator{UnitRange{Int64}, typeof(abs2)},
↪→ Int64}(Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4), 1)
```

SeeBase.restfor details on the precise handling and customization for specific iterators.

### 8.10 Argument destructuring.

The destructuring feature can also be used within a function argument. If a function argument name is written  
as a tuple (e.g.(x, y)) instead of just a symbol, then an assignment(x, y) = argumentwill be inserted for  
you:

```
julia> minmax(x, y)= (y < x)? (y, x): (x, y)
```

```
julia> gap((min, max))= max - min
```

```
julia> gap(minmax(10, 2))
8
```

Notice the extra set of parentheses in the definition ofgap. Without those,gapwould be a two-argument  
function, and this example would not work.

For anonymous functions, destructuring a single tuple requires an extra comma:

```
julia> map(((x,y),) -> x + y, [(1,2), (3,4)])
2-element Array{Int64,1}:
3
7
```

### 8.11 Varargs Functions

It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are  
traditionally known as"varargs" functions, which is short for"variable number of arguments". You can define  
a varargs function by following the last positional argument with an ellipsis:

```
julia> bar(a,b,x...) = (a,b,x)
bar (generic function with 1 method)
```

#### CHAPTER 8. FUNCTIONS 68

The variablesaandbare bound to the first two argument values as usual, and the variablexis bound to an  
iterable collection of the zero or more values passed tobarafter its first two arguments:

```
julia> bar(1,2)
(1, 2, ())
```

```
julia> bar(1,2,3)
(1, 2, (3,))
```

```
julia> bar(1, 2, 3, 4)
(1, 2, (3, 4))
```

```
julia> bar(1,2,3,4,5,6)
(1, 2, (3, 4, 5, 6))
```

In all these cases,xis bound to a tuple of the trailing values passed tobar.

It is possible to constrain the number of values passed as a variable argument; this will be discussed later in  
Parametrically-constrained Varargs methods.

On the flip side, it is often handy to"splat" the values contained in an iterable collection into a function call as  
individual arguments. To do this, one also uses...but in the function call instead:

```
julia> x = (3, 4)
(3, 4)
```

```
julia> bar(1,2,x...)
(1, 2, (3, 4))
```

In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments  
go. This need not be the case, however:

```
julia> x = (2, 3, 4)
(2, 3, 4)
```

```
julia> bar(1,x...)
(1, 2, (3, 4))
```

```
julia> x = (1, 2, 3, 4)
(1, 2, 3, 4)
```

```
julia> bar(x...)
(1, 2, (3, 4))
```

Furthermore, the iterable object splatted into a function call need not be a tuple:

```
julia> x = [3,4]
2-element Vector{Int64}:
3
4
```

```
julia> bar(1,2,x...)
(1, 2, (3, 4))
```

#### CHAPTER 8. FUNCTIONS 69

```
julia> x = [1,2,3,4]
4-element Vector{Int64}:
1
2
3
4
```

```
julia> bar(x...)
(1, 2, (3, 4))
```

Also, the function that arguments are splatted into need not be a varargs function (although it often is):

```
julia> baz(a,b)= a + b;
```

```
julia> args= [1,2]
2-element Vector{Int64}:
1
2
```

```
julia> baz(args...)
3
```

```
julia> args= [1,2,3]
3-element Vector{Int64}:
1
2
3
```

```
julia> baz(args...)
ERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)
Closest candidates are:
baz(::Any, ::Any) at none:1
```

As you can see, if the wrong number of elements are in the splatted container, then the function call will fail,  
just as it would if too many arguments were given explicitly.

### 8.12 Optional Arguments.

Itisoftenpossibletoprovidesensibledefaultvaluesforfunctionarguments. Thiscansaveusersfromhavingto  
passeveryargumentoneverycall. Forexample, thefunctionDate(y, [m, d])fromDatesmoduleconstructs  
aDatetype for a given yeary, monthmand dayd. However,manddarguments are optional and their default  
value is 1. This behavior can be expressed concisely as:

```
functionDate (y:: Int64 , m :: Int64 =1, d :: Int64 =1)
err = validargs( Date , y, m, d)
err === nothing|| throw(err)
returnDate (UTD(totaldays(y, m, d)))
end
```

Observe, that this definition calls another method of theDatefunction that takes one argument of type  
UTInstant{Day}.

#### CHAPTER 8. FUNCTIONS 70

With this definition, the function can be called with either one, two or three arguments, and 1 is automatically  
passed when only one or two of the arguments are specified:

```
julia>using Dates
```

```
julia>Date (2000, 12, 12)
2000-12-12
```

```
julia>Date (2000, 12)
2000-12-01
```

```
julia>Date (2000)
2000-01-01
```

Optional arguments are actually just a convenient syntax for writing multiple method definitions with different  
numbers of arguments (seeNote on Optional and keyword Arguments). This can be checked for ourDate  
function example by callingmethodsfunction.

### 8.13 Keyword Arguments.

Some functions need a large number of arguments, or have a large number of behaviors. Remembering how  
to call such functions can be difficult. Keyword arguments can make these complex interfaces easier to use  
and extend by allowing arguments to be identified by name instead of only by position.

For example, consider a functionplotthat plots a line. This function might have many options, for controlling  
line style, width, color, and so on. If it accepts keyword arguments, a possible call might look likeplot(x, y,  
width=2), where we have chosen to specify only line width. Notice that this serves two purposes. The call is  
easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset  
of a large number of arguments, in any order.

Functions with keyword arguments are defined using a semicolon in the signature:

```
function plot(x, y; style="solid", width=1, color="black")
###
end
```

When the function is called, the semicolon is optional: one can either callplot(x, y, width=2)orplot(x,  
y; width=2), but the former style is more common. An explicit semicolon is required only for passing varargs  
or computed keywords as described below.

Keyword argument default values are evaluated only when necessary (when a corresponding keyword ar-  
gument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword  
arguments.

The types of keyword arguments can be made explicit as follows:

```
function f(;x:: Int =1)
###
end
```

Keyword arguments can also be used in varargs functions:

#### CHAPTER 8. FUNCTIONS 71

```
function plot(x...; style="solid")
###
end
```

Extra keyword arguments can be collected using..., as in varargs functions:

```
function f(x; y=0, kwargs...)
###
end
```

Insidef,kwargswill be an immutable key-value iterator over a named tuple. Named tuples (as well as dictio-  
naries with keys ofSymbol) can be passed as keyword arguments using a semicolon in a call, e.g.f(x, z=1;  
kwargs...).

Ifakeywordargumentisnotassignedadefaultvalueinthemethoddefinition,thenitisrequired: anUndefKeywordError  
exception will be thrown if the caller does not assign it a value:

```
function f(x; y)
###
end
f(3, y =5) # ok, y is assigned
f(3) # throws UndefKeywordError(:y)
```

One can also passkey => valueexpressions after a semicolon. For example,plot(x, y; :width => 2)  
is equivalent toplot(x, y, width=2). This is useful in situations where the keyword name is computed at  
runtime.

When a bare identifier or dot expression occurs after a semicolon, the keyword argument name is implied by  
the identifier or field name. For exampleplot(x, y; width)is equivalent toplot(x, y; width=width)and  
plot(x, y; options.width)is equivalent toplot(x, y; width=options.width).

The nature of keyword arguments makes it possible to specify the same argument more than once. For exam-  
ple, in the callplot(x, y; options..., width=2)it is possible that theoptionsstructure also contains a  
value forwidth. In such a case the rightmost occurrence takes precedence; in this example,widthis certain  
to have the value 2. However, explicitly specifying the same keyword argument multiple times, for example  
plot(x, y, width=2, width=3), is not allowed and results in a syntax error.

### 8.14 Evaluation Scope of Default Values

Whenoptionalandkeywordargumentdefaultexpressionsareevaluated,onlypreviousargumentsareinscope.  
For example, given this definition:

```
function f(x, a=b, b =1)
###
end
```

thebina=brefers to abin an outer scope, not the subsequent argumentb.

#### CHAPTER 8. FUNCTIONS 72

### 8.15 Do-Block Syntax for Function Arguments

Passing functions as arguments to other functions is a powerful technique, but the syntax for it is not always  
convenient. Such calls are especially awkward to write when the function argument requires multiple lines. As  
an example, consider callingmapon a function with several cases:

```
map(x-> begin
if x < 0 && iseven(x)
return 0
elseif x == 0
return 1
else
return x
end
end ,
[A, B, C])
```

Julia provides a reserved worddofor rewriting this code more clearly:

```
map([A, B, C]) do x
if x < 0 && iseven(x)
return 0
elseif x == 0
return 1
else
return x
end
end
```

Thedo xsyntax creates an anonymous function with argumentxand passes it as the first argument tomap.  
Similarly,do a,bwould create a two-argument anonymous function. Note thatdo (a,b)would create a one-  
argument anonymous function, whose argument is a tuple to be deconstructed. A plaindowould declare that  
what follows is an anonymous function of the form() -> ....

How these arguments are initialized depends on the"outer" function; here,mapwill sequentially setxtoA,B,  
C, calling the anonymous function on each, just as would happen in the syntaxmap(func, [A, B, C]).

Thissyntaxmakesiteasiertousefunctionstoeffectivelyextendthelanguage, sincecallslooklikenormalcode  
blocks. There are many possible uses quite different frommap, such as managing system state. For example,  
there is a version ofopenthat runs code ensuring that the opened file is eventually closed:

```
open("outfile", "w") do io
write(io, data)
end
```

This is accomplished by the following definition:

```
function open(f:: Function , args...)
io = open(args...)
try
f(io)
finally
close(io)
end
end
```

#### CHAPTER 8. FUNCTIONS 73

Here,openfirst opens the file for writing and then passes the resulting output stream to the anonymous  
function you defined in thedo ... endblock. After your function exits,openwill make sure that the stream is  
properly closed, regardless of whether your function exited normally or threw an exception. (Thetry/finally  
construct will be described inControl Flow.)

With thedoblock syntax, it helps to check the documentation or implementation to know how the arguments  
of the user function are initialized.

Adoblock, like any other inner function, can"capture" variables from its enclosing scope. For example, the  
variabledatain the above example ofopen...dois captured from the outer scope. Captured variables can  
create performance challenges as discussed inperformance tips.

### 8.16 Function composition and piping

Functions in Julia can be combined by composing or piping (chaining) them together.

Function composition is when you combine functions together and apply the resulting composition to argu-  
ments. You use the function composition operator (∘) to compose the functions, so(f ∘ g)(args...)is the  
same asf(g(args...)).

You can type the composition operator at the REPL and suitably-configured editors using\circ.

For example, thesqrtand+functions can be composed like this:

```
julia> (sqrt ∘+)(3, 6)
3.0
```

This adds the numbers first, then finds the square root of the result.

The next example composes three functions and maps the result over an array of strings:

```
julia> map(first ∘ reverse ∘ uppercase, split("you can compose functions like this"))
6-element Vector{Char}:
'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)
'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)
'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)
'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
```

Function chaining (sometimes called"piping" or "using a pipe" to send data to a subsequent function) is when  
you apply a function to the previous function's output:

```
julia> 1:10 |> sum |> sqrt
7.416198487095663
```

Here, the total produced bysumis passed to thesqrtfunction. The equivalent composition would be:

```
julia> (sqrt ∘ sum)(1:10)
7.416198487095663
```

The pipe operator can also be used with broadcasting, as.|>, to provide a useful combination of the chain-  
ing/piping and dot vectorization syntax (described next).

#### CHAPTER 8. FUNCTIONS 74

```
julia> ["a", "list", "of", "strings"] .|> [uppercase, reverse, titlecase, length]
4-element Vector{Any}:
"A"
"tsil"
"Of"
7
```

### 8.17 Dot Syntax for Vectorizing Functions

In technical-computing languages, it is common to have"vectorized" versions of functions, which simply apply  
a given functionf(x)to each element of an arrayAto yield a new array viaf(A). This kind of syntax is  
convenient for data processing, but in other languages vectorization is also often required for performance: if  
loops are slow, the"vectorized" version of a function can call fast library code written in a low-level language.  
In Julia, vectorized functions are not required for performance, and indeed it is often beneficial to write your  
own loops (seePerformance Tips), but they can still be convenient. Therefore, any Julia functionfcan be  
applied elementwise to any array (or other collection) with the syntaxf.(A). For example,sincan be applied  
to all elements in the vectorAlike so:

```
julia> A = [1.0, 2.0, 3.0]
3-element Vector{Float64}:
1.0
2.0
3.0
```

```
julia> sin.(A)
3-element Vector{Float64}:
0.8414709848078965
0.9092974268256817
0.1411200080598672
```

Of course, you can omit the dot if you write a specialized"vector" method off, e.g. viaf(A::AbstractArray)  
= map(f, A), and this is just as efficient asf.(A). The advantage of thef.(A)syntax is that which functions  
are vectorizable need not be decided upon in advance by the library writer.

More generally,f.(args...)is actually equivalent tobroadcast(f, args...), which allows you to operate  
on multiple arrays (even of different shapes), or a mix of arrays and scalars (seeBroadcasting). For example,  
if you havef(x,y) = 3x + 4y, thenf.(pi,A)will return a new array consisting off(pi,a)for eachainA,  
andf.(vector1,vector2)will return a new vector consisting off(vector1[i],vector2[i])for each index  
i(throwing an exception if the vectors have different length).

```
julia> f(x,y)= 3x + 4y;
```

```
julia> A = [1.0, 2.0, 3.0];
```

```
julia> B = [4.0, 5.0, 6.0];
```

```
julia> f.(pi, A)
3-element Vector{Float64}:
13.42477796076938
17.42477796076938
21.42477796076938
```

```
julia> f.(A, B)
```

#### CHAPTER 8. FUNCTIONS 75

```
3-element Vector{Float64}:
19.0
26.0
33.0
```

Moreover, nestedf.(args...)calls are fused into a singlebroadcastloop. For example,sin.(cos.(X))is  
equivalent tobroadcast(x -> sin(cos(x)), X), similar to[sin(cos(x)) for x in X]: there is only a sin-  
gle loop overX, and a single array is allocated for the result. [In contrast,sin(cos(X))in a typical"vectorized"  
language would first allocate one temporary array fortmp=cos(X), and then computesin(tmp)in a separate  
loop, allocating a second array.] This loop fusion is not a compiler optimization that may or may not occur, it is  
a syntactic guarantee whenever nestedf.(args...)calls are encountered. Technically, the fusion stops as  
soon as a"non-dot" function call is encountered; for example, insin.(sort(cos.(X)))thesinandcosloops  
cannot be merged because of the interveningsortfunction.

Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is pre-  
allocated, so that repeated calls do not allocate new arrays over and over again for the results (seePre-  
allocating outputs). A convenient syntax for this isX .= ..., which is equivalent tobroadcast!(identity,  
X, ...)except that, as above, thebroadcast! loop is fused with any nested"dot" calls. For example,X  
.= sin.(Y)is equivalent tobroadcast!(sin, X, Y), overwritingXwithsin.(Y)in-place. If the left-hand  
side is an array-indexing expression, e.g.X[begin+1:end] .= sin.(Y), then it translates tobroadcast!on  
aview, e.g.broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y), so that the left-hand side is  
updated in-place.

Since adding dots to many operations and function calls in an expression can be tedious and lead to code that  
is difficult to read, the macro@.is provided to convert every function call, operation, and assignment in an  
expression into the"dotted" version.

```
julia> Y = [1.0, 2.0, 3.0, 4.0];
```

```
julia> X = similar(Y);# pre-allocate output array
```

```
julia> @. X = sin(cos(Y))# equivalent to X .= sin.(cos.(Y))
4-element Vector{Float64}:
0.5143952585235492
-0.4042391538522658
-0.8360218615377305
-0.6080830096407656
```

Binary (or unary) operators like.+are handled with the same mechanism: they are equivalent tobroadcast  
calls and are fused with other nested"dot" calls.X .+= Yetcetera is equivalent toX .= X .+ Yand results  
in a fused in-place assignment; see alsodot operators.

You can also combine dot operations with function chaining using|>, as in this example:

```
julia> [1:5;] .|> [x->x^2, inv, x->2*x, -, isodd]
5-element Vector{Real}:
1
0.5
6
-4
true
```

#### CHAPTER 8. FUNCTIONS 76

### 8.18 Further Reading

We should mention here that this is far from a complete picture of defining functions. Julia has a sophisticated  
type system and allows multiple dispatch on argument types. None of the examples given here provide any  
type annotations on their arguments, meaning that they are applicable to all types of arguments. The type  
system is described inTypes and defining a function in terms of methods chosen by multiple dispatch on  
run-time argument types is described inMethods.

**Chapter 9**

**Control Flow**

Julia provides a variety of control flow constructs:

-   Compound Expressions:beginand;.
-   Conditional Evaluation:if-elseif-elseand?:(ternary operator).
-   Short-Circuit Evaluation: logical operators&&(“and”) and||(“or”), and also chained comparisons.
-   Repeated Evaluation: Loops:whileandfor.
-   Exception Handling:try-catch,errorandthrow.
-   Tasks (aka Coroutines):yieldto.

The first five control flow mechanisms are standard to high-level programming languages.Tasks are not so  
standard: they provide non-local control flow, making it possible to switch between temporarily-suspended  
computations. This is a powerful construct: both exception handling and cooperative multitasking are imple-  
mented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems  
can be solved much more easily by using tasks.

### 9.1 Compound Expressions

Sometimes it is convenient to have a single expression which evaluates several subexpressions in order, re-  
turning the value of the last subexpression as its value. There are two Julia constructs that accomplish this:  
beginblocksand;chains. Thevalueofbothcompoundexpressionconstructsisthatofthelastsubexpression.  
Here 's an example of abeginblock:

```
julia> z = begin
x = 1
y = 2
x + y
end
3
```

Since these are fairly small, simple expressions, they could easily be placed onto a single line, which is where  
the;chain syntax comes in handy:

#### 77

#### CHAPTER 9. CONTROL FLOW 78

```
julia> z = (x = 1; y = 2; x + y)
3
```

This syntax is particularly useful with the terse single-line function definition form introduced inFunctions.  
Although it is typical, there is no requirement thatbeginblocks be multiline or that;chains be single-line:

```
julia>begin x = 1; y = 2; x + y end
3
```

```
julia> (x = 1;
y = 2;
x + y)
3
```

### 9.2 Conditional Evaluation.

Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a  
boolean expression. Here is the anatomy of theif-elseif-elseconditional syntax:

```
if x < y
println("x is less than y")
elseif x > y
println("x is greater than y")
else
println("x is equal to y")
end
```

If the condition expressionx < yistrue, then the corresponding block is evaluated; otherwise the condition  
expressionx > yis evaluated, and if it istrue, the corresponding block is evaluated; if neither expression is  
true, theelseblock is evaluated. Here it is in action:

```
julia>function test(x, y)
if x < y
println("x is less than y")
elseif x > y
println("x is greater than y")
else
println("x is equal to y")
end
end
test (generic function with 1 method)
```

```
julia> test(1, 2)
x is less than y
```

```
julia> test(2, 1)
x is greater than y
```

```
julia> test(1, 1)
x is equal to y
```

#### CHAPTER 9. CONTROL FLOW 79

Theelseifandelseblocks are optional, and as manyelseifblocks as desired can be used. The condition  
expressions in theif-elseif-elseconstruct are evaluated until the first one evaluates totrue, after which  
the associated block is evaluated, and no further condition expressions or blocks are evaluated.

ifblocks are"leaky ", i.e. they do not introduce a local scope. This means that new variables defined inside  
theifclauses can be used after theifblock, even if they weren't defined before. So, we could have defined  
thetestfunction above as

```
julia>function test(x,y)
if x < y
relation= "less than"
elseif x == y
relation= "equal to"
else
relation= "greater than"
end
println("x is ", relation," y.")
end
test (generic function with 1 method)
```

```
julia> test(2, 1)
x is greater than y.
```

The variablerelationis declared inside theifblock, but used outside. However, when depending on this  
behavior, make sure all possible code paths define a value for the variable. The following change to the above  
function results in a runtime error

```
julia>function test(x,y)
if x < y
relation= "less than"
elseif x == y
relation= "equal to"
end
println("x is ", relation," y.")
end
test (generic function with 1 method)
```

```
julia> test(1,2)
x is less than y.
```

```
julia> test(2,1)
ERROR: UndefVarError: relation not defined
Stacktrace:
[1] test(::Int64, ::Int64) at ./none:7
```

ifblocks also return a value, which may seem unintuitive to users coming from many other languages. This  
value is simply the return value of the last executed statement in the branch that was chosen, so

```
julia> x = 3
3
```

```
julia>if x > 0
"positive!"
else
```

#### CHAPTER 9. CONTROL FLOW 80

```
"negative..."
end
"positive!"
```

Notethatveryshortconditionalstatements(one-liners)arefrequentlyexpressedusingShort-CircuitEvaluation  
in Julia, as outlined in the next section.

Unlike C, MATLAB, Perl, Python, and Ruby – but like Java, and a few other stricter, typed languages – it is an  
error if the value of a conditional expression is anything buttrueorfalse:

```
julia>if 1
println("true")
end
ERROR: TypeError: non-boolean (Int64) used in boolean context
```

This error indicates that the conditional was of the wrong type:Int64rather than the requiredBool.

The so-called"ternary operator",?:, is closely related to theif-elseif-elsesyntax, but is used where a  
conditional choice between single expression values is required, as opposed to conditional execution of longer  
blocks of code. It gets its name from being the only operator in most languages taking three operands:

```
a? b : c
```

The expressiona, before the?, is a condition expression, and the ternary operation evaluates the expression  
b, before the:, if the conditionaistrueor the expressionc, after the:, if it isfalse. Note that the spaces  
around?and:are mandatory: an expression likea?b:cis not a valid ternary expression (but a newline is  
acceptable after both the?and the:).

The easiest way to understand this behavior is to see an example. In the previous example, theprintlncall  
is shared by all three branches: the only real choice is which literal string to print. This could be written more  
concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:

```
julia> x = 1; y = 2;
```

```
julia> println(x< y? "less than": "not less than")
less than
```

```
julia> x = 1; y = 0;
```

```
julia> println(x< y? "less than": "not less than")
not less than
```

If the expressionx < yis true, the entire ternary operator expression evaluates to the string"less than"  
and otherwise it evaluates to the string"not less than". The original three-way example requires chaining  
multiple uses of the ternary operator together:

```
julia> test(x, y)= println(x< y? "x is less than y" :
x > y? "x is greater than y": "x is equal to y")
test (generic function with 1 method)
```

```
julia> test(1, 2)
x is less than y
```

#### CHAPTER 9. CONTROL FLOW 81

```
julia> test(2, 1)
x is greater than y
```

```
julia> test(1, 1)
x is equal to y
```

To facilitate chaining, the operator associates from right to left.

It is significant that likeif-elseif-else, the expressions before and after the: are only evaluated if the  
condition expression evaluates totrueorfalse, respectively:

```
julia> v(x)= (println(x); x)
v (generic function with 1 method)
```

```
julia> 1 < 2? v("yes") : v("no")
yes
"yes"
```

```
julia> 1 > 2? v("yes") : v("no")
no
"no"
```

### 9.3 Short-Circuit Evaluation

The&&and||operators in Julia correspond to logical “and” and “or” operations, respectively, and are typi-  
cally used for this purpose. However, they have an additional property of short-circuit evaluation: they don't  
necessarily evaluate their second argument, as explained below. (There are also bitwise&and|operators  
that can be used as logical “and” and “or” without short-circuit behavior, but beware that&and|have higher  
precedence than&&and||for evaluation order.)

Short-circuit evaluation is quite similar to conditional evaluation. The behavior is found in most imperative  
programminglanguageshavingthe&&and||booleanoperators: inaseriesofbooleanexpressionsconnected  
by these operators, only the minimum number of expressions are evaluated as are necessary to determine the  
final boolean value of the entire chain. Some languages (like Python) refer to them asand(&&) andor(||).  
Explicitly, this means that:

-   In the expressiona && b, the subexpressionbis only evaluated ifaevaluates totrue.
-   In the expressiona || b, the subexpressionbis only evaluated ifaevaluates tofalse.

The reasoning is thata && bmust befalseifaisfalse, regardless of the value ofb, and likewise, the value  
ofa || bmust be true ifaistrue, regardless of the value ofb. Both&&and||associate to the right, but&&  
has higher precedence than||does. It's easy to experiment with this behavior:

```
julia> t(x)= (println(x); true )
t (generic function with 1 method)
```

```
julia> f(x)= (println(x); false )
f (generic function with 1 method)
```

```
julia> t(1) && t(2)
1
2
```

#### CHAPTER 9. CONTROL FLOW 82

```
true
```

```
julia> t(1) && f(2)
1
2
false
```

```
julia> f(1) && t(2)
1
false
```

```
julia> f(1) && f(2)
1
false
```

```
julia> t(1) || t(2)
1
true
```

```
julia> t(1) || f(2)
1
true
```

```
julia> f(1) || t(2)
1
2
true
```

```
julia> f(1) || f(2)
1
2
false
```

You can easily experiment in the same way with the associativity and precedence of various combinations of  
&&and||operators.

This behavior is frequently used in Julia to form an alternative to very shortifstatements. Instead ofif  
end, one can write && (which could be read as: and then  
). Similarly, instead ofif! end, one can write ||  
(which could be read as: or else ).

For example, a recursive factorial routine could be defined like this:

```
julia>function fact(n:: Int )
n >= 0 || error("n must be non-negative")
n == 0 && return 1
n * fact(n-1)
end
fact (generic function with 1 method)
```

```
julia> fact(5)
120
```

```
julia> fact(0)
1
```

#### CHAPTER 9. CONTROL FLOW 83

```
julia> fact(-1)
ERROR: n must be non-negative
Stacktrace:
[1] error at ./error.jl:33 [inlined]
[2] fact(::Int64) at ./none:2
[3] top-level scope
```

Boolean operations without short-circuit evaluation can be done with the bitwise boolean operators introduced  
in Mathematical Operations and Elementary Functions:&and|. These are normal functions, which happen to  
support infix operator syntax, but always evaluate their arguments:

```
julia> f(1) & t(2)
1
2
false
```

```
julia> t(1) | t(2)
1
2
true
```

Just like condition expressions used inif,elseifor the ternary operator, the operands of&&or||must be  
boolean values (trueorfalse). Using a non-boolean value anywhere except for the last entry in a conditional  
chain is an error:

```
julia> 1 && true
ERROR: TypeError: non-boolean (Int64) used in boolean context
```

On the other hand, any type of expression can be used at the end of a conditional chain. It will be evaluated  
and returned depending on the preceding conditionals:

```
julia>true && (x = (1, 2, 3))
(1, 2, 3)
```

```
julia>false && (x = (1, 2, 3))
false
```

### 9.4 Repeated Evaluation: Loops.

There are two constructs for repeated evaluation of expressions: thewhileloop and theforloop. Here is an  
example of awhileloop:

```
julia> i = 1;
```

```
julia>while i <= 5
println(i)
global i += 1
end
1
2
3
4
5
```

#### CHAPTER 9. CONTROL FLOW 84

Thewhileloop evaluates the condition expression (i <= 5in this case), and as long it remainstrue, keeps  
also evaluating the body of thewhileloop. If the condition expression isfalsewhen thewhileloop is first  
reached, the body is never evaluated.

Theforloop makes common repeated evaluation idioms easier to write. Since counting up and down like the  
abovewhileloop does is so common, it can be expressed more concisely with aforloop:

```
julia>for i = 1:5
println(i)
end
1
2
3
4
5
```

Here the1:5is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. Theforloop iterates  
through these values, assigning each one in turn to the variablei. One rather important distinction between  
the previouswhileloop form and theforloop form is the scope during which the variable is visible. If the  
variableihas not been introduced in another scope, in theforloop form, it is visible only inside of thefor  
loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable  
name to test this:

```
julia>for j = 1:5
println(j)
end
1
2
3
4
5
```

```
julia> j
ERROR: UndefVarError: j not defined
```

See Scope of Variablesfor a detailed explanation of variable scope and how it works in Julia.

In general, theforloop construct can iterate over any container. In these cases, the alternative (but fully  
equivalent) keywordinor∈is typically used instead of=, since it makes the code read more clearly:

```
julia>for i in [1,4,0]
println(i)
end
1
4
0
```

```
julia>for s ∈ ["foo","bar","baz"]
println(s)
end
foo
bar
baz
```

#### CHAPTER 9. CONTROL FLOW 85

Various types of iterable containers will be introduced and discussed in later sections of the manual (see, e.g.,  
Multi-dimensional Arrays).

It is sometimes convenient to terminate the repetition of awhilebefore the test condition is falsified or stop  
iterating in aforloop before the end of the iterable object is reached. This can be accomplished with the  
breakkeyword:

```
julia> i = 1;
```

```
julia>whiletrue
println(i)
if i >= 5
break
end
global i += 1
end
1
2
3
4
5
```

```
julia>for j = 1:1000
println(j)
if j >= 5
break
end
end
1
2
3
4
5
```

Without thebreakkeyword, the abovewhileloop would never terminate on its own, and theforloop would  
iterate up to 1000. These loops are both exited early by usingbreak.

In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately.  
Thecontinuekeyword accomplishes this:

```
julia>for i = 1:10
if i % 3 != 0
continue
end
println(i)
end
3
6
9
```

This is a somewhat contrived example since we could produce the same behavior more clearly by negating  
the condition and placing theprintlncall inside theifblock. In realistic usage there is more code to be  
evaluated after thecontinue, and often there are multiple points from which one callscontinue.

Multiple nestedforloops can be combined into a single outer loop, forming the cartesian product of its iter-  
ables:

#### CHAPTER 9. CONTROL FLOW 86

```
julia>for i = 1:2, j = 3:4
println((i, j))
end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
```

Withthissyntax, iterablesmaystillrefertoouterloopvariables; e.g.for i = 1:n, j = 1:iisvalid. However  
abreakstatement inside such a loop exits the entire nest of loops, not just the inner one. Both variables (i  
andj) are set to their current iteration values each time the inner loop runs. Therefore, assignments toiwill  
not be visible to subsequent iterations:

```
julia>for i = 1:2, j = 3:4
println((i, j))
i = 0
end
(1, 3)
(1, 4)
(2, 3)
(2, 4)
```

If this example were rewritten to use aforkeyword for each variable, then the output would be different: the  
second and fourth values would contain 0.

Multiple containers can be iterated over at the same time in a singleforloop usingzip:

```
julia>for (j, k) in zip([1 2 3], [ 4 5 6 7])
println((j,k))
end
(1, 4)
(2, 5)
(3, 6)
```

Usingzipwill create an iterator that is a tuple containing the subiterators for the containers passed to it. The  
zipiterator will iterate over all subiterators in order, choosing theith element of each subiterator in theith  
iteration of theforloop. Once any of the subiterators run out, theforloop will stop.

### 9.5 Exception Handling

When an unexpected condition occurs, a function may be unable to return a reasonable value to its caller.  
In such cases, it may be best for the exceptional condition to either terminate the program while printing a  
diagnostic error message, or if the programmer has provided code to handle such exceptional circumstances  
then allow that code to take the appropriate action.

### Built-inExceptions

Exceptions are thrown when an unexpected condition has occurred. The built-inExceptions listed below all  
interrupt the normal flow of control.

For example, thesqrtfunction throws aDomainErrorif applied to a negative real value:

#### CHAPTER 9. CONTROL FLOW 87

```
Exception
ArgumentError
BoundsError
CompositeException
DimensionMismatch
DivideError
DomainError
EOFError
ErrorException
InexactError
InitError
InterruptException
InvalidStateException
KeyError
LoadError
OutOfMemoryError
ReadOnlyMemoryError
RemoteException
MethodError
OverflowError
Meta.ParseError
SystemError
TypeError
UndefRefError
UndefVarError
StringIndexError
```

```
julia> sqrt(-1)
ERROR: DomainError with -1.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
```

You may define your own exceptions in the following way:

```
julia> struct MyCustomException<: Exceptionend
```

### Thethrowfunction

Exceptionscanbecreatedexplicitlywiththrow. Forexample, afunctiondefinedonlyfornonnegativenumbers  
could be written tothrowaDomainErrorif the argument is negative:

```
julia> f(x)= x>=0? exp(-x) : throw( DomainError (x, "argument must be nonnegative"))
f (generic function with 1 method)
```

```
julia> f(1)
0.36787944117144233
```

```
julia> f(-1)
ERROR: DomainError with -1:
argument must be nonnegative
```

#### CHAPTER 9. CONTROL FLOW 88

```
Stacktrace:
[1] f(::Int64) at ./none:1
```

Note thatDomainErrorwithout parentheses is not an exception, but a type of exception. It needs to be called  
to obtain anExceptionobject:

```
julia> typeof( DomainError (nothing)) <: Exception
true
```

```
julia> typeof( DomainError ) <: Exception
false
```

Additionally, some exception types take one or more arguments that are used for error reporting:

```
julia> throw( UndefVarError (:x))
ERROR: UndefVarError: x not defined
```

This mechanism can be implemented easily by custom exception types following the wayUndefVarErroris  
written:

```
julia> struct MyUndefVarError<: Exception
var:: Symbol
end
```

```
julia> Base.showerror(io:: IO , e::MyUndefVarError)= print(io,e.var," not defined")
```

```
Note
When writing an error message, it is preferred to make the first word lowercase. For example,
size(A) == size(B) || throw(DimensionMismatch("size of A not equal to size of B"))
is preferred over
size(A) == size(B) || throw(DimensionMismatch("Size of A not equal to size of B")).
However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument
to a function is a capital letter:
size(A,1) == size(B,2) || throw(DimensionMismatch("A has first dimension...")).
```

### Errors

Theerrorfunction is used to produce anErrorExceptionthat interrupts the normal flow of control.

Suppose we want to stop execution immediately if the square root of a negative number is taken. To do this,  
we can define a fussy version of thesqrtfunction that raises an error if its argument is negative:

```
julia> fussy_sqrt(x)= x >= 0? sqrt(x): error("negative x not allowed")
fussy_sqrt (generic function with 1 method)
```

```
julia> fussy_sqrt(2)
1.4142135623730951
```

```
julia> fussy_sqrt(-1)
ERROR: negative x not allowed
```

#### CHAPTER 9. CONTROL FLOW 89

```
Stacktrace:
[1] error at ./error.jl:33 [inlined]
[2] fussy_sqrt(::Int64) at ./none:1
[3] top-level scope
```

Iffussy_sqrtis called with a negative value from another function, instead of trying to continue execution of  
the calling function, it returns immediately, displaying the error message in the interactive session:

```
julia>function verbose_fussy_sqrt(x)
println("before fussy_sqrt")
r = fussy_sqrt(x)
println("after fussy_sqrt")
return r
end
verbose_fussy_sqrt (generic function with 1 method)
```

```
julia> verbose_fussy_sqrt(2)
before fussy_sqrt
after fussy_sqrt
1.4142135623730951
```

```
julia> verbose_fussy_sqrt(-1)
before fussy_sqrt
ERROR: negative x not allowed
Stacktrace:
[1] error at ./error.jl:33 [inlined]
[2] fussy_sqrt at ./none:1 [inlined]
[3] verbose_fussy_sqrt(::Int64) at ./none:3
[4] top-level scope
```

### Thetry/catchstatement

Thetry/catchstatement allows forExceptions to be tested for, and for the graceful handling of things that  
may ordinarily break your application. For example, in the below code the function for square root would  
normally throw an exception. By placing atry/catchblock around it we can mitigate that here. You may  
choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the  
case below where we just printed out a statement. One thing to think about when deciding how to handle  
unexpected situations is that using atry/catchblock is much slower than using conditional branching to  
handle those situations. Below there are more examples of handling exceptions with atry/catchblock:

```
julia>try
sqrt("ten")
catch e
println("You should have entered a numeric value")
end
You should have entered a numeric value
```

try/catchstatements also allow theExceptionto be saved in a variable. The following contrived example  
calculates the square root of the second element ofxifxis indexable, otherwise assumesxis a real number  
and returns its square root:

```
julia> sqrt_second(x)= try
sqrt(x[2])
```

#### CHAPTER 9. CONTROL FLOW 90

```
catch y
if isa(y, DomainError )
sqrt(complex(x[2], 0))
elseif isa(y, BoundsError )
sqrt(x)
end
end
sqrt_second (generic function with 1 method)
```

```
julia> sqrt_second([1 4])
2.0
```

```
julia> sqrt_second([1 -4])
0.0 + 2.0im
```

```
julia> sqrt_second(9)
3.0
```

```
julia> sqrt_second(-9)
ERROR: DomainError with -9.0:
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).
Stacktrace:
[...]
```

Note that the symbol followingcatchwill always be interpreted as a name for the exception, so care is needed  
when writingtry/catchexpressions on a single line. The following code will not work to return the value ofx  
in case of an error:

```
try bad() catch x end
```

Instead, use a semicolon or insert a line break aftercatch:

```
try bad() catch ; x end
```

```
try bad()
catch
x
end
```

The power of thetry/catchconstruct lies in the ability to unwind a deeply nested computation immediately  
to a much higher level in the stack of calling functions. There are situations where no error has occurred, but  
the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides therethrow,  
backtrace,catch_backtraceandcurrent_exceptionsfunctions for more advanced error handling.

### finallyClauses

Incodethatperformsstatechangesorusesresourceslikefiles, thereistypicallyclean-upwork(suchasclosing  
files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they  
can cause a block of code to exit before reaching its normal end. Thefinallykeyword provides a way to run  
some code when a given block of code exits, regardless of how it exits.

For example, here is how we can guarantee that an opened file is closed:

#### CHAPTER 9. CONTROL FLOW 91

```
f = open("file")
try
# operate on file f
finally
close(f)
end
```

When control leaves thetryblock (for example due to areturn, or just finishing normally),close(f)will be  
executed. If thetryblock exits due to an exception, the exception will continue propagating. Acatchblock  
maybecombinedwithtryandfinallyaswell. Inthiscasethefinallyblockwillrunaftercatchhashandled  
the error.

### 9.6 Tasks (aka Coroutines).

Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner.  
We mention them here only for completeness; for a full discussion seeAsynchronous Programming.

**Chapter 10**

**Scope of Variables**

The scope of a variable is the region of code within which a variable is visible. Variable scoping helps avoid  
variable naming conflicts. The concept is intuitive: two functions can both have arguments calledxwithout  
the twox's referring to the same thing. Similarly, there are many other cases where different blocks of code  
can use the same name without referring to the same thing. The rules for when the same variable name does  
or doesn't refer to the same thing are called scope rules; this section spells them out in detail.

Certain constructs in the language introduce scope blocks, which are regions of code that are eligible to be the  
scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it  
will always line up with one of these blocks. There are two main types of scopes in Julia, global scope and local  
scope. The latter can be nested. There is also a distinction in Julia between constructs which introduce a"hard  
scope" and those which only introduce a"soft scope", which affects whethershadowinga global variable by  
the same name is allowed or not.

### Scope constructs

The constructs introducing scope blocks are:

```
Construct Scope type Allowed within
module,baremodule global global
struct local (soft) global
for,while,try local (soft) global, local
macro local (hard) global
functions,doblocks,letblocks, comprehensions, generators local (hard) global, local
```

Notably missing from this table arebegin blocksand if blockswhich do not introduce new scopes. The three  
types of scopes follow somewhat different rules which will be explained below.

Julia useslexical scoping, meaning that a function's scope does not inherit from its caller's scope, but from the  
scope in which the function was defined. For example, in the following code thexinsidefoorefers to thexin  
the global scope of its moduleBar:

```
julia>module Bar
x = 1
foo()= x
end ;
```

and not axin the scope wherefoois used:

#### 92

#### CHAPTER 10. SCOPE OF VARIABLES 93

```
julia>import .Bar
```

```
julia> x = -1;
```

```
julia> Bar.foo()
1
```

Thus lexical scope means that what a variable in a particular piece of code refers to can be deduced from the  
code in which it appears alone and does not depend on how the program executes. A scope nested inside  
another scope can"see" variables in all the outer scopes in which it is contained. Outer scopes, on the other  
hand, cannot see variables in inner scopes.

### 10.1 Global Scope.

Each module introduces a new global scope, separate from the global scope of all other modules—there is no  
all-encompassing global scope. Modules can introduce variables of other modules into their scope through the  
using or importstatements or through qualified access using the dot-notation, i.e. each module is a so-called  
namespace as well as a first-class data structure associating names with values. Note that while variable  
bindings can be read externally, they can only be changed within the module to which they belong. As an  
escape hatch, you can always evaluate code inside that module to modify a variable; this guarantees, in  
particular, that module bindings cannot be modified externally by code that never callseval.

```
julia>module A
a = 1 # a global in A's scope
end ;
```

```
julia>module B
module C
c = 2
end
b = C.c # can access the namespace of a nested global scope
# through a qualified access
import ..A # makes module A available
d = A.a
end ;
```

```
julia>module D
b = a # errors as D's global scope is separate from A's
end ;
ERROR: UndefVarError: a not defined
```

```
julia>module E
import ..A # make module A available
A.a = 2 # throws below error
end ;
ERROR: cannot assign variables in other modules
```

Note that the interactive prompt (aka REPL) is in the global scope of the moduleMain.

### 10.2 Local Scope

A new local scope is introduced by most code blocks (see abovetable for a complete list). If such a block is  
syntactically nested inside of another local scope, the scope it creates is nested inside of all the local scopes

#### CHAPTER 10. SCOPE OF VARIABLES 94

that it appears within, which are all ultimately nested inside of the global scope of the module in which the  
code is evaluated. Variables in outer scopes are visible from any scope they contain — meaning that they can  
be read and written in inner scopes — unless there is a local variable with the same name that"shadows" the  
outer variable of the same name. This is true even if the outer local is declared after (in the sense of textually  
below) an inner block. When we say that a variable"exists " in a given scope, this means that a variable by  
that name exists in any of the scopes that the current scope is nested inside of, including the current one.

Someprogramminglanguagesrequireexplicitlydeclaringnewvariablesbeforeusingthem. Explicitdeclaration  
works in Julia too: in any local scope, writinglocal xdeclares a new local variable in that scope, regardless  
of whether there is already a variable namedxin an outer scope or not. Declaring each new variable like this  
is somewhat verbose and tedious, however, so Julia, like many other languages, considers assignment to a  
variable name that doesn't already exist to implicitly declare that variable. If the current scope is global, the  
new variable is global; if the current scope is local, the new variable is local to the innermost local scope and  
will be visible inside of that scope but not outside of it. If you assign to an existing local, it always updates  
that existing local: you can only shadow a local by explicitly declaring a new local in a nested scope with the  
localkeyword. In particular, this applies to variables assigned in inner functions, which may surprise users  
coming from Python where assignment in an inner function creates a new local unless the variable is explictly  
declared to be non-local.

Mostly this is pretty intuitive, but as with many things that behave intuitively, the details are more subtle than  
one might naïvely imagine.

Whenx = occurs in a local scope, Julia applies the following rules to decide what the expression  
means based on where the assignment expression occurs and whatxalready refers to at that location:

1.  **Existing local:** Ifxis already a local variable, then the existing localxis assigned;
2.  **Hard scope:** Ifxisnotalreadyalocalvariableandassignmentoccursinsideofanyhardscopeconstruct  
    (i.e. within aletblock, function or macro body, comprehension, or generator), a new local namedxis  
    created in the scope of the assignment;
3.  **Soft scope:** Ifxis not already a local variable and all of the scope constructs containing the assignment  
    are soft scopes (loops,try/catchblocks, orstructblocks), the behavior depends on whether the global  
    variablexis defined:  
    **-** if globalxis undefined, a new local namedxis created in the scope of the assignment;  
    **-** if globalxis defined, the assignment is considered ambiguous:  
    ∗ in non-interactive contexts (files, eval), an ambiguity warning is printed and a new local is  
    created;  
    ∗ in interactive contexts (REPL, notebooks), the global variablexis assigned.

You may note that in non-interactive contexts the hard and soft scope behaviors are identical except that a  
warning is printed when an implicitly local variable (i.e. not declared withlocal x) shadows a global. In  
interactive contexts, the rules follow a more complex heuristic for the sake of convenience. This is covered in  
depth in examples that follow.

Now that you know the rules, let's look at some examples. Each example is assumed to be evaluated in a fresh  
REPL session so that the only globals in each snippet are the ones that are assigned in that block of code.

We 'll begin with a nice and clear-cut situation—assignment inside of a hard scope, in this case a function body,  
when no local variable by that name already exists:

```
julia>function greet()
x = "hello"# new local
```

#### CHAPTER 10. SCOPE OF VARIABLES 95

```
println(x)
end
greet (generic function with 1 method)
```

```
julia> greet()
hello
```

```
julia> x # global
ERROR: UndefVarError: x not defined
```

Inside of thegreetfunction, the assignmentx = "hello"causesxto be a new local variable in the function's  
scope. There are two relevant facts: the assignment occurs in local scope and there is no existing localx  
variable. Sincexis local, it doesn't matter if there is a global namedxor not. Here for example we definex =  
123 before defining and callinggreet:

```
julia> x = 123 # global
123
```

```
julia>function greet()
x = "hello"# new local
println(x)
end
greet (generic function with 1 method)
```

```
julia> greet()
hello
```

```
julia> x # global
123
```

Since thexingreetis local, the value (or lack thereof) of the globalxis unaffected by callinggreet. The  
hard scope rule doesn't care whether a global namedxexists or not: assignment toxin a hard scope is local  
(unlessxis declared global).

The next clear cut situation we'll consider is when there is already a local variable namedx, in which casex =  
always assigns to this existing localx. This is true whether the assignment occurs in the same local  
scope, an inner local scope in the same function body, or in the body of a function nested inside of another  
function, also known as aclosure.

We 'll use thesum_tofunction, which computes the sum of integers from one up ton, as an example:

```
function sum_to(n)
s = 0 # new local
for i = 1:n
s = s + i # assign existing local
end
return s # same local
end
```

As in the previous example, the first assignment tosat the top ofsum_tocausessto be a new local variable  
in the body of the function. Theforloop has its own inner local scope within the function scope. At the point  
wheres = s + ioccurs,sis already a local variable, so the assignment updates the existingsinstead of  
creating a new local. We can test this out by callingsum_toin the REPL:

#### CHAPTER 10. SCOPE OF VARIABLES 96

```
julia>function sum_to(n)
s = 0 # new local
for i = 1:n
s = s + i # assign existing local
end
return s # same local
end
sum_to (generic function with 1 method)
```

```
julia> sum_to(10)
55
```

```
julia> s # global
ERROR: UndefVarError: s not defined
```

Sincesis local to the functionsum_to, calling the function has no effect on the global variables. We can also  
see that the updates = s + iin theforloop must have updated the samescreated by the initializations  
= 0since we get the correct sum of 55 for the integers 1 through 10.

Let 's dig into the fact that theforloop body has its own scope for a second by writing a slightly more verbose  
variation which we'll callsum_to_def, in which we save the sums + iin a variabletbefore updatings:

```
julia>function sum_to_def(n)
s = 0 # new local
for i = 1:n
t = s + i # new local `t`
s = t # assign existing local `s`
end
return s, @isdefined(t)
end
sum_to_def (generic function with 1 method)
```

```
julia> sum_to_def(10)
(55, false)
```

This version returnssas before but it also uses the@isdefinedmacro to return a boolean indicating whether  
there is a local variable namedtdefined in the function's outermost local scope. As you can see, there is no  
tdefined outside of theforloop body. This is because of the hard scope rule again: since the assignment to  
toccurs inside of a function, which introduces a hard scope, the assignment causestto become a new local  
variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global namedt,  
it would make no difference—the hard scope rule isn't affected by anything in global scope.

Note that the local scope of a for loop body is no different from the local scope of an inner function. This means  
that we could rewrite this example so that the loop body is implemented as a call to an inner helper function  
and it behaves the same way:

```
julia>function sum_to_def_closure(n)
function loop_body(i)
t = s + i # new local `t`
s = t # assign same local `s` as below
end
s = 0 # new local
for i = 1:n
loop_body(i)
```

#### CHAPTER 10. SCOPE OF VARIABLES 97

```
end
return s, @isdefined(t)
end
sum_to_def_closure (generic function with 1 method)
```

```
julia> sum_to_def_closure(10)
(55, false)
```

This example illustrates a couple of key points:

1.  Inner function scopes are just like any other nested local scope. In particular, if a variable is already a  
    local outside of an inner function and you assign to it in the inner function, the outer local variable is  
    updated.
2.  Itdoesn'tmatterifthedefinitionofanouterlocalhappensbelowwhereitisupdated,theruleremainsthe  
    same. The entire enclosing local scope is parsed and its locals determined before inner local meanings  
    are resolved.

This design means that you can generally move code in or out of an inner function without changing its mean-  
ing, which facilitates a number of common idioms in the language using closures (seedo blocks).

Let 's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting  
the bodies of thegreetandsum_to_deffunctions into soft scope contexts. First, let's put the body ofgreet  
in aforloop—which is soft, rather than hard—and evaluate it in the REPL:

```
julia>for i = 1:3
x = "hello"# new local
println(x)
end
hello
hello
hello
```

```
julia> x
ERROR: UndefVarError: x not defined
```

Since the globalxis not defined when theforloop is evaluated, the first clause of the soft scope rule applies  
andxis created as local to theforloop and therefore globalxremains undefined after the loop executes.  
Next, let's consider the body ofsum_to_defextracted into global scope, fixing its argument ton = 10

```
s = 0
for i = 1:10
t = s + i
s = t
end
s
@isdefined(t)
```

What does this code do? Hint: it's a trick question. The answer is"it depends." If this code is entered inter-  
actively, it behaves the same way it does in a function body. But if the code appears in a file, it prints an  
ambiguity warning and throws an undefined variable error. Let's see it working in the REPL first:

#### CHAPTER 10. SCOPE OF VARIABLES 98

```
julia> s = 0 # global
0
```

```
julia>for i = 1:10
t = s + i # new local `t`
s = t # assign global `s`
end
```

```
julia> s # global
55
```

```
julia> @isdefined(t) # global
false
```

The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns  
to a global or creates new local based on whether a global variable by that name is defined or not. If a global  
by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new  
local variable. In this example we see both cases in action:

-   There is no global namedt, sot = s + icreates a newtthat is local to theforloop;
-   There is a global nameds, sos = tassigns to it.

The second fact is why execution of the loop changes the global value ofsand the first fact is whytis still  
undefined after the loop executes. Now, let's try evaluating this same code as though it were in a file instead:

```
julia> code= """
s = 0 # global
for i = 1:10
t = s + i # new local `t`
s = t # new local `s` with warning
end
s, # global
@isdefined(t) # global
""";
```

```
julia> include_string(Main, code)
┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name
exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this
warning or `global s` to assign to the existing global variable.
```

```
↪→
↪→
└ @ string:4
ERROR: LoadError: UndefVarError: s not defined
```

Here we useinclude_string, to evaluatecodeas though it were the contents of a file. We could also save  
codeto a file and then callincludeon that file—the result would be the same. As you can see, this behaves  
quite different from evaluating the same code in the REPL. Let's break down what's happening here:

-   globalsis defined with the value 0 before the loop is evaluated
-   the assignments = toccurs in a soft scope—aforloop outside of any function body or other hard  
    scope construct
-   thereforethesecondclauseofthesoftscoperuleapplies, andtheassignmentisambiguoussoawarning  
    is emitted

#### CHAPTER 10. SCOPE OF VARIABLES 99

-   execution continues, makingslocal to theforloop body
-   sincesis local to theforloop, it is undefined whent = s + iis evaluated, causing an error
-   evaluation stops there, but if it got tosand@isdefined(t), it would return 0 andfalse.

This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning,  
and that meaning is determined regardless of the order of expressions. The presence of the expressions = t  
in the loop causessto be local to the loop, which means that it is also local when it appears on the right hand  
side oft = s + i, even though that expression appears first and is evaluated first. One might imagine that  
theson the first line of the loop could be global while theson the second line of the loop is local, but that's  
not possible since the two lines are in the same scope block and each variable can only mean one thing in a  
given scope.

**On Soft Scope**

Wehavenowcoveredallthelocalscoperules, butbeforewrappingupthissection, perhapsafewwordsshould  
be said about why the ambiguous soft scope case is handled differently in interactive and non-interactive  
contexts. There are two obvious questions one could ask:

1.  Why doesn't it just work like the REPL everywhere?
2.  Why doesn't it just work like in files everywhere? And maybe skip the warning?

In Julia ≤ 0.6, all global scopes did work like the current REPL: whenx = occurred in a loop (or  
try/catch, orstructbody) but outside of a function body (orletblock or comprehension), it was decided  
based on whether a global namedxwas defined or not whetherxshould be local to the loop. This behavior  
has the advantage of being intuitive and convenient since it approximates the behavior inside of a function  
body as closely as possible. In particular, it makes it easy to move code back and forth between a function  
body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First,  
it's quite a complex behavior: many people over the years were confused about this behavior and complained  
that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is  
that it 's bad for programming"at scale." When you see a small piece of code in one place like this, it's quite  
clear what's going on:

```
s = 0
for i = 1:10
s += i
end
```

Obviously the intention is to modify the existing global variables. What else could it mean? However, not all  
real world code is so short or so clear. We found that code like the following often occurs in the wild:

```
x = 123
```

```
# much later
# maybe in a different file
```

```
for i = 1:10
x = "hello"
println(x)
end
```

#### CHAPTER 10. SCOPE OF VARIABLES 100

```
# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`
```

```
y = x + 234
```

It's far less clear what should happen here. Sincex + "hello"is a method error, it seems probable that the  
intention is forxto be local to theforloop. But runtime values and what methods happen to exist cannot  
be used to determine the scopes of variables. With the Julia ≤ 0.6 behavior, it's especially concerning that  
someone might have written theforloop first, had it working just fine, but later when someone else adds a  
new global far away—possibly in a different file—the code suddenly changes meaning and either breaks noisily  
or, worse still, silently does the wrong thing. This kind of"spooky action at a distance" is something that good  
programming language designs should prevent.

So in Julia 1.0, we simplified the rules for scope: in any local scope, assignment to a name that wasn't already a  
local variable created a new local variable. This eliminated the notion of soft scope entirely as well as removing  
the potential for spooky action. We uncovered and fixed a significant number of bugs due to the removal of  
soft scope, vindicating the choice to get rid of it. And there was much rejoicing! Well, no, not really. Because  
some people were angry that they now had to write:

```
s = 0
for i = 1:10
global s += i
end
```

Do you see thatglobalannotation in there? Hideous. Obviously this situation could not be tolerated. But  
seriously, there are two main issues with requiringglobalfor this kind of top-level code:

1.  It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug  
    it—you have to addglobalannotations and then remove them again to go back;
2.  Beginners will write this kind of code without theglobaland have no idea why their code doesn't  
    work—the error that they get is thatsis undefined, which does not seem to enlighten anyone who  
    happens to make this mistake.

As of Julia 1.5, this code works without theglobalannotation in interactive contexts like the REPL or Jupyter  
notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:

```
Assignment tosin soft scope is ambiguous because a global variable by the same name exists:s
will be treated as a new local. Disambiguate by usinglocal sto suppress this warning orglobal
sto assign to the existing global variable.
```

This addresses both issues while preserving the"programming at scale" benefits of the 1.0 behavior: global  
variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste  
debugging works and beginners don't have any issues; any time someone either forgets aglobal annotation  
or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they  
get a nice clear warning.

An important property of this design is that any code that executes in a file without a warning will behave the  
same way in a fresh REPL. And on the flip side, if you take a REPL session and save it to file, if it behaves  
differently than it did in the REPL, then you will get a warning.

#### CHAPTER 10. SCOPE OF VARIABLES 101

### Let Blocks

letstatements create a new hard scope block (see above) and introduce new variable bindings each time  
they run. Whereas assignments might reassign a new value to an existing value location,letalways creates  
a new location. This difference is usually not important, and is only detectable in the case of variables that  
outlivetheirscopeviaclosures. Theletsyntaxacceptsacomma-separatedseriesofassignmentsandvariable  
names:

```
julia> x, y, z= -1, -1, -1;
```

```
julia>let x = 1, z
println("x: $x , y: $y ") # x is local variable, y the global
println("z: $z ") # errors as z has not been assigned yet but is local
end
x: 1, y: -1
ERROR: UndefVarError: z not defined
```

The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new  
variable on the left-hand side has been introduced. Therefore it makes sense to write something likelet x =  
xsince the twoxvariables are distinct and have separate storage. Here is an example where the behavior of  
letis needed:

```
julia> Fs = Vector { Any }(undef,2); i= 1;
```

```
julia>while i <= 2
Fs[i]= ()->i
global i += 1
end
```

```
julia> Fs[1]()
3
```

```
julia> Fs[2]()
3
```

Here we create and store two closures that return variablei. However, it is always the same variablei, so the  
two closures behave identically. We can useletto create a new binding fori:

```
julia> Fs = Vector { Any }(undef,2); i= 1;
```

```
julia>while i <= 2
let i = i
Fs[i]= ()->i
end
global i += 1
end
```

```
julia> Fs[1]()
1
```

```
julia> Fs[2]()
2
```

#### CHAPTER 10. SCOPE OF VARIABLES 102

Since thebeginconstruct does not introduce a new scope, it can be useful to use a zero-argumentletto just  
introduce a new scope block without creating any new bindings immediately:

```
julia>let
local x = 1
let
local x = 2
end
x
end
1
```

Sinceletintroduces a new scope block, the inner localxis a different variable than the outer localx. This  
particular example is equivalent to:

```
julia>let x = 1
let x = 2
end
x
end
1
```

### Loops and Comprehensions

In loops andcomprehensions, new variables introduced in their body scopes are freshly allocated for each loop  
iteration, as if the loop body were surrounded by aletblock, as demonstrated by this example:

```
julia> Fs = Vector { Any }(undef,2);
```

```
julia>for j = 1:2
Fs[j]= ()->j
end
```

```
julia> Fs[1]()
1
```

```
julia> Fs[2]()
2
```

Aforloop or comprehension iteration variable is always a new variable:

```
julia>function f()
i = 0
for i = 1:3
# empty
end
return i
end ;
```

```
julia> f()
0
```

However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done  
conveniently by adding the keywordouter:

#### CHAPTER 10. SCOPE OF VARIABLES 103

```
julia>function f()
i = 0
for outer i= 1:3
# empty
end
return i
end ;
```

```
julia> f()
3
```

### 10.3 Constants

A common use of variables is giving names to specific, unchanging values. Such variables are only assigned  
once. This intent can be conveyed to the compiler using theconstkeyword:

```
julia>const e = 2.71828182845904523536;
```

```
julia>const pi = 3.14159265358979323846;
```

Multiple variables can be declared in a singleconststatement:

```
julia>const a, b= 1, 2
(1, 2)
```

Theconstdeclaration should only be used in global scope on globals. It is difficult for the compiler to optimize  
code involving global variables, since their values (or even their types) might change at almost any time. If a  
global variable will not change, adding aconstdeclaration solves this performance problem.

Local constants are quite different. The compiler is able to determine automatically when a local variable is  
constant, so local constant declarations are not necessary, and in fact are currently not supported.

Special top-level assignments, such as those performed by thefunctionandstructkeywords, are constant  
by default.

Note thatconstonly affects the variable binding; the variable may be bound to a mutable object (such as an  
array), and that object may still be modified. Additionally when one tries to assign a value to a variable that is  
declared constant the following scenarios are possible:

-   if a new value has a different type than the type of the constant then an error is thrown:

```
julia>const x = 1.0
1.0
```

```
julia> x = 1
ERROR: invalid redefinition of constant x
```

-   if a new value has the same type as the constant then a warning is printed:

```
julia>const y = 1.0
1.0
```

#### CHAPTER 10. SCOPE OF VARIABLES 104

```
julia> y = 2.0
WARNING: redefinition of constant y. This may fail, cause incorrect answers, or produce other
↪→ errors.
2.0
```

-   if an assignment would not result in the change of variable value no message is given:

```
julia>const z = 100
100
```

```
julia> z = 100
100
```

The last rule applies to immutable objects even if the variable binding would change, e.g.:

```
julia>const s1 = "1"
"1"
```

```
julia> s2 = "1"
"1"
```

```
julia> pointer.([s1, s2],1)
2-element Array{Ptr{UInt8},1}:
Ptr{UInt8} @0x00000000132c9638
Ptr{UInt8} @0x0000000013dd3d18
```

```
julia> s1 = s2
"1"
```

```
julia> pointer.([s1, s2],1)
2-element Array{Ptr{UInt8},1}:
Ptr{UInt8} @0x0000000013dd3d18
Ptr{UInt8} @0x0000000013dd3d18
```

However, for mutable objects the warning is printed as expected:

```
julia>const a = [1]
1-element Vector{Int64}:
1
```

```
julia> a = [1]
WARNING: redefinition of constant a. This may fail, cause incorrect answers, or produce other
↪→ errors.
1-element Vector{Int64}:
1
```

Note that although sometimes possible, changing the value of aconstvariable is strongly discouraged, and  
is intended only for convenience during interactive use. Changing constants can cause various problems or  
unexpected behaviors. For instance, if a method references a constant and is already compiled before the  
constant is changed, then it might keep using the old value:

#### CHAPTER 10. SCOPE OF VARIABLES 105

```
julia>const x = 1
1
```

```
julia> f() = x
f (generic function with 1 method)
```

```
julia> f()
1
```

```
julia> x = 2
WARNING: redefinition of constant x. This may fail, cause incorrect answers, or produce other
↪→ errors.
2
```

```
julia> f()
1
```

**Chapter 11**

**Types**

Typesystemshavetraditionallyfallenintotwoquitedifferentcamps: statictypesystems,whereeveryprogram  
expression must have a type computable before the execution of the program, and dynamic type systems,  
where nothing is known about types until run time, when the actual values manipulated by the program are  
available. Object orientation allows some flexibility in statically typed languages by letting code be written  
without the precise types of values being known at compile time. The ability to write code that can operate on  
different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only  
by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values  
ever restricted.

Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible  
to indicate that certain values are of specific types. This can be of great assistance in generating efficient  
code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply  
integratedwiththelanguage. MethoddispatchisexploredindetailinMethods, butisrootedinthetypesystem  
presented here.

The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write  
many useful Julia functions without ever explicitly using types. When additional expressiveness is needed,  
however, it is easy to gradually introduce explicit type annotations into previously"untyped" code. Adding  
annotationsservesthreeprimarypurposes: totakeadvantageofJulia'spowerfulmultiple-dispatchmechanism,  
to improve human readability, and to catch programmer errors.

Describing Julia in the lingo oftype systems, it is: dynamic, nominative and parametric. Generic types can be  
parameterized, and the hierarchical relationships between types areexplicitly declared, rather thanimplied  
by compatible structure. One particularly distinctive feature of Julia's type system is that concrete types may  
not subtype each other: all concrete types are final and may only have abstract types as their supertypes.  
While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few  
drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit  
structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other  
high-level aspects of Julia's type system that should be mentioned up front are:

-   There is no division between object and non-object values: all values in Julia are true objects having a  
    type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as  
    types.
-   There is no meaningful concept of a"compile-time type": the only type a value has is its actual type  
    when the program is running. This is called a"run-time type" in object-oriented languages where the  
    combination of static compilation with polymorphism makes this distinction significant.
-   Only values, not variables, have types – variables are simply names bound to values, although for sim-  
    plicity we may say"type of a variable" as shorthand for"type of the value to which a variable refers".

#### 106

#### CHAPTER 11. TYPES 107

-   Both abstract and concrete types can be parameterized by other types. They can also be parameterized  
    by symbols, by values of any type for whichisbitsreturns true (essentially, things like numbers and  
    boolsthatarestoredlikeCtypesorstructswithnopointerstootherobjects),andalsobytuplesthereof.  
    Type parameters may be omitted when they do not need to be referenced or restricted.

Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia  
programmers may never feel the need to write code that explicitly uses types. Some kinds of programming,  
however, become clearer, simpler, faster and more robust with declared types.

### 11.1 Type Declarations

The::operator can be used to attach type annotations to expressions and variables in programs. There are  
two primary reasons to do this:

1.  As an assertion to help confirm that your program works the way you expect,
2.  To provide extra type information to the compiler, which can then improve performance in some cases

When appended to an expression computing a value, the::operator is read as"is an instance of". It can be  
used anywhere to assert that the value of the expression on the left is an instance of the type on the right.  
When the type on the right is concrete, the value on the left must have that type as its implementation – recall  
that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it  
suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type  
assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:

```
julia> (1+2):: AbstractFloat
ERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64
```

```
julia> (1+2):: Int
3
```

This allows a type assertion to be attached to any expression in-place.

When appended to a variable on the left-hand side of an assignment, or as part of alocaldeclaration, the::  
operator means something a bit different: it declares the variable to always have the specified type, like a type  
declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to  
the declared type usingconvert:

```
julia>function foo()
x:: Int8 = 100
x
end
foo (generic function with 1 method)
```

```
julia> x = foo()
100
```

```
julia> typeof(x)
Int8
```

#### CHAPTER 11. TYPES 108

Thisfeatureisusefulforavoidingperformance"gotchas"thatcouldoccurifoneoftheassignmentstoavariable  
changed its type unexpectedly.

This "declaration" behavior only occurs in specific contexts:

```
local x:: Int8 # in a local declaration
x:: Int8 = 10 # as the left-hand side of an assignment
```

and applies to the whole current scope, even before the declaration. Currently, type declarations cannot be  
used in global scope, e.g. in the REPL, since Julia does not yet have constant-type globals.

Declarations can also be attached to function definitions:

```
function sinc(x):: Float64
if x == 0
return 1
end
return sin(pi*x)/(pi*x)
end
```

Returning from this function behaves just like an assignment to a variable with a declared type: the value is  
always converted toFloat64.

### 11.2 Abstract Types.

Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets  
of related concrete types: those concrete types which are their descendants. We begin with abstract types  
even though they have no instantiation because they are the backbone of the type system: they form the  
conceptual hierarchy which makes Julia's type system more than just a collection of object implementations.

Recall that inIntegers and Floating-Point Numbers, we introduced a variety of concrete types of numeric val-  
ues:Int8,UInt8,Int16,UInt16,Int32,UInt32,Int64,UInt64,Int128,UInt128,Float16,Float32, and  
Float64. Although they have different representation sizes,Int8,Int16,Int32,Int64andInt128all have  
in common that they are signed integer types. LikewiseUInt8,UInt16,UInt32,UInt64andUInt128are all  
unsigned integer types, whileFloat16,Float32andFloat64are distinct in being floating-point types rather  
than integers. It is common for a piece of code to make sense, for example, only if its arguments are some  
kind of integer, but not really depend on what particular kind of integer. For example, the greatest common  
denominator algorithm works for all kinds of integers, but will not work for floating-point numbers. Abstract  
types allow the construction of a hierarchy of types, providing a context into which concrete types can fit. This  
allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to a  
specific type of integer.

Abstract types are declared using theabstract typekeyword. The general syntaxes for declaring an abstract  
type are:

```
abstract type «name» end
abstract type «name» <: «supertype» end
```

Theabstract typekeyword introduces a new abstract type, whose name is given by«name». This name can  
be optionally followed by<:and an already-existing type, indicating that the newly declared abstract type is  
a subtype of this"parent " type.

When no supertype is given, the default supertype isAny– a predefined abstract type that all objects are  
instances of and all types are subtypes of. In type theory,Anyis commonly called"top" because it is at the

#### CHAPTER 11. TYPES 109

apex of the type graph. Julia also has a predefined abstract"bottom" type, at the nadir of the type graph,  
which is written asUnion{}. It is the exact opposite ofAny: no object is an instance ofUnion{}and all types  
are supertypes ofUnion{}.

Let 's consider some of the abstract types that make up Julia's numerical hierarchy:

```
abstracttypeNumberend
abstracttypeReal <: Numberend
abstracttypeAbstractFloat <: Realend
abstracttypeInteger <: Realend
abstracttypeSigned <: Integerend
abstracttypeUnsigned <: Integerend
```

TheNumbertype is a direct child type ofAny, andRealis its child. In turn,Realhas two children (it has  
more, but only two are shown here; we'll get to the others later):IntegerandAbstractFloat, separating the  
world into representations of integers and representations of real numbers. Representations of real numbers  
include, of course, floating-point types, but also include other types, such as rationals. Hence,AbstractFloat  
is a proper subtype ofReal, including only floating-point representations of real numbers. Integers are further  
subdivided intoSignedandUnsignedvarieties.

The<:operator in general means"is a subtype of", and, used in declarations like this, declares the right-hand  
type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype  
operator which returnstruewhen its left operand is a subtype of its right operand:

```
julia>Integer <: Number
true
```

```
julia>Integer <: AbstractFloat
false
```

An important use of abstract types is to provide default implementations for concrete types. To give a simple  
example, consider:

```
function myplus(x,y)
x+y
end
```

The first thing to note is that the above argument declarations are equivalent tox::Anyandy::Any. When  
this function is invoked, say asmyplus(2,5), the dispatcher chooses the most specific method namedmyplus  
that matches the given arguments. (SeeMethodsfor more information on multiple dispatch.)

Assumingnomethodmorespecificthantheaboveisfound, Julianextinternallydefinesandcompilesamethod  
calledmyplusspecifically for twoIntarguments based on the generic function given above, i.e., it implicitly  
defines and compiles:

```
function myplus(x:: Int ,y:: Int )
x+y
end
```

and finally, it invokes this specific method.

Thus, abstracttypesallowprogrammerstowritegenericfunctionsthatcanlaterbeusedasthedefaultmethod  
by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over  
whether the default or more specific method is used.

#### CHAPTER 11. TYPES 110

An important point to note is that there is no loss in performance if the programmer relies on a function whose  
arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it  
is invoked. (There may be a performance issue, however, in the case of function arguments that are containers  
of abstract types; seePerformance Tips.)

### 11.3 Primitive Types.

```
Warning
It is almost always preferable to wrap an existing primitive type in a new composite type than to
define your own primitive type.
ThisfunctionalityexiststoallowJuliatobootstrapthestandardprimitivetypesthatLLVMsupports.
Once they are defined, there is very little reason to define more.
```

A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types  
are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types,  
rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in  
the language itself:

```
primitive typeFloat16 <: AbstractFloat 16 end
primitive typeFloat32 <: AbstractFloat 32 end
primitive typeFloat64 <: AbstractFloat 64 end
```

```
primitive typeBool <: Integer 8 end
primitive typeChar <: AbstractChar 32 end
```

```
primitive typeInt8 <: Signed 8 end
primitive typeUInt8 <: Unsigned 8 end
primitive typeInt16 <: Signed 16 end
primitive typeUInt16 <: Unsigned 16 end
primitive typeInt32 <: Signed 32 end
primitive typeUInt32 <: Unsigned 32 end
primitive typeInt64 <: Signed 64 end
primitive typeUInt64 <: Unsigned 64 end
primitive typeInt128 <: Signed 128 end
primitive typeUInt128 <: Unsigned 128 end
```

The general syntaxes for declaring a primitive type are:

```
primitive type «name» «bits» end
primitive type «name» <: «supertype» «bits» end
```

The number of bits indicates how much storage the type requires and the name gives the new type a name.  
A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then  
the type defaults to havingAnyas its immediate supertype. The declaration ofBoolabove therefore means  
that a boolean value takes eight bits to store, and hasIntegeras its immediate supertype. Currently, only  
sizes that are multiples of 8 bits are supported and you are likely to experience LLVM bugs with sizes other than  
those used above. Therefore, boolean values, although they really need just a single bit, cannot be declared  
to be any smaller than eight bits.

The typesBool,Int8andUInt8all have identical representations: they are eight-bit chunks of memory. Since  
Julia's type system is nominative, however, they are not interchangeable despite having identical structure.  
A fundamental difference between them is that they have different supertypes:Bool's direct supertype is

#### CHAPTER 11. TYPES 111

Integer,Int8's isSigned, andUInt8's isUnsigned. All other differences betweenBool,Int8, andUInt8are  
mattersofbehavior–thewayfunctionsaredefinedtoactwhengivenobjectsofthesetypesasarguments. This  
is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior,  
then it would be impossible to makeBoolbehave any differently thanInt8orUInt8.

### 11.4 Composite Types.

Composite typesare called records, structs, or objects in various languages. A composite type is a collection  
of named fields, an instance of which can be treated as a single value. In many languages, composite types  
are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia  
as well.

In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have  
named functions associated with them, and the combination is called an"object". In purer object-oriented  
languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure  
object oriented languages, including C++ and Java, some values, such as integers and floating-point values,  
are not objects, while instances of user-defined composite types are true objects with associated methods. In  
Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary  
since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of all of a  
function's arguments are considered when selecting a method, rather than just the first one (seeMethodsfor  
more information on methods and dispatch). Thus, it would be inappropriate for functions to"belong" to only  
their first argument. Organizing methods into function objects rather than having named bags of methods  
"inside" each object ends up being a highly beneficial aspect of the language design.

Composite types are introduced with thestructkeyword followed by a block of field names, optionally anno-  
tated with types using the::operator:

```
julia> struct Foo
bar
baz:: Int
qux:: Float64
end
```

Fields with no type annotation default toAny, and can accordingly hold any type of value.

New objects of typeFooare created by applying theFootype object like a function to values for its fields:

```
julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.", 23, 1.5)
```

```
julia> typeof(foo)
Foo
```

When a type is applied like a function it is called a constructor. Two constructors are generated automatically  
(these are called default constructors). One accepts any arguments and callsconvertto convert them to the  
types of the fields, and the other accepts arguments that match the field types exactly. The reason both of  
these are generated is that this makes it easier to add new definitions without inadvertently replacing a default  
constructor.

Since thebarfield is unconstrained in type, any value will do. However, the value forbazmust be convertible  
toInt:

#### CHAPTER 11. TYPES 112

```
julia> Foo((),23.5, 1)
ERROR: InexactError: Int64(23.5)
Stacktrace:
[...]
```

You may find a list of field names using thefieldnamesfunction.

```
julia> fieldnames(Foo)
(:bar, :baz, :qux)
```

You can access the field values of a composite object using the traditionalfoo.barnotation:

```
julia> foo.bar
"Hello, world."
```

```
julia> foo.baz
23
```

```
julia> foo.qux
1.5
```

Composite objects declared withstructare immutable; they cannot be modified after construction. This may  
seem odd at first, but it has several advantages:

-   It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the  
    compiler is able to avoid allocating immutable objects entirely.
-   It is not possible to violate the invariants provided by the type's constructors.
-   Code using immutable objects can be easier to reason about.

An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will  
remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.

Where required, mutable composite objects can be declared with the keywordmutable struct, to be dis-  
cussed in the next section.

If all the fields of an immutable structure are indistinguishable (===) then two immutable values containing  
those fields are also indistinguishable:

```
julia> struct X
a:: Int
b:: Float64
end
```

```
julia> X(1, 2) === X(1, 2)
true
```

There is much more to say about how instances of composite types are created, but that discussion depends  
on bothParametric Typesand onMethods, and is sufficiently important to be addressed in its own section:  
Constructors.

#### CHAPTER 11. TYPES 113

### 11.5 Mutable Composite Types.

If a composite type is declared withmutable structinstead ofstruct, then instances of it can be modified:

```
julia> mutable struct Bar
baz
qux:: Float64
end
```

```
julia> bar = Bar("Hello", 1.5);
```

```
julia> bar.qux = 2.0
2.0
```

```
julia> bar.baz = 1//2
1//2
```

In order to support mutation, such objects are generally allocated on the heap, and have stable memory  
addresses. A mutable object is like a little container that might hold different values over time, and so can only  
be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific  
field values –- the field values alone tell you everything about the object. In deciding whether to make a type  
mutable, ask whether two instances with the same field values would be considered identical, or if they might  
need to change independently over time. If they would be considered identical, the type should probably be  
immutable.

To recap, two essential properties define immutability in Julia:

-   It is not permitted to modify the value of an immutable type.  
    **-** For bits types this means that the bit pattern of a value once set will never change and that value  
    is the identity of a bits type.  
    **-** For composite types, this means that the identity of the values of its fields will never change.  
    When the fields are bits types, that means their bits will never change, for fields whose values are  
    mutable types like arrays, that means the fields will always refer to the same mutable value even  
    though that mutable value's content may itself be modified.
-   An object with an immutable type may be copied freely by the compiler since its immutability makes it  
    impossible to programmatically distinguish between the original object and a copy.  
    **-** In particular, this means that small enough immutable values like integers and floats are typically  
    passed to functions in registers (or stack allocated).  
    **-** Mutable values, on the other hand are heap-allocated and passed to functions as pointers to heap-  
    allocated values except in cases where the compiler is sure that there's no way to tell that this is  
    not what is happening.

### 11.6 Declared Types

The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all  
closely related. They share the same key properties:

-   They are explicitly declared.

#### CHAPTER 11. TYPES 114

-   They have names.
-   They have explicitly declared supertypes.
-   They may have parameters.

Because of these shared properties, these types are internally represented as instances of the same concept,  
DataType, which is the type of any of these types:

```
julia> typeof( Real )
DataType
```

```
julia> typeof( Int )
DataType
```

ADataTypemaybeabstractorconcrete. Ifitisconcrete, ithasaspecifiedsize, storagelayout, and(optionally)  
field names. Thus a primitive type is aDataTypewith nonzero size, but no field names. A composite type is a  
DataTypethat has field names or is empty (zero size).

Every concrete value in the system is an instance of someDataType.

### 11.7 Type Unions

A type union is a special abstract type which includes as objects all instances of any of its argument types,  
constructed using the specialUnionkeyword:

```
julia> IntOrString= Union { Int , AbstractString }
Union{Int64, AbstractString}
```

```
julia> 1 :: IntOrString
1
```

```
julia> "Hello!":: IntOrString
"Hello!"
```

```
julia> 1.0 :: IntOrString
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64
```

The compilers for many languages have an internal union construct for reasoning about types; Julia simply  
exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence ofUnion  
types with a small number of types^1 , by generating specialized code in separate branches for each possible  
type.

A particularly useful case of aUniontype isUnion{T, Nothing}, whereTcan be any type andNothingis  
the singleton type whose only instance is the objectnothing. This pattern is the Julia equivalent ofNullable,  
OptionorMaybetypes in other languages. Declaring a function argument or a field asUnion{T, Nothing}  
allows setting it either to a value of typeT, or tonothingto indicate that there is no value. Seethis FAQ entry  
for more information.

#### CHAPTER 11. TYPES 115

### 11.8 Parametric Types

An important and powerful feature of Julia's type system is that it is parametric: types can take parameters, so  
that type declarations actually introduce a whole family of new types – one for each possible combination of  
parametervalues. Therearemanylanguagesthatsupportsomeversionofgenericprogramming,whereindata  
structures and algorithms to manipulate them may be specified without specifying the exact types involved.  
For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and  
Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell,  
Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so  
many different varieties of generic programming and parametric types in various languages, we won't even  
attempt to compare Julia's parametric types to other languages, but will instead focus on explaining Julia's  
system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn't  
need to make all type decisions at compile time, many traditional difficulties encountered in static parametric  
type systems can be relatively easily handled.

All declared types (theDataTypevariety) can be parameterized, with the same syntax in each case. We will  
discuss them in the following order: first, parametric composite types, then parametric abstract types, and  
finally parametric primitive types.

### Parametric Composite Types

Type parameters are introduced immediately after the type name, surrounded by curly braces:

```
julia> struct Point{T}
x::T
y::T
end
```

This declaration defines a new parametric type,Point{T}, holding two"coordinates" of typeT. What, one may  
ask, isT? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits  
type, actually, although here it's clearly used as a type). Point{Float64}is a concrete type equivalent to  
the type defined by replacingTin the definition ofPointwithFloat64. Thus, this single declaration actually  
declares an unlimited number of types:Point{Float64},Point{AbstractString},Point{Int64}, etc. Each  
of these is now a usable concrete type:

```
julia> Point{ Float64 }
Point{Float64}
```

```
julia> Point{ AbstractString }
Point{AbstractString}
```

ThetypePoint{Float64}isapointwhosecoordinatesare64-bitfloating-pointvalues,whilethetypePoint{AbstractString}  
is a "point" whose"coordinates" are string objects (seeStrings).

Pointitselfisalsoavalidtypeobject, containingallinstancesPoint{Float64},Point{AbstractString}, etc.  
as subtypes:

```
julia> Point{ Float64 } <: Point
true
```

```
julia> Point{ AbstractString } <: Point
true
```

#### CHAPTER 11. TYPES 116

Other types, of course, are not subtypes of it:

```
julia>Float64 <: Point
false
```

```
julia>AbstractString <: Point
false
```

ConcretePointtypes with different values ofTare never subtypes of each other:

```
julia> Point{ Float64 } <: Point{ Int64 }
false
```

```
julia> Point{ Float64 } <: Point{ Real }
false
```

```
Warning
Thislastpointisveryimportant: eventhoughFloat64 <: Realwe DONOT havePoint{Float64}
<: Point{Real}.
```

Inotherwords, intheparlanceoftypetheory, Julia'stypeparametersareinvariant, ratherthanbeingcovariant  
(or even contravariant). This is for practical reasons: while any instance ofPoint{Float64}may conceptually  
be like an instance ofPoint{Real}as well, the two types have different representations in memory:

-   An instance ofPoint{Float64}can be represented compactly and efficiently as an immediate pair of  
    64-bit values;
-   An instance ofPoint{Real}must be able to hold any pair of instances ofReal. Since objects that are  
    instances ofRealcan be of arbitrary size and structure, in practice an instance ofPoint{Real}must be  
    represented as a pair of pointers to individually allocatedRealobjects.

The efficiency gained by being able to storePoint{Float64}objects with immediate values is magnified  
enormously in the case of arrays: anArray{Float64}can be stored as a contiguous memory block of 64-bit  
floating-point values, whereas anArray{Real}must be an array of pointers to individually allocatedReal  
objects – which may well beboxed64-bit floating-point values, but also might be arbitrarily large, complex  
objects, which are declared to be implementations of theRealabstract type.

SincePoint{Float64}is not a subtype ofPoint{Real}, the following method can't be applied to arguments  
of typePoint{Float64}:

```
function norm(p::Point{ Real })
sqrt(p.x^2 + p.y^2)
end
```

A correct way to define a method that accepts all arguments of typePoint{T}whereTis a subtype ofRealis:

```
function norm(p::Point{<: Real })
sqrt(p.x^2 + p.y^2)
end
```

#### CHAPTER 11. TYPES 117

(Equivalently,onecoulddefinefunction norm(p::Point{T} where T<:Real)orfunction norm(p::Point{T})  
where T<:Real; see UnionAll Types.)

More examples will be discussed later inMethods.

HowdoesoneconstructaPointobject? Itispossibletodefinecustomconstructorsforcompositetypes, which  
will be discussed in detail inConstructors, but in the absence of any special constructor declarations, there  
are two default ways of creating new composite objects, one in which the type parameters are explicitly given  
and the other in which they are implied by the arguments to the object constructor.

Since the typePoint{Float64}is a concrete type equivalent toPointdeclared withFloat64in place ofT, it  
can be applied as a constructor accordingly:

```
julia> p = Point{ Float64 }(1.0, 2.0)
Point{Float64}(1.0, 2.0)
```

```
julia> typeof(p)
Point{Float64}
```

For the default constructor, exactly one argument must be supplied for each field:

```
julia> Point{ Float64 }(1.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64)
[...]
```

```
julia> Point{ Float64 }(1.0,2.0,3.0)
ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
[...]
```

Only one default constructor is generated for parametric types, since overriding it is not possible. This con-  
structor accepts any arguments and converts them to the field types.

In many cases, it is redundant to provide the type ofPointobject one wants to construct, since the types of  
arguments to the constructor call already implicitly provide type information. For that reason, you can also  
applyPointitself as a constructor, provided that the implied value of the parameter typeTis unambiguous:

```
julia> p1 = Point(1.0,2.0)
Point{Float64}(1.0, 2.0)
```

```
julia> typeof(p1)
Point{Float64}
```

```
julia> p2 = Point(1,2)
Point{Int64}(1, 2)
```

```
julia> typeof(p2)
Point{Int64}
```

In the case ofPoint, the type ofTis unambiguously implied if and only if the two arguments toPointhave  
the same type. When this isn't the case, the constructor will fail with aMethodError:

```
julia> Point(1,2.5)
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
Point(::T, !Matched::T) where T at none:2
```

#### CHAPTER 11. TYPES 118

Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed  
until later on inConstructors.

### Parametric Abstract Types

Parametric abstract type declarations declare a collection of abstract types, in much the same way:

```
julia>abstracttype Pointy{T} end
```

With this declaration,Pointy{T}is a distinct abstract type for each type or integer value ofT. As with para-  
metric composite types, each such instance is a subtype ofPointy:

```
julia> Pointy{ Int64 } <: Pointy
true
```

```
julia> Pointy{1} <: Pointy
true
```

Parametric abstract types are invariant, much as parametric composite types are:

```
julia> Pointy{ Float64 } <: Pointy{ Real }
false
```

```
julia> Pointy{ Real } <: Pointy{ Float64 }
false
```

ThenotationPointy{<:Real}canbeusedtoexpresstheJuliaanalogueofacovarianttype,whilePointy{>:Int}  
the analogue of a contravariant type, but technically these represent sets of types (seeUnionAll Types).

```
julia> Pointy{ Float64 } <: Pointy{<: Real }
true
```

```
julia> Pointy{ Real } <: Pointy{>: Int }
true
```

Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric  
abstract types serve the same purpose with respect to parametric composite types. We could, for example,  
have declaredPoint{T}to be a subtype ofPointy{T}as follows:

```
julia> struct Point{T}<: Pointy{T}
x::T
y::T
end
```

Given such a declaration, for each choice ofT, we havePoint{T}as a subtype ofPointy{T}:

```
julia> Point{ Float64 } <: Pointy{ Float64 }
true
```

```
julia> Point{ Real } <: Pointy{ Real }
true
```

```
julia> Point{ AbstractString } <: Pointy{ AbstractString }
true
```

#### CHAPTER 11. TYPES 119

This relationship is also invariant:

```
julia> Point{ Float64 } <: Pointy{ Real }
false
```

```
julia> Point{ Float64 } <: Pointy{<: Real }
true
```

What purpose do parametric abstract types likePointyserve? Consider if we create a point-like implementa-  
tion that only requires a single coordinate because the point is on the diagonal line x = y:

```
julia> struct DiagPoint{T}<: Pointy{T}
x::T
end
```

Now bothPoint{Float64}andDiagPoint{Float64}are implementations of thePointy{Float64}abstrac-  
tion, and similarly for every other possible choice of typeT. This allows programming to a common interface  
shared by allPointyobjects, implemented for bothPointandDiagPoint. This cannot be fully demonstrated,  
however, until we have introduced methods and dispatch in the next section,Methods.

There are situations where it may not make sense for type parameters to range freely over all possible types.  
In such situations, one can constrain the range ofTlike so:

```
julia>abstracttype Pointy{T<: Real } end
```

With such a declaration, it is acceptable to use any type that is a subtype ofRealin place ofT, but not types  
that are not subtypes ofReal:

```
julia> Pointy{ Float64 }
Pointy{Float64}
```

```
julia> Pointy{ Real }
Pointy{Real}
```

```
julia> Pointy{ AbstractString }
ERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}
```

```
julia> Pointy{1}
ERROR: TypeError: in Pointy, in T, expected T<:Real, got a value of type Int64
```

Type parameters for parametric composite types can be restricted in the same manner:

```
struct Point{T<: Real } <: Pointy{T}
x::T
y::T
end
```

To give a real-world example of how all this parametric type machinery can be useful, here is the actual defini-  
tion of Julia'sRationalimmutable type (except that we omit the constructor here for simplicity), representing  
an exact ratio of integers:

#### CHAPTER 11. TYPES 120

```
struct Rational {T<: Integer } <: Real
num::T
den::T
end
```

It only makes sense to take ratios of integer values, so the parameter typeTis restricted to being a subtype  
ofInteger, and a ratio of integers represents a value on the real number line, so anyRationalis an instance  
of theRealabstraction.

### Tuple Types

Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of  
a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized  
immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles  
the following immutable type:

```
struct Tuple2{A,B}
a::A
b::B
end
```

However, there are three key differences:

-   Tuple types may have any number of parameters.
-   Tuple types are covariant in their parameters: Tuple{Int}is a subtype ofTuple{Any}. Therefore  
    Tuple{Any}is considered an abstract type, and tuple types are only concrete if their parameters are.
-   Tuples do not have field names; fields are only accessed by index.

Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple  
type is generated on demand:

```
julia> typeof((1,"foo",2.5))
Tuple{Int64, String, Float64}
```

Note the implications of covariance:

```
julia>Tuple { Int , AbstractString } <: Tuple { Real , Any }
true
```

```
julia>Tuple { Int , AbstractString } <: Tuple { Real , Real }
false
```

```
julia>Tuple { Int , AbstractString } <: Tuple { Real ,}
false
```

Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature  
(when the signature matches).

#### CHAPTER 11. TYPES 121

### Vararg Tuple Types

The last parameter of a tuple type can be the special valueVararg, which denotes any number of trailing  
elements:

```
julia> mytupletype= Tuple { AbstractString , Vararg { Int }}
Tuple{AbstractString, Vararg{Int64}}
```

```
julia> isa(("1",), mytupletype)
true
```

```
julia> isa(("1",1), mytupletype)
true
```

```
julia> isa(("1",1,2), mytupletype)
true
```

```
julia> isa(("1",1,2,3.0), mytupletype)
false
```

MoreoverVararg{T}corresponds to zero or more elements of typeT. Vararg tuple types are used to represent  
the arguments accepted by varargs methods (seeVarargs Functions).

The special valueVararg{T,N}(when used as the last parameter of a tuple type) corresponds to exactlyN  
elements of typeT.NTuple{N,T}is a convenient alias forTuple{Vararg{T,N}}, i.e. a tuple type containing  
exactlyNelements of typeT.

### Named Tuple Types

Named tuples are instances of theNamedTupletype, which has two parameters: a tuple of symbols giving the  
field names, and a tuple type giving the field types.

```
julia> typeof((a=1,b="hello"))
NamedTuple{(:a, :b), Tuple{Int64, String}}
```

The@NamedTuplemacro provides a more convenientstruct-like syntax for declaringNamedTupletypes via  
key::Typedeclarations, where an omitted::Typecorresponds to::Any.

```
julia> @NamedTuple{a:: Int , b ::String}
NamedTuple{(:a, :b), Tuple{Int64, String}}
```

```
julia> @NamedTuple begin
a:: Int
b::String
end
NamedTuple{(:a, :b), Tuple{Int64, String}}
```

ANamedTupletypecanbeusedasaconstructor,acceptingasingletupleargument. TheconstructedNamedTuple  
type can be either a concrete type, with both parameters specified, or a type that specifies only field names:

```
julia> @NamedTuple{a:: Float32 ,b::String}((1,""))
(a = 1.0f0, b = "")
```

```
julia> NamedTuple{(:a, :b)}((1,""))
(a = 1, b = "")
```

#### CHAPTER 11. TYPES 122

If field types are specified, the arguments are converted. Otherwise the types of the arguments are used  
directly.

### Parametric Primitive Types

Primitive types can also be declared parametrically. For example, pointers are represented as primitive types  
which would be declared in Julia like this:

```
# 32-bit system:
primitive typePtr {T} 32 end
```

```
# 64-bit system:
primitive typePtr {T} 64 end
```

The slightly odd feature of these declarations as compared to typical parametric composite types, is that the  
type parameterTis not used in the definition of the type itself – it is just an abstract tag, essentially defining an  
entire family of types with identical structure, differentiated only by their type parameter. Thus,Ptr{Float64}  
andPtr{Int64}are distinct types, even though they have identical representations. And of course, all specific  
pointer types are subtypes of the umbrellaPtrtype:

```
julia>Ptr { Float64 } <: Ptr
true
```

```
julia>Ptr { Int64 } <: Ptr
true
```

### 11.9 UnionAll Types.

We have said that a parametric type likePtracts as a supertype of all its instances (Ptr{Int64}etc.). How  
does this work?Ptritself cannot be a normal data type, since without knowing the type of the referenced data  
the type clearly cannot be used for memory operations. The answer is thatPtr(or other parametric types like  
Array) is a different kind of type called aUnionAlltype. Such a type expresses the iterated union of types for  
all values of some parameter.

UnionAlltypes are usually written using the keywordwhere. For examplePtrcould be more accurately  
written asPtr{T} where T, meaning all values whose type isPtr{T}for some value ofT. In this context,  
the parameterTis also often called a"type variable" since it is like a variable that ranges over types. Each  
whereintroduces a single type variable, so these expressions are nested for types with multiple parameters,  
for exampleArray{T,N} where N where T.

The type application syntaxA{B,C}requiresAto be aUnionAlltype, and first substitutesBfor the outer-  
most type variable inA. The result is expected to be anotherUnionAlltype, into whichCis then substi-  
tuted. SoA{B,C}is equivalent toA{B}{C}. This explains why it is possible to partially instantiate a type, as in  
Array{Float64}: the first parameter value has been fixed, but the second still ranges over all possible values.  
Using explicitwheresyntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional  
arrays can be written asArray{T,1} where T.

Typevariablescanberestrictedwithsubtyperelations.Array{T} where T<:Integerreferstoallarrayswhose  
element type is some kind ofInteger. The syntaxArray{<:Integer}is a convenient shorthand forArray{T}  
where T<:Integer. Typevariablescanhavebothlowerandupperbounds.Array{T} where Int<:T<:Number  
refers to all arrays ofNumbers that are able to containInts (sinceTmust be at least as big asInt). The syntax  
where T>:Intalso works to specify only the lower bound of a type variable, andArray{>:Int}is equivalent  
toArray{T} where T>:Int.

#### CHAPTER 11. TYPES 123

Sincewhereexpressionsnest,typevariableboundscanrefertooutertypevariables. ForexampleTuple{T,Array{S}}  
where S<:AbstractArray{T} where T<:Realrefers to 2-tuples whose first element is someReal, and whose  
secondelementisanArrayofanykindofarraywhoseelementtypecontainsthetypeofthefirsttupleelement.

Thewherekeyword itself can be nested inside a more complex declaration. For example, consider the two  
types created by the following declarations:

```
julia>const T1 = Array { Array {T, 1} where T,1}
Vector{Vector} (alias for Array{Array{T, 1} where T, 1})
```

```
julia>const T2 = Array { Array {T, 1}, 1} where T
Array{Vector{T}, 1} where T
```

TypeT1defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of  
the same type, but this type may vary from one inner array to the next. On the other hand, typeT2defines a  
1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type. Note thatT2  
is an abstract type, e.g.,Array{Array{Int,1},1} <: T2, whereasT1is a concrete type. As a consequence,  
T1can be constructed with a zero-argument constructora=T1()butT2cannot.

There is a convenient syntax for naming such types, similar to the short form of function definition syntax:

```
Vector {T} = Array {T, 1}
```

This is equivalent toconst Vector = Array{T,1} where T. WritingVector{Float64}is equivalent to writ-  
ingArray{Float64,1}, and the umbrella typeVectorhas as instances allArrayobjects where the second  
parameter – the number of array dimensions – is 1, regardless of what the element type is. In languages where  
parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to  
write justVectorfor the abstract type including all one-dimensional dense arrays of any element type.

### 11.10Singleton types

Immutable composite types with no fields are called singletons. Formally, if

1.  Tis an immutable composite type (i.e. defined withstruct),
2.  a isa T && b isa Timpliesa === b,

thenTis a singleton type.^2 Base.issingletontypecan be used to check if a type is a singleton type.Abstract  
types cannot be singleton types by construction.

From the definition, it follows that there can be only one instance of such types:

```
julia> struct NoFields
end
```

```
julia> NoFields()=== NoFields()
true
```

```
julia> Base.issingletontype(NoFields)
true
```

The===function confirms that the constructed instances ofNoFieldsare actually one and the same.

Parametric types can be singleton types when the above condition holds. For example,

#### CHAPTER 11. TYPES 124

```
julia> struct NoFieldsParam{T}
end
```

```
julia> Base.issingletontype(NoFieldsParam)# can't be a singleton type ...
false
```

```
julia> NoFieldsParam{ Int }() isa NoFieldsParam# ... because it has ...
true
```

```
julia> NoFieldsParam{ Bool }() isa NoFieldsParam# ... multiple instances
true
```

```
julia> Base.issingletontype(NoFieldsParam{ Int }) # parametrized, it is a singleton
true
```

```
julia> NoFieldsParam{ Int }() === NoFieldsParam{ Int }()
true
```

### 11.11 Type{T}type selectors

For each typeT,Type{T}is an abstract parametric type whose only instance is the objectT. Until we discuss  
Parametric Methodsand conversions, it is difficult to explain the utility of this construct, but in short, it allows  
one to specialize function behavior on specific types as values. This is useful for writing methods (especially  
parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied  
by the type of one of its arguments.

Since the definition is a little difficult to parse, let's look at some examples:

```
julia> isa( Float64 , Type { Float64 })
true
```

```
julia> isa( Real , Type { Float64 })
false
```

```
julia> isa( Real , Type { Real })
true
```

```
julia> isa( Float64 , Type { Real })
false
```

In other words,isa(A, Type{B})is true if and only ifAandBare the same object and that object is a type.

In particular, since parametric types areinvariant, we have

```
julia> struct TypeParamExample{T}
x::T
end
```

```
julia> TypeParamExample isa Type {TypeParamExample}
true
```

```
julia> TypeParamExample{ Int } isa Type {TypeParamExample}
false
```

```
julia> TypeParamExample{ Int } isa Type {TypeParamExample{ Int }}
true
```

#### CHAPTER 11. TYPES 125

Without the parameter,Typeis simply an abstract type which has all type objects as its instances:

```
julia> isa( Type { Float64 }, Type )
true
```

```
julia> isa( Float64 , Type )
true
```

```
julia> isa( Real , Type )
true
```

Any object that is not a type is not an instance ofType:

```
julia> isa(1, Type )
false
```

```
julia> isa("foo", Type )
false
```

WhileTypeis part of Julia's type hierarchy like any other abstract parametric type, it is not commonly used  
outside method signatures except in some special cases. Another important use case forTypeis sharpening  
fieldtypes which wouldotherwisebe capturedless precisely, e.g. asDataTypeinthe examplebelow wherethe  
default constuctor could lead to performance problems in code relying on the precise wrapped type (similarly  
to abstract type parameters).

```
julia> struct WrapType{T}
value::T
end
```

```
julia> WrapType( Float64 ) # default constructor, note DataType
WrapType{DataType}(Float64)
```

```
julia> WrapType(:: Type {T}) where T= WrapType{ Type {T}}(T)
WrapType
```

```
julia> WrapType( Float64 ) # sharpened constructor, note more precise Type{Float64}
WrapType{Type{Float64}}(Float64)
```

### 11.12Type Aliases

Sometimes it is convenient to introduce a new name for an already expressible type. This can be done with  
a simple assignment statement. For example,UIntis aliased to eitherUInt32orUInt64as is appropriate for  
the size of pointers on the system:

```
# 32-bit system:
julia>UInt
UInt32
```

```
# 64-bit system:
julia>UInt
UInt64
```

#### CHAPTER 11. TYPES 126

This is accomplished via the following code inbase/boot.jl:

```
if Int === Int64
constUInt = UInt64
else
constUInt = UInt32
end
```

Of course, this depends on whatIntis aliased to – but that is predefined to be the correct type – eitherInt32  
orInt64.

(Note that unlikeInt,Floatdoes not exist as a type alias for a specific sizedAbstractFloat. Unlike with  
integer registers, where the size ofIntreflects the size of a native pointer on that machine, the floating point  
register sizes are specified by the IEEE-754 standard.)

### 11.13Operations on Types.

Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are  
particularly useful for working with or exploring types have already been introduced, such as the<:operator,  
which indicates whether its left hand operand is a subtype of its right hand operand.

Theisafunction tests if an object is of a given type and returns true or false:

```
julia> isa(1, Int )
true
```

```
julia> isa(1, AbstractFloat )
false
```

Thetypeoffunction, alreadyusedthroughoutthemanualinexamples, returnsthetypeofitsargument. Since,  
as noted above, types are objects, they also have types, and we can ask what their types are:

```
julia> typeof( Rational { Int })
DataType
```

```
julia> typeof( Union { Real ,String})
Union
```

What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite  
values and thus all have a type ofDataType:

```
julia> typeof( DataType )
DataType
```

```
julia> typeof( Union )
DataType
```

DataTypeis its own type.

Another operation that applies to some types issupertype, which reveals a type's supertype. Only declared  
types (DataType) have unambiguous supertypes:

#### CHAPTER 11. TYPES 127

```
julia> supertype( Float64 )
AbstractFloat
```

```
julia> supertype( Number )
Any
```

```
julia> supertype( AbstractString )
Any
```

```
julia> supertype( Any )
Any
```

If you applysupertypeto other type objects (or non-type objects), aMethodErroris raised:

```
julia> supertype( Union { Float64 , Int64 })
ERROR: MethodError: no method matching supertype(::Type{Union{Float64, Int64}})
Closest candidates are:
[...]
```

### 11.14Custom pretty-printing

Often, one wants to customize how instances of a type are displayed. This is accomplished by overloading the  
showfunction. For example, suppose we define a type to represent complex numbers in polar form:

```
julia> struct Polar{T<: Real } <: Number
r::T
Θ::T
end
```

```
julia> Polar(r:: Real ,Θ:: Real ) = Polar(promote(r,Θ)...)
Polar
```

Here, we've added a custom constructor function so that it can take arguments of differentRealtypes and  
promote them to a common type (seeConstructorsand Conversion and Promotion). (Of course, we would  
have to define lots of other methods, too, to make it act like aNumber, e.g.+,*,one,zero, promotion rules  
and so on.) By default, instances of this type display rather simply, with information about the type name and  
the field values, as e.g.Polar{Float64}(3.0,4.0).

If we want it to display instead as3.0 * exp(4.0im), we would define the following method to print the object  
to a given output objectio(representing a file, terminal, buffer, etcetera; seeNetworking and Streams):

```
julia> Base.show(io:: IO , z ::Polar)= print(io, z.r, " * exp(", z .Θ, "im)")
```

More fine-grained control over display ofPolarobjects is possible. In particular, sometimes one wants both  
a verbose multi-line printing format, used for displaying a single object in the REPL and other interactive  
environments, and also a more compact single-line format used forprintor for displaying the object as part  
of another object (e.g. in an array). Although by default theshow(io, z)function is called in both cases, you  
can define a different multi-line format for displaying an object by overloading a three-argument form ofshow  
that takes thetext/plainMIME type as its second argument (seeMultimedia I/O), for example:

```
julia> Base.show(io:: IO , :: MIME "text/plain", z ::Polar{T}) where{T}=
print(io,"Polar{ $T } complex number: \n ", z)
```

#### CHAPTER 11. TYPES 128

(Note thatprint(..., z)here will call the 2-argumentshow(io, z)method.) This results in:

```
julia> Polar(3, 4.0)
Polar{Float64} complex number:
3.0 * exp(4.0im)
```

```
julia> [Polar(3, 4.0), Polar(4.0,5.3)]
2-element Vector{Polar{Float64}}:
3.0 * exp(4.0im)
4.0 * exp(5.3im)
```

where the single-lineshow(io, z)form is still used for an array ofPolarvalues. Technically, the REPL calls  
display(z)to display the result of executing a line, which defaults toshow(stdout, MIME("text/plain"),  
z), which in turn defaults toshow(stdout, z), but you should not define newdisplaymethods unless you  
are defining a new multimedia display handler (seeMultimedia I/O).

Moreover, you can also defineshowmethods for other MIME types in order to enable richer display (HTML, im-  
ages, etcetera) of objects in environments that support this (e.g. IJulia). For example, we can define formatted  
HTML display ofPolarobjects, with superscripts and italics, via:

```
julia> Base.show(io:: IO , :: MIME "text/html", z ::Polar{T}) where {T}=
println(io,"<code>Polar{ $T }</code> complex number: ",
z.r, " <i>e</i><sup>", z .Θ, " <i>i</i></sup>")
```

APolarobject will then display automatically using HTML in an environment that supports HTML display, but  
you can callshowmanually to get HTML output if you want:

```
julia> show(stdout,"text/html", Polar(3.0,4.0))
<code>Polar{Float64}</code> complex number: 3.0 <i>e</i><sup>4.0 <i>i</i></sup>
```

As a rule of thumb, the single-lineshowmethod should print a valid Julia expression for creating the shown  
object. When thisshowmethod contains infix operators, such as the multiplication operator (*) in our single-  
lineshowmethod forPolarabove, it may not parse correctly when printed as part of another object. To see  
this, consider the expression object (seeProgram representation) which takes the square of a specific instance  
of ourPolartype:

```
julia> a = Polar(3, 4.0)
Polar{Float64} complex number:
3.0 * exp(4.0im)
```

```
julia> print(:($a^2))
3.0 * exp(4.0im) ^ 2
```

Because the operator^has higher precedence than*(see Operator Precedence and Associativity), this output  
doesnotfaithfullyrepresenttheexpressiona ^ 2whichshouldbeequalto(3.0 * exp(4.0im)) ^ 2. Tosolve  
this issue, we must make a custom method forBase.show_unquoted(io::IO, z::Polar, indent::Int,  
precedence::Int), which is called internally by the expression object when printing:

```
julia>function Base.show_unquoted(io:: IO , z ::Polar,:: Int , precedence:: Int )
if Base.operator_precedence(:*) <= precedence
print(io,"(")
```

#### CHAPTER 11. TYPES 129

```
show(io, z)
print(io,")")
else
show(io, z)
end
end
```

```
julia> :($a^2)
:((3.0 * exp(4.0im)) ^ 2)
```

The method defined above adds parentheses around the call toshowwhen the precedence of the calling  
operator is higher than or equal to the precedence of multiplication. This check allows expressions which  
parse correctly without the parentheses (such as:($a + 2)and:($a == 2)) to omit them when printing:

```
julia> :($a + 2)
:(3.0 * exp(4.0im) + 2)
```

```
julia> :($a == 2)
:(3.0 * exp(4.0im) == 2)
```

In some cases, it is useful to adjust the behavior ofshowmethods depending on the context. This can be  
achieved via theIOContexttype, which allows passing contextual properties together with a wrapped IO  
stream. For example, we can build a shorter representation in ourshowmethod when the:compactproperty  
is set totrue, falling back to the long representation if the property isfalseor absent:

```
julia>function Base.show(io:: IO , z ::Polar)
if get(io,:compact, false )
print(io, z.r, "", z .Θ, "im")
else
print(io, z.r, " * exp(", z .Θ, "im)")
end
end
```

This new compact representation will be used when the passed IO stream is anIOContextobject with the  
:compactproperty set. In particular, this is the case when printing arrays with multiple columns (where hori-  
zontal space is limited):

```
julia> show(IOContext(stdout,:compact=> true ), Polar(3, 4.0))
3.04.0im
```

```
julia> [Polar(3, 4.0) Polar(4.0,5.3)]
1×2 Matrix{Polar{Float64}}:
3.04.0im 4.05.3im
```

See theIOContextdocumentation for a list of common properties which can be used to adjust printing.

### 11.15"Value types"

In Julia, you can't dispatch on a value such astrueorfalse. However, you can dispatch on parametric types,  
and Julia allows you to include"plain bits" values (Types, Symbols, Integers, floating-point numbers, tuples,  
etc.) as type parameters. A common example is the dimensionality parameter inArray{T,N}, whereTis a  
type (e.g.,Float64) butNis just anInt.

#### CHAPTER 11. TYPES 130

You can create your own custom types that take values as parameters, and use them to control dispatch of  
custom types. By way of illustration of this idea, let's introduce a parametric type,Val{x}, and a constructor  
Val(x) = Val{x}(), which serves as a customary way to exploit this technique for cases where you don't  
need a more elaborate hierarchy.

Valis defined as:

```
julia> struct Val {x}
end
```

```
julia>Val (x) = Val {x}()
Val
```

There is no more to the implementation ofValthan this. Some functions in Julia's standard library acceptVal  
instances as arguments, and you can also use it to write your own functions. For example:

```
julia> firstlast(:: Val { true }) = "First"
firstlast (generic function with 1 method)
```

```
julia> firstlast(:: Val { false }) = "Last"
firstlast (generic function with 2 methods)
```

```
julia> firstlast( Val ( true ))
"First"
```

```
julia> firstlast( Val ( false ))
"Last"
```

For consistency across Julia, the call site should always pass aValinstance rather than using a type, i.e., use  
foo(Val(:bar))rather thanfoo(Val{:bar}).

It's worth noting that it's extremely easy to mis-use parametric"value" types, includingVal; in unfavorable  
cases, you can easily end up making the performance of your code much worse. In particular, you would never  
want to write actual code as illustrated above. For more information about the proper (and improper) uses of  
Val, please readthe more extensive discussion in the performance tips.

(^1) "Small" is defined by theMAX_UNION_SPLITTINGconstant, which is currently set to 4.  
(^2) A few popular languages have singleton types, including Haskell, Scala and Ruby.

**Chapter 12**

**Methods**

Recall fromFunctionsthat a function is an object that maps a tuple of arguments to a return value, or throws an  
exception if no appropriate value can be returned. It is common for the same conceptual function or operation  
to be implemented quite differently for different types of arguments: adding two integers is very different from  
addingtwofloating-pointnumbers,bothofwhicharedistinctfromaddinganintegertoafloating-pointnumber.  
Despite their implementation differences, these operations all fall under the general concept of"addition".  
Accordingly, in Julia, these behaviors all belong to a single object: the+function.

Tofacilitateusingmanydifferentimplementationsofthesameconceptsmoothly,functionsneednotbedefined  
all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of  
argument types and counts. A definition of one possible behavior for a function is called a method. Thus  
far, we have presented only examples of functions defined with a single method, applicable to all types of  
arguments. However,thesignaturesofmethoddefinitionscanbeannotatedtoindicatethetypesofarguments  
in addition to their number, and more than a single method definition may be provided. When a function is  
applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied.  
Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If  
the patchwork is well designed, even though the implementations of the methods may be quite different, the  
outward behavior of the function will appear seamless and consistent.

The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch  
process to choose which of a function's methods to call based on the number of arguments given, and on the  
types of all of the function's arguments. This is different than traditional object-oriented languages, where  
dispatch occurs based only on the first argument, which often has a special argument syntax, and is some-  
times implied rather than explicitly written as an argument.^1 Using all of a function's arguments to choose  
which method should be invoked, rather than just the first, is known asmultiple dispatch. Multiple dispatch  
is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to  
"belong" to one argument more than any of the others: does the addition operation inx + ybelong toxany  
more than it does toy? The implementation of a mathematical operator generally depends on the types of all  
of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful  
and convenient paradigm for structuring and organizing programs.

```
Note
All the examples in this chapter assume that you are defining modules for a function in the same
module. If you want to add methods to a function in another module, you have toimportit or use
the name qualified with module names. See the section onnamespace management.
```

(^1) In C++ or Java, for example, in a method call likeobj.meth(arg1,arg2), the object obj"receives" the method call and is implicitly  
passed to the method via thethiskeyword, rather than as an explicit method argument. When the currentthisobject is the receiver of  
a method call, it can be omitted altogether, writing justmeth(arg1,arg2), withthisimplied as the receiving object.

#### 131

#### CHAPTER 12. METHODS 132

### 12.1 Defining Methods

Until now, we have, in our examples, defined only functions with a single method having unconstrained ar-  
gument types. Such functions behave just like they would in traditional dynamically typed languages. Nev-  
ertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of  
Julia's standard functions and operators, like the aforementioned+function, have many methods defining their  
behavior over various possible combinations of argument type and count.

When defining a function, one can optionally constrain the types of parameters it is applicable to, using the::  
type-assertion operator, introduced in the section onComposite Types:

```
julia> f(x:: Float64 , y :: Float64 ) = 2x + y
f (generic function with 1 method)
```

This function definition applies only to calls wherexandyare both values of typeFloat64:

```
julia> f(2.0, 3.0)
7.0
```

Applying it to any other types of arguments will result in aMethodError:

```
julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
f(::Float64, !Matched::Float64) at none:1
```

```
julia> f( Float32 (2.0), 3.0)
ERROR: MethodError: no method matching f(::Float32, ::Float64)
Closest candidates are:
f(!Matched::Float64, ::Float64) at none:1
```

```
julia> f(2.0, "3.0")
ERROR: MethodError: no method matching f(::Float64, ::String)
Closest candidates are:
f(::Float64, !Matched::Float64) at none:1
```

```
julia> f("2.0", "3.0")
ERROR: MethodError: no method matching f(::String, ::String)
```

As you can see, the arguments must be precisely of typeFloat64. Other numeric types, such as integers  
or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed  
as numbers. BecauseFloat64is a concrete type and concrete types cannot be subclassed in Julia, such a  
definition can only be applied to arguments that are exactly of typeFloat64. It may often be useful, however,  
to write more general methods where the declared parameter types are abstract:

```
julia> f(x:: Number , y :: Number ) = 2x - y
f (generic function with 2 methods)
```

```
julia> f(2.0, 3)
1.0
```

#### CHAPTER 12. METHODS 133

This method definition applies to any pair of arguments that are instances ofNumber. They need not be of  
the same type, so long as they are each numeric values. The problem of handling disparate numeric types is  
delegated to the arithmetic operations in the expression2x - y.

To define a function with multiple methods, one simply defines the function multiple times, with different  
numbers and types of arguments. The first method definition for a function creates the function object, and  
subsequent method definitions add new methods to the existing function object. The most specific method  
definition matching the number and types of the arguments will be executed when the function is applied.  
Thus, the two method definitions above, taken together, define the behavior forfover all pairs of instances  
of the abstract typeNumber– but with a different behavior specific to pairs ofFloat64values. If one of the  
arguments is a 64-bit float but the other one is not, then thef(Float64,Float64)method cannot be called  
and the more generalf(Number,Number)method must be used:

```
julia> f(2.0, 3.0)
7.0
```

```
julia> f(2, 3.0)
1.0
```

```
julia> f(2.0, 3)
1.0
```

```
julia> f(2, 3)
1
```

The2x + ydefinition is only used in the first case, while the2x - ydefinition is used in the others. No  
automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical  
and completely explicit. Conversion and Promotion, however, shows how clever application of sufficiently  
advanced technology can be indistinguishable from magic.^2

For non-numeric values, and for fewer or more than two arguments, the functionfremains undefined, and  
applying it will still result in aMethodError:

```
julia> f("foo", 3)
ERROR: MethodError: no method matching f(::String, ::Int64)
Closest candidates are:
f(!Matched::Number, ::Number) at none:1
```

```
julia> f()
ERROR: MethodError: no method matching f()
Closest candidates are:
f(!Matched::Float64, !Matched::Float64) at none:1
f(!Matched::Number, !Matched::Number) at none:1
```

You can easily see which methods exist for a function by entering the function object itself in an interactive  
session:

```
julia> f
f (generic function with 2 methods)
```

This output tells us thatfis a function object with two methods. To find out what the signatures of those  
methods are, use themethodsfunction:

#### CHAPTER 12. METHODS 134

```
julia> methods(f)
# 2 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1
```

which shows thatfhas two methods, one taking twoFloat64arguments and one taking arguments of type  
Number. It also indicates the file and line number where the methods were defined: because these methods  
were defined at the REPL, we get the apparent line numbernone:1.

In the absence of a type declaration with::, the type of a method parameter isAnyby default, meaning that it  
is unconstrained since all values in Julia are instances of the abstract typeAny. Thus, we can define a catch-all  
method forflike so:

```
julia> f(x,y)= println("Whoa there, Nelly.")
f (generic function with 3 methods)
```

```
julia> methods(f)
# 3 methods for generic function "f":
[1] f(x::Float64, y::Float64) in Main at none:1
[2] f(x::Number, y::Number) in Main at none:1
[3] f(x, y) in Main at none:1
```

```
julia> f("foo", 1)
Whoa there, Nelly.
```

This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will  
only be called on pairs of arguments to which no other method definition applies.

Note that in the signature of the third method, there is no type specified for the argumentsxandy. This is a  
shortened way of expressingf(x::Any, y::Any).

Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most pow-  
erful and central feature of the Julia language. Core operations typically have dozens of methods:

```
julia> methods(+)
# 180 methods for generic function "+":
[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227
[2] +(x::Bool, y::Bool) in Base at bool.jl:89
[3] +(x::Bool) in Base at bool.jl:86
[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96
[5] +(x::Bool, z::Complex) in Base at complex.jl:234
[6] +(a::Float16, b::Float16) in Base at float.jl:373
[7] +(x::Float32, y::Float32) in Base at float.jl:375
[8] +(x::Float64, y::Float64) in Base at float.jl:376
[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228
[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242
[11] +(x::Char, y::Integer) in Base at char.jl:40
[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307
[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392
[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391
[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390
[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361
[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398
...
[180] +(a, b, c, xs...) in Base at operators.jl:424
```

#### CHAPTER 12. METHODS 135

Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express  
high-levelalgorithmsdecoupledfromimplementationdetails,yetgenerateefficient,specializedcodetohandle  
each case at run time.

### 12.2 Method Ambiguities

It is possible to define a set of function methods such that there is no unique most specific method applicable  
to some combinations of arguments:

```
julia> g(x:: Float64 , y)= 2x + y
g (generic function with 1 method)
```

```
julia> g(x, y:: Float64 ) = x + 2y
g (generic function with 2 methods)
```

```
julia> g(2.0, 3)
7.0
```

```
julia> g(2, 3.0)
8.0
```

```
julia> g(2.0, 3.0)
ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:
g(x::Float64, y) in Main at none:1
g(x, y::Float64) in Main at none:1
Possible fix, define
g(::Float64, ::Float64)
```

Here the callg(2.0, 3.0)could be handled by either theg(Float64, Any)or theg(Any, Float64)method,  
and neither is more specific than the other. In such cases, Julia raises aMethodErrorrather than arbitrarily  
picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection  
case:

```
julia> g(x:: Float64 , y :: Float64 ) = 2x + 2y
g (generic function with 3 methods)
```

```
julia> g(2.0, 3)
7.0
```

```
julia> g(2, 3.0)
8.0
```

```
julia> g(2.0, 3.0)
10.0
```

It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if  
transiently, until the more specific method is defined.

In more complex cases, resolving method ambiguities involves a certain element of design; this topic is ex-  
plored furtherbelow.

#### CHAPTER 12. METHODS 136

### 12.3 Parametric Methods

Method definitions can optionally have type parameters qualifying the signature:

```
julia> same_type(x::T, y ::T) where {T}= true
same_type (generic function with 1 method)
```

```
julia> same_type(x,y)= false
same_type (generic function with 2 methods)
```

The first method applies whenever both arguments are of the same concrete type, regardless of what type that  
is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean  
function that checks whether its two arguments are of the same type:

```
julia> same_type(1, 2)
true
```

```
julia> same_type(1, 2.0)
false
```

```
julia> same_type(1.0, 2.0)
true
```

```
julia> same_type("foo", 2.0)
false
```

```
julia> same_type("foo", "bar")
true
```

```
julia> same_type( Int32 (1), Int64 (2))
false
```

Such definitions correspond to methods whose type signatures areUnionAlltypes (seeUnionAll Types).

This kind of definition of function behavior by dispatch is quite common – idiomatic, even – in Julia. Method  
type parameters are not restricted to being used as the types of arguments: they can be used anywhere a  
value would be in the signature of the function or body of the function. Here's an example where the method  
type parameterTis used as the type parameter to the parametric typeVector{T}in the method signature:

```
julia> myappend(v:: Vector {T}, x::T) where {T}= [v..., x]
myappend (generic function with 1 method)
```

```
julia> myappend([1,2,3],4)
4-element Vector{Int64}:
1
2
3
4
```

```
julia> myappend([1,2,3],2.5)
ERROR: MethodError: no method matching myappend(::Vector{Int64}, ::Float64)
Closest candidates are:
myappend(::Vector{T}, !Matched::T) where T at none:1
Stacktrace:
```

#### CHAPTER 12. METHODS 137

```
[...]
```

```
julia> myappend([1.0,2.0,3.0],4.0)
4-element Vector{Float64}:
1.0
2.0
3.0
4.0
```

```
julia> myappend([1.0,2.0,3.0],4)
ERROR: MethodError: no method matching myappend(::Vector{Float64}, ::Int64)
Closest candidates are:
myappend(::Vector{T}, !Matched::T) where T at none:1
Stacktrace:
[...]
```

As you can see, the type of the appended element must match the element type of the vector it is appended  
to, or else aMethodErroris raised. In the following example, the method type parameterTis used as the  
return value:

```
julia> mytypeof(x::T) where {T}= T
mytypeof (generic function with 1 method)
```

```
julia> mytypeof(1)
Int64
```

```
julia> mytypeof(1.0)
Float64
```

Just as you can put subtype constraints on type parameters in type declarations (seeParametric Types), you  
can also constrain type parameters of methods:

```
julia> same_type_numeric(x::T, y ::T) where {T<: Number } = true
same_type_numeric (generic function with 1 method)
```

```
julia> same_type_numeric(x:: Number , y :: Number ) = false
same_type_numeric (generic function with 2 methods)
```

```
julia> same_type_numeric(1, 2)
true
```

```
julia> same_type_numeric(1, 2.0)
false
```

```
julia> same_type_numeric(1.0, 2.0)
true
```

```
julia> same_type_numeric("foo", 2.0)
ERROR: MethodError: no method matching same_type_numeric(::String, ::Float64)
Closest candidates are:
same_type_numeric(!Matched::T, ::T) where T<:Number at none:1
same_type_numeric(!Matched::Number, ::Number) at none:1
```

```
julia> same_type_numeric("foo", "bar")
```

#### CHAPTER 12. METHODS 138

```
ERROR: MethodError: no method matching same_type_numeric(::String, ::String)
```

```
julia> same_type_numeric( Int32 (1), Int64 (2))
false
```

Thesame_type_numericfunctionbehavesmuchlikethesame_typefunctiondefinedabove, butisonlydefined  
for pairs of numbers.

Parametric methods allow the same syntax aswhereexpressions used to write types (seeUnionAll Types).  
If there is only a single parameter, the enclosing curly braces (inwhere {T}) can be omitted, but are often  
preferredforclarity. Multipleparameterscanbeseparatedwithcommas, e.g.where {T, S<:Real}, orwritten  
using nestedwhere, e.g.where S<:Real where T.

### 12.4 Redefining Methods

Whenredefiningamethodoraddingnewmethods,itisimportanttorealizethatthesechangesdon'ttakeeffect  
immediately. This is key to Julia's ability to statically infer and compile code to run fast, without the usual JIT  
tricks and overhead. Indeed, any new method definition won't be visible to the current runtime environment,  
including Tasks and Threads (and any previously defined@generatedfunctions). Let's start with an example  
to see what this means:

```
julia>function tryeval()
@evalnewfun()= 1
newfun()
end
tryeval (generic function with 1 method)
```

```
julia> tryeval()
ERROR: MethodError: no method matching newfun()
The applicable method may be too new: running in world age xxxx1, while current world is xxxx2.
Closest candidates are:
newfun() at none:1 (method too new to be called from this world context.)
in tryeval() at none:1
...
```

```
julia> newfun()
1
```

In this example, observe that the new definition fornewfunhas been created, but can't be immediately called.  
The new global is immediately visible to thetryevalfunction, so you could writereturn newfun(without  
parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new  
method definition!

But there's an exception: future calls tonewfunfrom the REPL work as expected, being able to both see and  
call the new definition ofnewfun.

However,futurecallstotryevalwillcontinuetoseethedefinitionofnewfunasitwasatthepreviousstatement  
at the REPL, and thus before that call totryeval.

You may want to try this for yourself to see how it works.

The implementation of this behavior is a"world age counter". This monotonically increasing value tracks each  
method definition operation. This allows describing"the set of method definitions visible to a given runtime  
environment" as a single number, or"world age". It also allows comparing the methods available in two worlds  
just by comparing their ordinal value. In the example above, we see that the"current world" (in which the

#### CHAPTER 12. METHODS 139

methodnewfunexists), is one greater than the task-local"runtime world" that was fixed when the execution  
oftryevalstarted.

Sometimes it is necessary to get around this (for example, if you are implementing the above REPL). Fortu-  
nately, there is an easy solution: call the function usingBase.invokelatest:

```
julia>function tryeval2()
@evalnewfun2()= 2
Base.invokelatest(newfun2)
end
tryeval2 (generic function with 1 method)
```

```
julia> tryeval2()
2
```

Finally, let's take a look at some more complex examples where this rule comes into play. Define a function  
f(x), which initially has one method:

```
julia> f(x)= "original definition"
f (generic function with 1 method)
```

Start some other operations that usef(x):

```
julia> g(x)= f(x)
g (generic function with 1 method)
```

```
julia> t = @asyncf(wait()); yield();
```

Now we add some new methods tof(x):

```
julia> f(x:: Int ) = "definition for Int"
f (generic function with 2 methods)
```

```
julia> f(x:: Type { Int }) = "definition for Type{Int}"
f (generic function with 3 methods)
```

Compare how these results differ:

```
julia> f(1)
"definition for Int"
```

```
julia> g(1)
"definition for Int"
```

```
julia> fetch(schedule(t,1))
"original definition"
```

```
julia> t = @asyncf(wait()); yield();
```

```
julia> fetch(schedule(t,1))
"definition for Int"
```

#### CHAPTER 12. METHODS 140

### 12.5 Design Patterns with Parametric Methods.

While complex dispatch logic is not required for performance or usability, sometimes it can be the best way  
to express some algorithm. Here are a few common design patterns that come up sometimes when using  
dispatch in this way.

### Extracting the type parameter from a super-type

Here is a correct code template for returning the element-typeTof any arbitrary subtype ofAbstractArray  
that has well-defined element type:

```
abstracttypeAbstractArray {T, N} end
eltype(:: Type {<: AbstractArray {T}}) where {T}= T
```

using so-called triangular dispatch. Note thatUnionAlltypes, for exampleeltype(AbstractArray{T} where  
T <: Integer), do not match the above method. The implementation ofeltypeinBaseadds a fallback  
method toAnyfor such cases.

One common mistake is to try and get the element-type by using introspection:

```
eltype_wrong(:: Type {A}) where {A<: AbstractArray } = A.parameters[1]
```

However, it is not hard to construct cases where this will fail:

```
struct BitVector <: AbstractArray { Bool , 1}; end
```

Here we have created a typeBitVectorwhich has no parameters, but where the element-type is still fully  
specified, withTequal toBool!

Another mistake is to try to walk up the type hierarchy usingsupertype:

```
eltype_wrong(:: Type { AbstractArray {T}}) where {T}= T
eltype_wrong(:: Type { AbstractArray {T, N}}) where {T, N}= T
eltype_wrong(:: Type {A}) where {A<: AbstractArray } = eltype_wrong(supertype(A))
```

While this works for declared types, it fails for types without supertypes:

```
julia> eltype_wrong( Union { AbstractArray { Int }, AbstractArray { Float64 }})
ERROR: MethodError: no method matching supertype(::Type{Union{AbstractArray{Float64,N} where N,
↪→ AbstractArray{Int64,N} where N}})
Closest candidates are:
supertype(::DataType) at operators.jl:43
supertype(::UnionAll) at operators.jl:48
```

### Building a similar type with a different type parameter

When building generic code, there is often a need for constructing a similar object with some change made  
to the layout of the type, also necessitating a change of the type parameters. For instance, you might have  
some sort of abstract array with an arbitrary element type and want to write your computation on it with a  
specific element type. We must implement a method for eachAbstractArray{T}subtype that describes how  
to compute this type transform. There is no general transform of one subtype into another subtype with a  
different parameter. (Quick review: do you see why this is?)

#### CHAPTER 12. METHODS 141

The subtypes ofAbstractArraytypically implement two methods to achieve this: A method to convert the  
input array to a subtype of a specificAbstractArray{T, N}abstract type; and a method to make a new  
uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base.  
Here is a basic example usage of them, guaranteeing thatinputandoutputare of the same type:

```
input= convert( AbstractArray {Eltype}, input)
output= similar(input, Eltype)
```

As an extension of this, in cases where the algorithm needs a copy of the input array,convertis insufficient as  
the return value may alias the original input. Combiningsimilar(to make the output array) andcopyto!(to  
fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:

```
copy_with_eltype(input, Eltype)= copyto!(similar(input, Eltype), input)
```

### Iterated dispatch

In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch  
into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is  
still more flexible.

For example, trying to dispatch on the element-type of an array will often run into ambiguous situations.  
Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method  
based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach,  
while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for  
example, in the logic to sum two matrices:

```
# First dispatch selects the map algorithm for element-wise summation.
+(a:: Matrix , b :: Matrix ) = map(+, a, b)
# Then dispatch handles each element and selects the appropriate
# common element type for the computation.
+(a, b)= +(promote(a, b)...)
# Once the elements have the same type, they can be added.
# For example, via primitive operations exposed by the processor.
+(a:: Float64 , b :: Float64 ) = Core.add(a, b)
```

### Trait-based dispatch

A natural extension to the iterated dispatch above is to add a layer to method selection that allows to dispatch  
on sets of types which are independent from the sets defined by the type hierarchy. We could construct such  
a set by writing out aUnionof the types in question, but then this set would not be extensible asUnion-types  
cannot be altered after creation. However, such an extensible set can be programmed with a design pattern  
often referred to as a"Holy-trait".

Thispatternisimplementedbydefiningagenericfunctionwhichcomputesadifferentsingletonvalue(ortype)  
for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on  
performance compared to normal dispatch.

The example in the previous section glossed over the implementation details ofmapandpromote, which both  
operate in terms of these traits. When iterating over a matrix, such as in the implementation ofmap, one  
important question is what order to use to traverse the data. WhenAbstractArraysubtypes implement the  
Base.IndexStyletrait, other functions such asmapcan dispatch on this information to pick the best algorithm  
(see Abstract Array Interface). This means that each subtype does not need to implement a custom version of  
map, since the generic definitions + trait classes will enable the system to select the fastest version. Here is a  
toy implementation ofmapillustrating the trait-based dispatch:

#### CHAPTER 12. METHODS 142

```
map(f, a:: AbstractArray , b :: AbstractArray ) = map(Base.IndexStyle(a, b), f, a, b)
# generic implementation:
map(::Base.IndexCartesian, f, a:: AbstractArray , b :: AbstractArray ) = ...
# linear-indexing implementation (faster)
map(::Base.IndexLinear, f, a:: AbstractArray , b :: AbstractArray ) = ...
```

Thistrait-basedapproachisalsopresentinthepromotemechanismemployedbythescalar+. Itusespromote_type,  
which returns the optimal common type to compute the operation given the two types of the operands. This  
makes it possible to reduce the problem of implementing every function for every pair of possible type argu-  
ments, to the much smaller problem of implementing a conversion operation from each type to a common  
type, plus a table of preferred pair-wise promotion rules.

### Output-type computation

The discussion of trait-based promotion provides a transition into our next design pattern: computing the  
output element type for a matrix operation.

For implementing primitive operations, such as addition, we use thepromote_typefunction to compute the  
desired output type. (As before, we saw this at work in thepromotecall in the call to+).

For more complex functions on matrices, it may be necessary to compute the expected return type for a more  
complex sequence of operations. This is often performed by the following steps:

1.  Write a small functionopthat expresses the set of operations performed by the kernel of the algorithm.
2.  Compute the element typeRof the result matrix aspromote_op(op, argument_types...), where  
    argument_typesis computed fromeltypeapplied to each input array.
3.  Build the output matrix assimilar(R, dims), wheredimsare the desired dimensions of the output  
    array.

For a more specific example, a generic square-matrix multiply pseudo-code might look like:

```
function matmul(a:: AbstractMatrix , b :: AbstractMatrix )
op = (ai, bi)-> ai * bi + ai * bi
```

```
## this is insufficient because it assumes `one(eltype(a))` is constructable:
# R = typeof(op(one(eltype(a)), one(eltype(b))))
```

```
## this fails because it assumes `a[1]` exists and is representative of all elements of the
↪→ array
# R = typeof(op(a[1], b[1]))
```

```
## this is incorrect because it assumes that `+` calls `promote_type`
## but this is not true for some types, such as Bool:
# R = promote_type(ai, bi)
```

```
# this is wrong, since depending on the return value
# of type-inference is very brittle (as well as not being optimizable):
# R = Base.return_types(op, (eltype(a), eltype(b)))
```

```
## but, finally, this works:
R = promote_op(op, eltype(a), eltype(b))
## although sometimes it may give a larger type than desired
```

#### CHAPTER 12. METHODS 143

```
## it will always give a correct type
```

```
output= similar(b, R, (size(a,1), size(b,2)))
if size(a,2) > 0
for j in 1:size(b,2)
for i in 1:size(a,1)
## here we don't use `ab = zero(R)`,
## since `R` might be `Any` and `zero(Any)` is not defined
## we also must declare `ab::R` to make the type of `ab` constant in the loop,
## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R
ab::R = a[i,1] * b[1, j]
for k in 2:size(a,2)
ab += a[i, k]* b[k, j]
end
output[i, j]= ab
end
end
end
return output
end
```

### Separate convert and kernel logic

One way to significantly cut down on compile-times and testing complexity is to isolate the logic for converting  
to the desired type and the computation. This lets the compiler specialize and inline the conversion logic  
independent from the rest of the body of the larger kernel.

This is a common pattern seen when converting from a larger class of types to the one specific argument type  
that is actually supported by the algorithm:

```
complexfunction(arg:: Int ) = ...
complexfunction(arg:: Any ) = complexfunction(convert( Int , arg))
```

```
matmul(a::T, b ::T) = ...
matmul(a, b)= matmul(promote(a, b)...)
```

### 12.6 Parametrically-constrained Varargs methods

Functionparameterscanalsobeusedtoconstrainthenumberofargumentsthatmaybesuppliedtoa"varargs"  
function (Varargs Functions). The notationVararg{T,N}is used to indicate such a constraint. For example:

```
julia> bar(a,b,x:: Vararg { Any ,2}) = (a,b,x)
bar (generic function with 1 method)
```

```
julia> bar(1,2,3)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
Closest candidates are:
bar(::Any, ::Any, ::Any, !Matched::Any) at none:1
```

```
julia> bar(1,2,3,4)
(1, 2, (3, 4))
```

```
julia> bar(1,2,3,4,5)
ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
```

#### CHAPTER 12. METHODS 144

```
Closest candidates are:
bar(::Any, ::Any, ::Any, ::Any) at none:1
```

More usefully, it is possible to constrain varargs methods by a parameter. For example:

```
function getindex(A:: AbstractArray {T,N}, indices:: Vararg { Number ,N}) where {T,N}
```

would be called only when the number ofindicesmatches the dimensionality of the array.

When only the type of supplied arguments needs to be constrainedVararg{T}can be equivalently written as  
T.... For instancef(x::Int...) = xis a shorthand forf(x::Vararg{Int}) = x.

### 12.7 Note on Optional and keyword Arguments

As mentioned briefly inFunctions, optional arguments are implemented as syntax for multiple method defini-  
tions. For example, this definition:

```
f(a=1,b=2) = a+2b
```

translates to the following three methods:

```
f(a,b)= a+2b
f(a)= f(a,2)
f() = f(1,2)
```

This means that callingf()is equivalent to callingf(1,2). In this case the result is 5 , becausef(1,2)invokes  
the first method offabove. However, this need not always be the case. If you define a fourth method that is  
more specialized for integers:

```
f(a:: Int ,b:: Int ) = a-2b
```

then the result of bothf()andf(1,2)is-3. In other words, optional arguments are tied to a function, not  
to any specific method of that function. It depends on the types of the optional arguments which method is  
invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument  
may even change at run-time.

Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not  
participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword  
arguments processed after the matching method is identified.

### 12.8 Function-like objects.

Methods are associated with types, so it is possible to make any arbitrary Julia object"callable" by adding  
methods to its type. (Such"callable" objects are sometimes called"functors.")

For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function  
evaluating the polynomial:

#### CHAPTER 12. METHODS 145

```
julia> struct Polynomial{R}
coeffs:: Vector {R}
end
```

```
julia>function (p::Polynomial)(x)
v = p.coeffs[ end ]
for i = (length(p.coeffs)-1):-1:1
v = v*x + p.coeffs[i]
end
return v
end
```

```
julia> (p::Polynomial)()= p(5)
```

Notice that the function is specified by type instead of by name. As with normal functions there is a terse  
syntax form. In the function body,pwill refer to the object that was called. APolynomialcan be used as  
follows:

```
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])
```

```
julia> p(3)
931
```

```
julia> p()
2551
```

This mechanism is also the key to how type constructors and closures (inner functions that refer to their  
surrounding environment) work in Julia.

### 12.9 Empty generic functions.

Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to  
separate interface definitions from implementations. It might also be done for the purpose of documentation  
or code readability. The syntax for this is an emptyfunctionblock without a tuple of arguments:

```
function emptyfunc end
```

### 12.10Method design and the avoidance of ambiguities.

Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design  
challenges. In particular, in more complex method hierarchies it is not uncommon forambiguitiesto arise.

Above, it was pointed out that one can resolve ambiguities like

```
f(x, y:: Int ) = 1
f(x:: Int , y)= 2
```

by defining a method

```
f(x:: Int , y :: Int ) = 3
```

#### CHAPTER 12. METHODS 146

This is often the right strategy; however, there are circumstances where following this advice mindlessly can  
be counterproductive. In particular, the more methods a generic function has, the more possibilities there  
are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be  
worth your while to think carefully about alternative strategies.

Below we discuss particular challenges and some alternative ways to resolve such issues.

### Tuple and NTuple arguments

Tuple(andNTuple) arguments present special challenges. For example,

```
f(x:: NTuple {N, Int }) where {N}= 1
f(x:: NTuple {N, Float64 }) where {N}= 2
```

are ambiguous because of the possibility thatN == 0: there are no elements to determine whether theIntor  
Float64variant should be called. To resolve the ambiguity, one approach is define a method for the empty  
tuple:

```
f(x:: Tuple {}) = 3
```

Alternatively, for all methods but one you can insist that there is at least one element in the tuple:

```
f(x:: NTuple {N, Int }) where {N}= 1 # this is the fallback
f(x:: Tuple { Float64 , Vararg { Float64 }}) = 2 # this requires at least one Float64
```

### Orthogonalize your design

When you might be tempted to dispatch on two or more arguments, consider whether a"wrapper" function  
might make for a simpler design. For example, instead of writing multiple variants:

```
f(x::A, y ::A) = ...
f(x::A, y ::B) = ...
f(x::B, y ::A) = ...
f(x::B, y ::B) = ...
```

you might consider defining

```
f(x::A, y ::A) = ...
f(x, y)= f(g(x), g(y))
```

wheregconverts the argument to typeA. This is a very specific example of the more general principle of  
orthogonal design, in which separate concepts are assigned to separate methods. Here,gwill most likely need  
a fallback definition

```
g(x::A) = x
```

A related strategy exploitspromoteto bringxandyto a common type:

```
f(x::T, y ::T) where {T}= ...
f(x, y)= f(promote(x, y)...)
```

One risk with this design is the possibility that if there is no suitable promotion method convertingxandyto  
the same type, the second method will recurse on itself infinitely and trigger a stack overflow.

#### CHAPTER 12. METHODS 147

### Dispatch on one argument at a time

If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations  
to make it practical to define all possible variants, then consider introducing a"name cascade" where (for  
example) you dispatch on the first argument and then call an internal method:

```
f(x::A, y)= _fA(x, y)
f(x::B, y)= _fB(x, y)
```

Then the internal methods_fAand_fBcan dispatch onywithout concern about ambiguities with each other  
with respect tox.

Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users  
to further customize the behavior offby defining further specializations of your exported functionf. Instead,  
they have to define specializations for your internal methods_fAand_fB, and this blurs the lines between  
exported and internal methods.

### Abstract containers and element types

Where possible, try to avoid defining methods that dispatch on specific element types of abstract containers.  
For example,

```
-(A:: AbstractArray {T}, b:: Date ) where {T<: Date }
```

generates ambiguities for anyone who defines a method

```
-(A::MyArrayType{T}, b::T) where {T}
```

Thebestapproachistoavoiddefiningeitherofthesemethods: instead,relyonagenericmethod-(A::AbstractArray,  
b)and make sure this method is implemented with generic calls (likesimilarand-) that do the right thing  
for each container type and element type separately. This is just a more complex variant of the advice to  
orthogonalizeyour methods.

When this approach is not possible, it may be worth starting a discussion with other developers about resolving  
the ambiguity; just because one method was defined first does not necessarily mean that it can't be modified  
or eliminated. As a last resort, one developer can define the"band-aid" method

```
-(A::MyArrayType{T}, b:: Date ) where {T<: Date } = ...
```

that resolves the ambiguity by brute force.

### Complex method"cascades" with default arguments

If you are defining a method"cascade" that supplies defaults, be careful about dropping any arguments that  
correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have  
a method that handles the edges of the signal by applying padding:

```
function myfilter(A, kernel,::Replicate)
Apadded= replicate_edges(A, size(kernel))
myfilter(Apadded, kernel) # now perform the "real" computation
end
```

#### CHAPTER 12. METHODS 148

This will run afoul of a method that supplies default padding:

```
myfilter(A, kernel)= myfilter(A, kernel, Replicate())# replicate the edge by default
```

Together, these two methods generate an infinite recursion withAconstantly growing bigger.

The better design would be to define your call hierarchy like this:

```
struct NoPad end # indicate that no padding is desired, or that it's already applied
```

```
myfilter(A, kernel)= myfilter(A, kernel, Replicate()) # default boundary conditions
```

```
function myfilter(A, kernel,::Replicate)
Apadded= replicate_edges(A, size(kernel))
myfilter(Apadded, kernel, NoPad()) # indicate the new boundary conditions
end
```

```
# other padding methods go here
```

```
function myfilter(A, kernel,::NoPad)
# Here's the "real" implementation of the core computation
end
```

NoPadissuppliedinthesameargumentpositionasanyotherkindofpadding,soitkeepsthedispatchhierarchy  
wellorganizedandwithreducedlikelihoodofambiguities. Moreover,itextendsthe"public"myfilterinterface:  
a user who wants to control the padding explicitly can call theNoPadvariant directly.

(^2) Arthur C. Clarke, Profiles of the Future (1961): Clarke's Third Law.

**Chapter 13**

**Constructors**

Constructors^1 are functions that create new objects – specifically, instances ofComposite Types. In Julia,  
type objects also serve as constructor functions: they create new instances of themselves when applied to an  
argumenttupleasafunction. Thismuchwasalreadymentionedbrieflywhencompositetypeswereintroduced.  
For example:

```
julia> struct Foo
bar
baz
end
```

```
julia> foo = Foo(1, 2)
Foo(1, 2)
```

```
julia> foo.bar
1
```

```
julia> foo.baz
2
```

For many types, forming new objects by binding their field values together is all that is ever needed to create  
instances. However, in some cases more functionality is required when creating composite objects. Some-  
times invariants must be enforced, either by checking arguments or by transforming them.Recursive data  
structures, especially those that may be self-referential, often cannot be constructed cleanly without first be-  
ing created in an incomplete state and then altered programmatically to be made whole, as a separate step  
from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different  
types of parameters than they have fields. Julia's system for object construction addresses all of these cases  
and more.

### 13.1 Outer Constructor Methods

A constructor is just like any other function in Julia in that its overall behavior is defined by the combined be-  
havior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods.

(^1) Nomenclature: while the term"constructor" generally refers to the entire function which constructs objects of a type, it is common  
to abuse terminology slightly and refer to specific constructor methods as"constructors". In such situations, it is generally clear from the  
context that the term is used to mean"constructor method" rather than"constructor function", especially as it is often used in the sense  
of singling out a particular method of the constructor from all of the others.

#### 149

#### CHAPTER 13. CONSTRUCTORS 150

For example, let's say you want to add a constructor method forFooobjects that takes only one argument and  
uses the given value for both thebarandbazfields. This is simple:

```
julia> Foo(x)= Foo(x,x)
Foo
```

```
julia> Foo(1)
Foo(1, 1)
```

You could also add a zero-argumentFooconstructor method that supplies default values for both of thebar  
andbazfields:

```
julia> Foo()= Foo(0)
Foo
```

```
julia> Foo()
Foo(0, 0)
```

Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls  
the automatically provided two-argument constructor method. For reasons that will become clear very shortly,  
additional constructor methods declared as normal methods like this are called outer constructor methods.  
Outer constructor methods can only ever create a new instance by calling another constructor method, such  
as the automatically provided default ones.

### 13.2 Inner Constructor Methods

Whileouterconstructormethodssucceedinaddressingtheproblemofprovidingadditionalconveniencemeth-  
ods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this  
chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one  
needs inner constructor methods. An inner constructor method is like an outer constructor method, except for  
two differences:

1.  It is declared inside the block of a type declaration, rather than outside of it like normal methods.
2.  It has access to a special locally existent function callednewthat creates objects of the block's type.

For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint  
that the first number is not greater than the second one. One could declare it like this:

```
julia> struct OrderedPair
x:: Real
y:: Real
OrderedPair(x,y)= x > y? error("out of order") : new(x,y)
end
```

NowOrderedPairobjects can only be constructed such thatx <= y:

```
julia> OrderedPair(1, 2)
OrderedPair(1, 2)
```

#### CHAPTER 13. CONSTRUCTORS 151

```
julia> OrderedPair(2,1)
ERROR: out of order
Stacktrace:
[1] error at ./error.jl:33 [inlined]
[2] OrderedPair(::Int64, ::Int64) at ./none:4
[3] top-level scope
```

If the type were declaredmutable, you could reach in and directly change the field values to violate this  
invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone  
else) can also provide additional outer constructor methods at any later point, but once a type is declared,  
there is no way to add more inner constructor methods. Since outer constructor methods can only create  
objects by calling other constructor methods, ultimately, some inner constructor must be called to create an  
object. This guarantees that all objects of the declared type must come into existence by a call to one of  
the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's  
invariants.

If any inner constructor method is defined, no default constructor method is provided: it is presumed that you  
have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing  
your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the  
correct type, if the corresponding field has a type), and passes them tonew, returning the resulting object:

```
julia> struct Foo
bar
baz
Foo(bar,baz)= new(bar,baz)
end
```

ThisdeclarationhasthesameeffectastheearlierdefinitionoftheFootypewithoutanexplicitinnerconstructor  
method. The following two types are equivalent – one with a default constructor, the other with an explicit  
constructor:

```
julia> struct T1
x:: Int64
end
```

```
julia> struct T2
x:: Int64
T2(x)= new(x)
end
```

```
julia> T1(1)
T1(1)
```

```
julia> T2(1)
T2(1)
```

```
julia> T1(1.0)
T1(1)
```

```
julia> T2(1.0)
T2(1)
```

#### CHAPTER 13. CONSTRUCTORS 152

It is good practice to provide as few inner constructor methods as possible: only those taking all arguments  
explicitlyandenforcingessentialerrorcheckingandtransformation. Additionalconvenienceconstructormeth-  
ods, supplying default values or auxiliary transformations, should be provided as outer constructors that call  
the inner constructors to do the heavy lifting. This separation is typically quite natural.

### 13.3 Incomplete Initialization.

The final problem which has still not been addressed is construction of self-referential objects, or more gener-  
ally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly  
explain it. Consider the following recursive type declaration:

```
julia> mutable struct SelfReferential
obj::SelfReferential
end
```

This type may appear innocuous enough, until one considers how to construct an instance of it. Ifais an  
instance ofSelfReferential, then a second instance can be created by the call:

```
julia> b = SelfReferential(a)
```

But how does one construct the first instance when no instance exists to provide as a valid value for itsobj  
field? The only solution is to allow creating an incompletely initialized instance ofSelfReferentialwith an  
unassignedobjfield, and using that incomplete instance as a valid value for theobjfield of another instance,  
such as, for example, itself.

To allow for the creation of incompletely initialized objects, Julia allows thenewfunction to be called with fewer  
than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The  
inner constructor method can then use the incomplete object, finishing its initialization before returning it.  
Here, for example, is another attempt at defining theSelfReferentialtype, this time using a zero-argument  
inner constructor returning instances havingobjfields pointing to themselves:

```
julia> mutable struct SelfReferential
obj::SelfReferential
SelfReferential()= (x = new(); x.obj = x)
end
```

We can verify that this constructor works and constructs objects that are, in fact, self-referential:

```
julia> x = SelfReferential();
```

```
julia> x === x
true
```

```
julia> x === x.obj
true
```

```
julia> x === x.obj.obj
true
```

Although it is generally a good idea to return a fully initialized object from an inner constructor, it is possible  
to return incompletely initialized objects:

#### CHAPTER 13. CONSTRUCTORS 153

```
julia> mutable struct Incomplete
data
Incomplete()= new()
end
```

```
julia> z = Incomplete();
```

While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an  
immediate error:

```
julia> z.data
ERROR: UndefRefError: access to undefined reference
```

This avoids the need to continually check fornullvalues. However, not all object fields are references. Julia  
considers some types to be"plain data", meaning all of their data is self-contained and does not reference  
other objects. The plain data types consist of primitive types (e.g.Int) and immutable structs of other plain  
data types. The initial contents of a plain data type is undefined:

```
julia> struct HasPlain
n:: Int
HasPlain()= new()
end
```

```
julia> HasPlain()
HasPlain(438103441441)
```

Arrays of plain data types exhibit the same behavior.

You can pass incomplete objects to other functions from inner constructors to delegate their completion:

```
julia> mutable struct Lazy
data
Lazy(v)= complete_me(new(), v)
end
```

As with incomplete objects returned from constructors, ifcomplete_meor any of its callees try to access the  
datafield of theLazyobject before it has been initialized, an error will be thrown immediately.

### 13.4 Parametric Constructors.

Parametric types add a few wrinkles to the constructor story. Recall fromParametric Typesthat, by default,  
instances of parametric composite types can be constructed either with explicitly given type parameters or  
withtypeparametersimpliedbythetypesoftheargumentsgiventotheconstructor. Herearesomeexamples:

```
julia> struct Point{T<: Real }
x::T
y::T
end
```

```
julia> Point(1,2) ## implicit T ##
Point{Int64}(1, 2)
```

#### CHAPTER 13. CONSTRUCTORS 154

```
julia> Point(1.0,2.5) ## implicit T ##
Point{Float64}(1.0, 2.5)
```

```
julia> Point(1,2.5) ## implicit T ##
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
Closest candidates are:
Point(::T, ::T) where T<:Real at none:2
```

```
julia> Point{ Int64 }(1, 2) ## explicit T ##
Point{Int64}(1, 2)
```

```
julia> Point{ Int64 }(1.0,2.5) ## explicit T ##
ERROR: InexactError: Int64(2.5)
Stacktrace:
[...]
```

```
julia> Point{ Float64 }(1.0, 2.5) ## explicit T ##
Point{Float64}(1.0, 2.5)
```

```
julia> Point{ Float64 }(1,2) ## explicit T ##
Point{Float64}(1.0, 2.0)
```

As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied  
fieldtypes:Point{Int64}(1,2)works,butPoint{Int64}(1.0,2.5)raisesanInexactErrorwhenconverting  
2.5toInt64. When the type is implied by the arguments to the constructor call, as inPoint(1,2), then the  
types of the arguments must agree – otherwise theTcannot be determined – but any pair of real arguments  
with matching type may be given to the genericPointconstructor.

What's really going on here is thatPoint,Point{Float64}andPoint{Int64}are all different constructor  
functions. In fact,Point{T}is a distinct constructor function for each typeT. Without any explicitly provided  
inner constructors, the declaration of the composite typePoint{T<:Real}automatically provides an inner  
constructor,Point{T}, for each possible typeT<:Real, that behaves just like non-parametric default inner  
constructors do. It also provides a single general outerPointconstructor that takes pairs of real arguments,  
which must be of the same type. This automatic provision of constructors is equivalent to the following explicit  
declaration:

```
julia> struct Point{T<: Real }
x::T
y::T
Point{T}(x,y) where {T<: Real } = new(x,y)
end
```

```
julia> Point(x::T, y ::T) where {T<: Real } = Point{T}(x,y);
```

Notice that each definition looks like the form of constructor call that it handles. The callPoint{Int64}(1,2)  
will invoke the definitionPoint{T}(x,y)inside thestructblock. The outer constructor declaration, on the  
other hand, defines a method for the generalPointconstructor which only applies to pairs of values of the  
same real type. This declaration makes constructor calls without explicit type parameters, likePoint(1,2)  
andPoint(1.0,2.5), work. Since the method declaration restricts the arguments to being of the same type,  
calls likePoint(1,2.5), with arguments of different types, result in"no method" errors.

Suppose we wanted to make the constructor callPoint(1,2.5)work by"promoting" the integer value 1 to the  
floating-pointvalue1.0. Thesimplestwaytoachievethisistodefinethefollowingadditionalouterconstructor  
method:

#### CHAPTER 13. CONSTRUCTORS 155

```
julia> Point(x:: Int64 , y :: Float64 ) = Point(convert( Float64 ,x),y);
```

This method uses theconvertfunction to explicitly convertxtoFloat64and then delegates construction to  
the general constructor for the case where both arguments areFloat64. With this method definition what was  
previously aMethodErrornow successfully creates a point of typePoint{Float64}:

```
julia> p = Point(1,2.5)
Point{Float64}(1.0, 2.5)
```

```
julia> typeof(p)
Point{Float64}
```

However, other similar calls still don't work:

```
julia> Point(1.5,2)
ERROR: MethodError: no method matching Point(::Float64, ::Int64)
Closest candidates are:
Point(::T, !Matched::T) where T<:Real at none:1
```

For a more general way to make all such calls work sensibly, seeConversion and Promotion. At the risk of  
spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all  
calls to the generalPointconstructor work as one would expect:

```
julia> Point(x:: Real , y :: Real ) = Point(promote(x,y)...);
```

Thepromotefunction converts all its arguments to a common type – in this caseFloat64. With this method  
definition, thePointconstructor promotes its arguments the same way that numeric operators like+do, and  
works for all kinds of real numbers:

```
julia> Point(1.5,2)
Point{Float64}(1.5, 2.0)
```

```
julia> Point(1,1//2)
Point{Rational{Int64}}(1//1, 1//2)
```

```
julia> Point(1.0,1//2)
Point{Float64}(1.0, 0.5)
```

Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible  
to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can  
leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior  
is typically quite simple.

### 13.5 Case Study: Rational

Perhapsthebestwaytotieallthesepiecestogetheristopresentarealworldexampleofaparametriccompos-  
ite type and its constructor methods. To that end, we implement our own rational number typeOurRational,  
similar to Julia's built-inRationaltype, defined inrational.jl:

#### CHAPTER 13. CONSTRUCTORS 156

```
julia> struct OurRational{T<: Integer } <: Real
num::T
den::T
function OurRational{T}(num::T, den::T) where T<: Integer
if num == 0 && den == 0
error("invalid rational: 0//0")
end
num = flipsign(num, den)
den = flipsign(den, den)
g = gcd(num, den)
num = div(num, g)
den = div(den, g)
new(num, den)
end
end
```

```
julia> OurRational(n::T, d ::T) where {T<: Integer } = OurRational{T}(n,d)
OurRational
```

```
julia> OurRational(n:: Integer , d :: Integer ) = OurRational(promote(n,d)...)
OurRational
```

```
julia> OurRational(n:: Integer ) = OurRational(n,one(n))
OurRational
```

```
julia> ⊘(n:: Integer , d :: Integer ) = OurRational(n,d)
⊘ (generic function with 1 method)
```

```
julia> ⊘(x::OurRational, y:: Integer ) = x.num ⊘ (x.den*y)
⊘ (generic function with 2 methods)
```

```
julia> ⊘(x:: Integer , y ::OurRational)= (x*y.den) ⊘ y.num
⊘ (generic function with 3 methods)
```

```
julia> ⊘(x:: Complex , y :: Real ) = complex(real(x) ⊘ y, imag(x) ⊘ y)
⊘ (generic function with 4 methods)
```

```
julia> ⊘(x:: Real , y :: Complex ) = (x*y') ⊘ real(y*y')
⊘ (generic function with 5 methods)
```

```
julia>function ⊘(x:: Complex , y :: Complex )
xy = x*y'
yy = real(y*y')
complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)
end
⊘ (generic function with 6 methods)
```

The first line –struct OurRational{T<:Integer} <: Real– declares thatOurRationaltakes one type pa-  
rameter of an integer type, and is itself a real type. The field declarationsnum::Tandden::Tindicate that  
the data held in aOurRational{T}object are a pair of integers of typeT, one representing the rational value's  
numerator and the other representing its denominator.

Now things get interesting.OurRationalhas a single inner constructor method which checks thatnumand  
denaren 't both zero and ensures that every rational is constructed in"lowest terms" with a non-negative  
denominator. This is accomplished by first flipping the signs of numerator and denominator if the denominator  
is negative. Then, both are divided by their greatest common divisor (gcdalways returns a non-negative

#### CHAPTER 13. CONSTRUCTORS 157

number, regardless of the sign of its arguments). Because this is the only inner constructor forOurRational,  
we can be certain thatOurRationalobjects are always constructed in this normalized form.

OurRationalalso provides several outer constructor methods for convenience. The first is the"standard"  
general constructor that infers the type parameterTfrom the type of the numerator and denominator when  
they have the same type. The second applies when the given numerator and denominator values have dif-  
ferent types: it promotes them to a common type and then delegates construction to the outer constructor  
for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a  
value of 1 as the denominator.

Following the outer constructor definitions, we defined a number of methods for the⊘operator, which provides  
a syntax for writing rationals (e.g.1 ⊘ 2). Julia 'sRationaltype uses the//operator for this purpose. Before  
thesedefinitions,⊘isacompletelyundefinedoperatorwithonlysyntaxandnomeaning. Afterwards,itbehaves  
just as described inRational Numbers– its entire behavior is defined in these few lines. The first and most  
basic definition just makesa ⊘ bconstruct aOurRationalby applying theOurRationalconstructor toaand  
bwhen they are integers. When one of the operands of⊘is already a rational number, we construct a new  
rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with  
an integer. Finally, applying⊘to complex integral values creates an instance ofComplex{<:OurRational}– a  
complex number whose real and imaginary parts are rationals:

```
julia> z = (1 + 2im) ⊘ (1 - 2im);
```

```
julia> typeof(z)
Complex{OurRational{Int64}}
```

```
julia> typeof(z)<: Complex {<:OurRational}
true
```

Thus,althoughthe⊘operatorusuallyreturnsaninstanceofOurRational,ifeitherofitsargumentsarecomplex  
integers, it will return an instance ofComplex{<:OurRational}instead. The interested reader should consider  
perusing the rest ofrational.jl: it is short, self-contained, and implements an entire basic Julia type.

### 13.6 Outer-only constructors

As we have seen, a typical parametric type has inner constructors that are called when type parameters are  
known; e.g. they apply toPoint{Int}but not toPoint. Optionally, outer constructors that determine type  
parameters automatically can be added, for example constructing aPoint{Int}from the callPoint(1,2).  
Outer constructors call inner constructors to actually make instances. However, in some cases one would  
rather not provide inner constructors, so that specific type parameters cannot be requested manually.

For example, say we define a type that stores a vector along with an accurate representation of its sum:

```
julia> struct SummedArray{T<: Number ,S<: Number }
data:: Vector {T}
sum::S
end
```

```
julia> SummedArray( Int32 [1; 2; 3], Int32 (6))
SummedArray{Int32, Int32}(Int32[1, 2, 3], 6)
```

The problem is that we wantSto be a larger type thanT, so that we can sum many elements with less  
information loss. For example, whenTisInt32, we would likeSto beInt64. Therefore we want to avoid  
an interface that allows the user to construct instances of the typeSummedArray{Int32,Int32}. One way to

#### CHAPTER 13. CONSTRUCTORS 158

do this is to provide a constructor only forSummedArray, but inside thestructdefinition block to suppress  
generation of default constructors:

```
julia> struct SummedArray{T<: Number ,S<: Number }
data:: Vector {T}
sum::S
function SummedArray(a:: Vector {T}) where T
S = widen(T)
new{T,S}(a, sum(S, a))
end
end
```

```
julia> SummedArray( Int32 [1; 2; 3], Int32 (6))
ERROR: MethodError: no method matching SummedArray(::Vector{Int32}, ::Int32)
Closest candidates are:
SummedArray(::Vector{T}) where T at none:4
Stacktrace:
[...]
```

This constructor will be invoked by the syntaxSummedArray(a). The syntaxnew{T,S}allows specifying pa-  
rameters for the type to be constructed, i.e. this call will return aSummedArray{T,S}.new{T,S}can be used  
in any constructor definition, but for convenience the parameters tonew{}are automatically derived from the  
type being constructed when possible.

**Chapter 14**

**Conversion and Promotion**

Julia has a system for promoting arguments of mathematical operators to a common type, which has been  
mentioned in various other sections, includingIntegers and Floating-Point Numbers, Mathematical Operations  
and Elementary Functions, Types , and Methods. In this section, we explain how this promotion system works,  
as well as how to extend it to new types and apply it to functions besides built-in mathematical operators.  
Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:

-   **Automatic promotion for built-in arithmetic types and operators.** In most languages, built-in  
    numeric types, when used as operands to arithmetic operators with infix syntax, such as+,-,*, and/,  
    areautomaticallypromotedtoacommontypetoproducetheexpectedresults. C,Java,Perl,andPython,  
    tonameafew,allcorrectlycomputethesum1 + 1.5asthefloating-pointvalue2.5,eventhoughoneof  
    the operands to+is an integer. These systems are convenient and designed carefully enough that they  
    are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion  
    taking place when writing such an expression, but compilers and interpreters must perform conversion  
    before addition since integers and floating-point values cannot be added as-is. Complex rules for such  
    automaticconversionsarethusinevitablypartofspecificationsandimplementationsforsuchlanguages.
-   **No automatic promotion.** This camp includes Ada and ML – very"strict" statically typed languages. In  
    these languages, every conversion must be explicitly specified by the programmer. Thus, the example  
    expression1 + 1.5would be a compilation error in both Ada and ML. Instead one must writereal(1)
    -   1.5, explicitly converting the integer 1 to a floating-point value before performing addition. Explicit  
        conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic con-  
        version: integer literals are promoted to the expected integer type automatically, and floating-point  
        literals are similarly promoted to appropriate floating-point types.

In a sense, Julia falls into the"no automatic promotion" category: mathematical operators are just functions  
with special syntax, and the arguments of functions are never automatically converted. However, one may  
observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme  
caseofpolymorphicmultipledispatch–somethingwhichJulia'sdispatchandtypesystemsareparticularlywell-  
suited to handle."Automatic" promotion of mathematical operands simply emerges as a special application:  
Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific  
implementation exists for some combination of operand types. These catch-all rules first promote all operands  
to a common type using user-definable promotion rules, and then invoke a specialized implementation of the  
operator in question for the resulting values, now of the same type. User-defined types can easily participate  
in this promotion system by defining methods for conversion to and from other types, and providing a handful  
of promotion rules defining what types they should promote to when mixed with other types.

#### 159

#### CHAPTER 14. CONVERSION AND PROMOTION 160

### 14.1 Conversion.

The standard way to obtain a value of a certain typeTis to call the type's constructor,T(x). However, there  
are cases where it's convenient to convert a value from one type to another without the programmer asking  
for it explicitly. One example is assigning a value into an array: ifAis aVector{Float64}, the expressionA[1]  
= 2should work by automatically converting the 2 fromInttoFloat64, and storing the result in the array.  
This is done via theconvertfunction.

Theconvertfunction generally takes two arguments: the first is a type object and the second is a value to  
convert to that type. The returned value is the value converted to an instance of given type. The simplest way  
to understand this function is to see it in action:

```
julia> x = 12
12
```

```
julia> typeof(x)
Int64
```

```
julia> xu = convert( UInt8 , x)
0x0c
```

```
julia> typeof(xu)
UInt8
```

```
julia> xf = convert( AbstractFloat , x)
12.0
```

```
julia> typeof(xf)
Float64
```

```
julia> a = Any [1 2 3; 4 5 6]
2×3 Matrix{Any}:
1 2 3
4 5 6
```

```
julia> convert( Array { Float64 }, a)
2×3 Matrix{Float64}:
1.0 2.0 3.0
4.0 5.0 6.0
```

Conversion isn't always possible, in which case aMethodErroris thrown indicating thatconvertdoesn't know  
how to perform the requested conversion:

```
julia> convert( AbstractFloat , "foo")
ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
[...]
```

Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions  
(many dynamic languages will even perform conversion for you automatically). This is not the case in Julia.  
Even though some strings can be parsed as numbers, most strings are not valid representations of numbers,  
and only a very limited subset of them are. Therefore in Julia the dedicatedparsefunction must be used to  
perform this operation, making it more explicit.

#### CHAPTER 14. CONVERSION AND PROMOTION 161

### When isconvertcalled?

The following language constructs callconvert:

-   Assigning to an array converts to the array's element type.
-   Assigning to a field of an object converts to the declared type of the field.
-   Constructing an object withnewconverts to the object's declared field types.
-   Assigning to a variable with a declared type (e.g.local x::T) converts to that type.
-   A function with a declared return type converts its return value to that type.
-   Passing a value toccallconverts it to the corresponding argument type.

### Conversion vs. Construction

Notethatthebehaviorofconvert(T, x)appearstobenearlyidenticaltoT(x). Indeed, itusuallyis. However,  
there is a key semantic difference: sinceconvertcan be called implicitly, its methods are restricted to cases  
that are considered"safe" or "unsurprising".convertwill only convert between types that represent the same  
basic kind of thing (e.g. different representations of numbers, or different string encodings). It is also usually  
lossless; converting a value to a different type and back again should result in the exact same value.

There are four general kinds of cases where constructors differ fromconvert:

**Constructors for types unrelated to their arguments**

Some constructors don't implement the concept of"conversion". For example,Timer(2)creates a 2-second  
timer, which is not really a"conversion" from an integer to a timer.

**Mutable collections**

convert(T, x)is expected to return the originalxifxis already of typeT. In contrast, ifTis a mutable  
collection type thenT(x)should always make a new collection (copying elements fromx).

**Wrapper types**

For some types which"wrap" other values, the constructor may wrap its argument inside a new object even  
if it is already of the requested type. For exampleSome(x)wrapsxto indicate that a value is present (in a  
context where the result might be aSomeornothing). However,xitself might be the objectSome(y), in which  
case the result isSome(Some(y)), with two levels of wrapping.convert(Some, x), on the other hand, would  
just returnxsince it is already aSome.

**Constructors that don't return instances of their own type**

In very rare cases it might make sense for the constructorT(x)to return an object not of typeT. This could  
happen if a wrapper type is its own inverse (e.g.Flip(Flip(x)) === x), or to support an old calling syntax  
for backwards compatibility when a library is restructured. Butconvert(T, x)should always return a value  
of typeT.

#### CHAPTER 14. CONVERSION AND PROMOTION 162

### Defining New Conversions

When defining a new type, initially all ways of creating it should be defined as constructors. If it becomes  
clear that implicit conversion would be useful, and that some constructors meet the above"safety" criteria,  
thenconvertmethods can be added. These methods are typically quite simple, as they only need to call the  
appropriate constructor. Such a definition might look like this:

```
convert(:: Type {MyType}, x)= MyType(x)
```

The type of the first argument of this method isType{MyType}, the only instance of which isMyType. Thus,  
this method is only invoked when the first argument is the type valueMyType. Notice the syntax used for the  
first argument: the argument name is omitted prior to the::symbol, and only the type is given. This is the  
syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced  
by name.

All instances of some abstract types are by default considered"sufficiently similar" that a universalconvert  
definition is provided in Julia Base. For example, this definition states that it's valid toconvertanyNumber  
type to any other by calling a 1-argument constructor:

```
convert(:: Type {T}, x:: Number ) where {T<: Number } = T(x)
```

This means that newNumbertypes only need to define constructors, since this definition will handleconvert  
for them. An identity conversion is also provided to handle the case where the argument is already of the  
requested type:

```
convert(:: Type {T}, x::T) where {T<: Number } = x
```

Similar definitions exist forAbstractString,AbstractArray, andAbstractDict.

### 14.2 Promotion

Promotion refers to converting values of mixed types to a single common type. Although it is not strictly nec-  
essary, it is generally implied that the common type to which the values are converted can faithfully represent  
all of the original values. In this sense, the term"promotion" is appropriate since the values are converted to  
a "greater" type – i.e. one which can represent all of the input values in a single common type. It is important,  
however, not to confuse this with object-oriented (structural) super-typing, or Julia's notion of abstract super-  
types: promotion has nothing to do with the type hierarchy, and everything to do with converting between  
alternate representations. For instance, although everyInt32value can also be represented as aFloat64  
value,Int32is not a subtype ofFloat64.

Promotion to a common"greater" type is performed in Julia by thepromotefunction, which takes any number  
of arguments, and returns a tuple of the same number of values, converted to a common type, or throws  
an exception if promotion is not possible. The most common use case for promotion is to convert numeric  
arguments to a common type:

```
julia> promote(1, 2.5)
(1.0, 2.5)
```

```
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
```

#### CHAPTER 14. CONVERSION AND PROMOTION 163

```
julia> promote(2, 3//4)
(2//1, 3//4)
```

```
julia> promote(1, 2.5, 3, 3//4)
(1.0, 2.5, 3.0, 0.75)
```

```
julia> promote(1.5, im)
(1.5 + 0.0im, 0.0 + 1.0im)
```

```
julia> promote(1 + 2im, 3//4)
(1//1 + 2//1*im, 3//4 + 0//1*im)
```

Floating-point values are promoted to the largest of the floating-point argument types. Integer values are  
promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures  
of integers and floating-point values are promoted to a floating-point type big enough to hold all the values.  
Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats.  
Complex values mixed with real values are promoted to the appropriate kind of complex value.

That is really all there is to using promotions. The rest is just a matter of clever application, the most typ-  
ical "clever" application being the definition of catch-all methods for numeric operations like the arithmetic  
operators+,-,*and/. Here are some of the catch-all method definitions given inpromotion.jl:

```
+(x:: Number , y :: Number ) = +(promote(x,y)...)
-(x:: Number , y :: Number ) = -(promote(x,y)...)
*(x:: Number , y :: Number ) = *(promote(x,y)...)
/(x:: Number , y :: Number ) = /(promote(x,y)...)
```

These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying  
and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there  
is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic  
operations – it just happens automatically. There are definitions of catch-all promotion methods for a number  
of other arithmetic and mathematical functions inpromotion.jl, but beyond that, there are hardly any calls  
topromoterequired in Julia Base. The most common usages ofpromoteoccur in outer constructors methods,  
provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields  
promoted to an appropriate common type. For example, recall thatrational.jlprovides the following outer  
constructor method:

```
Rational (n:: Integer , d :: Integer ) = Rational (promote(n,d)...)
```

This allows calls like the following to work:

```
julia> x = Rational ( Int8 (15), Int32 (-5))
-3//1
```

```
julia> typeof(x)
Rational{Int32}
```

For most user-defined types, it is better practice to require programmers to supply the expected types to  
constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do  
promotion automatically.

#### CHAPTER 14. CONVERSION AND PROMOTION 164

### Defining Promotion Rules

Although one could, in principle, define methods for thepromotefunction directly, this would require many re-  
dundantdefinitionsforallpossiblepermutationsofargumenttypes. Instead,thebehaviorofpromoteisdefined  
in terms of an auxiliary function calledpromote_rule, which one can provide methods for. Thepromote_rule  
function takes a pair of type objects and returns another type object, such that instances of the argument  
types will be promoted to the returned type. Thus, by defining the rule:

```
promote_rule(:: Type { Float64 }, :: Type { Float32 }) = Float64
```

onedeclaresthatwhen64-bitand32-bitfloating-pointvaluesarepromotedtogether, theyshouldbepromoted  
to 64-bit floating-point. The promotion type does not need to be one of the argument types. For example, the  
following promotion rules both occur in Julia Base:

```
promote_rule(:: Type { BigInt }, :: Type { Float64 }) = BigFloat
promote_rule(:: Type { BigInt }, :: Type { Int8 }) = BigInt
```

In the latter case, the result type isBigIntsinceBigIntis the only type large enough to hold integers for  
arbitrary-precisionintegerarithmetic. Alsonotethatonedoesnotneedtodefinebothpromote_rule(::Type{A},  
::Type{B})andpromote_rule(::Type{B}, ::Type{A})–thesymmetryisimpliedbythewaypromote_rule  
is used in the promotion process.

Thepromote_rulefunctionisusedasabuildingblocktodefineasecondfunctioncalledpromote_type, which,  
given any number of type objects, returns the common type to which those values, as arguments topromote  
should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values  
of certain types would promote to, one can usepromote_type:

```
julia> promote_type( Int8 , Int64 )
Int64
```

Internally,promote_typeis used inside ofpromoteto determine what type argument values should be con-  
verted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in  
promotion.jl, which defines the complete promotion mechanism in about 35 lines.

### Case Study: Rational Promotions

Finally,wefinishoffourongoingcasestudyofJulia'srationalnumbertype,whichmakesrelativelysophisticated  
use of the promotion mechanism with the following promotion rules:

```
promote_rule(:: Type { Rational {T}},:: Type {S}) where {T<: Integer ,S<: Integer } =
↪→ Rational {promote_type(T,S)}
promote_rule(:: Type { Rational {T}},:: Type { Rational {S}}) where {T<: Integer ,S<: Integer } =
↪→ Rational {promote_type(T,S)}
promote_rule(:: Type { Rational {T}},:: Type {S}) where {T<: Integer ,S<: AbstractFloat } = promote_type(T,S)
```

The first rule says that promoting a rational number with any other integer type promotes to a rational type  
whosenumerator/denominatortypeistheresultofpromotionofitsnumerator/denominatortypewiththeother  
integer type. The second rule applies the same logic to two different types of rational numbers, resulting in  
a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates  
that promoting a rational with a float results in the same type as promoting the numerator/denominator type  
with the float.

#### CHAPTER 14. CONVERSION AND PROMOTION 165

This small handful of promotion rules, together with the type's constructors and the defaultconvertmethod  
for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other  
numeric types – integers, floating-point numbers, and complex numbers. By providing appropriate conversion  
methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as  
naturally with Julia's predefined numerics.

**Chapter 15**

**Interfaces**

A lot of the power and extensibility in Julia comes from a collection of informal interfaces. By extending a few  
specific methods to work for a custom type, objects of that type not only receive those functionalities, but they  
are also able to be used in other methods that are written to generically build upon those behaviors.

### 15.1 Iteration

```
Required methods Brief description
iterate(iter) Returns either a tuple of the first item and initial state or
nothingif empty
iterate(iter,
state)
```

```
Returns either a tuple of the next item and next state or
nothingif no items remain
Important optional
methods
```

```
Default
definition
```

```
Brief description
```

```
IteratorSize(IterType)HasLength() One ofHasLength(),HasShape{N}(),IsInfinite(), or
SizeUnknown()as appropriate
IteratorEltype(IterType)HasEltype() EitherEltypeUnknown()orHasEltype()as appropriate
eltype(IterType) Any The type of the first entry of the tuple returned byiterate()
length(iter) (undefined) The number of items, if known
size(iter, [dim]) (undefined) The number of items in each dimension, if known
```

```
Value returned byIteratorSize(IterType) Required Methods
HasLength() length(iter)
HasShape{N}() length(iter)andsize(iter, [dim])
IsInfinite() (none)
SizeUnknown() (none)
```

```
Value returned byIteratorEltype(IterType) Required Methods
HasEltype() eltype(IterType)
EltypeUnknown() (none)
```

Sequential iteration is implemented by theiteratefunction. Instead of mutating objects as they are iterated  
over, Julia iterators may keep track of the iteration state externally from the object. The return value from  
iterate is always either a tuple of a value and a state, ornothingif no elements remain. The state object will  
be passed back to the iterate function on the next iteration and is generally considered an implementation  
detail private to the iterable object.

#### 166

#### CHAPTER 15. INTERFACES 167

Any object that defines this function is iterable and can be used in themany functions that rely upon iteration.  
It can also be used directly in aforloop since the syntax:

```
for item in iter # or "for item = iter"
# body
end
```

is translated into:

```
next= iterate(iter)
while next!== nothing
(item, state)= next
# body
next= iterate(iter, state)
end
```

A simple example is an iterable sequence of square numbers with a defined length:

```
julia> struct Squares
count:: Int
end
```

```
julia> Base.iterate(S::Squares, state=1) = state> S.count? nothing: (state*state, state+1)
```

Withonlyiteratedefinition, theSquarestypeisalreadyprettypowerful. Wecaniterateoveralltheelements:

```
julia>for item in Squares(7)
println(item)
end
1
4
9
16
25
36
49
```

We can use many of the builtin methods that work with iterables, likein, ormeanandstdfrom theStatistics  
standard library module:

```
julia> 25 in Squares(10)
true
```

```
julia>using Statistics
```

```
julia> mean(Squares(100))
3383.5
```

```
julia> std(Squares(100))
3024.355854282583
```

#### CHAPTER 15. INTERFACES 168

There are a few more methods we can extend to give Julia more information about this iterable collection. We  
know that the elements in aSquaressequence will always beInt. By extending theeltypemethod, we can  
give that information to Julia and help it make more specialized code in the more complicated methods. We  
also know the number of elements in our sequence, so we can extendlength, too:

```
julia> Base.eltype(:: Type {Squares})= Int # Note that this is defined for the type
```

```
julia> Base.length(S::Squares)= S.count
```

Now, when we ask Julia tocollectall the elements into an array it can preallocate aVector{Int}of the right  
size instead of naivelypush!ing each element into aVector{Any}:

```
julia> collect(Squares(4))
4-element Vector{Int64}:
1
4
9
16
```

While we can rely upon generic implementations, we can also extend specific methods where we know there  
is a simpler algorithm. For example, there's a formula to compute the sum of squares, so we can override the  
generic iterative version with a more performant solution:

```
julia> Base.sum(S::Squares)= (n = S.count; return n*(n+1)*(2n+1)÷6)
```

```
julia> sum(Squares(1803))
1955361914
```

This is a very common pattern throughout Julia Base: a small set of required methods define an informal  
interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those  
extra behaviors when they know a more efficient algorithm can be used in their specific case.

ItisalsooftenusefultoallowiterationoveracollectioninreverseorderbyiteratingoverIterators.reverse(iterator).  
To actually support reverse-order iteration, however, an iterator typeTneeds to implementiteratefor  
Iterators.Reverse{T}. (Givenr::Iterators.Reverse{T}, the underling iterator of typeTisr.itr.) In our  
Squaresexample, we would implementIterators.Reverse{Squares}methods:

```
julia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count)= state< 1? nothing:
↪→ (state*state, state-1)
```

```
julia> collect(Iterators.reverse(Squares(4)))
4-element Vector{Int64}:
16
9
4
1
```

### 15.2 Indexing

For theSquaresiterable above, we can easily compute theith element of the sequence by squaring it. We  
can expose this as an indexing expressionS[i]. To opt into this behavior,Squaressimply needs to define  
getindex:

#### CHAPTER 15. INTERFACES 169

```
Methods to implement Brief description
getindex(X, i) X[i], indexed element access
setindex!(X, v, i) X[i] = v, indexed assignment
firstindex(X) The first index, used inX[begin]
lastindex(X) The last index, used inX[end]
```

```
julia>function Base.getindex(S::Squares, i:: Int )
1 <= i <= S.count|| throw( BoundsError (S, i))
return i*i
end
```

```
julia> Squares(100)[23]
529
```

Additionally,tosupportthesyntaxS[begin]andS[end],wemustdefinefirstindexandlastindextospecify  
the first and last valid indices, respectively:

```
julia> Base.firstindex(S::Squares)= 1
```

```
julia> Base.lastindex(S::Squares)= length(S)
```

```
julia> Squares(23)[ end ]
529
```

Formulti-dimensionalbegin/endindexingasina[3, begin, 7],forexample,youshoulddefinefirstindex(a,  
dim)andlastindex(a, dim)(which default to callingfirstandlastonaxes(a, dim), respectively).

Note, though, that the above only definesgetindexwith one integer index. Indexing with anything other than  
anIntwill throw aMethodErrorsaying that there was no matching method. In order to support indexing with  
ranges or vectors ofInts, separate methods must be written:

```
julia> Base.getindex(S::Squares, i:: Number ) = S[convert( Int , i)]
```

```
julia> Base.getindex(S::Squares,I) = [S[i] for i in I]
```

```
julia> Squares(10)[[3,4.,5]]
3-element Vector{Int64}:
9
16
25
```

While this is starting to support more of theindexing operations supported by some of the builtin types, there 's  
stillquiteanumberofbehaviorsmissing. ThisSquaressequenceisstartingtolookmoreandmorelikeavector  
as we 've added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as  
a subtype of anAbstractArray.

### 15.3 Abstract Arrays

If a type is defined as a subtype ofAbstractArray, it inherits a very large set of rich behaviors including  
iteration and multidimensional indexing built on top of single-element access. See thearrays manual page  
and theJulia Base sectionfor more supported methods.

#### CHAPTER 15. INTERFACES 170

```
Methods to implement Brief description
size(A) Returns a tuple containing the dimensions ofA
getindex(A, i::Int) (ifIndexLinear) Linear scalar indexing
getindex(A,
I::Vararg{Int, N})
```

```
(ifIndexCartesian, whereN = ndims(A))
N-dimensional scalar indexing
setindex!(A, v,
i::Int)
```

```
(ifIndexLinear) Scalar indexed assignment
```

```
setindex!(A, v,
I::Vararg{Int, N})
```

```
(ifIndexCartesian, whereN = ndims(A))
N-dimensional scalar indexed assignment
Optional methods Default definition Brief description
IndexStyle(::Type) IndexCartesian() Returns eitherIndexLinear()or
IndexCartesian(). See the description below.
getindex(A, I...) defined in terms of
scalargetindex
```

```
Multidimensional and nonscalar indexing
```

```
setindex!(A, X, I...) defined in terms of
scalarsetindex!
```

```
Multidimensional and nonscalar indexed
assignment
iterate defined in terms of
scalargetindex
```

```
Iteration
```

```
length(A) prod(size(A)) Number of elements
similar(A) similar(A,
eltype(A), size(A))
```

```
Return a mutable array with the same shape and
element type
similar(A, ::Type{S}) similar(A, S,
size(A))
```

```
Return a mutable array with the same shape and
the specified element type
similar(A, dims::Dims) similar(A,
eltype(A), dims)
```

```
Return a mutable array with the same element
type and size dims
similar(A, ::Type{S},
dims::Dims)
```

```
Array{S}(undef,
dims)
```

```
Return a mutable array with the specified
element type and size
Non-traditional indices Default definition Brief description
axes(A) map(OneTo, size(A)) Return the a tuple of
AbstractUnitRange{<:Integer}of valid indices
similar(A, ::Type{S},
inds)
```

```
similar(A, S,
Base.to_shape(inds))
```

```
Return a mutable array with the specified indices
inds(see below)
similar(T::Union{Type,Function},
inds)
```

```
T(Base.to_shape(inds))Return an array similar toTwith the specified
indicesinds(see below)
```

Akeypartin defininganAbstractArraysubtypeisIndexStyle. Sinceindexingissuchanimportantpart ofan  
arrayandoftenoccursinhotloops, it'simportanttomakebothindexingandindexedassignmentasefficientas  
possible. Array data structures are typically defined in one of two ways: either it most efficiently accesses its  
elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified  
for every dimension. These two modalities are identified by Julia asIndexLinear()andIndexCartesian().  
Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-  
based mechanism to enable efficient generic code for all array types.

This distinction determines which scalar indexing methods the type must define.IndexLinear()arrays are  
simple: just definegetindex(A::ArrayType, i::Int). When the array is subsequently indexed with a mul-  
tidimensional set of indices, the fallbackgetindex(A::AbstractArray, I...)()efficiently converts the in-  
dices into one linear index and then calls the above method.IndexCartesian()arrays, on the other hand,  
require methods to be defined for each supported dimensionality withndims(A) Intindices. For example,  
SparseMatrixCSCfrom theSparseArraysstandard library module, only supports two dimensions, so it just  
definesgetindex(A::SparseMatrixCSC, i::Int, j::Int). The same holds forsetindex!.

#### CHAPTER 15. INTERFACES 171

Returningtothesequenceofsquaresfromabove,wecouldinsteaddefineitasasubtypeofanAbstractArray{Int,  
1}:

```
julia> struct SquaresVector<: AbstractArray { Int , 1}
count:: Int
end
```

```
julia> Base.size(S::SquaresVector)= (S.count,)
```

```
julia> Base.IndexStyle(:: Type {<:SquaresVector})= IndexLinear()
```

```
julia> Base.getindex(S::SquaresVector, i:: Int ) = i*i
```

Note that it's very important to specify the two parameters of theAbstractArray; the first defines theeltype,  
and the second defines thendims. That supertype and those three methods are all it takes forSquaresVector  
to be an iterable, indexable, and completely functional array:

```
julia> s = SquaresVector(4)
4-element SquaresVector:
1
4
9
16
```

```
julia> s[s .> 8]
2-element Vector{Int64}:
9
16
```

```
julia> s + s
4-element Vector{Int64}:
2
8
18
32
```

```
julia> sin.(s)
4-element Vector{Float64}:
0.8414709848078965
-0.7568024953079282
0.4121184852417566
-0.2879033166650653
```

As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of  
Dict:

```
julia> struct SparseArray{T,N}<: AbstractArray {T,N}
data:: Dict { NTuple {N, Int }, T}
dims:: NTuple {N, Int }
end
```

```
julia> SparseArray(:: Type {T}, dims:: Int ...) where {T}= SparseArray(T, dims);
```

#### CHAPTER 15. INTERFACES 172

```
julia> SparseArray(:: Type {T}, dims:: NTuple {N, Int }) where {T,N}=
↪→ SparseArray{T,N}( Dict { NTuple {N, Int }, T}(), dims);
```

```
julia> Base.size(A::SparseArray)= A.dims
```

```
julia> Base.similar(A::SparseArray,:: Type {T}, dims:: Dims ) where {T}= SparseArray(T, dims)
```

```
julia> Base.getindex(A::SparseArray{T,N},I:: Vararg { Int ,N}) where {T,N}= get(A.data,I, zero(T))
```

```
julia> Base.setindex!(A::SparseArray{T,N}, v,I:: Vararg { Int ,N}) where {T,N}= (A.data[I] = v)
```

Notice that this is anIndexCartesianarray, so we must manually definegetindexandsetindex!at the  
dimensionality of the array. Unlike theSquaresVector, we are able to definesetindex!, and so we can  
mutate the array:

```
julia> A = SparseArray( Float64 , 3, 3)
3×3 SparseArray{Float64, 2}:
0.0 0.0 0.0
0.0 0.0 0.0
0.0 0.0 0.0
```

```
julia> fill!(A,2)
3×3 SparseArray{Float64, 2}:
2.0 2.0 2.0
2.0 2.0 2.0
2.0 2.0 2.0
```

```
julia> A[:] = 1:length(A); A
3×3 SparseArray{Float64, 2}:
1.0 4.0 7.0
2.0 5.0 8.0
3.0 6.0 9.0
```

TheresultofindexinganAbstractArraycanitselfbeanarray(forinstancewhenindexingbyanAbstractRange).  
TheAbstractArrayfallback methods usesimilarto allocate anArrayof the appropriate size and element  
type, which is filled in using the basic indexing method described above. However, when implementing an  
array wrapper you often want the result to be wrapped as well:

```
julia> A[1:2,:]
2×3 SparseArray{Float64, 2}:
1.0 4.0 7.0
2.0 5.0 8.0
```

In this example it is accomplished by definingBase.similar(A::SparseArray, ::Type{T}, dims::Dims)  
where Tto create the appropriate wrapped array. (Note that whilesimilarsupports 1- and 2-argument forms,  
inmostcaseyouonlyneedtospecializethe3-argumentform.) Forthistoworkit'simportantthatSparseArray  
is mutable (supportssetindex!). Definingsimilar,getindexandsetindex!forSparseArrayalso makes it  
possible tocopythe array:

```
julia> copy(A)
3×3 SparseArray{Float64, 2}:
1.0 4.0 7.0
2.0 5.0 8.0
3.0 6.0 9.0
```

#### CHAPTER 15. INTERFACES 173

In addition to all the iterable and indexable methods from above, these types can also interact with each other  
and use most of the methods defined in Julia Base forAbstractArrays:

```
julia> A[SquaresVector(3)]
3-element SparseArray{Float64, 1}:
1.0
4.0
9.0
```

```
julia> sum(A)
45.0
```

If you are defining an array type that allows non-traditional indexing (indices that start at something other  
than 1), you should specializeaxes. You should also specializesimilarso that thedimsargument (ordinarily  
aDimssize-tuple) can acceptAbstractUnitRangeobjects, perhaps range-typesIndof your own design. For  
more information, seeArrays with custom indices.

### 15.4 Strided Arrays

```
Methods to
implement
```

```
Brief description
```

```
strides(A) Return the distance in memory (in number of elements) between
adjacent elements in each dimension as a tuple. IfAis an
AbstractArray{T,0}, this should return an empty tuple.
Base.unsafe_convert(::Type{Ptr{T}},
A)
```

```
Return the native address of an array.
```

```
Base.elsize(::Type{<:A}) Return the stride between consecutive elements in the array.
Optional
methods
```

```
Default
defini-
tion
```

```
Brief description
```

```
stride(A,
i::Int)
```

```
strides(A)[i]Return the distance in memory (in number of elements) between
adjacent elements in dimension k.
```

A strided array is a subtype ofAbstractArraywhose entries are stored in memory with fixed strides. Provided  
the element type of the array is compatible with BLAS, a strided array can utilize BLAS and LAPACK routines  
for more efficient linear algebra routines. A typical example of a user-defined strided array is one that wraps  
a standardArraywith additional structure.

Warning: do not implement these methods if the underlying storage is not actually strided, as it may lead to  
incorrect results or segmentation faults.

Here are some examples to demonstrate which type of arrays are strided and which are not:

```
1:5 # not strided (there is no storage associated with this array.)
Vector (1:5) # is strided with strides (1,)
A = [1 5; 2 6; 3 7; 4 8] # is strided with strides (1,4)
V = view(A,1:2, :) # is strided with strides (1,4)
V = view(A,1:2:3, 1:2) # is strided with strides (2,4)
V = view(A, [1,2,4], :) # is not strided, as the spacing between rows is not fixed.
```

#### CHAPTER 15. INTERFACES 174

```
Methods to implement Brief description
Base.BroadcastStyle(::Type{SrcType}) =
SrcStyle()
```

```
Broadcasting behavior ofSrcType
```

```
Base.similar(bc::Broadcasted{DestStyle},
::Type{ElType})
```

```
Allocation of output container
```

```
Optional methods
Base.BroadcastStyle(::Style1, ::Style2) =
Style12()
```

```
Precedence rules for mixing styles
```

```
Base.axes(x) Declaration of the indices ofx, as peraxes(x).
Base.broadcastable(x) Convertxto an object that hasaxesand supports
indexing
Bypassing default machinery
Base.copy(bc::Broadcasted{DestStyle}) Custom implementation ofbroadcast
Base.copyto!(dest,
bc::Broadcasted{DestStyle})
```

```
Custom implementation ofbroadcast!,
specializing onDestStyle
Base.copyto!(dest::DestType,
bc::Broadcasted{Nothing})
```

```
Custom implementation ofbroadcast!,
specializing onDestType
Base.Broadcast.broadcasted(f, args...) Override the default lazy behavior within a fused
expression
Base.Broadcast.instantiate(bc::Broadcasted{DestStyle})Override the computation of the lazy broadcast's
axes
```

### 15.5 Customizing broadcasting.

Broadcastingis triggered by an explicit call tobroadcastorbroadcast!, or implicitly by"dot" operations  
likeA .+ borf.(x, y). Any object that hasaxesand supports indexing can participate as an argument in  
broadcasting, and by default the result is stored in anArray. This basic framework is extensible in three major  
ways:

-   Ensuring that all arguments support broadcast
-   Selecting an appropriate output array for the given set of arguments
-   Selecting an efficient implementation for the given set of arguments

Notalltypessupportaxesandindexing,butmanyareconvenienttoallowinbroadcast. TheBase.broadcastable  
function is called on each argument to broadcast, allowing it to return something different that supportsaxes  
and indexing. By default, this is the identity function for allAbstractArrays andNumbers — they already  
supportaxesand indexing. For a handful of other types (including but not limited to types themselves,  
functions, special singletons likemissingandnothing, and dates),Base.broadcastablereturns the argu-  
ment wrapped in aRefto act as a 0-dimensional"scalar" for the purposes of broadcasting. Custom types  
can similarly specializeBase.broadcastableto define their shape, but they should follow the convention  
thatcollect(Base.broadcastable(x)) == collect(x). A notable exception isAbstractString; strings  
are special-cased to behave as scalars for the purposes of broadcast even though they are iterable collections  
of their characters (seeStringsfor more).

The next two steps (selecting the output array and implementation) are dependent upon determining a single  
answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse  
them down to just one output array and one implementation. Broadcast calls this single answer a"style".  
Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine  
these styles into a single answer — the"destination style".

#### CHAPTER 15. INTERFACES 175

### Broadcast Styles

Base.BroadcastStyleistheabstracttypefromwhichallbroadcaststylesarederived. Whenusedasafunction  
it has two possible forms, unary (single-argument) and binary. The unary variant states that you intend to  
implement specific broadcasting behavior and/or output type, and do not wish to rely on the default fallback  
Broadcast.DefaultArrayStyle.

To override these defaults, you can define a customBroadcastStylefor your object:

```
struct MyStyle<: Broadcast.BroadcastStyle end
Base.BroadcastStyle(:: Type {<:MyType})= MyStyle()
```

In some cases it might be convenient not to have to defineMyStyle, in which case you can leverage one of  
the general broadcast wrappers:

-   Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.Style{MyType}()can be used for arbitrary  
    types.
-   Base.BroadcastStyle(::Type{<:MyType}) = Broadcast.ArrayStyle{MyType}()ispreferredifMyType  
    is anAbstractArray.
-   ForAbstractArraysthatonlysupportacertaindimensionality,createasubtypeofBroadcast.AbstractArrayStyle{N}  
    (see below).

When your broadcast operation involves several arguments, individual argument styles get combined to de-  
termine a singleDestStylethat controls the type of the output container. For more details, seebelow.

### Selecting an appropriate output array

The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The  
actual allocation of the result array is handled bysimilar, using the Broadcasted object as its first argument.

```
Base.similar(bc::Broadcasted{DestStyle},:: Type {ElType})
```

The fallback definition is

```
similar(bc::Broadcasted{DefaultArrayStyle{N}},:: Type {ElType}) where {N,ElType}=
similar( Array {ElType}, axes(bc))
```

However, if needed you can specialize on any or all of these arguments. The final argumentbcis a lazy  
representation of a (potentially fused) broadcast operation, aBroadcastedobject. For these purposes, the  
most important fields of the wrapper arefandargs, describing the function and argument list, respectively.  
Note that the argument list can — and often does — include other nestedBroadcastedwrappers.

For a complete example, let's say you have created a type,ArrayAndChar, that stores an array and a single  
character:

```
struct ArrayAndChar{T,N}<: AbstractArray {T,N}
data:: Array {T,N}
char:: Char
end
Base.size(A::ArrayAndChar)= size(A.data)
Base.getindex(A::ArrayAndChar{T,N}, inds:: Vararg { Int ,N}) where {T,N}= A.data[inds...]
Base.setindex!(A::ArrayAndChar{T,N}, val, inds:: Vararg { Int ,N}) where {T,N}= A.data[inds...] = val
Base.showarg(io:: IO , A ::ArrayAndChar, toplevel)= print(io, typeof(A)," with char '", A .char,"'")
```

#### CHAPTER 15. INTERFACES 176

You might want broadcasting to preserve thechar"metadata". First we define

```
Base.BroadcastStyle(:: Type {<:ArrayAndChar})= Broadcast.ArrayStyle{ArrayAndChar}()
```

This means we must also define a correspondingsimilarmethod:

```
function Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}},:: Type {ElType})
↪→ where ElType
# Scan the inputs for the ArrayAndChar:
A = find_aac(bc)
# Use the char field of A to create the output
ArrayAndChar(similar( Array {ElType}, axes(bc)), A.char)
end
```

```
"`A = find_aac(As)` returns the first ArrayAndChar among the arguments."
find_aac(bc::Base.Broadcast.Broadcasted)= find_aac(bc.args)
find_aac(args:: Tuple ) = find_aac(find_aac(args[1]), Base.tail(args))
find_aac(x)= x
find_aac(:: Tuple {}) = nothing
find_aac(a::ArrayAndChar, rest)= a
find_aac(:: Any , rest)= find_aac(rest)
```

From these definitions, one obtains the following behavior:

```
julia> a = ArrayAndChar([1 2; 3 4], 'x')
2×2 ArrayAndChar{Int64, 2} with char 'x':
1 2
3 4
```

```
julia> a .+ 1
2×2 ArrayAndChar{Int64, 2} with char 'x':
2 3
4 5
```

```
julia> a .+ [5,10]
2×2 ArrayAndChar{Int64, 2} with char 'x':
6 7
13 14
```

### Extending broadcast with custom implementations

In general, a broadcast operation is represented by a lazyBroadcastedcontainer that holds onto the func-  
tion to be applied alongside its arguments. Those arguments may themselves be more nestedBroadcasted  
containers, forming a large expression tree to be evaluated. A nested tree ofBroadcastedcontainers is  
directly constructed by the implicit dot syntax;5 .+ 2._xis transiently represented byBroadcasted(+,  
5, Broadcasted(_, 2, x)), for example. This is invisible to users as it is immediately realized through a  
call tocopy, but it is this container that provides the basis for broadcast's extensibility for authors of cus-  
tom types. The built-in broadcast machinery will then determine the result type and size based upon the  
arguments, allocate it, and then finally copy the realization of theBroadcastedobject into it with a de-  
faultcopyto!(::AbstractArray, ::Broadcasted)method. The built-in fallbackbroadcastandbroadcast!  
methods similarly construct a transientBroadcastedrepresentation of the operation so they can follow the  
same codepath. This allows custom array implementations to provide their owncopyto!specialization to cus-  
tomize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an

#### CHAPTER 15. INTERFACES 177

important part of the operation that it is stored as the first type parameter of theBroadcastedtype, allowing  
for dispatch and specialization.

For some types, the machinery to"fuse" operations across nested levels of broadcasting is not available or  
could be done more efficiently incrementally. In such cases, you may need or want to evaluatex .* (x .+  
1)as if it had been writtenbroadcast(_, x, broadcast(+, x, 1)), where the inner operation is evaluated  
before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirec-  
tion; instead of directly constructingBroadcastedobjects, Julia lowers the fused expressionx ._ (x .+ 1)  
toBroadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1)). Now, by default,broadcastedjust  
calls theBroadcastedconstructor to create the lazy representation of the fused expression tree, but you can  
choose to override it for a particular combination of function and arguments.

Asanexample,thebuiltinAbstractRangeobjectsusethismachinerytooptimizepiecesofbroadcastedexpres-  
sions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing  
everysingle element. Just likeall the other machinery,broadcastedalsocomputes and exposesthe combined  
broadcast style of its arguments, so instead of specializing onbroadcasted(f, args...), you can specialize  
onbroadcasted(::DestStyle, f, args...)for any combination of style, function, and arguments.

For example, the following definition supports the negation of ranges:

```
broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r :: OrdinalRange ) = range(-first(r), step=-step(r),
↪→ length=length(r))
```

### Extending in-place broadcasting

In-placebroadcastingcanbesupportedbydefiningtheappropriatecopyto!(dest, bc::Broadcasted)method.  
Becauseyoumightwanttospecializeeitherondestorthespecificsubtypeofbc,toavoidambiguitiesbetween  
packages we recommend the following convention.

If you wish to specialize on a particular styleDestStyle, define a method for

```
copyto!(dest, bc::Broadcasted{DestStyle})
```

Optionally, with this form you can also specialize on the type ofdest.

If instead you want to specialize on the destination typeDestTypewithout specializing onDestStyle, then  
you should define a method with the following signature:

```
copyto!(dest::DestType, bc::Broadcasted{Nothing})
```

Thisleveragesafallbackimplementationofcopyto!thatconvertsthewrapperintoaBroadcasted{Nothing}.  
Consequently, specializing onDestTypehas lower precedence than methods that specialize onDestStyle.

Similarly, you can completely override out-of-place broadcasting with acopy(::Broadcasted)method.

**Working withBroadcastedobjects**

In order to implement such acopyorcopyto!, method, of course, you must work with theBroadcasted  
wrapper to compute each element. There are two main ways of doing so:

-   Broadcast.flattenrecomputes the potentially nested operation into a single function and flat list of  
    arguments. You are responsible for implementing the broadcasting shape rules yourself, but this may  
    be helpful in limited situations.
-   IteratingovertheCartesianIndicesoftheaxes(::Broadcasted)andusingindexingwiththeresulting  
    CartesianIndexobject to compute the result.

#### CHAPTER 15. INTERFACES 178

### Writing binary broadcasting rules

The precedence rules are defined by binaryBroadcastStylecalls:

```
Base.BroadcastStyle(::Style1,::Style2)= Style12()
```

whereStyle12is theBroadcastStyleyou want to choose for outputs involving arguments ofStyle1and  
Style2. For example,

```
Base.BroadcastStyle(::Broadcast.Style{ Tuple }, ::Broadcast.AbstractArrayStyle{0}) =
↪→ Broadcast.Style{ Tuple }()
```

indicates thatTuple"wins" over zero-dimensional arrays (the output container will be a tuple). It is worth  
noting that you do not need to (and should not) define both argument orders of this call; defining one is  
sufficient no matter what order the user supplies the arguments in.

ForAbstractArraytypes,definingaBroadcastStylesupersedesthefallbackchoice,Broadcast.DefaultArrayStyle.  
DefaultArrayStyleand the abstract supertype,AbstractArrayStyle, store the dimensionality as a type pa-  
rameter to support specialized array types that have fixed dimensionality requirements.

DefaultArrayStyle"loses" to any otherAbstractArrayStylethat has been defined because of the following  
methods:

```
BroadcastStyle(a::AbstractArrayStyle{ Any }, ::DefaultArrayStyle)= a
BroadcastStyle(a::AbstractArrayStyle{N},::DefaultArrayStyle{N}) where N= a
BroadcastStyle(a::AbstractArrayStyle{M},::DefaultArrayStyle{N}) where {M,N}=
typeof(a)( Val (max(M, N)))
```

You do not need to write binaryBroadcastStylerules unless you want to establish precedence for two or more  
non-DefaultArrayStyletypes.

Ifyourarraytypedoeshavefixeddimensionalityrequirements,thenyoushouldsubtypeAbstractArrayStyle.  
For example, the sparse array code has the following definitions:

```
struct SparseVecStyle<: Broadcast.AbstractArrayStyle{1} end
struct SparseMatStyle<: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(:: Type {<:SparseVector})= SparseVecStyle()
Base.BroadcastStyle(:: Type {<: SparseMatrixCSC }) = SparseMatStyle()
```

Whenever you subtypeAbstractArrayStyle, you also need to define rules for combining dimensionalities, by  
creating a constructor for your style that takes aVal(N)argument. For example:

```
SparseVecStyle(:: Val {0}) = SparseVecStyle()
SparseVecStyle(:: Val {1}) = SparseVecStyle()
SparseVecStyle(:: Val {2}) = SparseMatStyle()
SparseVecStyle(:: Val {N}) where N= Broadcast.DefaultArrayStyle{N}()
```

These rules indicate that the combination of aSparseVecStylewith 0- or 1-dimensional arrays yields another  
SparseVecStyle, that its combination with a 2-dimensional array yields aSparseMatStyle, and anything of  
higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting  
to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an  
Arrayfor any other dimensionality.

**Chapter 16**

**Modules**

ModulesinJuliahelporganizecodeintocoherentunits. Theyaredelimitedsyntacticallyinsidemodule NameOfModule  
... end, and have the following features:

1.  Modulesareseparatenamespaces, eachintroducinganewglobalscope. Thisisuseful, becauseitallows  
    the same name to be used for different functions or global variables without conflict, as long as they are  
    in separate modules.
2.  Modules have facilities for detailed namespace management: each defines a set of names itexports,  
    and can import names from other modules withusingandimport(we explain these below).
3.  Modules can be precompiled for faster loading, and contain code for runtime initialization.

Typically, in larger Julia packages you will see module code organized into files, eg

```
module SomeModule
```

```
# export, using, import statements are usually here; we discuss these below
```

```
include("file1.jl")
include("file2.jl")
```

```
end
```

Files and file names are mostly unrelated to modules; modules are associated only with module expressions.  
One can have multiple files per module, and multiple modules per file.includebehaves as if the contents of  
the source file were evaluated in the global scope of the including module. In this chapter, we use short and  
simplified examples, so we won't useinclude.

The recommended style is not to indent the body of the module, since that would typically lead to whole files  
being indented. Also, it is common to useUpperCamelCasefor module names (just like types), and use the  
plural form if applicable, especially if the module contains a similarly named identifier, to avoid name clashes.  
For example,

```
module FastThings
```

```
struct FastThing
...
end
```

```
end
```

#### 179

#### CHAPTER 16. MODULES 180

### 16.1 Namespace management.

Namespace management refers to the facilities the language offers for making names in a module available  
in other modules. We discuss the related concepts and functionality below in detail.

### Qualified names

Names for functions, variables and types in the global scope likesin,ARGS, andUnitRangealways belong to  
a module, called the parent module, which can be found interactively withparentmodule, for example

```
julia> parentmodule( UnitRange )
Base
```

One can also refer to these names outside their parent module by prefixing them with their module, eg  
Base.UnitRange. This is called a qualified name. The parent module may be accessible using a chain of  
submodules likeBase.Math.sin, whereBase.Mathis called the module path. Due to syntactic ambiguities,  
qualifying a name that contains only symbols, such as an operator, requires inserting a colon, e.g.Base.:+. A  
small number of operators additionally require parentheses, e.g.Base.:(==).

If a name is qualified, then it is always accessible, and in case of a function, it can also have methods added  
to it by using the qualified name as the function name.

Within a module, a variable name can be “reserved” without assigning to it by declaring it asglobal x. This  
prevents name conflicts for globals initialized after load time. The syntaxM.x = ydoes not work to assign a  
global in another module; global assignment is always module-local.

### Export lists

Names (referring to functions, types, global variables, and constants) can be added to the export list of a  
module withexport. Typically, they are at or near the top of the module definition so that readers of the  
source code can find them easily, as in

```
module NiceStuff
```

```
export nice, DOG
```

```
struct Dog end # singleton type, not exported
```

```
const DOG = Dog() # named instance, exported
```

```
nice(x)= "nice $x " # function, exported
```

```
end
```

but this is just a style suggestion — a module can have multipleexportstatements in arbitrary locations.

It is common to export names which form part of the API (application programming interface). In the above  
code,theexportlistsuggeststhatusersshoulduseniceandDOG.However,sincequalifiednamesalwaysmake  
identifiers accessible, this is just an option for organizing APIs: unlike other languages, Julia has no facilities  
for truly hiding module internals.

Also, some modules don't export names at all. This is usually done if they use common words, such as  
derivative, in their API, which could easily clash with the export lists of other modules. We will see how  
to manage name clashes below.

#### CHAPTER 16. MODULES 181

### Standaloneusingandimport

Possibly the most common way of loading a module isusing ModuleName. This loads the code associated with  
ModuleName, and brings

1.  the module name
2.  and the elements of the export list into the surrounding global namespace.

Technically, the statementusing ModuleNamemeans that a module calledModuleNamewill be available for  
resolvingnamesasneeded. Whenaglobalvariableisencounteredthathasnodefinitioninthecurrentmodule,  
the system will search for it among variables exported byModuleNameand use it if it is found there. This means  
thatallusesofthatglobalwithinthecurrentmodulewillresolvetothedefinitionofthatvariableinModuleName.

To continue with our example,

```
using NiceStuff
```

would load the above code, makingNiceStuff(the module name),DOGandniceavailable.Dogis not on the  
export list, but it can be accessed if the name is qualified with the module path (which here is just the module  
name) asNiceStuff.Dog.

Importantly, **using ModuleNameis the only form for which export lists matter at all**.

In contrast,

```
import NiceStuff
```

brings only the module name into scope. Users would need to useNiceStuff.DOG,NiceStuff.Dog, and  
NiceStuff.niceto access its contents. Usually,import ModuleNameis used in contexts when the user wants  
to keep the namespace clean. As we will see in the next sectionimport NiceStuffis equivalent tousing  
NiceStuff: NiceStuff.

You can combine multipleusingandimportstatements of the same kind in a comma-separated expression,  
e.g.

```
using LinearAlgebra, Statistics
```

### usingandimportwith specific identifiers, and adding methods

Whenusing ModuleName:orimport ModuleName:is followed by a comma-separated list of names, the mod-  
ule is loaded, but only those specific names are brought into the namespace by the statement. For example,

```
using NiceStuff: nice, DOG
```

will import the namesniceandDOG.

Importantly, the module nameNiceStuffwill not be in the namespace. If you want to make it accessible, you  
have to list it explicitly, as

```
using NiceStuff: nice, DOG, NiceStuff
```

#### CHAPTER 16. MODULES 182

Julia has two forms for seemingly the same thing because onlyimport ModuleName: fallows adding methods  
tofwithout a module path. That is to say, the following example will give an error:

```
using NiceStuff: nice
struct Cat end
nice(::Cat)= "nice "
```

This error prevents accidentally adding methods to functions in other modules that you only intended to use.

There are two ways to deal with this. You can always qualify function names with a module path:

```
using NiceStuff
struct Cat end
NiceStuff.nice(::Cat)= "nice "
```

Alternatively, you canimportthe specific function name:

```
import NiceStuff: nice
struct Cat end
nice(::Cat)= "nice "
```

Which one you choose is a matter of style. The first form makes it clear that you are adding a method to a  
function in another module (remember, that the imports and the method defintion may be in separate files),  
while the second one is shorter, which is especially convenient if you are defining multiple methods.

Once a variable is made visible viausingorimport, a module may not create its own variable with the same  
name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the  
current module, or else raises an error.

### Renaming withas

An identifier brought into scope byimportorusingcan be renamed with the keywordas. This is useful for  
working around name conflicts as well as for shortening names. For example,Baseexports the function name  
read, but the CSV.jl package also providesCSV.read. If we are going to invoke CSV reading many times, it  
wouldbeconvenienttodroptheCSV.qualifier. ButthenitisambiguouswhetherwearereferringtoBase.read  
orCSV.read:

```
julia> read;
```

```
julia> import CSV: read
WARNING: ignoring conflicting import of CSV.read into Main
```

Renaming provides a solution:

```
julia> import CSV: read as rd
```

Imported packages themselves can also be renamed:

```
import BenchmarkTools as BT
```

asworks withusingonly when a single identifier is brought into scope. For exampleusing CSV: read as rd  
works, butusing CSV as Cdoes not, since it operates on all of the exported names inCSV.

#### CHAPTER 16. MODULES 183

### Mixing multipleusingandimportstatements

When multipleusingorimportstatements of any of the forms above are used, their effect is combined in the  
order they appear. For example,

```
using NiceStuff # exported names and the module name
import NiceStuff: nice # allows adding methods to unqualified functions
```

would bring all the exported names ofNiceStuffand the module name itself into scope, and also allow adding  
methods tonicewithout prefixing it with a module name.

### Handling name conflicts

Consider the situation where two (or more) packages export the same name, as in

```
module A
export f
f() = 1
end
```

```
module B
export f
f() = 2
end
```

The statementusing A, Bworks, but when you try to callf, you get a warning

```
WARNING: both B and A export "f"; uses of it in module Main must be qualified
ERROR: LoadError : UndefVarError : f not defined
```

Here, Julia cannot decide whichfyou are referring to, so you have to make a choice. The following solutions  
are commonly used:

1.  Simply proceed with qualified names likeA.fandB.f. This makes the context clear to the reader of  
    your code, especially iffjust happens to coincide but has different meaning in various packages. For  
    example,degreehas various uses in mathematics, the natural sciences, and in everyday life, and these  
    meanings should be kept separate.
2.  Use theaskeyword above to rename one or both identifiers, eg

```
using A: f as f
using B: f as g
```

```
wouldmakeB.favailableasg. Here, weareassumingthatyoudidnotuseusing Abefore, whichwould
have broughtfinto the namespace.
```

3.  When the names in question do share a meaning, it is common for one module to import it from another,  
    or have a lightweight “base” package with the sole function of defining an interface like this, which can  
    be used by other packages. It is conventional to have such package names end in...Base(which has  
    nothing to do with Julia'sBasemodule).

#### CHAPTER 16. MODULES 184

### Default top-level definitions and bare modules

Modules automatically containusing Core,using Base, and definitions of theevalandincludefunctions,  
which evaluate expressions/files within the global scope of that module.

If these default definitions are not wanted, modules can be defined using the keywordbaremoduleinstead  
(note:Coreis still imported). In terms ofbaremodule, a standardmodulelooks like this:

```
baremodule Mod
```

```
using Base
```

```
eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)
```

```
end
```

### Standard modules

There are three important standard modules:

-   Corecontains all functionality"built into" the language.
-   Basecontains basic functionality that is useful in almost all cases.
-   Mainis the top-level module and the current module, when Julia is started.

```
Standard library modules
BydefaultJuliashipswithsomestandardlibrarymodules. ThesebehavelikeregularJuliapackages
except that you don't need to install them explicitly. For example, if you wanted to perform some
unit testing, you could load theTeststandard library as follows:
```

```
using Test
```

### 16.2 Submodules and relative paths

Modules can contain submodules, nesting the same syntaxmodule ... end. They can be used to introduce  
separate namespaces, which can be helpful for organizing complex codebases. Note that eachmoduleintro-  
duces its ownscope, so submodules do not automatically “inherit” names from their parent.

It is recommended that submodules refer to other modules within the enclosing parent module (including the  
latter) using relative module qualifiers inusingandimportstatements. A relative module qualifier starts  
with a period (.), which corresponds to the current module, and each successive.leads to the parent of the  
current module. This should be followed by modules if necessary, and eventually the actual name to access,  
all separated by.s.

Consider the following example, where the submoduleSubAdefines a function, which is then extended in its  
“sibling” module:

```
module ParentModule
```

```
module SubA
```

#### CHAPTER 16. MODULES 185

```
export add_D # exported interface
const D = 3
add_D(x)= x + D
end
```

```
using .SubA # brings `add_D` into the namespace
```

```
export add_D# export it from ParentModule too
```

```
module SubB
import ..SubA: add_D# relative path for a “sibling” module
struct Infinity end
add_D(x::Infinity)= x
end
```

```
end
```

You may see code in packages, which, in a similar situation, uses

```
import ParentModule.SubA: add_D
```

However, this operates throughcode loading, and thus only works ifParentModuleis in a package. It is better  
to use relative paths.

Note that the order of definitions also matters if you are evaluating values. Consider

```
module TestPackage
```

```
export x, y
```

```
x = 0
```

```
module Sub
using ..TestPackage
z = y # ERROR: UndefVarError: y not defined
end
```

```
y = 1
```

```
end
```

whereSubis trying to useTestPackage.ybefore it was defined, so it does not have a value.

For similar reasons, you cannot use a cyclic ordering:

```
module A
```

```
module B
using ..C # ERROR: UndefVarError: C not defined
end
```

```
module C
using ..B
end
```

```
end
```

#### CHAPTER 16. MODULES 186

### Module initialization and precompilation

Large modules can take several seconds to load because executing all of the statements in a module often  
involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.

The incremental precompiled module file are created and used automatically when usingimportorusing  
to load a module. This will cause it to be automatically compiled the first time it is imported. Alterna-  
tively, you can manually callBase.compilecache(modulename). The resulting cache files will be stored in  
DEPOT_PATH[1]/compiled/. Subsequently, the module is automatically recompiled uponusingorimport  
whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it in-  
cludes, or explicit dependencies declared byinclude_dependency(path)in the module file(s).

For file dependencies, a change is determined by examining whether the modification time (mtime) of each file  
loaded byincludeor added explicitly byinclude_dependencyis unchanged, or equal to the modification time  
truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy).  
It also takes into account whether the path to the file chosen by the search logic inrequirematches the path  
that had created the precompile file. It also takes into account the set of dependencies already loaded into the  
current process and won't recompile those modules, even if their files change or disappear, in order to avoid  
creating incompatibilities between the running system and the precompile cache.

If you know that a module is not safe to precompile (for example, for one of the reasons described below),  
you should put__precompile__(false)in the module file (typically placed at the top). This will cause  
Base.compilecacheto throw an error, and will causeusing/importto load it directly into the current process  
and skip the precompile and caching. This also thereby prevents the module from being imported by any other  
precompiled module.

You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which  
may require care when writing your module. For example, external state is not preserved. To accommodate  
this, explicitly separate any initialization steps that must occur at runtime from steps that can occur at compile  
time. For this purpose, Julia allows you to define an__init__()function in your module that executes any  
initialization steps that must occur at runtime. This function will not be called during compilation (--output-  
*). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call  
it manually if necessary, but the default is to assume this function deals with computing state for the local  
machine, which does not need to be – or even should not be – captured in the compiled image. It will be  
called after the module is loaded into a process, including if it is being loaded into an incremental compile  
(--output-incremental=yes), but not if it is being loaded into a full-compilation process.

In particular, if you define afunction **init**()in a module, then Julia will call__init__()immediately  
after the module is loaded (e.g., byimport,using, orrequire) at runtime for the first time (i.e.,__init__is  
only called once, and only after all statements in the module have been executed). Because it is called after  
the module is fully imported, any submodules or other imported modules have their__init__functions called  
before the__init__of the enclosing module.

Two typical uses of__init__are calling runtime initialization functions of external C libraries and initializing  
global constants that involve pointers returned by external libraries. For example, suppose that we are calling  
a C librarylibfoothat requires us to call afoo_init()initialization function at runtime. Suppose that we also  
want to define a global constantfoo_data_ptrthat holds the return value of avoid *foo_data()function  
defined bylibfoo– this constant must be initialized at runtime (not at compile time) because the pointer  
address will change from run to run. You could accomplish this by defining the following__init__function in  
your module:

```
const foo_data_ptr= Ref { Ptr {Cvoid}}(0)
function __init__()
ccall ((:foo_init,:libfoo), Cvoid, ())
foo_data_ptr[]= ccall ((:foo_data,:libfoo), Ptr {Cvoid}, ())
```

#### CHAPTER 16. MODULES 187

```
nothing
end
```

Noticethatitisperfectlypossibletodefineaglobalinsideafunctionlike__init__; thisisoneoftheadvantages  
ofusingadynamiclanguage. Butbymakingitaconstantatglobalscope, wecanensurethatthetypeisknown  
to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module  
that depends onfoo_data_ptrwould also have to be initialized in__init__.

Constants involving most Julia objects that are not produced byccalldo not need to be placed in__init__:  
their definitions can be precompiled and loaded from the cached module image. This includes complicated  
heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at  
runtime for precompilation to work (Ptrobjects will turn into null pointers unless they are hidden inside an  
isbitsobject). This includes the return values of the Julia functions@cfunctionandpointer.

Dictionary and set types, or in general anything that depends on the output of ahash(key)method, are a  
trickiercase. Inthecommoncasewherethekeysarenumbers,strings,symbols,ranges,Expr,orcompositions  
of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile. However, for a few other  
key types, such asFunctionorDataTypeand generic user-defined types where you haven't defined ahash  
method, the fallbackhashmethod depends on the memory address of the object (via itsobjectid) and hence  
may change from run to run. If you have one of these key types, or if you aren't sure, to be safe you can  
initialize this dictionary from within your__init__function. Alternatively, you can use theIdDictdictionary  
type, which is specially handled by precompilation so that it is safe to initialize at compile-time.

When using precompilation, it is important to keep a clear sense of the distinction between the compilation  
phaseandtheexecutionphase. Inthismode, itwilloftenbemuchmoreclearlyapparentthatJuliaisacompiler  
which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.

Other known potential failure scenarios include:

1.  Global counters (for example, for attempting to uniquely identify objects). Consider the following code  
    snippet:

```
mutable struct UniquedById
myid:: Int
let counter= 0
UniquedById()= new(counter+= 1)
end
end
```

```
while the intent of this code was to give every instance a unique id, the counter value is recorded at the
end of compilation. All subsequent usages of this incrementally compiled module will start from that
same counter value.
Note thatobjectid(which works by hashing the memory pointer) has similar issues (see notes onDict
usage below).
One alternative is to use a macro to capture@__MODULE__and store it alone with the currentcounter
value, however, it may be better to redesign the code to not depend on this global state.
```

2.  Associative collections (such asDictandSet) need to be re-hashed in__init__. (In the future, a  
    mechanism may be provided to register an initializer function.)
3.  Depending on compile-time side-effects persisting through load-time. Example include: modifying ar-  
    rays or other variables in other Julia modules; maintaining handles to open files or devices; storing  
    pointers to other system resources (including memory);

#### CHAPTER 16. MODULES 188

4.  Creating accidental"copies" of global state from another module, by referencing it directly instead of  
    via its lookup path. For example, (in global scope):

```
#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this
↪→ module =#
# instead use accessor functions:
getstdout()= Base.stdout#= best option =#
# or move the assignment into the runtime:
__init__()= global mystdout= Base.stdout#= also works =#
```

Several additional restrictions are placed on the operations that can be done while precompiling code to help  
the user avoid other wrong-behavior situations:

1.  Callingevalto cause a side-effect in another module. This will also cause a warning to be emitted when  
    the incremental precompile flag is set.
2.  global conststatements from local scope after__init__()has been started (see issue #12010 for  
    plans to add an error for this)
3.  Replacing a module is a runtime error while doing an incremental precompile.

A few other points to be aware of:

1.  No code reload / cache invalidation is performed after changes are made to the source files themselves,  
    (including byPkg.update), and no cleanup is done afterPkg.rm
2.  The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its  
    own copy)
3.  Expectingthefilesystemtobeunchangedbetweencompile-timeandruntimee.g.@**FILE**/source_path()  
    to find resources at runtime, or the BinDeps@checked_libmacro. Sometimes this is unavoidable. How-  
    ever, when possible, it can be good practice to copy resources into the module at compile-time so they  
    won't need to be found at runtime.
4.  WeakRefobjects and finalizers are not currently handled properly by the serializer (this will be fixed in  
    an upcoming release).
5.  It is usually best to avoid capturing references to instances of internal metadata objects such asMethod,  
    MethodInstance,MethodTable,TypeMapLevel,TypeMapEntryand fields of those objects, as this can  
    confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do  
    this, but you simply need to be prepared that the system will try to copy some of these and to create a  
    single unique instance of others.

It is sometimes helpful during module development to turn off incremental precompilation. The command line  
flag--compiled-modules={yes|no}enables you to toggle module precompilation on and off. When Julia is  
started with--compiled-modules=nothe serialized modules in the compile cache are ignored when loading  
modules and module dependencies.Base.compilecachecan still be called manually. The state of this com-  
mandlineflagispassedtoPkg.buildtodisableautomaticprecompilationtriggeringwheninstalling,updating,  
and explicitly building packages.

**Chapter 17**

**Documentation**

Julia enables package developers and users to document functions, types and other objects easily via a built-in  
documentation system.

The basic syntax is simple: any string appearing at the toplevel right before an object (function, macro, type  
or instance) will be interpreted as documenting it (these are called docstrings). Note that no blank lines or  
comments may intervene between a docstring and the documented object. Here is a basic example:

```
"Tell whether there are too foo items in the array."
foo(xs:: Array ) = ...
```

Documentation is interpreted asMarkdown, so you can use indentation and code fences to delimit code ex-  
amples from text. Technically, any object can be associated with any other as metadata; Markdown happens  
to be the default, but one can construct other string macros and pass them to the@docmacro just as well.

```
Note
Markdown support is implemented in theMarkdownstandard library and for a full list of supported
syntax see thedocumentation.
```

Here is a more complex example, still using Markdown:

```
"""
bar(x[, y])
```

```
Compute the Bar index between `x` and `y`.
```

```
If `y` is unspecified, compute the Bar index between all pairs of columns of `x`.
```

````
# Examples
```julia-repl
julia> bar([1, 2], [1, 2])
1
````

"""  
function bar(x, y)...

```
As in the example above, we recommend following some simple conventions when writing documentation:

#### 189


#### CHAPTER 17. DOCUMENTATION 190

1. Always show the signature of a function at the top of the documentation, with a four-space indent so
    that it is printed as Julia code.
    This can be identical to the signature present in the Julia code (likemean(x::AbstractArray)), or a sim-
    plified form. Optional arguments should be represented with their default values (i.e.f(x, y=1)) when
    possible, following the actual Julia syntax. Optional arguments which do not have a default value should
    be put in brackets (i.e.f(x[, y])andf(x[, y[, z]])). An alternative solution is to use several lines:
    one without optional arguments, the other(s) with them. This solution can also be used to document
    several related methods of a given function. When a function accepts many keyword arguments, only
    include a<keyword arguments>placeholder in the signature (i.e.f(x; <keyword arguments>)), and
    give the complete list under an# Argumentssection (see point 4 below).
2. Include a single one-line sentence describing what the function does or what the object represents after
    the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.
    The one-line sentence should use the imperative form ("Do this", "Return that") instead of the third
    person (do not write"Returns the length...") when documenting functions. It should end with a period.
    If the meaning of a function cannot be summarized easily, splitting it into separate composable parts
    could be beneficial (this should not be taken as an absolute requirement for every single case though).
3. Do not repeat yourself.
    Since the function name is given by the signature, there is no need to start the documentation with"The
    functionbar...": go straight to the point. Similarly, if the signature specifies the types of the arguments,
    mentioning them in the description is redundant.
4. Only provide an argument list when really necessary.
    For simple functions, it is often clearer to mention the role of the arguments directly in the description
    of the function's purpose. An argument list would only repeat information already provided elsewhere.
    However, providing an argument list can be a good idea for complex functions with many arguments
    (in particular keyword arguments). In that case, insert it after the general description of the function,
    under an# Argumentsheader, with one-bullet for each argument. The list should mention the types
    and default values (if any) of the arguments:

```

"""  
...

# Arguments

```
- `n::Integer`: the number of elements to compute.
- `dim::Integer=1`: the dimensions along which to perform the computation.
...
"""
5. Provide hints to related functions.
Sometimes there are functions of related functionality. To increase discoverability please provide a short
list of these in aSee alsoparagraph.
See also [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref).
6. Include any code examples in an# Examplessection.
Examples should, whenever possible, be written as doctests. A doctest is a fenced code block (seeCode
blocks) starting with```jldoctestand contains any number ofjulia>prompts together with inputs
and expected outputs that mimic the Julia REPL.

```

Note  
DoctestsareenabledbyDocumenter.jl. FormoredetaileddocumentationseeDocumenter's  
manual.

```

#### CHAPTER 17. DOCUMENTATION 191

```

For example in the following docstring a variableais defined and the expected result, as printed in a  
Julia REPL, appears afterwards:

"""  
Some nice documentation here.

# Examples

```jldoctest
julia> a = [1 2; 3 4]
2×2 Array{Int64,2}:
1 2
3 4
```

"""

Warning  
Callingrandand other RNG-related functions should be avoided in doctests since they will  
not produce consistent outputs during different Julia sessions. If you would like to show some  
random number generation related functionality, one option is to explicitly construct and  
seed your own RNG object (seeRandom) and pass it to the functions you are doctesting.  
Operating system word size (Int32orInt64) as well as path separator differences (/or)  
will also affect the reproducibility of some doctests.  
Note that whitespace in your doctest is significant! The doctest will fail if you misalign the  
output of pretty-printing an array, for example.

You can then runmake -C doc doctest=trueto run all the doctests in the Julia Manual and API docu-  
mentation, which will ensure that your example works.  
To indicate that the output result is truncated, you may write[...]at the line where checking should  
stop. This is useful to hide a stacktrace (which contains non-permanent references to lines of julia code)  
when the doctest shows that an exception is thrown, for example:

```jldoctest
julia> div(1, 0)
ERROR: DivideError: integer division error
[...]
```

Examples that are untestable should be written within fenced code blocks starting with```juliaso that  
they are highlighted correctly in the generated documentation.

Tip  
Wherever possible examples should be self-contained and runnable so that readers are  
able to try them out without having to include any dependencies.

```
7. Use backticks to identify code and equations.
    Julia identifiers and code excerpts should always appear between backticks`to enable highlighting.
    Equations in the LaTeX syntax can be inserted between double backticks``. Use Unicode characters
    rather than their LaTeX escape sequence, i.e.``α = 1``rather than``\\alpha = 1``.
8. Place the starting and ending"""characters on lines by themselves.
    That is, write:


#### CHAPTER 17. DOCUMENTATION 192

```

"""

"""  
f(x, y)= ...

rather than:

"""...

..."""  
f(x, y)= ...

This makes it clearer where docstrings start and end.

```
9. Respect the line length limit used in the surrounding code.
    Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is
    recommended that lines are at most 92 characters wide.
10. Provide information allowing custom types to implement the function in an# Implementationsection.
These implementation details are intended for developers rather than users, explaining e.g. which func-
tions should be overridden and which functions automatically use appropriate fallbacks. Such details
are best kept separate from the main description of the function's behavior.
11. For long docstrings, consider splitting the documentation with an# Extended helpheader. The typical
help-mode will show only the material above the header; you can access the full help by adding a'?' at
the beginning of the expression (i.e.,"??foo" rather than"?foo").

### 17.1 Accessing Documentation.

Documentation can be accessed at the REPL or inIJulia by typing?followed by the name of a function or
macro, and pressingEnter. For example,

```

?cos  
?@time  
?r""

```
will show documentation for the relevant function, macro or string macro respectively. InJuno usingCtrl-J,
Ctrl-Dwill show the documentation for the object under the cursor.

### 17.2 Functions & Methods

Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic
functionstohaveasinglepurpose, Juliaallowsmethodstobedocumentedindividuallyifnecessary. Ingeneral,
onlythemostgenericmethodshouldbedocumented,oreventhefunctionitself(i.e. theobjectcreatedwithout
any methods byfunction bar end). Specific methods should only be documented if their behaviour differs
from the more generic ones. In any case, they should not repeat the information provided elsewhere. For
example:

```

"""  
*(x, y, z...)

```

#### CHAPTER 17. DOCUMENTATION 193

```

Multiplication operator. `x * y * z *...` calls this function with multiple  
arguments, i.e. `*(x, y, z...)`.  
"""  
function *(x, y, z...)

# ... [implementation sold separately] ...

end

"""  
*(x::AbstractString, y::AbstractString, z::AbstractString...)

When applied to strings, concatenates them.  
"""  
function *(x:: AbstractString , y :: AbstractString , z :: AbstractString ...)

# ... [insert secret sauce here] ...

end

help?> *  
search: * .*

*(x, y, z...)

Multiplication operator. x * y * z *...calls this function with multiple  
arguments, i.e. *(x,y,z...).

*(x:: AbstractString , y :: AbstractString , z :: AbstractString ...)

When applied to strings, concatenates them.

```
When retrieving documentation for a generic function, the metadata for each method is concatenated with the
catdocfunction, which can of course be overridden for custom types.

### 17.3 Advanced Usage.

The@docmacro associates its first argument with its second in a per-module dictionary calledMETA.

To make it easier to write documentation, the parser treats the macro name@docspecially: if a call to@doc
has one argument, but another expression appears after a single line break, then that additional expression is
added as an argument to the macro. Therefore the following syntax is parsed as a 2-argument call to@doc:

```

@docraw"""  
...  
"""  
f(x)= x

```
This makes it possible to use expressions other than normal string literals (such as theraw""string macro) as
a docstring.

When used for retrieving documentation, the@docmacro (or equally, thedocfunction) will search allMETA
dictionaries for metadata relevant to the given object and return it. The returned object (some Markdown
content, for example) will by default display itself intelligently. This design also makes it easy to use the doc
system in a programmatic way; for example, to re-use documentation between different versions of a function:

```

@doc"..."foo!  
@doc(@docfoo!) foo

```

#### CHAPTER 17. DOCUMENTATION 194

Or for use with Julia's metaprogramming functionality:

```

for (f, op) in ((:add,:+), ( :subtract,:-), ( :multiply,:*), ( :divide,:/))  
@eval begin  
$f(a,b)= $op(a,b)  
end  
end  
@doc"`add(a,b)` adds `a` and `b` together"add  
@doc"`subtract(a,b)` subtracts `b` from `a`"subtract

```
Documentation written in non-toplevel blocks, such asbegin,if,for, andlet, is added to the documentation
system as blocks are evaluated. For example:

```

if condition()  
"..."  
f(x)= x  
end

```
will add documentation tof(x)whencondition()istrue. Note that even iff(x)goes out of scope at the
end of the block, its documentation will remain.

It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-
interpolation within the docstring you will need to use an extra$as shown with$($name):

```

for func in (:day,:dayofmonth)  
name= string(func)  
@eval begin  
@doc"""  
$ ($name)(dt::TimeType) -> Int64

The day of month of a `Date` or `DateTime` as an `Int64`.  
""" $func(dt::Dates.TimeType)  
end  
end

```
### Dynamic documentation

Sometimes the appropriate documentation for an instance of a type depends on the field values of that in-
stance, rather than just on the type itself. In these cases, you can add a method toDocs.getdocfor your
custom type that returns the documentation on a per-instance basis. For instance,

```

struct MyType  
value:: Int  
end

Docs.getdoc(t::MyType)= "Documentation for MyType with value $ (t.value)"

x = MyType(1)  
y = MyType(2)

```
?xwill display"Documentation for MyType with value 1" while?ywill display"Documentation for MyType with
value 2".


#### CHAPTER 17. DOCUMENTATION 195

### 17.4 Syntax Guide

This guide provides a comprehensive overview of how to attach documentation to all Julia syntax constructs
for which providing documentation is possible.

In the following examples"..."is used to illustrate an arbitrary docstring.

### $and\characters

The$and\characters are still parsed as string interpolation or start of an escape sequence in docstrings too.
Theraw""string macro together with the@docmacro can be used to avoid having to escape them. This is
handy when the docstrings include LaTeX or Julia source code examples containing interpolation:

```

@docraw"""

```math
\LaTeX
```

"""  
function f end

```
### Functions and Methods

```

"..."  
function f end

"..."  
f

```
Adds docstring"..."to the functionf. The first version is the preferred syntax, however both are equivalent.

```

"..."  
f(x)= x

"..."  
function f(x)  
x  
end

"..."  
f(x)

```
Adds docstring"..."to the methodf(::Any).

```

"..."  
f(x, y= 1) = x + y

```
Adds docstring"..."to twoMethods, namelyf(::Any)andf(::Any, ::Any).


#### CHAPTER 17. DOCUMENTATION 196

### Macros

```

"..."  
macro m(x) end

```
Adds docstring"..."to the@m(::Any)macro definition.

```

"..."  
:(@m)

```
Adds docstring"..."to the macro named@m.

### Types

```

"..."  
abstract type T1 end

"..."  
mutable struct T2  
...  
end

"..."  
struct T3  
...  
end

```
Adds the docstring"..."to typesT1,T2, andT3.

```

"..."  
struct T  
"x"  
x  
"y"  
y  
end

```
Adds docstring"..."to typeT,"x"to fieldT.xand"y"to fieldT.y. Also applicable tomutable structtypes.

### Modules

```

"..."  
module M end

module M

"..."  
M

end

```
Adds docstring"..."to theModule M. Adding the docstring above theModuleis the preferred syntax, however
both are equivalent.


#### CHAPTER 17. DOCUMENTATION 197

```

"..."  
baremodule M

# ...

end

baremodule M

import Base: @doc

"..."  
f(x)= x

end

```
Documenting abaremoduleby placing a docstring above the expression automatically imports@docinto the
module. These imports must be done manually when the module expression is not documented.

### Global Variables

```

"..."  
const a = 1

"..."  
b = 2

"..."  
global c = 3

```
Adds docstring"..."to theBindingsa,b, andc.

Bindings are used to store a reference to a particularSymbolin aModulewithout storing the referenced value
itself.

```

Note  
When aconstdefinition is only used to define an alias of another definition, such as is the case  
with the functiondivand its alias÷inBase, do not document the alias and instead document the  
actual function.  
If the alias is documented and not the real definition then the docsystem (?mode) will not return  
the docstring attached to the alias when the real definition is searched for.  
For example you should write

"..."  
f(x)= x + 1  
const alias= f

rather than

f(x)= x + 1  
"..."  
const alias= f

"..."  
sym

```

#### CHAPTER 17. DOCUMENTATION 198

Adds docstring"..."to the value associated withsym. However, it is preferred thatsymis documented where
it is defined.

### Multiple Objects

```

"..."  
a, b

```
Adds docstring"..."toaandbeach of which should be a documentable expression. This syntax is equivalent
to

```

"..."  
a

"..."  
b

```
Any number of expressions many be documented together in this way. This syntax can be useful when two
functions are related, such as non-mutating and mutating versionsfandf!.

### Macro-generated code

```

"..."  
@m expression

```
Adds docstring"..."to the expression generated by expanding@m expression. This allows for expressions
decorated with@inline,@noinline,@generated, or any other macro to be documented in the same way as
undecorated expressions.

Macro authors should take note that only macros that generate a single expression will automatically support
docstrings. If a macro returns a block containing multiple subexpressions then the subexpression that should
be documented must be marked using the@__doc__macro.

The@enummacromakesuseof@__doc__toallowfordocumentingEnums. Examiningitsdefinitionshouldserve
as an example of how to use@__doc__correctly.

Core.@__doc__– Macro.

```

@**doc**(ex)

Low-level macro used to mark expressions returned by a macro that should be documented. If more than  
one expression is marked then the same docstring is applied to each expression.  
macro example(f)  
quote  
$(f)() = 0  
@**doc** $(f)(x) = 1  
$(f)(x, y) = 2  
end |> esc  
end

@__doc__has no effect when a macro that uses it is not documented.  
source

```

**Chapter 18**

**Metaprogramming**

The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents
its own code as a data structure of the language itself. Since code is represented by objects that can be
created and manipulated from within the language, it is possible for a program to transform and generate its
own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style
macros operating at the level ofabstract syntax trees. In contrast, preprocessor"macro " systems, like that of
C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs.
BecausealldatatypesandcodeinJuliaarerepresentedbyJuliadatastructures, powerfulreflectioncapabilities
are available to explore the internals of a program and its types just like any other data.

### 18.1 Program representation

Every Julia program starts life as a string:

```

julia> prog= "1 + 1"  
"1 + 1"

```
**What happens next?**

The next step is toparse each string into an object called an expression, represented by the Julia typeExpr:

```

julia> ex1 = Meta.parse(prog)  
:(1 + 1)

julia> typeof(ex1)  
Expr

```
Exprobjects contain two parts:

- aSymbolidentifying the kind of expression. A symbol is aninterned stringidentifier (more discussion
    below).

```

julia> ex1.head  
:call

```
- the expression arguments, which may be symbols, other expressions, or literal values:

#### 199


#### CHAPTER 18. METAPROGRAMMING 200

```

julia> ex1.args  
3-element Vector{Any}:  
:+  
1  
1

```
Expressions may also be constructed directly inprefix notation:

```

julia> ex2 = Expr (:call,:+, 1, 1)  
:(1 + 1)

```
The two expressions constructed above – by parsing and by direct construction – are equivalent:

```

julia> ex1 == ex2  
true

```
**The key point here is that Julia code is internally represented as a data structure that is accessible
from the language itself.**

Thedumpfunction provides indented and annotated display ofExprobjects:

```

julia> dump(ex2)  
Expr  
head: Symbol call  
args: Array{Any}((3,))  
1: Symbol +  
2: Int64 1  
3: Int64 1

```
Exprobjects may also be nested:

```

julia> ex3 = Meta.parse("(4 + 4) / 2")  
:((4 + 4) / 2)

```
Another way to view expressions is withMeta.show_sexpr, which displays theS-expressionform of a given
Expr, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested
Expr:

```

julia> Meta.show_sexpr(ex3)  
(:call, :/, (:call, :+, 4, 4), 2)

```
### Symbols

The:character has two syntactic purposes in Julia. The first form creates aSymbol, an interned stringused
as one building-block of expressions:

```

julia> s = :foo  
:foo

julia> typeof(s)  
Symbol

```

#### CHAPTER 18. METAPROGRAMMING 201

TheSymbolconstructor takes any number of arguments and creates a new symbol by concatenating their
string representations together:

```

julia> :foo == Symbol ("foo")  
true

julia>Symbol ("func",10)  
:func10

julia>Symbol (:var,'_',"sym")  
:var_sym

```
Notethattouse:syntax,thesymbol'snamemustbeavalididentifier. OtherwisetheSymbol(str)constructor
must be used.

In the context of an expression, symbols are used to indicate access to variables; when an expression is
evaluated, a symbol is replaced with the value bound to that symbol in the appropriatescope.

Sometimes extra parentheses around the argument to:are needed to avoid ambiguity in parsing:

```

julia> :(:)  
:(:)

julia> :(::)  
:(::)

```
### 18.2 Expressions and evaluation

### Quoting

The second syntactic purpose of the:character is to create expression objects without using the explicitExpr
constructor. This is referred to as quoting. The:character, followed by paired parentheses around a single
statement of Julia code, produces anExprobject based on the enclosed code. Here is an example of the short
form used to quote an arithmetic expression:

```

julia> ex = :(a+b*c+1)  
:(a + b * c + 1)

julia> typeof(ex)  
Expr

```
(to view the structure of this expression, tryex.headandex.args, or usedumpas above orMeta.@dump)

Note that equivalent expressions may be constructed usingMeta.parseor the directExprform:

```

julia> :(a + b_c + 1) ==  
Meta.parse("a + b_c + 1") ==  
Expr (:call,:+, :a, Expr (:call,:*, :b, :c), 1)  
true

```
Expressions provided by the parser generally only have symbols, other expressions, and literal values as their
args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as


#### CHAPTER 18. METAPROGRAMMING 202

args. In this specific example,+andaare symbols,*(b,c)is a subexpression, and 1 is a literal 64-bit signed
integer.

There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed inquote ...
end.

```

julia> ex = quote  
x = 1  
y = 2  
x + y  
end  
quote  
#= none:2 =#  
x = 1  
#= none:3 =#  
y = 2  
#= none:4 =#  
x + y  
end

julia> typeof(ex)  
Expr

```
### Interpolation

Direct construction ofExprobjects with value arguments is powerful, butExprconstructors can be tedious
compared to"normal" Julia syntax. As an alternative, Julia allows interpolation of literals or expressions into
quoted expressions. Interpolation is indicated by a prefix$.

In this example, the value of variableais interpolated:

```

julia> a = 1;

julia> ex = :($a + b)  
:(1 + b)

```
Interpolating into an unquoted expression is not supported and will cause a compile-time error:

```

julia> $a + b  
ERROR: syntax: "$" expression outside quote

```
In this example, the tuple(1,2,3)is interpolated as an expression into a conditional test:

```

julia> ex = :(a in $:((1,2,3)) )  
:(a in (1, 2, 3))

```
The use of$for expression interpolation is intentionally reminiscent ofstring interpolationand command
interpolation. Expression interpolation allows convenient, readable programmatic construction of complex
Julia expressions.


#### CHAPTER 18. METAPROGRAMMING 203

### Splatting interpolation

Notice that the$interpolation syntax allows inserting only a single expression into an enclosing expression.
Occasionally, you have an array of expressions and need them all to become arguments of the surrounding
expression. This can be done with the syntax$(xs...). For example, the following code generates a function
call where the number of arguments is determined programmatically:

```

julia> args= [:x, :y, :z];

julia> :(f(1, $(args...)))  
:(f(1, x, y, z))

```
### Nested quote

Naturally, it is possible for quote expressions to contain other quote expressions. Understanding how interpo-
lation works in these cases can be a bit tricky. Consider this example:

```

julia> x = :(1 + 2);

julia> e = quotequote $x end end  
quote  
#= none:1 =#  
$(Expr(:quote, quote  
#= none:1 =#  
$(Expr(:$, :x))  
end))  
end

```
Notice that the result contains$x, which means thatxhas not been evaluated yet. In other words, the$
expression"belongs to" the inner quote expression, and so its argument is only evaluated when the inner
quote expression is:

```

julia> eval(e)  
quote  
#= none:1 =#  
1 + 2  
end

```
However, the outerquoteexpression is able to interpolate values inside the$in the inner quote. This is done
with multiple$s:

```

julia> e = quotequote $$x end end  
quote  
#= none:1 =#  
$(Expr(:quote, quote  
#= none:1 =#  
$(Expr(:$, :(1 + 2)))  
end))  
end

```
Notice that(1 + 2)now appears in the result instead of the symbolx. Evaluating this expression yields an
interpolated 3 :


#### CHAPTER 18. METAPROGRAMMING 204

```

julia> eval(e)  
quote  
#= none:1 =#  
3  
end

```
The intuition behind this behavior is thatxis evaluated once for each$: one$works similarly toeval(:x),
givingx's value, while two$s do the equivalent ofeval(eval(:x)).

### QuoteNode

The usual representation of aquoteform in an AST is anExprwith head:quote:

```

julia> dump(Meta.parse(":(1+2)"))  
Expr  
head: Symbol quote  
args: Array{Any}((1,))  
1: Expr  
head: Symbol call  
args: Array{Any}((3,))  
1: Symbol +  
2: Int64 1  
3: Int64 2

```
As we have seen, such expressions support interpolation with$. However, in some situations it is necessary to
quote code without performing interpolation. This kind of quoting does not yet have syntax, but is represented
internally as an object of typeQuoteNode:

```

julia> eval(Meta.quot( Expr (:$, :(1+2))))  
3

julia> eval( QuoteNode ( Expr (:$, :(1+2))))  
:($(Expr(:$, :(1 + 2))))

```
The parser yieldsQuoteNodes for simple quoted items like symbols:

```

julia> dump(Meta.parse(":x"))  
QuoteNode  
value: Symbol x

```
QuoteNodecan also be used for certain advanced metaprogramming tasks.

### Evaluating expressions

Given an expression object, one can cause Julia to evaluate (execute) it at global scope usingeval:

```

julia> ex1 = :(1 + 2)  
:(1 + 2)

julia> eval(ex1)  
3

```

#### CHAPTER 18. METAPROGRAMMING 205

```

julia> ex = :(a + b)  
:(a + b)

julia> eval(ex)  
ERROR: UndefVarError: b not defined  
[...]

julia> a = 1; b = 2;

julia> eval(ex)  
3

```
Every modulehas its ownevalfunction that evaluates expressions in its global scope. Expressions passed to
evalare not limited to returning values – they can also have side-effects that alter the state of the enclosing
module's environment:

```

julia> ex = :(x = 1)  
:(x = 1)

julia> x  
ERROR: UndefVarError: x not defined

julia> eval(ex)  
1

julia> x  
1

```
Here, the evaluation of an expression object causes a value to be assigned to the global variablex.

Since expressions are justExprobjects which can be constructed programmatically and then evaluated, it is
possible to dynamically generate arbitrary code which can then be run usingeval. Here is a simple example:

```

julia> a = 1;

julia> ex = Expr (:call,:+, a,:b)  
:(1 + b)

julia> a = 0; b = 2;

julia> eval(ex)  
3

```
Thevalueofaisusedtoconstructtheexpressionexwhichappliesthe+functiontothevalue1andthevariable
b. Note the important distinction between the wayaandbare used:

- The value of the variableaat expression construction time is used as an immediate value in the ex-
    pression. Thus, the value ofawhen the expression is evaluated no longer matters: the value in the
    expression is already 1 , independent of whatever the value ofamight be.
- On the other hand, the symbol:bis used in the expression construction, so the value of the variableb
    at that time is irrelevant –:bis just a symbol and the variablebneed not even be defined. At expression
    evaluation time, however, the value of the symbol:bis resolved by looking up the value of the variable
    b.


#### CHAPTER 18. METAPROGRAMMING 206

### Functions onExpressions

As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code
within Julia itself. We have already seen one example of a function returningExprobjects: theparsefunction,
which takes a string of Julia code and returns the correspondingExpr. A function can also take one or more
Exprobjects as arguments, and return anotherExpr. Here is a simple, motivating example:

```

julia>function math_expr(op, op1, op2)  
expr= Expr (:call, op, op1, op2)  
return expr  
end  
math_expr (generic function with 1 method)

julia> ex = math_expr(:+, 1, Expr (:call,:*, 4, 5))  
:(1 + 4 * 5)

julia> eval(ex)  
21

```
As another example, here is a function that doubles any numeric argument, but leaves expressions alone:

```

julia>function make_expr2(op, opr1, opr2)  
opr1f, opr2f= map(x-> isa(x, Number )? 2*x : x, (opr1, opr2))  
retexpr= Expr (:call, op, opr1f, opr2f)  
return retexpr  
end  
make_expr2 (generic function with 1 method)

julia> make_expr2(:+, 1, 2)  
:(2 + 4)

julia> ex = make_expr2(:+, 1, Expr (:call,:*, 5, 8))  
:(2 + 5 * 8)

julia> eval(ex)  
42

```
### 18.3 Macros.

Macros provide a mechanism to include generated code in the final body of a program. A macro maps a tuple
of arguments to a returned expression, and the resulting expression is compiled directly rather than requiring
a runtimeevalcall. Macro arguments may include expressions, literal values, and symbols.

### Basics

Here is an extraordinarily simple macro:

```

julia>macro sayhello()  
return :( println("Hello, world!") )  
end  
@sayhello (macro with 1 method)

```
Macros have a dedicated character in Julia's syntax: the@(at-sign), followed by the unique name declared in
amacro NAME ... endblock. In this example, the compiler will replace all instances of@sayhellowith:


#### CHAPTER 18. METAPROGRAMMING 207

```

:( println("Hello, world!") )

```
When@sayhellois entered in the REPL, the expression executes immediately, thus we only see the evaluation
result:

```

julia> @sayhello()  
Hello, world!

```
Now, consider a slightly more complex macro:

```

julia>macro sayhello(name)  
return :( println("Hello, ", $name) )  
end  
@sayhello (macro with 1 method)

```
This macro takes one argument:name. When@sayhellois encountered, the quoted expression is expanded
to interpolate the value of the argument into the final expression:

```

julia> @sayhello("human")  
Hello, human

```
We can view the quoted return expression using the functionmacroexpand( **important note:** this is an ex-
tremely useful tool for debugging macros):

```

julia> ex = macroexpand(Main,:(@sayhello("human")) )  
:(Main.println("Hello, ", "human"))

julia> typeof(ex)  
Expr

```
We can see that the"human"literal has been interpolated into the expression.

There also exists a macro@macroexpandthat is perhaps a bit more convenient than themacroexpandfunction:

```

julia> @macroexpand@sayhello"human"  
:(println("Hello, ", "human"))

```
### Hold up: why macros?

We have already seen a functionf(::Expr...) -> Exprin a previous section. In fact,macroexpandis also
such a function. So, why do macros exist?

Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to
generate and include fragments of customized code before the full program is run. To illustrate the difference,
consider the following example:

```

julia>macro twostep(arg)  
println("I execute at parse time. The argument is: ", arg)  
return :(println("I execute at runtime. The argument is: ", $arg))  
end  
@twostep (macro with 1 method)

julia> ex = macroexpand(Main,:(@twostep:(1, 2, 3)) );  
I execute at parse time. The argument is: :((1, 2, 3))

```

#### CHAPTER 18. METAPROGRAMMING 208

The first call toprintlnis executed whenmacroexpandis called. The resulting expression contains only the
secondprintln:

```

julia> typeof(ex)  
Expr

julia> ex  
:(println("I execute at runtime. The argument is: ", $(Expr(:copyast, :($(QuoteNode(:((1, 2,  
↪→ 3)))))))))

julia> eval(ex)  
I execute at runtime. The argument is: (1, 2, 3)

```
### Macro invocation

Macros are invoked with the following general syntax:

```

@nameexpr1 expr2...  
@name(expr1, expr2,...)

```
Note the distinguishing@before the macro name and the lack of commas between the argument expressions
in the first form, and the lack of whitespace after@namein the second form. The two styles should not be
mixed. For example, the following syntax is different from the examples above; it passes the tuple(expr1,
expr2, ...)as one argument to the macro:

```

@name(expr1, expr2,...)

```
An alternative way to invoke a macro over an array literal (or comprehension) is to juxtapose both without
using parentheses. In this case, the array will be the only expression fed to the macro. The following syntax is
equivalent (and different from@name [a b] * v):

```

@name[a b]* v  
@name([a b])* v

```
It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way
to explore macro arguments is to call theshowfunction within the macro body:

```

julia>macro showarg(x)  
show(x)

# ... remainder of macro, returning an expression

end  
@showarg (macro with 1 method)

julia> @showarg(a)  
:a

julia> @showarg(1+1)  
:(1 + 1)

julia> @showarg(println("Yo!"))  
:(println("Yo!"))

```

#### CHAPTER 18. METAPROGRAMMING 209

Inadditiontothegivenargumentlist,everymacroispassedextraargumentsnamed__source__and__module__.

The argument__source__provides information (in the form of aLineNumberNodeobject) about the parser
location of the@sign from the macro invocation. This allows macros to include better error diagnostic informa-
tion, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement
the@__LINE__,@__FILE__, and@__DIR__macros.

The location information can be accessed by referencing__source__.lineand__source__.file:

```

julia>macro **LOCATION**(); returnQuoteNode (**source**); end  
@**LOCATION** (macro with 1 method)

julia> dump(  
@**LOCATION**(  
))  
LineNumberNode  
line: Int64 2  
file: Symbol none

```
The argument__module__provides information (in the form of aModuleobject) about the expansion context
of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to
insert the value as an extra argument to a runtime function call doing self-reflection in the current module.

### Building an advanced macro

Here is a simplified definition of Julia's@assertmacro:

```

julia>macro assert(ex)  
return :( $ex? nothing: throw( AssertionError ($(string(ex)))) )  
end  
@assert (macro with 1 method)

```
This macro can be used like this:

```

julia> @assert1 == 1.0

julia> @assert1 == 0  
ERROR: AssertionError: 1 == 0

```
In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent
to writing:

```

1 == 1.0? nothing: throw( AssertionError ("1 == 1.0"))  
1 == 0? nothing: throw( AssertionError ("1 == 0"))

```
That is, in the first call, the expression:(1 == 1.0)is spliced into the test condition slot, while the value of
string(:(1 == 1.0))is spliced into the assertion message slot. The entire expression, thus constructed, is
placed into the syntax tree where the@assertmacro call occurs. Then at execution time, if the test expression
evaluatestotrue,thennothingisreturned,whereasifthetestisfalse,anerrorisraisedindicatingtheasserted
expression that was false. Notice that it would not be possible to write this as a function, since only the value
of the condition is available and it would be impossible to display the expression that computed it in the error
message.


#### CHAPTER 18. METAPROGRAMMING 210

The actual definition of@assertin Julia Base is more complicated. It allows the user to optionally specify their
own error message, instead of just printing the failed expression. Just like in functions with a variable number
of arguments (Varargs Functions), this is specified with an ellipses following the last argument:

```

julia>macro assert(ex, msgs...)  
msg_body= isempty(msgs)? ex : msgs[1]  
msg = string(msg_body)  
return :($ex? nothing: throw( AssertionError ($msg)))  
end  
@assert (macro with 1 method)

```
Now@asserthas two modes of operation, depending upon the number of arguments it receives! If there's
only one argument, the tuple of expressions captured bymsgswill be empty and it will behave the same as
the simpler definition above. But now if the user specifies a second argument, it is printed in the message
body instead of the failing expression. You can inspect the result of a macro expansion with the aptly named
@macroexpandmacro:

```

julia> @macroexpand@asserta == b  
:(if Main.a == Main.b  
Main.nothing  
else  
Main.throw(Main.AssertionError("a == b"))  
end)

julia> @macroexpand@asserta==b "a should equal b!"  
:(if Main.a == Main.b  
Main.nothing  
else  
Main.throw(Main.AssertionError("a should equal b!"))  
end)

```
There is yet another case that the actual@assertmacro handles: what if, in addition to printing"a should
equal b," we wanted to print their values? One might naively try to use string interpolation in the custom
message, e.g.,@assert a==b "a ($a) should equal b ($b)!", but this won't work as expected with the
above macro. Can you see why? Recall fromstring interpolationthat an interpolated string is rewritten to a
call tostring. Compare:

```

julia> typeof(:("a should equal b"))  
String

julia> typeof(:("a ( $a ) should equal b ( $b )!"))  
Expr

julia> dump(:("a ( $a ) should equal b ( $b )!"))  
Expr  
head: Symbol string  
args: Array{Any}((5,))  
1: String "a ("  
2: Symbol a  
3: String ") should equal b ("  
4: Symbol b  
5: String ")!"

```

#### CHAPTER 18. METAPROGRAMMING 211

So now instead of getting a plain string inmsg_body, the macro is receiving a full expression that will need to
be evaluated in order to display as expected. This can be spliced directly into the returned expression as an
argument to thestringcall; seeerror.jlfor the complete implementation.

The@assertmacro makes great use of splicing into quoted expressions to simplify the manipulation of ex-
pressions inside the macro body.

### Hygiene

Anissuethatarisesinmorecomplexmacrosisthatofhygiene. Inshort, macrosmustensurethatthevariables
they introduce in their returned expressions do not accidentally clash with existing variables in the surround-
ing code they expand into. Conversely, the expressions that are passed into a macro as arguments are often
expected to evaluate in the context of the surrounding code, interacting with and modifying the existing vari-
ables. Another concern arises from the fact that a macro may be called in a different module from where it
was defined. In this case we need to ensure that all global variables are resolved to the correct module. Julia
already has a major advantage over languages with textual macro expansion (like C) in that it only needs to
consider the returned expression. All the other variables (such asmsgin@assertabove) follow thenormal
scoping block behavior.

To demonstrate these issues, let us consider writing a@timemacro that takes an expression as its argument,
records the time, evaluates the expression, records the time again, prints the difference between the before
and after times, and then has the value of the expression as its final value. The macro might look like this:

```

macro time(ex)  
returnquote  
local t0 = time_ns()  
local val = $ex  
local t1 = time_ns()  
println("elapsed time: ", (t1-t0)/1e9, " seconds")  
val  
end  
end

```
Here, we wantt0,t1, andvalto be private temporary variables, and we wanttime_nsto refer to thetime_ns
function in Julia Base, not to anytime_nsvariable the user might have (the same applies toprintln). Imagine
the problems that could occur if the user expressionexalso contained assignments to a variable calledt0, or
defined its owntime_nsvariable. We might get errors, or mysteriously incorrect behavior.

Julia's macro expander solves these problems in the following way. First, variables within a macro result are
classified as either local or global. A variable is considered local if it is assigned to (and not declared global),
declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are
then renamed to be unique (using thegensymfunction, which generates new symbols), and global variables
are resolved within the macro definition environment. Therefore both of the above concerns are handled; the
macro 's locals will not conflict with any user variables, andtime_nsandprintlnwill refer to the Julia Base
definitions.

One problem remains however. Consider the following use of this macro:

```

module MyModule  
import Base.@time

time_ns()= ... # compute something

@timetime_ns()  
end

```

#### CHAPTER 18. METAPROGRAMMING 212

Here the user expressionexis a call totime_ns, but not the sametime_nsfunction that the macro uses. It
clearly refers toMyModule.time_ns. Therefore we must arrange for the code inexto be resolved in the macro
call environment. This is done by"escaping" the expression withesc:

```

macro time(ex)  
...  
local val = $(esc(ex))  
...  
end

```
An expression wrapped in this manner is left alone by the macro expander and simply pasted into the output
verbatim. Therefore it will be resolved in the macro call environment.

Thisescapingmechanismcanbeusedto"violate"hygienewhennecessary,inordertointroduceormanipulate
user variables. For example, the following macro setsxto zero in the call environment:

```

julia>macro zerox()  
return esc(:(x = 0))  
end  
@zerox (macro with 1 method)

julia>function foo()  
x = 1  
@zerox  
return x # is zero  
end  
foo (generic function with 1 method)

julia> foo()  
0

```
This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.

Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to
consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as
possible to runtime. For example, many macros simply wrap their arguments in aQuoteNodeor other similar
Expr. Some examples of this include@task bodywhich simply returnsschedule(Task(() -> $body)), and
@eval expr, which simply returnseval(QuoteNode(expr)).

To demonstrate, we might rewrite the@timeexample above as:

```

macro time(expr)  
return :(timeit(()-> $(esc(expr))))  
end  
function timeit(f)  
t0 = time_ns()  
val = f()  
t1 = time_ns()  
println("elapsed time: ", (t1-t0)/1e9, " seconds")  
return val  
end

```
However, wedon'tdothisforagoodreason: wrappingtheexprinanewscopeblock(theanonymousfunction)
also slightly changes the meaning of the expression (the scope of any variables in it), while we want@timeto
be usable with minimum impact on the wrapped code.


#### CHAPTER 18. METAPROGRAMMING 213

### Macros and dispatch

Macros, justlikeJuliafunctions, aregeneric. Thismeanstheycanalsohavemultiplemethoddefinitions, thanks
to multiple dispatch:

```

julia>macro m end  
@m (macro with 0 methods)

julia>macro m(args...)  
println(" $ (length(args))arguments")  
end  
@m (macro with 1 method)

julia>macro m(x,y)  
println("Two arguments")  
end  
@m (macro with 2 methods)

julia> @m "asd"  
1 arguments

julia> @m 1 2  
Two arguments

```
However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the
macro, not the types that the AST evaluates to at runtime:

```

julia>macro m(:: Int )  
println("An Integer")  
end  
@m (macro with 3 methods)

julia> @m 2  
An Integer

julia> x = 2  
2

julia> @m x  
1 arguments

```
### 18.4 Code Generation.

When a significant amount of repetitive boilerplate code is required, it is common to generate it programmat-
ically to avoid redundancy. In most languages, this requires an extra build step, and a separate program to
generate the repetitive code. In Julia, expression interpolation andevalallow such code generation to take
place in the normal course of program execution. For example, consider the following custom type

```

struct MyNumber  
x:: Float64  
end

# output

```
for which we want to add a number of methods to. We can do this programmatically in the following loop:


#### CHAPTER 18. METAPROGRAMMING 214

```

for op = (:sin,:cos,:tan,:log,:exp)  
eval( quote  
Base.$op(a::MyNumber)= MyNumber($op(a.x))  
end )  
end

# output

```
and we can now use those functions with our custom type:

```

julia> x = MyNumber(π)  
MyNumber(3.141592653589793)

julia> sin(x)  
MyNumber(1.2246467991473532e-16)

julia> cos(x)  
MyNumber(-1.0)

```
In this manner, Julia acts as its ownpreprocessor, and allows code generation from inside the language. The
above code could be written slightly more tersely using the:prefix quoting form:

```

for op = (:sin,:cos,:tan,:log,:exp)  
eval(:(Base.$op(a::MyNumber)= MyNumber($op(a.x))))  
end

```
This sort of in-language code generation, however, using theeval(quote(...))pattern, is common enough
that Julia comes with a macro to abbreviate this pattern:

```

for op = (:sin,:cos,:tan,:log,:exp)  
@evalBase.$op(a::MyNumber)= MyNumber($op(a.x))  
end

```
The@evalmacro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks
of generated code, the expression argument given to@evalcan be a block:

```

@eval begin

# multiple lines

end

```
### 18.5 Non-Standard String Literals.

Recall fromStringsthat string literals prefixed by an identifier are called non-standard string literals, and can
have different semantics than un-prefixed string literals. For example:

- r"^\s*(?:#|$)"produces aregular expression objectrather than a string
- b"DATA\xff\u2200"is a byte array literalfor[68,65,84,65,255,226,136,128].

Perhaps surprisingly, these behaviors are not hard-coded into the Julia parser or compiler. Instead, they are
custom behaviors provided by a general mechanism that anyone can use: prefixed string literals are parsed
as calls to specially-named macros. For example, the regular expression macro is just the following:


#### CHAPTER 18. METAPROGRAMMING 215

```

macro r_str(p)  
Regex (p)  
end

```
That's all. This macro says that the literal contents of the string literalr"^\s*(?:#|$)"should be passed to
the@r_strmacro and the result of that expansion should be placed in the syntax tree where the string literal
occurs. In other words, the expressionr"^\s*(?:#|$)"is equivalent to placing the following object directly
into the syntax tree:

```

Regex ("^ \ s*(?:#| $ )")

```
Not only is the string literal form shorter and far more convenient, but it is also more efficient: since the regular
expression is compiled and theRegexobject is actually created when the code is compiled, the compilation
occurs only once, rather than every time the code is executed. Consider if the regular expression occurs in a
loop:

```

for line= lines  
m = match(r"^\s*(?:#|$)", line)  
if m === nothing

# non-comment

else

# comment

end  
end

```
Since the regular expressionr"^\s*(?:#|$)"is compiled and inserted into the syntax tree when this code is
parsed, the expression is only compiled once instead of each time the loop is executed. In order to accomplish
this without macros, one would have to write this loop like this:

```

re = Regex ("^ \ s*(?:#| $ )")  
for line= lines  
m = match(re, line)  
if m === nothing

# non-comment

else

# comment

end  
end

```
Moreover, if the compiler could not determine that the regex object was constant over all loops, certain opti-
mizations might not be possible, making this version still less efficient than the more convenient literal form
above. Of course, there are still situations where the non-literal form is more convenient: if one needs to
interpolate a variable into the regular expression, one must take this more verbose approach; in cases where
the regular expression pattern itself is dynamic, potentially changing upon each loop iteration, a new regular
expression object must be constructed on each iteration. In the vast majority of use cases, however, regular
expressions are not constructed based on run-time data. In this majority of cases, the ability to write regular
expressions as compile-time values is invaluable.

The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard
literalsimplementedusingit,butthecommandliteralsyntax(`echo "Hello, $person"`)isalsoimplemented
using the following innocuous-looking macro:


#### CHAPTER 18. METAPROGRAMMING 216

```

macro cmd(str)  
:(cmd_gen($(shell_parse(str)[1])))  
end

```
Of course, a large amount of complexity is hidden in the functions used in this macro definition, but they are
just functions, written entirely in Julia. You can read their source and see precisely what they do – and all they
do is construct expression objects to be inserted into your program's syntax tree.

Like string literals, command literals can also be prefixed by an identifier to form what are called non-standard
command literals. These command literals are parsed as calls to specially-named macros. For example, the
syntaxcustom`literal`is parsed as@custom_cmd "literal". Julia itself does not contain any non-standard
command literals, but packages can make use of this syntax. Aside from the different syntax and the_cmd
suffixinsteadofthe_strsuffix,non-standardcommandliteralsbehaveexactlylikenon-standardstringliterals.

In the event that two modules provide non-standard string or command literals with the same name, it is
possible to qualify the string or command literal with a module name. For instance, if bothFooandBarprovide
non-standard string literal@x_str, then one can writeFoo.x"literal"orBar.x"literal"to disambiguate
between the two.

Another way to define a macro would be like this:

```

macro foo_str(str, flag)

# do stuff

end

```
This macro can then be called with the following syntax:

```

foo"str"flag

```
The type of flag in the above mentioned syntax would be aStringwith contents of whatever trails after the
string literal.

### 18.6 Generated functions

A very special macro is@generated, which allows you to define so-called generated functions. These have the
capability to generate specialized code depending on the types of their arguments with more flexibility and/or
less code than what can be achieved with multiple dispatch. While macros work with expressions at parse time
and cannot access the types of their inputs, a generated function gets expanded at a time when the types of
the arguments are known, but the function is not yet compiled.

Instead of performing some calculation or action, a generated function declaration returns a quoted expression
which then forms the body for the method corresponding to the types of the arguments. When a generated
function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually
cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions
provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on
allowed constructs.

When defining generated functions, there are five main differences to ordinary functions:

1. You annotate the function declaration with the@generatedmacro. This adds some information to the
    AST that lets the compiler know that this is a generated function.
2. In the body of the generated function you only have access to the types of the arguments – not their
    values.


#### CHAPTER 18. METAPROGRAMMING 217

3. Insteadofcalculatingsomethingorperformingsomeaction,youreturnaquotedexpressionwhich,when
    evaluated, does what you want.
4. Generated functions are only permitted to call functions that were defined before the definition of the
    generated function. (Failure to follow this may result in gettingMethodErrorsreferring to functions from
    a future world-age.)
5. Generated functions must not mutate or observe any non-constant global state (including, for example,
    IO, locks, non-local dictionaries, or usinghasmethod). This means they can only read global constants,
    and cannot have any side effects. In other words, they must be completely pure. Due to an implemen-
    tation limitation, this also means that they currently cannot define a closure or generator.

It's easiest to illustrate this with an example. We can declare a generated functionfooas

```

julia> @generated function foo(x)  
Core.println(x)  
return :(x * x)  
end  
foo (generic function with 1 method)

```
Note that the body returns a quoted expression, namely:(x * x), rather than just the value ofx * x.

From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether
you're calling a regular or generated function. Let's see howfoobehaves:

```

julia> x = foo(2); # note: output is from println() statement in the body  
Int64

julia> x # now we print x  
4

julia> y = foo("bar");  
String

julia> y  
"barbar"

```
So, we see that in the body of the generated function,xis the type of the passed argument, and the value
returned by the generated function, is the result of evaluating the quoted expression we returned from the
definition, now with the value ofx.

What happens if we evaluatefooagain with a type that we have already used?

```

julia> foo(4)  
16

```
Note that there is no printout ofInt64. We can see that the body of the generated function was only executed
once here, for the specific set of argument types, and the result was cached. After that, for this example,
the expression returned from the generated function on the first invocation was re-used as the method body.
However, the actual caching behavior is an implementation-defined performance optimization, so it is invalid
to depend too closely on this behavior.

The number of times a generated function is generated might be only once, but it might also be more often, or
appear to not happen at all. As a consequence, you should never write a generated function with side effects -


#### CHAPTER 18. METAPROGRAMMING 218

when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros,
the use ofevalin a generated function is a sign that you're doing something the wrong way.) However, unlike
macros, the runtime system cannot correctly handle a call toeval, so it is disallowed.

It is also important to see how@generatedfunctions interact with method redefinition. Following the principle
that a correct@generatedfunction must not observe any mutable state or cause any mutation of global state,
we see the following behavior. Observe that the generated function cannot call any method that was not
defined prior to the definition of the generated function itself.

Initiallyf(x)has one definition

```

julia> f(x)= "original definition";

```
Define other operations that usef(x):

```

julia> g(x)= f(x);

julia> @generatedgen1(x)= f(x);

julia> @generatedgen2(x)= :(f(x));

```
We now add some new definitions forf(x):

```

julia> f(x:: Int ) = "definition for Int";

julia> f(x:: Type { Int }) = "definition for Type{Int}";

```
and compare how these results differ:

```

julia> f(1)  
"definition for Int"

julia> g(1)  
"definition for Int"

julia> gen1(1)  
"original definition"

julia> gen2(1)  
"definition for Int"

```
Each method of a generated function has its own view of defined functions:

```

julia> @generatedgen1(x:: Real ) = f(x);

julia> gen1(1)  
"definition for Type{Int}"

```
The example generated functionfooabove did not do anything a normal functionfoo(x) = x * xcould not
do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a
generated function lies in its ability to compute different quoted expressions depending on the types passed
to it:


#### CHAPTER 18. METAPROGRAMMING 219

```

julia> @generated function bar(x)  
if x <: Integer  
return :(x ^ 2)  
else  
return :(x)  
end  
end  
bar (generic function with 1 method)

julia> bar(4)  
16

julia> bar("baz")  
"baz"

```
(although of course this contrived example would be more easily implemented using multiple dispatch...)

Abusing this will corrupt the runtime system and cause undefined behavior:

```

julia> @generated function baz(x)  
if rand()< .9  
return :(x^2)  
else  
return :("boo!")  
end  
end  
baz (generic function with 1 method)

```
Since the body of the generated function is non-deterministic, its behavior, and the behavior of all subsequent
code is undefined.

Don't copy these examples!

These examples are hopefully helpful to illustrate how generated functions work, both in the definition end
and at the call site; however, don't copy them, for the following reasons:

- thefoofunction has side-effects (the call toCore.println), and it is undefined exactly when, how often
    or how many times these side-effects will occur
- thebarfunction solves a problem that is better solved with multiple dispatch - definingbar(x) = xand
    bar(x::Integer) = x ^ 2will do the same thing, but it is both simpler and faster.
- thebazfunction is pathological

Notethatthesetofoperationsthatshouldnotbeattemptedinageneratedfunctionisunbounded,andtherun-
time system can currently only detect a subset of the invalid operations. There are many other operations that
will simply corrupt the runtime system without notification, usually in subtle ways not obviously connected to
the bad definition. Because the function generator is run during inference, it must respect all of the limitations
of that code.

Some operations that should not be attempted include:

1. Caching of native pointers.
2. Interacting with the contents or methods ofCore.Compilerin any way.


#### CHAPTER 18. METAPROGRAMMING 220

3. Observing any mutable state.
    **-** Inferenceonthegeneratedfunctionmayberunatanytime,includingwhileyourcodeisattempting
       to observe or mutate this state.
4. Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic to
    callmalloc, even though most implementations require locks internally) but don't attempt to hold or
    acquire any while executing Julia code.
5. Calling any function that is defined after the body of the generated function. This condition is relaxed
    for incrementally-loaded precompiled modules to allow calling any function in the module.

Alright, now that we have a better understanding of how generated functions work, let's use them to build
some more advanced (and valid) functionality...

### An advanced example

Julia's base library has an internalsub2indfunction to calculate a linear index into an n-dimensional array,
based on a set of n multilinear indices - in other words, to calculate the indexithat can be used to index into
an arrayAusingA[i], instead ofA[x,y,z,...]. One possible implementation is the following:

```

julia>function sub2ind_loop(dims:: NTuple {N},I:: Integer ...) where N  
ind = I[N] - 1  
for i = N-1:-1:1  
ind = I[i]-1 + dims[i]*ind  
end  
return ind + 1  
end  
sub2ind_loop (generic function with 1 method)

julia> sub2ind_loop((3, 5), 1, 2)  
4

```
The same thing can be done using recursion:

```

julia> sub2ind_rec(dims:: Tuple {}) = 1;

julia> sub2ind_rec(dims:: Tuple {}, i1:: Integer , I:: Integer ...) =  
i1 == 1? sub2ind_rec(dims,I...) : throw( BoundsError ());

julia> sub2ind_rec(dims:: Tuple { Integer , Vararg { Integer }}, i1:: Integer ) = i1;

julia> sub2ind_rec(dims:: Tuple { Integer , Vararg { Integer }}, i1:: Integer , I:: Integer ...) =  
i1 + dims[1] * (sub2ind_rec(Base.tail(dims),I...) - 1);

julia> sub2ind_rec((3, 5), 1, 2)  
4

```
Both these implementations, although different, do essentially the same thing: a runtime loop over the dimen-
sions of the array, collecting the offset in each dimension into the final index.

However, all the information we need for the loop is embedded in the type information of the arguments.
Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use
generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating
the linear index, we build up an expression that calculates the index:


#### CHAPTER 18. METAPROGRAMMING 221

```

julia> @generated function sub2ind_gen(dims:: NTuple {N},I:: Integer ...) where N  
ex = :(I[$N] - 1)  
for i = (N - 1):-1:1  
ex = :(I[$i] - 1 + dims[$i] * $ex)  
end  
return :($ex + 1)  
end  
sub2ind_gen (generic function with 1 method)

julia> sub2ind_gen((3, 5), 1, 2)  
4

```
**What code will this generate?**

An easy way to find out is to extract the body into another (regular) function:

```

julia> @generated function sub2ind_gen(dims:: NTuple {N},I:: Integer ...) where N  
return sub2ind_gen_impl(dims,I...)  
end  
sub2ind_gen (generic function with 1 method)

julia>function sub2ind_gen_impl(dims:: Type {T},I...) where T<: NTuple {N, Any } where N  
length(I) == N || return :(error("partial indexing is unsupported"))  
ex = :(I[$N] - 1)  
for i = (N - 1):-1:1  
ex = :(I[$i] - 1 + dims[$i] * $ex)  
end  
return :($ex + 1)  
end  
sub2ind_gen_impl (generic function with 1 method)

```
We can now executesub2ind_gen_impland examine the expression it returns:

```

julia> sub2ind_gen_impl( Tuple { Int , Int }, Int , Int )  
:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)

```
So, the method body that will be used here doesn't include a loop at all - just indexing into the two tuples,
multiplicationandaddition/subtraction. Alltheloopingisperformedcompile-time, andweavoidloopingduring
execution entirely. Thus, we only loop once per type, in this case once perN(except in edge cases where the
function is generated more than once - see disclaimer above).

### Optionally-generated functions

Generatedfunctionscanachievehighefficiencyatruntime, butcomewithacompiletimecost: anewfunction
body must be generated for every combination of concrete argument types. Typically, Julia is able to compile
"generic"versionsoffunctionsthatwillworkforanyarguments,butwithgeneratedfunctionsthisisimpossible.
This means that programs making heavy use of generated functions might be impossible to statically compile.

To solve this problem, the language provides syntax for writing normal, non-generated alternative implemen-
tations of generated functions. Applied to thesub2indexample above, it would look like this:

```

function sub2ind_gen(dims:: NTuple {N},I:: Integer ...) where N  
if N != length(I)

```

#### CHAPTER 18. METAPROGRAMMING 222

```

throw( ArgumentError ("Number of dimensions must match number of indices."))  
end  
if @generated  
ex = :(I[$N] - 1)  
for i = (N - 1):-1:1  
ex = :(I[$i] - 1 + dims[$i] * $ex)  
end  
return :($ex + 1)  
else  
ind = I[N] - 1  
for i = (N - 1):-1:1  
ind = I[i] - 1 + dims[i]*ind  
end  
return ind + 1  
end  
end

```
Internally, this code creates two implementations of the function: a generated one where the first block inif
@generatedisused, andanormalonewheretheelseblockisused. Insidethethenpartoftheif @generated
block, code has the same semantics as other generated functions: argument names refer to types, and the
code should return an expression. Multipleif @generatedblocks may occur, in which case the generated
implementation uses all of thethenblocks and the alternate implementation uses all of theelseblocks.

Notice that we added an error check to the top of the function. This code will be common to both versions,
and is run-time code in both versions (it will be quoted and returned as an expression from the generated
version). That means that the values and types of local variables are not available at code generation time –-
the code-generation code can only see the types of arguments.

In this style of definition, the code generation feature is essentially an optional optimization. The compiler
will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is
preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since
normal code is more readable than code-generating code. However, which implementation is used depends
on compiler implementation details, so it is essential for the two implementations to behave identically.


**Chapter 19**

**Multi-dimensional Arrays**

Julia, like most technical computing languages, provides a first-class array implementation. Most technical
computing languages pay a lot of attention to their array implementation at the expense of other containers.
Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia
itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's
also possible to define custom array types by inheriting fromAbstractArray. See themanual section on the
AbstractArray interfacefor more details on implementing a custom array type.

An array is a collection of objects stored in a multi-dimensional grid. In the most general case, an array may
contain objects of typeAny. For most computational purposes, arrays should contain objects of a more specific
type, such asFloat64orInt32.

In general, unlike many other technical computing languages, Julia does not expect programs to be written in a
vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar
array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing
performance, and using less memory at times.

In Julia, all arguments to functions arepassed by sharing(i.e. by pointers). Some technical computing lan-
guages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller,
it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a!in-
dicates that it will mutate or destroy the value of one or more of its arguments (compare, for example,sort
andsort!). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend
to change. Many non- mutating functions are implemented by calling a function of the same name with an
added!at the end on an explicit copy of the input, and returning that copy.

### 19.1 Basic Functions

```

Function Description  
eltype(A) the type of the elements contained inA  
length(A) the number of elements inA  
ndims(A) the number of dimensions ofA  
size(A) a tuple containing the dimensions ofA  
size(A,n) the size ofAalong dimensionn  
axes(A) a tuple containing the valid indices ofA  
axes(A,n) a range expressing the valid indices along dimensionn  
eachindex(A) an efficient iterator for visiting each position inA  
stride(A,k) the stride (linear index distance between adjacent elements) along dimensionk  
strides(A) a tuple of the strides in each dimension

```
#### 223


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 224

### 19.2 Construction and Initialization.

Many functions for constructing and initializing arrays are provided. In the following list of such functions,
calls with adims...argument can either take a single tuple of dimension sizes or a series of dimension sizes
passed as a variable number of arguments. Most of these functions also accept a first inputT, which is the
element type of the array. If the typeTis omitted it will default toFloat64.

```

Function Description  
Array{T}(undef,  
dims...)

an uninitialized denseArray

zeros(T,  
dims...)

anArrayof all zeros

ones(T, dims...) anArrayof all ones  
trues(dims...) aBitArraywith all valuestrue  
falses(dims...) aBitArraywith all valuesfalse  
reshape(A,  
dims...)

an array containing the same data asA, but with different dimensions

copy(A) copyA  
deepcopy(A) copyA, recursively copying its elements  
similar(A, T,  
dims...)

an uninitialized array of the same type asA(dense, sparse, etc.), but with the  
specified element type and dimensions. The second and third arguments are both  
optional, defaulting to the element type and dimensions ofAif omitted.  
reinterpret(T,  
A)

an array with the same binary data asA, but with element typeT

rand(T, dims...) anArraywith random, iid^1 and uniformly distributed values in the half-open  
interval[0,1)  
randn(T,  
dims...)

anArraywith random, iid and standard normally distributed values

Matrix{T}(I, m,  
n)

m-by-nidentity matrix. Requiresusing LinearAlgebraforI.

range(start,  
stop=stop,  
length=n)

range ofnlinearly spaced elements fromstarttostop

fill!(A, x) fill the arrayAwith the valuex  
fill(x, dims...) anArrayfilled with the valuex

```
To see the various ways we can pass dimensions to these functions, consider the following examples:

```

julia> zeros( Int8 , 2, 3)  
2×3 Matrix{Int8}:  
0 0 0  
0 0 0

julia> zeros( Int8 , ( 2, 3))  
2×3 Matrix{Int8}:  
0 0 0  
0 0 0

julia> zeros((2, 3))  
2×3 Matrix{Float64}:

```
(^1) iid, independently and identically distributed.


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 225

```

0.0 0.0 0.0  
0.0 0.0 0.0

```
Here,(2, 3)is aTupleand the first argument — the element type — is optional, defaulting toFloat64.

### 19.3 Array literals.

Arrays can also be directly constructed with square braces; the syntax[A, B, C, ...]creates a one dimen-
sional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type
(eltype) of the resulting array is automatically determined by the types of the arguments inside the braces.
If all the arguments are the same type, then that is itseltype. If they all have a commonpromotion typethen
they get converted to that type usingconvertand that type is the array'seltype. Otherwise, a heteroge-
neous array that can hold anything — aVector{Any}— is constructed; this includes the literal[]where no
arguments are given.

```

julia> [1,2,3] # An array of `Int`s  
3-element Vector{Int64}:  
1  
2  
3

julia> promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64  
(1.0, 2.3, 0.8)

julia> [1, 2.3, 4//5] # Thus that's the element type of this Array  
3-element Vector{Float64}:  
1.0  
2.3  
0.8

julia> []  
Any[]

```
### Concatenation

If the arguments inside the square brackets are separated by single semicolons (;) or newlines instead of
commas, then their contents are vertically concatenated together instead of the arguments being used as
elements themselves.

```

julia> [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements  
2-element Vector{UnitRange{Int64}}:  
1:2  
4:5

julia> [1:2; 4:5]  
4-element Vector{Int64}:  
1  
2  
4  
5

julia> [1:2  
4:5

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 226

```

6]  
5-element Vector{Int64}:  
1  
2  
4  
5  
6

```
Similarly, if the arguments are separated by tabs or spaces or double semicolons, then their contents are
horizontally concatenated together.

```

julia> [1:2 4:5 7:8]  
2×3 Matrix{Int64}:  
1 4 7  
2 5 8

julia> [[1,2] [ 4,5] [ 7,8]]  
2×3 Matrix{Int64}:  
1 4 7  
2 5 8

julia> [1 2 3] # Numbers can also be horizontally concatenated  
1×3 Matrix{Int64}:  
1 2 3

julia> [1;; 2;; 3;; 4]  
1×4 Matrix{Int64}:  
1 2 3 4

```
Single semicolons (or newlines) and spaces (or tabs) can be combined to concatenate both horizontally and
vertically at the same time.

```

julia> [1 2  
3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> [zeros( Int , 2, 2) [ 1; 2]  
[3 4] 5]  
3×3 Matrix{Int64}:  
0 0 1  
0 0 2  
3 4 5

julia> [[1 1]; 2 3; [ 4 4]]  
3×2 Matrix{Int64}:  
1 1  
2 3  
4 4

```
Spaces (and tabs) have a higher precedence than semicolons, performing any horizontal concatenations first
and then concatenating the result. Using double semicolons for the horizontal concatenation, on the other
hand, performs any vertical concatenations before horizontally concatenating the result.


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 227

```

julia> [zeros( Int , 2, 2) ; [3 4] ;; [1; 2] ; 5]  
3×3 Matrix{Int64}:  
0 0 1  
0 0 2  
3 4 5

julia> [1:2; 4;; 1; 3:4]  
3×2 Matrix{Int64}:  
1 1  
2 3  
4 4

```
Just as;and;;concatenate in the first and second dimension, using more semicolons extends this same
general scheme. The number of semicolons in the separator specifies the particular dimension, so;;;con-
cetenates in the third dimension,;;;;in the 4th, and so on. Fewer semicolons take precedence, so the lower
dimensions are generally concatenated first.

```

julia> [1; 2;; 3; 4;; 5; 6;;;  
7; 8;; 9; 10;; 11; 12]  
2×3×2 Array{Int64, 3}:  
[:, :, 1] =  
1 3 5  
2 4 6

[:, :, 2] =  
7 9 11  
8 10 12

```
Like before, spaces (and tabs) for horizontal concatenation have a higher precedence than any number of
semicolons. Thus, higher dimensional arrays can also be written by specifying their rows first, with their
elements textually arranged in a manner similar to their layout:

```

julia> [1 3 5  
2 4 6;;;  
7 9 11  
8 10 12]  
2×3×2 Array{Int64, 3}:  
[:, :, 1] =  
1 3 5  
2 4 6

[:, :, 2] =  
7 9 11  
8 10 12

julia> [1 2;;; 3 4;;;;5 6;;; 7 8]  
1×2×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 2

[:, :, 2, 1] =  
3 4

[:, :, 1, 2] =

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 228

```

5 6

[:, :, 2, 2] =  
7 8

julia> [[1 2;;; 3 4];;;; [5 6];;; [7 8]]  
1×2×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 2

[:, :, 2, 1] =  
3 4

[:, :, 1, 2] =  
5 6

[:, :, 2, 2] =  
7 8

```
Although they both mean concatenation in the second dimension, spaces (or tabs) and;;cannot appear in
the same array expression unless the double semicolon is simply serving as a"line continuation" character.
This allows a single horizontal concatenation to span multiple lines (without the line break being interpreted
as a vertical concatenation).

```

julia> [1 2 ;;  
3 4]  
1×4 Matrix{Int64}:  
1 2 3 4

```
Terminating semicolons may also be used to add trailing length 1 dimensions.

```

julia> [1;;]  
1×1 Matrix{Int64}:  
1

julia> [2; 3;;;]  
2×1×1 Array{Int64, 3}:  
[:, :, 1] =  
2  
3

```
More generally, concatenation can be accomplished through thecatfunction. These syntaxes are shorthands
for function calls that themselves are convenience functions:

### Typed array literals

AnarraywithaspecificelementtypecanbeconstructedusingthesyntaxT[A, B, C, ...]. Thiswillconstruct
a 1-d array with element typeT, initialized to contain elementsA,B,C, etc. For example,Any[x, y, z]
constructs a heterogeneous array that can contain any values.

Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 229

```

Syntax Func-  
tion

Description

cat concatenate input arrays along dimension(s)k  
[A; B; C;  
...]

vcat shorthand for ‘cat(A...; dims=1)

[A B C ...] hcat shorthand for ‘cat(A...; dims=2)  
[A B; C D;  
...]

hvcat simultaneous vertical and horizontal concatenation

[A; C;; B;  
D;;; ...]

hvncat simultaneous n-dimensional concatenation, where number of semicolons  
indicate the dimension to concatenate

julia> [[1 2] [ 3 4]]  
1×4 Matrix{Int64}:  
1 2 3 4

julia>Int8 [[1 2] [ 3 4]]  
1×4 Matrix{Int8}:  
1 2 3 4

```
### 19.4 Comprehensions.

Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to
set construction notation in mathematics:

```

A = [ F(x,y,...) for x=rx, y=ry, ... ]

```
The meaning of this form is thatF(x,y,...)is evaluated with the variablesx,y, etc. taking on each value in
their given list of values. Values can be specified as any iterable object, but will commonly be ranges like1:n
or2:(n-1), or explicit arrays of values like[1.2, 3.4, 5.7]. The result is an N-d dense array with dimen-
sions that are the concatenation of the dimensions of the variable rangesrx,ry, etc. and eachF(x,y,...)
evaluation returns a scalar.

The following example computes a weighted average of the current element and its left and right neighbor
along a 1-d grid. :

```

julia> x = rand(8)  
8-element Array{Float64,1}:  
0.843025  
0.869052  
0.365105  
0.699456  
0.977653  
0.994953  
0.41084  
0.809411

julia> [ 0.25_x[i-1] + 0.5_x[i]+ 0.25*x[i+1] for i=2:length(x)-1 ]  
6-element Array{Float64,1}:  
0.736559  
0.57468  
0.685417  
0.912429  
0.8446  
0.656511

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 230

The resulting array type depends on the types of the computed elements just likearray literalsdo. In order
to control the type explicitly, a type can be prepended to the comprehension. For example, we could have
requested the result in single precision by writing:

```

Float32 [ 0.25_x[i-1] + 0.5_x[i]+ 0.25*x[i+1] for i=2:length(x)-1 ]

```
### 19.5 Generator Expressions.

Comprehensions can also be written without the enclosing square brackets, producing an object known as
a generator. This object can be iterated to produce values on demand, instead of allocating an array and
storing them in advance (seeIteration). For example, the following expression sums a series without allocating
memory:

```

julia> sum(1/n^2 for n=1:1000)  
1.6439345666815615

```
Whenwritingageneratorexpressionwithmultipledimensionsinsideanargumentlist, parenthesesareneeded
to separate the generator from subsequent arguments:

```

julia> map(tuple,1/(i+j) for i=1:2, j =1:2, [ 1:4;])  
ERROR: syntax: invalid iteration specification

```
All comma-separated expressions afterforare interpreted as ranges. Adding parentheses lets us add a third
argument tomap:

```

julia> map(tuple, (1/(i+j) for i=1:2, j =1:2), [ 1 3; 2 4])  
2×2 Matrix{Tuple{Float64, Int64}}:  
(0.5, 1) (0.333333, 3)  
(0.333333, 2) (0.25, 4)

```
Generators are implemented via inner functions. Just like inner functions used elsewhere in the language,
variables from the enclosing scope can be"captured" in the inner function. For example,sum(p[i] - q[i]
for i=1:n)captures the three variablesp,qandnfrom the enclosing scope. Captured variables can present
performance challenges; seeperformance tips.

Ranges in generators and comprehensions can depend on previous ranges by writing multipleforkeywords:

```

julia> [(i,j) for i=1:3 for j=1:i]  
6-element Vector{Tuple{Int64, Int64}}:  
(1, 1)  
(2, 1)  
(2, 2)  
(3, 1)  
(3, 2)  
(3, 3)

```
In such cases, the result is always 1-d.

Generated values can be filtered using theifkeyword:

```

julia> [(i,j) for i=1:3 for j=1:i if i+j == 4]  
2-element Vector{Tuple{Int64, Int64}}:  
(2, 2)  
(3, 1)

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 231

### 19.6 Indexing.

The general syntax for indexing into an n-dimensional arrayAis:

```

X = A[I_1, I_2, ..., I_n]

```
whereeachI_kmaybeascalarinteger,anarrayofintegers,oranyothersupportedindex. ThisincludesColon
(:) to select all indices within the entire dimension, ranges of the forma:cora:b:cto select contiguous or
strided subsections, and arrays of booleans to select elements at theirtrueindices.

If all the indices are scalars, then the resultXis a single element from the arrayA. Otherwise,Xis an array with
the same number of dimensions as the sum of the dimensionalities of all the indices.

If all indicesI_kare vectors, for example, then the shape ofXwould be(length(I_1), length(I_2), ...,
length(I_n)), with locationi_1, i_2, ..., i_nofXcontaining the valueA[I_1[i_1], I_2[i_2], ...,
I_n[i_n]].

Example:

```

julia> A = reshape(collect(1:16), ( 2, 2, 2, 2))  
2×2×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 3  
2 4

[:, :, 2, 1] =  
5 7  
6 8

[:, :, 1, 2] =  
9 11  
10 12

[:, :, 2, 2] =  
13 15  
14 16

julia> A[1, 2, 1, 1] # all scalar indices  
3

julia> A[[1, 2], [ 1], [ 1, 2], [ 1]] # all vector indices  
2×1×2×1 Array{Int64, 4}:  
[:, :, 1, 1] =  
1  
2

[:, :, 2, 1] =  
5  
6

julia> A[[1, 2], [ 1], [ 1, 2], 1] # a mix of index types  
2×1×2 Array{Int64, 3}:  
[:, :, 1] =  
1  
2

[:, :, 2] =

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 232

```

5  
6

```
Note how the size of the resulting array is different in the last two cases.

IfI_1is changed to a two-dimensional matrix, thenXbecomes ann+1-dimensional array of shape(size(I_1,
1), size(I_1, 2), length(I_2), ..., length(I_n)). The matrix adds a dimension.

Example:

```

julia> A = reshape(collect(1:16), ( 2, 2, 2, 2));

julia> A[[1 2; 1 2]]  
2×2 Matrix{Int64}:  
1 2  
1 2

julia> A[[1 2; 1 2], 1, 2, 1]  
2×2 Matrix{Int64}:  
5 6  
5 6

```
Thelocationi_1, i_2, i_3, ..., i_{n+1}containsthevalueatA[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]].
All dimensions indexed with scalars are dropped. For example, ifJis an array of indices, then the result of
A[2, J, 3]is an array with sizesize(J). Itsjth element is populated byA[2, J[j], 3].

As a special part of this syntax, theendkeyword may be used to represent the last index of each dimension
within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax
without theendkeyword is equivalent to a call togetindex:

```

X = getindex(A, I_1, I_2, ..., I_n)

```
Example:

```

julia> x = reshape(1:16, 4, 4)  
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

julia> x[2:3, 2: end -1]  
2×2 Matrix{Int64}:  
6 10  
7 11

julia> x[1, [ 2 3; 4 1]]  
2×2 Matrix{Int64}:  
5 9  
13 1

```
### 19.7 Indexed Assignment.

The general syntax for assigning values in an n-dimensional arrayAis:


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 233

```

A[I_1, I_2, ..., I_n] = X

```
whereeachI_kmaybeascalarinteger,anarrayofintegers,oranyothersupportedindex. ThisincludesColon
(:) to select all indices within the entire dimension, ranges of the forma:cora:b:cto select contiguous or
strided subsections, and arrays of booleans to select elements at theirtrueindices.

If all indicesI_kare integers, then the value in locationI_1, I_2, ..., I_nofAis overwritten with the value
ofX,converting to theeltypeofAif necessary.

If any indexI_kis itself an array, then the right hand sideXmust also be an array with the same shape as
the result of indexingA[I_1, I_2, ..., I_n]or a vector with the same number of elements. The value in
locationI_1[i_1], I_2[i_2], ..., I_n[i_n]ofAis overwritten with the valueX[I_1, I_2, ..., I_n],
converting if necessary. The element-wise assignment operator.=may be used tobroadcastXacross the
selected locations:

```

A[I_1, I_2, ..., I_n] .= X

```
Just as inIndexing, theendkeyword may be used to represent the last index of each dimension within the
indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax
without theendkeyword is equivalent to a call tosetindex!:

```

setindex!(A, X, I_1, I_2, ..., I_n)

```
Example:

```

julia> x = collect(reshape(1:9, 3, 3))  
3×3 Matrix{Int64}:  
1 4 7  
2 5 8  
3 6 9

julia> x[3, 3] = -9;

julia> x[1:2, 1:2] = [-1 -4; -2 -5];

julia> x  
3×3 Matrix{Int64}:  
-1 -4 7  
-2 -5 8  
3 6 -9

```
### 19.8 Supported index types.

In the expressionA[I_1, I_2, ..., I_n], eachI_kmay be a scalar index, an array of scalar indices, or an
object that represents an array of scalar indices and can be converted to such byto_indices:

1. A scalar index. By default this includes:
    **-** Non-boolean integers
    **-** CartesianIndex{N}s, which behave like anN-tuple of integers spanning multiple dimensions (see
       below for more details)
2. An array of scalar indices. This includes:
    **-** Vectors and multidimensional arrays of integers


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 234

**-** Empty arrays like[], which select no elements
**-** Ranges likea:cora:b:c, which select contiguous or strided subsections fromatoc(inclusive)
**-** Any custom array of scalar indices that is a subtype ofAbstractArray
**-** Arrays ofCartesianIndex{N}(see below for more details)
3. An object that represents an array of scalar indices and can be converted to such byto_indices. By
default this includes:
**-** Colon()(:), which represents all indices within an entire dimension or across the entire array
**-** Arrays of booleans, which select elements at theirtrueindices (see below for more details)

Some examples:

```

julia> A = reshape(collect(1:2:18), ( 3, 3))  
3×3 Matrix{Int64}:  
1 7 13  
3 9 15  
5 11 17

julia> A[4]  
7

julia> A[[2, 5, 8]]  
3-element Vector{Int64}:  
3  
9  
15

julia> A[[1 4; 3 8]]  
2×2 Matrix{Int64}:  
1 7  
5 15

julia> A[[]]  
Int64[]

julia> A[1:2:5]  
3-element Vector{Int64}:  
1  
5  
9

julia> A[2, :]  
3-element Vector{Int64}:  
3  
9  
15

julia> A[:, 3]  
3-element Vector{Int64}:  
13  
15  
17

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 235

### Cartesian indices

The specialCartesianIndex{N}object represents a scalar index that behaves like anN-tuple of integers span-
ning multiple dimensions. For example:

```

julia> A = reshape(1:32, 4, 4, 2);

julia> A[3, 2, 1]  
7

julia> A[ CartesianIndex (3, 2, 1)] == A[3, 2, 1] == 7  
true

```
Considered alone, this may seem relatively trivial;CartesianIndexsimply gathers multiple integers together
into one object that represents a single multidimensional index. When combined with other indexing forms
and iterators that yieldCartesianIndexes, however, this can produce very elegant and efficient code. See
Iterationbelow, and for some more advanced examples, seethis blog post on multidimensional algorithms
and iteration.

Arrays ofCartesianIndex{N}are also supported. They represent a collection of scalar indices that each span
Ndimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it
enables accessing the diagonal elements from the first"page" ofAfrom above:

```

julia> page= A[:,:,1]  
4×4 Matrix{Int64}:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

julia> page[[ CartesianIndex (1,1),  
CartesianIndex (2,2),  
CartesianIndex (3,3),  
CartesianIndex (4,4)]]  
4-element Vector{Int64}:  
1  
6  
11  
16

```
This can be expressed much more simply withdot broadcastingand by combining it with a normal integer
index (instead of extracting the firstpagefromAas a separate step). It can even be combined with a:to
extract both diagonals from the two pages at the same time:

```

julia> A[ CartesianIndex .(axes(A,1), axes(A,2)), 1]  
4-element Vector{Int64}:  
1  
6  
11  
16

julia> A[ CartesianIndex .(axes(A,1), axes(A,2)), :]  
4×2 Matrix{Int64}:  
1 17

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 236

```

6 22  
11 27  
16 32

Warning  
CartesianIndexand arrays ofCartesianIndexare not compatible with theendkeyword to rep-  
resent the last index of a dimension. Do not useendin indexing expressions that may contain  
eitherCartesianIndexor arrays thereof.

```
### Logical indexing

Often referred to as logical indexing or indexing with a logical mask, indexing by a boolean array selects
elements at the indices where its values aretrue. Indexing by a boolean vectorBis effectively the same
as indexing by the vector of integers that is returned byfindall(B). Similarly, indexing by aN-dimensional
boolean array is effectively the same as indexing by the vector ofCartesianIndex{N}s where its values are
true. A logical index must be a vector of the same length as the dimension it indexes into, or it must be the
only index provided and match the size and dimensionality of the array it indexes into. It is generally more
efficient to use boolean arrays as indices directly instead of first callingfindall.

```

julia> x = reshape(1:16, 4, 4)  
4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

julia> x[[ false , true , true , false ], :]  
2×4 Matrix{Int64}:  
2 6 10 14  
3 7 11 15

julia> mask= map(ispow2, x)  
4×4 Matrix{Bool}:  
1 0 0 0  
1 0 0 0  
0 0 0 0  
1 1 0 1

julia> x[mask]  
5-element Vector{Int64}:  
1  
2  
4  
8  
16

```
### Number of indices

**Cartesian indexing**

The ordinary way to index into anN-dimensional array is to use exactlyNindices; each index selects the
position(s) in its particular dimension. For example, in the three-dimensional arrayA = rand(4, 3, 2),A[2,
3, 1]will select the number in the second row of the third column in the first"page" of the array. This is often
referred to as cartesian indexing.


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 237

**Linear indexing**

When exactly one indexiis provided, that index no longer represents a location in a particular dimension of
the array. Instead, it selects theith element using the column-major iteration order that linearly spans the
entire array. This is known as linear indexing. It essentially treats the array as though it had been reshaped
into a one-dimensional vector withvec.

```

julia> A = [2 6; 4 7; 3 1]  
3×2 Matrix{Int64}:  
2 6  
4 7  
3 1

julia> A[5]  
7

julia> vec(A)[5]  
7

```
AlinearindexintothearrayAcanbeconvertedtoaCartesianIndexforcartesianindexingwithCartesianIndices(A)[i]
(seeCartesianIndices),andasetofNcartesianindicescanbeconvertedtoalinearindexwithLinearIndices(A)[i_1,
i_2, ..., i_N](seeLinearIndices).

```

julia> CartesianIndices(A)[5]  
CartesianIndex(2, 2)

julia> LinearIndices(A)[2, 2]  
5

```
It's important to note that there's a very large asymmetry in the performance of these conversions. Converting
a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the
other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than
multiplication. While some arrays — likeArrayitself — are implemented using a linear chunk of memory
and directly use a linear index in their implementations, other arrays — likeDiagonal— need the full set of
cartesian indices to do their lookup (seeIndexStyleto introspect which is which). As such, when iterating
over an entire array, it's much better to iterate overeachindex(A)instead of1:length(A). Not only will the
former be much faster in cases whereAisIndexCartesian, but it will also support OffsetArrays, too.

**Omitted and extra indices**

In addition to linear indexing, anN-dimensional array may be indexed with fewer or more thanNindices in
certain situations.

Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words,
trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an
in-bounds indexing expression. For example, a four-dimensional array with size(3, 4, 2, 1)may be indexed
with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that
linear indexing takes precedence over this rule.

```

julia> A = reshape(1:24, 3, 4, 2, 1)  
3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:  
[:, :, 1, 1] =  
1 4 7 10

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 238

```

2 5 8 11  
3 6 9 12

[:, :, 2, 1] =  
13 16 19 22  
14 17 20 23  
15 18 21 24

julia> A[1, 3, 2] # Omits the fourth dimension (length 1)  
19

julia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)  
ERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype  
↪→ Int64 at index [1, 3]

julia> A[19] # Linear indexing  
19

```
When omitting all indices withA[], this semantic provides a simple idiom to retrieve the only element in an
array and simultaneously ensure that there was only one element.

Similarly, more thanNindices may be provided if all the indices beyond the dimensionality of the array are 1
(or more generally are the first and only element ofaxes(A, d)wheredis that particular dimension number).
This allows vectors to be indexed like one-column matrices, for example:

```

julia> A = [8,6,7]  
3-element Vector{Int64}:  
8  
6  
7

julia> A[2,1]  
6

```
### 19.9 Iteration

The recommended ways to iterate over a whole array are

```

for a in A

# Do something with the element a

end

for i in eachindex(A)

# Do something with i and/or A[i]

end

```
The first construct is used when you need the value, but not index, of each element. In the second construct,
iwill be anIntifAis an array type with fast linear indexing; otherwise, it will be aCartesianIndex:

```

julia> A = rand(4,3);

julia> B = view(A,1:3, 2:3);

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 239

```

julia>for i in eachindex(B)  
@showi  
end  
i = CartesianIndex(1, 1)  
i = CartesianIndex(2, 1)  
i = CartesianIndex(3, 1)  
i = CartesianIndex(1, 2)  
i = CartesianIndex(2, 2)  
i = CartesianIndex(3, 2)

```
In contrast withfor i = 1:length(A), iterating witheachindexprovides an efficient way to iterate over any
array type.

### 19.10Array traits.

If you write a customAbstractArraytype, you can specify that it has fast linear indexing using

```

Base.IndexStyle(:: Type {<:MyArray})= IndexLinear()

```
This setting will causeeachindexiteration over aMyArrayto use integers. If you don't specify this trait, the
default valueIndexCartesian()is used.

### 19.11Array and Vectorized Operators and Functions

The following operators are supported for arrays:

1. Unary arithmetic –-,+
2. Binary arithmetic –-,+,*,/,\,^
3. Comparison –==,!=,≈(isapprox),≉

Toenableconvenientvectorizationofmathematicalandotheroperations,Juliaprovidesthedotsyntaxf.(args...),
e.g.sin.(x)ormin.(x,y), for elementwise operations over arrays or mixtures of arrays and scalars (aBroad-
castingoperation); these have the additional advantage of"fusing" into a single loop when combined with
other dot calls, e.g.sin.(cos.(x)).

Also, every binary operator supports adot versionthat can be applied to arrays (and combinations of arrays
and scalars) in suchfused broadcasting operations, e.g.z .== sin.(x .* y).

Note that comparisons such as==operate on whole arrays, giving a single boolean answer. Use dot operators
like.==for elementwise comparisons. (For comparison operations like<, only the elementwise.<version is
applicable to arrays.)

Alsonoticethedifferencebetweenmax.(a,b),whichbroadcastsmaxelementwiseoveraandb,andmaximum(a),
which finds the largest value withina. The same relationship holds formin.(a,b)andminimum(a).

### 19.12Broadcasting.

It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as
adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to
the size of the matrix:


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 240

```

julia> a = rand(2,1); A= rand(2,3);

julia> repeat(a,1,3)+A  
2×3 Array{Float64,2}:  
1.20813 1.82068 1.25387  
1.56851 1.86401 1.67846

```
This is wasteful when dimensions get large, so Julia providesbroadcast, which expands singleton dimensions
in array arguments to match the corresponding dimension in the other array without using extra memory, and
applies the given function elementwise:

```

julia> broadcast(+, a, A)  
2×3 Array{Float64,2}:  
1.20813 1.82068 1.25387  
1.56851 1.86401 1.67846

julia> b = rand(1,2)  
1×2 Array{Float64,2}:  
0.867535 0.00457906

julia> broadcast(+, a, b)  
2×2 Array{Float64,2}:  
1.71056 0.847604  
1.73659 0.873631

```
Dotted operatorssuch as.+and.*are equivalent tobroadcastcalls (except that they fuse, asdescribed
above). There is also abroadcast!function to specify an explicit destination (which can also be accessed in
a fusing fashion by.=assignment). In fact,f.(args...)is equivalent tobroadcast(f, args...), providing
a convenient syntax to broadcast any function (dot syntax). Nested"dot calls"f.(...)(including calls to.+
etcetera)automatically fuseinto a singlebroadcastcall.

Additionally,broadcastisnotlimitedtoarrays(seethefunctiondocumentation); italsohandlesscalars, tuples
and other collections. By default, only some argument types are considered scalars, including (but not limited
to)Numbers,Strings,Symbols,Types,Functions and some common singletons likemissingandnothing. All
other arguments are iterated over or indexed into elementwise.

```

julia> convert.( Float32 , [ 1, 2])  
2-element Vector{Float32}:  
1.0  
2.0

julia> ceil.( UInt8 , [ 1.2 3.4; 5.6 6.7])  
2×2 Matrix{UInt8}:  
0x02 0x04  
0x06 0x07

julia> string.(1:3, ". " , [ "First", "Second", "Third"])  
3-element Vector{String}:  
"1. First"  
"2. Second"  
"3. Third"

```
Sometimes, you want a container (like an array) that would normally participate in broadcast to be"protected"
from broadcast's behavior of iterating over all of its elements. By placing it inside another container (like a
single elementTuple) broadcast will treat it as a single value.


#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 241

```

julia> ([1, 2, 3], [ 4, 5, 6]) .+ ([1, 2, 3],)  
([2, 4, 6], [5, 7, 9])

julia> ([1, 2, 3], [ 4, 5, 6]) .+ tuple([1, 2, 3])  
([2, 4, 6], [5, 7, 9])

```
### 19.13Implementation

The base array type in Julia is the abstract typeAbstractArray{T,N}. It is parameterized by the number of
dimensionsNand the element typeT.AbstractVectorandAbstractMatrixare aliases for the 1-d and 2-d
cases. Operations onAbstractArrayobjects are defined using higher level operators and functions, in a way
that is independent of the underlying storage. These operations generally work correctly as a fallback for any
specific array implementation.

TheAbstractArraytype includes anything vaguely array-like, and implementations of it might be quite differ-
ent from conventional arrays. For example, elements might be computed on request rather than stored. How-
ever, any concreteAbstractArray{T,N}type should generally implement at leastsize(A)(returning anInt
tuple),getindex(A,i)andgetindex(A,i1,...,iN); mutable arrays should also implementsetindex!. It is
recommended that these operations have nearly constant time complexity, as otherwise some array functions
maybeunexpectedlyslow. Concretetypesshouldalsotypicallyprovideasimilar(A,T=eltype(A),dims=size(A))
method, which is used to allocate a similar array forcopyand other out-of-place operations. No matter how
anAbstractArray{T,N}is represented internally,Tis the type of object returned by integer indexing (A[1,
..., 1], whenAis not empty) andNshould be the length of the tuple returned bysize. For more details on
defining customAbstractArrayimplementations, see thearray interface guide in the interfaces chapter.

DenseArrayis an abstract subtype ofAbstractArrayintended to include all arrays where elements are stored
contiguously in column-major order (seeadditional notes in Performance Tips). TheArraytype is a specific
instance ofDenseArray;VectorandMatrixare aliases for the 1-d and 2-d cases. Very few operations are
implemented specifically forArraybeyond those that are required for allAbstractArrays; much of the array
library is implemented in a generic manner that allows all custom arrays to behave similarly.

SubArrayis a specialization ofAbstractArraythat performs indexing by sharing memory with the original
array rather than by copying it. ASubArrayis created with theviewfunction, which is called the same way
asgetindex(with an array and a series of index arguments). The result ofviewlooks the same as the result
ofgetindex, except the data is left in place.viewstores the input index vectors in aSubArrayobject, which
can later be used to index the original array indirectly. By putting the@viewsmacro in front of an expression
or block of code, anyarray[...]slice in that expression will be converted to create aSubArrayview instead.

BitArrays are space-efficient"packed" boolean arrays, which store one bit per boolean value. They can be
used similarly toArray{Bool}arrays (which store one byte per boolean value), and can be converted to/from
the latter viaArray(bitarray)andBitArray(array), respectively.

An array is"strided" if it is stored in memory with well-defined spacings (strides) between its elements. A
strided array with a supported element type may be passed to an external (non-Julia) library like BLAS or
LAPACK by simply passing itspointerand the stride for each dimension. Thestride(A, d)is the distance
betweenelementsalongdimensiond. Forexample,thebuiltinArrayreturnedbyrand(5,7,2)hasitselements
arranged contiguously in column major order. This means that the stride of the first dimension — the spacing
between elements in the same column — is 1 :

```

julia> A = rand(5,7,2);

julia> stride(A,1)  
1

```

#### CHAPTER 19. MULTI-DIMENSIONAL ARRAYS 242

The stride of the second dimension is the spacing between elements in the same row, skipping as many ele-
ments as there are in a single column ( 5 ). Similarly, jumping between the two"pages" (in the third dimension)
requires skipping5*7 == 35elements. Thestridesof this array is the tuple of these three numbers together:

```

julia> strides(A)  
(1, 5, 35)

```
In this particular case, the number of elements skipped in memory matches the number of linear indices
skipped. This is only the case for contiguous arrays likeArray(and otherDenseArraysubtypes) and is not
true in general. Views with range indices are a good example of non-contiguous strided arrays; considerV
= @view A[1:3:4, 2:2:6, 2:-1:1]. This viewVrefers to the same memory asAbut is skipping and re-
arranging some of its elements. The stride of the first dimension ofVis 3 because we're only selecting every
third row from our original array:

```

julia> V = @viewA[1:3:4, 2:2:6, 2:-1:1];

julia> stride(V,1)  
3

```
ThisviewissimilarlyselectingeveryothercolumnfromouroriginalA—andthusitneedstoskiptheequivalent
of two five-element columns when moving between indices in the second dimension:

```

julia> stride(V,2)  
10

```
The third dimension is interesting because its order is reversed! Thus to get from the first"page" to the second
one it must go backwards in memory, and so its stride in this dimension is negative!

```

julia> stride(V,3)  
-35

```
This means that thepointerforVis actually pointing into the middle ofA's memory block, and it refers to
elements both backwards and forwards in memory. See theinterface guide for strided arraysfor more details
on defining your own strided arrays. StridedVectorandStridedMatrixare convenient aliases for many
of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized
implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and
strides.

It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to
convert between linear (single-index) indexing and cartesian (multi-index) indexing, seeLinearIndicesand
CartesianIndices.


**Chapter 20**

**Missing Values**

Julia provides support for representing missing values in the statistical sense, that is for situations where no
value is available for a variable in an observation, but a valid value theoretically exists. Missing values are
represented via themissingobject, which is the singleton instance of the typeMissing.missingis equivalent
toNULLin SQLandNAin R , and behaves like them in most situations.

### 20.1 Propagation of Missing Values.

missingvalues propagate automatically when passed to standard mathematical operators and functions. For
these functions, uncertainty about the value of one of the operands induces uncertainty about the result. In
practice, this means a math operation involving amissingvalue generally returnsmissing

```

julia> missing+ 1  
missing

julia> "a" * missing  
missing

julia> abs(missing)  
missing

```
Asmissingis a normal Julia object, this propagation rule only works for functions which have opted in to
implement this behavior. This can be achieved either via a specific method defined for arguments of type
Missing, or simply by accepting arguments of this type, and passing them to functions which propagate them
(like standard math operators). Packages should consider whether it makes sense to propagate missing values
when defining new functions, and define methods appropriately if that is the case. Passing amissingvalue to
a function for which no method accepting arguments of typeMissingis defined throws aMethodError, just
like for any other type.

Functions that do not propagatemissingvalues can be made to do so by wrapping them in thepassmissing
function provided by theMissings.jlpackage. For example,f(x)becomespassmissing(f)(x).

### 20.2 Equality and Comparison Operators.

Standardequalityandcomparisonoperatorsfollowthepropagationrulepresentedabove: ifanyoftheoperands
ismissing, the result ismissing. Here are a few examples

```

julia> missing== 1  
missing

```
#### 243


#### CHAPTER 20. MISSING VALUES 244

```

julia> missing== missing  
missing

julia> missing< 1  
missing

julia> 2 >= missing  
missing

```
In particular, note thatmissing == missingreturnsmissing, so==cannot be used to test whether a value is
missing. To test whetherxismissing, useismissing(x).

Special comparison operatorsisequaland===are exceptions to the propagation rule: they always return a
Boolvalue, even in the presence ofmissingvalues, consideringmissingas equal tomissingand as different
from any other value. They can therefore be used to test whether a value ismissing

```

julia> missing=== 1  
false

julia> isequal(missing,1)  
false

julia> missing=== missing  
true

julia> isequal(missing, missing)  
true

```
Theislessoperatorisanotherexception:missingisconsideredasgreaterthananyothervalue. Thisoperator
is used bysort, which therefore placesmissingvalues after all other values.

```

julia> isless(1, missing)  
true

julia> isless(missing,Inf)  
false

julia> isless(missing, missing)  
false

```
### 20.3 Logical operators

Logical (or boolean) operators|,&andxorare another special case, as they only propagatemissingvalues
when it is logically required. For these operators, whether or not the result is uncertain depends on the partic-
ular operation, following the well-established rules ofthree-valued logicwhich are also implemented byNULL
in SQL andNAin R. This abstract definition actually corresponds to a relatively natural behavior which is best
explained via concrete examples.

Let us illustrate this principle with the logical"or" operator|. Following the rules of boolean logic, if one of the
operands istrue, the value of the other operand does not have an influence on the result, which will always
betrue


#### CHAPTER 20. MISSING VALUES 245

```

julia>true | true  
true

julia>true | false  
true

julia>false | true  
true

```
Based on this observation, we can conclude that if one of the operands istrueand the othermissing, we
know that the result istruein spite of the uncertainty about the actual value of one of the operands. If we
had been able to observe the actual value of the second operand, it could only betrueorfalse, and in both
cases the result would betrue. Therefore, in this particular case, missingness does not propagate

```

julia>true | missing  
true

julia> missing| true  
true

```
On the contrary, if one of the operands isfalse, the result could be eithertrueorfalsedepending on the
value of the other operand. Therefore, if that operand ismissing, the result has to bemissingtoo

```

julia>false | true  
true

julia>true | false  
true

julia>false | false  
false

julia>false | missing  
missing

julia> missing| false  
missing

```
The behavior of the logical"and" operator&is similar to that of the|operator, with the difference that miss-
ingness does not propagate when one of the operands isfalse. For example, when that is the case of the first
operand

```

julia>false & false  
false

julia>false & true  
false

julia>false & missing  
false

```
On the other hand, missingness propagates when one of the operands istrue, for example the first one


#### CHAPTER 20. MISSING VALUES 246

```

julia>true & true  
true

julia>true & false  
false

julia>true & missing  
missing

```
Finally, the"exclusive or" logical operatorxoralways propagatesmissingvalues, since both operands always
have an effect on the result. Also note that the negation operator!returnsmissingwhen the operand is
missingjust like other unary operators.

### 20.4 Control Flow and Short-Circuiting Operators

Control flow operators includingif,whileand theternary operatorx? y : zdo not allow for missing values.
This is because of the uncertainty about whether the actual value would betrueorfalseif we could observe
it, which implies that we do not know how the program should behave. ATypeErroris thrown as soon as a
missingvalue is encountered in this context

```

julia>if missing  
println("here")  
end  
ERROR: TypeError: non-boolean (Missing) used in boolean context

```
For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators&&
and||do not allow formissingvalues in situations where the value of the operand determines whether the
next operand is evaluated or not. For example

```

julia> missing|| false  
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia> missing&& false  
ERROR: TypeError: non-boolean (Missing) used in boolean context

julia>true && missing&& false  
ERROR: TypeError: non-boolean (Missing) used in boolean context

```
On the other hand, no error is thrown when the result can be determined without themissingvalues. This is
the case when the code short-circuits before evaluating themissingoperand, and when themissingoperand
is the last one

```

julia>true && missing  
missing

julia>false && missing  
false

```

#### CHAPTER 20. MISSING VALUES 247

### 20.5 Arrays With Missing Values

Arrays containing missing values can be created like other arrays

```

julia> [1, missing]  
2-element Vector{Union{Missing, Int64}}:  
1  
missing

```
As this example shows, the element type of such arrays isUnion{Missing, T}, withTthe type of the non-
missing values. This simply reflects the fact that array entries can be either of typeT(here,Int64) or of type
Missing. This kind of array uses an efficient memory storage equivalent to anArray{T}holding the actual
values combined with anArray{UInt8}indicating the type of the entry (i.e. whether it isMissingorT).

Arrays allowing for missing values can be constructed with the standard syntax. UseArray{Union{Missing,
T}}(missing, dims)to create arrays filled with missing values:

```

julia>Array { Union {Missing, String}}(missing,2, 3)  
2×3 Matrix{Union{Missing, String}}:  
missing missing missing  
missing missing missing

Note  
Usingundeforsimilarmay currently give an array filled withmissing, but this is not the correct  
way to obtain such an array. Use amissingconstructor as shown above instead.

```
An array allowing formissingvalues but which does not contain any such value can be converted back to
an array which does not allow for missing values usingconvert. If the array containsmissingvalues, a
MethodErroris thrown during conversion

```

julia> x = Union {Missing, String}["a", "b"]  
2-element Vector{Union{Missing, String}}:  
"a"  
"b"

julia> convert( Array {String}, x)  
2-element Vector{String}:  
"a"  
"b"

julia> y = Union {Missing, String}[missing,"b"]  
2-element Vector{Union{Missing, String}}:  
missing  
"b"

julia> convert( Array {String}, y)  
ERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String

```
### 20.6 Skipping Missing Values.

Sincemissingvalues propagate with standard mathematical operators, reduction functions returnmissing
when called on arrays which contain missing values


#### CHAPTER 20. MISSING VALUES 248

```

julia> sum([1, missing])  
missing

```
In this situation, use theskipmissingfunction to skip missing values

```

julia> sum(skipmissing([1, missing]))  
1

```
This convenience function returns an iterator which filters outmissingvalues efficiently. It can therefore be
used with any function which supports iterators

```

julia> x = skipmissing([3, missing,2, 1])  
skipmissing(Union{Missing, Int64}[3, missing, 2, 1])

julia> maximum(x)  
3

julia> mean(x)  
2.0

julia> mapreduce(sqrt,+, x)  
4.146264369941973

```
Objectscreatedbycallingskipmissingonanarraycanbeindexedusingindicesfromtheparentarray. Indices
corresponding to missing values are not valid for these objects and an error is thrown when trying to use them
(they are also skipped bykeysandeachindex)

```

julia> x[1]  
3

julia> x[2]  
ERROR: MissingException: the value at index (2,) is missing  
[...]

```
This allows functions which operate on indices to work in combination withskipmissing. This is notably the
case for search and find functions, which return indices valid for the object returned byskipmissingwhich
are also the indices of the matching entries in the parent array

```

julia> findall(==(1), x)  
1-element Vector{Int64}:  
4

julia> findfirst(!iszero, x)  
1

julia> argmax(x)  
1

```
Usecollectto extract non-missingvalues and store them in an array

```

julia> collect(x)  
3-element Vector{Int64}:  
3  
2  
1

```

#### CHAPTER 20. MISSING VALUES 249

### 20.7 Logical Operations on Arrays

The three-valued logic described above for logical operators is also used by logical functions applied to arrays.
Thus, array equality tests using the==operator returnmissingwhenever the result cannot be determined
without knowing the actual value of themissingentry. In practice, this means thatmissingis returned if all
non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly
at different positions)

```

julia> [1, missing]== [2, missing]  
false

julia> [1, missing]== [1, missing]  
missing

julia> [1, 2, missing]== [1, missing,2]  
missing

```
As for single values, useisequalto treatmissingvalues as equal to othermissingvalues but different from
non-missing values

```

julia> isequal([1, missing], [1, missing])  
true

julia> isequal([1, 2, missing], [1, missing,2])  
false

```
Functionsanyandallalso follow the rules of three-valued logic, returningmissingwhen the result cannot be
determined

```

julia> all([ true , missing])  
missing

julia> all([ false , missing])  
false

julia> any([ true , missing])  
true

julia> any([ false , missing])  
missing

```

**Chapter 21**

**Networking and Streams**

Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This
interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer
anditisusuallyunnecessarytothinkabouttheunderlyingasynchronousoperation. Thisisachievedbymaking
heavy use of Julia cooperative threading (coroutine) functionality.

### 21.1 Basic Stream I/O.

All Julia streams expose at least areadand awritemethod, taking the stream as their first argument, e.g.:

```

julia> write(stdout,"Hello World"); # suppress return value 11 with ;  
Hello World  
julia> read(stdin, Char )

'\n': ASCII/Unicode U+000a (category Cc: Other, control)

```
Note thatwritereturns 11, the number of bytes (in"Hello World") written tostdout, but this return value
is suppressed with the;.

Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example,
writetakes the data to write as its second argument, whilereadtakes the type of the data to be read as the
second argument.

For example, to read a simple byte array, we could do:

```

julia> x = zeros( UInt8 , 4)  
4-element Array{UInt8,1}:  
0x00  
0x00  
0x00  
0x00

julia> read!(stdin, x)  
abcd  
4-element Array{UInt8,1}:  
0x61  
0x62  
0x63  
0x64

```
#### 250


#### CHAPTER 21. NETWORKING AND STREAMS 251

However, since this is slightly cumbersome, there are several convenience methods provided. For example,
we could have written the above as:

```

julia> read(stdin,4)  
abcd  
4-element Array{UInt8,1}:  
0x61  
0x62  
0x63  
0x64

```
or if we had wanted to read the entire line instead:

```

julia> readline(stdin)  
abcd  
"abcd"

```
Note that depending on your terminal settings, your TTY may be line buffered and might thus require an
additional enter before the data is sent to Julia.

To read every line fromstdinyou can useeachline:

```

for line in eachline(stdin)  
print("Found $line ")  
end

```
orreadif you wanted to read by character instead:

```

while !eof(stdin)  
x = read(stdin, Char )  
println("Found: $x ")  
end

```
### 21.2 Text I/O

Note that thewritemethod mentioned above operates on binary streams. In particular, values do not get
converted to any canonical text representation but are written out as is:

```

julia> write(stdout,0x61); # suppress return value 1 with ;  
a

```
Note thatais written tostdoutby thewritefunction and that the returned value is 1 (since0x61is one byte).

For text I/O, use theprintorshowmethods, depending on your needs (see the documentation for these two
methods for a detailed discussion of the difference between them):

```

julia> print(stdout,0x61)  
97

```
See Custom pretty-printingfor more information on how to implement display methods for custom types.


#### CHAPTER 21. NETWORKING AND STREAMS 252

### 21.3 IO Output Contextual Properties.

Sometimes IO output can benefit from the ability to pass contextual information into show methods. The
IOContextobject provides this framework for associating arbitrary metadata with an IO object. For example,
:compact => trueadds a hinting parameter to the IO object that the invoked show method should print a
shorter output (if applicable). See theIOContextdocumentation for a list of common properties.

### 21.4 Working with Files

Like many other environments, Julia has anopenfunction, which takes a filename and returns anIOStream
object that you can use to read and write things from the file. For example, if we have a file,hello.txt, whose
contents areHello, World!:

```

julia> f = open("hello.txt")  
IOStream()

julia> readlines(f)  
1-element Array{String,1}:  
"Hello, World!"

```
If you want to write to a file, you can open it with the write ("w") flag:

```

julia> f = open("hello.txt","w")  
IOStream()

julia> write(f,"Hello again.")  
12

```
If you examine the contents ofhello.txtat this point, you will notice that it is empty; nothing has actually
been written to disk yet. This is because theIOStreammust be closed before the write is actually flushed to
disk:

```

julia> close(f)

```
Examininghello.txtagain will show its contents have been changed.

Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this
easier, there exists another invocation ofopenwhich takes a function as its first argument and filename as its
second, opens the file, calls the function with the file as an argument, and then closes it again. For example,
given a function:

```

function read_and_capitalize(f:: IOStream )  
return uppercase(read(f, String))  
end

```
You can call:

```

julia> open(read_and_capitalize,"hello.txt")  
"HELLO AGAIN."

```

#### CHAPTER 21. NETWORKING AND STREAMS 253

to openhello.txt, callread_and_capitalizeon it, closehello.txtand return the capitalized contents.

To avoid even having to define a named function, you can use thedosyntax, which creates an anonymous
function on the fly:

```

julia> open("hello.txt") do f  
uppercase(read(f, String))  
end  
"HELLO AGAIN."

```
### 21.5 A simple TCP example.

Let 's jump right in with a simple example involving TCP sockets. This functionality is in a standard library
package calledSockets. Let 's first create a simple server:

```

julia>using Sockets

julia> errormonitor(@async begin  
server= listen(2000)  
whiletrue  
sock= accept(server)  
println("Hello World \n ")  
end  
end )  
Task (runnable) @0x00007fd31dc11ae0

```
To those familiar with the Unix socket API, the method names will feel familiar, though their usage is some-
what simpler than the raw Unix socket API. The first call tolistenwill create a server waiting for incoming
connections on the specified port (2000) in this case. The same function may also be used to create various
other kinds of servers:

```

julia> listen(2000) # Listens on localhost:2000 (IPv4)  
Sockets.TCPServer(active)

julia> listen(ip"127.0.0.1",2000) # Equivalent to the first  
Sockets.TCPServer(active)

julia> listen(ip"::1",2000) # Listens on localhost:2000 (IPv6)  
Sockets.TCPServer(active)

julia> listen( IPv4 (0),2001) # Listens on port 2001 on all IPv4 interfaces  
Sockets.TCPServer(active)

julia> listen( IPv6 (0),2001) # Listens on port 2001 on all IPv6 interfaces  
Sockets.TCPServer(active)

julia> listen("testsocket") # Listens on a UNIX domain socket  
Sockets.PipeServer(active)

julia> listen(" \\. \ pipe \ testsocket") # Listens on a Windows named pipe  
Sockets.PipeServer(active)

```
Note that the return type of the last invocation is different. This is because this server does not listen on TCP,
but rather on a named pipe (Windows) or UNIX domain socket. Also note that Windows named pipe format has


#### CHAPTER 21. NETWORKING AND STREAMS 254

to be a specific pattern such that the name prefix (\\.\pipe\) uniquely identifies thefile type. The difference
between TCP and named pipes or UNIX domain sockets is subtle and has to do with theacceptandconnect
methods. Theacceptmethod retrieves a connection to the client that is connecting on the server we just
created, while theconnectfunction connects to a server using the specified method. Theconnectfunction
takes the same arguments aslisten, so, assuming the environment (i.e. host, cwd, etc.) is the same you
should be able to pass the same arguments toconnectas you did to listen to establish the connection. So
let's try that out (after having created the server above):

```

julia> connect(2000)  
TCPSocket(open, 0 bytes waiting)

julia> Hello World

```
As expected we saw"Hello World" printed. So, let's actually analyze what happened behind the scenes. When
we calledconnect, we connect to the server we had just created. Meanwhile, the accept function returns a
server-side connection to the newly created socket and prints"Hello World" to indicate that the connection
was successful.

AgreatstrengthofJuliaisthatsincetheAPIisexposedsynchronouslyeventhoughtheI/Oisactuallyhappening
asynchronously, wedidn'thavetoworryaboutcallbacksorevenmakingsurethattheservergetstorun. When
we calledconnectthe current task waited for the connection to be established and only continued executing
after that was done. In this pause, the server task resumed execution (because a connection request was now
available), accepted the connection, printed the message and waited for the next client. Reading and writing
works in the same way. To see this, consider the following simple echo server:

```

julia> errormonitor(@async begin  
server= listen(2001)  
whiletrue  
sock= accept(server)  
@async while isopen(sock)  
write(sock, readline(sock, keep= true ))  
end  
end  
end )  
Task (runnable) @0x00007fd31dc12e60

julia> clientside= connect(2001)  
TCPSocket(RawFD(28) open, 0 bytes waiting)

julia> errormonitor(@async while isopen(clientside)  
write(stdout, readline(clientside, keep= true ))  
end )  
Task (runnable) @0x00007fd31dc11870

julia> println(clientside,"Hello World from the Echo Server")  
Hello World from the Echo Server

```
As with other streams, usecloseto disconnect the socket:

```

julia> close(clientside)

```

#### CHAPTER 21. NETWORKING AND STREAMS 255

### 21.6 Resolving IP Addresses

Oneoftheconnectmethodsthatdoesnotfollowthelistenmethodsisconnect(host::String,port), which
will attempt to connect to the host given by thehostparameter on the port given by theportparameter. It
allows you to do things like:

```

julia> connect("google.com", 80)  
TCPSocket(RawFD(30) open, 0 bytes waiting)

```
At the base of this functionality isgetaddrinfo, which will do the appropriate address resolution:

```

julia> getaddrinfo("google.com")  
ip"74.125.226.225"

```
### 21.7 Asynchronous I/O

All I/O operations exposed byBase.readandBase.writecan be performed asynchronously through the use
of coroutines. You can create a new coroutine to read from or write to a stream using the@asyncmacro:

```

julia> task= @asyncopen("foo.txt", "w") do io  
write(io,"Hello, World!")  
end ;

julia> wait(task)

julia> readlines("foo.txt")  
1-element Array{String,1}:  
"Hello, World!"

```
It's common to run into situations where you want to perform multiple asynchronous operations concurrently
and wait until they've all completed. You can use the@syncmacro to cause your program to block until all of
the coroutines it wraps around have exited:

```

julia>using Sockets

julia> @sync for hostname in ("google.com", "github.com", "julialang.org")  
@async begin  
conn= connect(hostname,80)  
write(conn,"GET / HTTP/1.1 \r\n Host: $ (hostname) \r\n\r\n ")  
readline(conn, keep= true )  
println("Finished connection to $ (hostname)")  
end  
end  
Finished connection to google.com  
Finished connection to julialang.org  
Finished connection to github.com

```

**Chapter 22**

**Parallel Computing**

Julia supports these four categories of concurrent and parallel programming:

1. **Asynchronous"tasks", or coroutines** :
    Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer
    processes, and similar patterns. Tasks can synchronize through operations likewaitandfetch, and
    communicate viaChannels. While strictly not parallel computing by themselves, Julia lets you schedule
    Tasks on several threads.
2. **Multi-threading** :
    Julia's multi-threadingprovides the ability to schedule Tasks simultaneously on more than one thread
    or CPU core, sharing memory. This is usually the easiest way to get parallelism on one's PC or on a
    single large multi-core server. Julia's multi-threading is composable. When one multi-threaded function
    calls another multi-threaded function, Julia will schedule all the threads globally on available resources,
    without oversubscribing.
3. **Distributed computing** :
    Distributed computing runs multiple Julia processes with separate memory spaces. These can be on the
    same computer or multiple computers. TheDistributedstandard library provides the capability for
    remote execution of a Julia function. With this basic building block, it is possible to build many different
    kinds of distributed computing abstractions. Packages likeDistributedArrays.jlare an example of
    such an abstraction. On the other hand, packages likeMPI.jlandElemental.jlprovide access to the
    existing MPI ecosystem of libraries.
4. **GPU computing** :
    The Julia GPU compiler provides the ability to run Julia code natively on GPUs. There is a rich ecosystem
    of Julia packages that target GPUs. TheJuliaGPU.orgwebsite provides a list of capabilities, supported
    GPUs, related packages and documentation.

#### 256


**Chapter 23**

**Asynchronous Programming**

When a program needs to interact with the outside world, for example communicating with another machine
over the internet, operations in the program may need to happen in an unpredictable order. Say your program
needs to download a file. We would like to initiate the download operation, perform other operations while we
wait for it to complete, and then resume the code that needs the downloaded file when it is available. This
sort of scenario falls in the domain of asynchronous programming, sometimes also referred to as concurrent
programming (since, conceptually, multiple things are happening at once).

Toaddressthesescenarios, JuliaprovidesTasks(alsoknownbyseveralothernames, suchassymmetriccorou-
tines, lightweight threads, cooperative multitasking, or one-shot continuations). When a piece of computing
work (in practice, executing a particular function) is designated as aTask, it becomes possible to interrupt
it by switching to anotherTask. The originalTaskcan later be resumed, at which point it will pick up right
where it left off. At first, this may seem similar to a function call. However there are two key differences. First,
switching tasks does not use any space, so any number of task switches can occur without consuming the call
stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function
must finish executing before control returns to the calling function.

### 23.1 BasicTaskoperations.

You can think of aTaskas a handle to a unit of computational work to be performed. It has a create-start-run-
finish lifecycle. Tasks are created by calling theTaskconstructor on a 0-argument function to run, or using the
@taskmacro:

```

julia> t = @task begin ; sleep(5); println("done"); end  
Task (runnable) @0x00007f13a40c0eb0

```
@task xis equivalent toTask(()->x).

This task will wait for five seconds, and then printdone. However, it has not started running yet. We can run
it whenever we're ready by callingschedule:

```

julia> schedule(t);

```
If you try this in the REPL, you will see thatschedulereturns immediately. That is because it simply addstto
an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting
for keyboard input provides an opportunity for other tasks to run, so at that pointtwill start.tcallssleep,
which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five
seconds, the timer fires and restartst, and you will seedoneprinted.tis then finished.

Thewaitfunction blocks the calling task until some other task finishes. So for example if you type

#### 257


#### CHAPTER 23. ASYNCHRONOUS PROGRAMMING 258

```

julia> schedule(t); wait(t)

```
instead of only callingschedule, you will see a five second pause before the next input prompt appears. That
is because the REPL is waiting fortto finish before proceeding.

It is common to want to create a task and schedule it right away, so the macro@asyncis provided for that
purpose –-@async xis equivalent toschedule(@task x).

### 23.2 Communicating with Channels

In some problems, the various pieces of required work are not naturally related by function calls; there is
no obvious"caller" or "callee" among the jobs that need to be done. An example is the producer-consumer
problem, where one complex procedure is generating values and another complex procedure is consuming
them. The consumer cannot simply call a producer function to get a value, because the producer may have
more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can
both run as long as they need to, passing values back and forth as necessary.

Julia provides aChannelmechanism for solving this problem. AChannelis a waitable first-in first-out queue
which can have multiple tasks reading from and writing to it.

Let 's define a producer task, which produces values via theput!call. To consume values, we need to schedule
theproducertoruninanewtask. AspecialChannelconstructorwhichacceptsa1-argfunctionasanargument
can be used to run a task bound to a channel. We can thentake!values repeatedly from the channel object:

```

julia>function producer(c:: Channel )  
put!(c,"start")  
for n=1:4  
put!(c,2n)  
end  
put!(c,"stop")  
end ;

julia> chnl= Channel (producer);

julia> take!(chnl)  
"start"

julia> take!(chnl)  
2

julia> take!(chnl)  
4

julia> take!(chnl)  
6

julia> take!(chnl)  
8

julia> take!(chnl)  
"stop"

```
One way to think of this behavior is thatproducerwas able to return multiple times. Between calls toput!,
the producer's execution is suspended and the consumer has control.


#### CHAPTER 23. ASYNCHRONOUS PROGRAMMING 259

The returnedChannelcan be used as an iterable object in aforloop, in which case the loop variable takes on
all the produced values. The loop is terminated when the channel is closed.

```

julia>for x in Channel (producer)  
println(x)  
end  
start  
2  
4  
6  
8  
stop

```
Note that we did not have to explicitly close the channel in the producer. This is because the act of binding a
Channelto aTaskassociates the open lifetime of a channel with that of the bound task. The channel object is
closed automatically when the task terminates. Multiple channels can be bound to a task, and vice-versa.

While theTaskconstructor expects a 0-argument function, theChannelmethod that creates a task-bound
channel expects a function that accepts a single argument of typeChannel. A common pattern is for the
producertobeparameterized,inwhichcaseapartialfunctionapplicationisneededtocreatea0or1argument
anonymous function.

ForTaskobjects this can be done either directly or by use of a convenience macro:

```

function mytask(myarg)  
...  
end

taskHdl= Task (() -> mytask(7))

# or, equivalently

taskHdl= @taskmytask(7)

```
To orchestrate more advanced work distribution patterns,bindandschedulecan be used in conjunction with
TaskandChannelconstructors to explicitly link a set of channels with a set of producer/consumer tasks.

### More on Channels

A channel can be visualized as a pipe, i.e., it has a write end and a read end :

- Multiple writers in different tasks can write to the same channel concurrently viaput!calls.
- Multiple readers in different tasks can read data concurrently viatake!calls.
- As an example:

```

# Given Channels c1 and c2,

c1 = Channel (32)  
c2 = Channel (32)

# and a function `foo` which reads items from c1, processes the item read

# and writes a result to c2,

function foo()  
whiletrue  
data= take!(c1)

```

#### CHAPTER 23. ASYNCHRONOUS PROGRAMMING 260

```

[...] # process data  
put!(c2, result) # write out result  
end  
end

# we can schedule `n` instances of `foo` to be active concurrently.

for _ in 1:n  
errormonitor(@asyncfoo())  
end

```
- Channels are created via theChannel{T}(sz)constructor. The channel will only hold objects of typeT.
    If the type is not specified, the channel can hold objects of any type.szrefers to the maximum number
    of elements that can be held in the channel at any time. For example,Channel(32)creates a channel
    that can hold a maximum of 32 objects of any type. AChannel{MyType}(64)can hold up to 64 objects
    ofMyTypeat any time.
- If aChannelis empty, readers (on atake!call) will block until data is available.
- If aChannelis full, writers (on aput!call) will block until space becomes available.
- isreadytests for the presence of any object in the channel, whilewaitwaits for an object to become
    available.
- AChannelis in an open state initially. This means that it can be read from and written to freely viatake!
    andput!calls.closecloses aChannel. On a closedChannel,put!will fail. For example:

```

julia> c = Channel (2);

julia> put!(c,1) # `put!` on an open channel succeeds  
1

julia> close(c);

julia> put!(c,2) # `put!` on a closed channel throws an exception.  
ERROR: InvalidStateException("Channel is closed.",:closed)  
Stacktrace:  
[...]

```
- take!andfetch(which retrieves but does not remove the value) on a closed channel successfully
    return any existing values until it is emptied. Continuing the above example:

```

julia> fetch(c)# Any number of `fetch` calls succeed.  
1

julia> fetch(c)  
1

julia> take!(c)# The first `take!` removes the value.  
1

julia> take!(c)# No more data available on a closed channel.  
ERROR: InvalidStateException("Channel is closed.",:closed)  
Stacktrace:  
[...]

```

#### CHAPTER 23. ASYNCHRONOUS PROGRAMMING 261

Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from
asinglejobschannel. Jobs, identifiedbyanid(job_id), arewrittentothechannel. Eachtaskinthissimulation
reads ajob_id, waits for a random amount of time and writes back a tuple ofjob_idand the simulated time
to the results channel. Finally all theresultsare printed out.

```

julia>const jobs= Channel { Int }(32);

julia>const results= Channel { Tuple }(32);

julia>function do_work()  
for job_id in jobs  
exec_time= rand()  
sleep(exec_time) # simulates elapsed time doing actual work

# typically performed externally.

put!(results, (job_id, exec_time))  
end  
end ;

julia>function make_jobs(n)  
for i in 1:n  
put!(jobs, i)  
end  
end ;

julia> n = 12;

julia> errormonitor(@asyncmake_jobs(n));# feed the jobs channel with "n" jobs

julia>for i in 1:4 # start 4 tasks to process requests in parallel  
errormonitor(@asyncdo_work())  
end

julia> @elapsed while n > 0 # print out results  
job_id, exec_time= take!(results)  
println(" $job_id finished in $ (round(exec_time; digits=2)) seconds")  
global n = n - 1  
end  
4 finished in 0.22 seconds  
3 finished in 0.45 seconds  
1 finished in 0.5 seconds  
7 finished in 0.14 seconds  
2 finished in 0.78 seconds  
5 finished in 0.9 seconds  
9 finished in 0.36 seconds  
6 finished in 0.87 seconds  
8 finished in 0.79 seconds  
10 finished in 0.64 seconds  
12 finished in 0.5 seconds  
11 finished in 0.97 seconds  
0.029772311

```
Instead oferrormonitor(t), a more robust solution may be use usebind(results, t), as that will not only
log any unexpected failures, but also force the associated resources to close and propagate the exception
everywhere.


#### CHAPTER 23. ASYNCHRONOUS PROGRAMMING 262

### 23.3 More task operations

Taskoperationsarebuiltonalow-levelprimitivecalledyieldto.yieldto(task, value)suspendsthecurrent
task, switches to the specifiedtask, and causes that task's lastyieldtocall to return the specifiedvalue.
Noticethatyieldtoistheonlyoperationrequiredtousetask-stylecontrolflow; insteadofcallingandreturning
we are always just switching to a different task. This is why this feature is also called"symmetric coroutines";
each task is switched to and from using the same mechanism.

yieldtois powerful, but most uses of tasks do not invoke it directly. Consider why this might be. If you
switch away from the current task, you will probably want to switch back to it at some point, but knowing when
to switch back, and knowing which task has the responsibility of switching back, can require considerable
coordination. For example,put! andtake! are blocking operations, which, when used in the context of
channels maintain state to remember who the consumers are. Not needing to manually keep track of the
consuming task is what makesput!easier to use than the low-levelyieldto.

In addition toyieldto, a few other basic functions are needed to use tasks effectively.

- current_taskgets a reference to the currently-running task.
- istaskdonequeries whether a task has exited.
- istaskstartedqueries whether a task has run yet.
- task_local_storagemanipulates a key-value store specific to the current task.

### 23.4 Tasks and events

MosttaskswitchesoccurasaresultofwaitingforeventssuchasI/Orequests,andareperformedbyascheduler
included in Julia Base. The scheduler maintains a queue of runnable tasks, and executes an event loop that
restarts tasks based on external events such as message arrival.

The basic function for waiting for an event iswait. Several objects implementwait; for example, given a
Processobject,waitwill wait for it to exit.waitis often implicit; for example, awaitcan happen inside a call
toreadto wait for data to be available.

In all of these cases,waitultimately operates on aConditionobject, which is in charge of queueing and
restarting tasks. When a task callswaiton aCondition, the task is marked as non-runnable, added to the
condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block
waiting for external events. If all goes well, eventually an event handler will callnotifyon the condition, which
causes tasks waiting for that condition to become runnable again.

A task created explicitly by callingTaskis initially not known to the scheduler. This allows you to manage
tasks manually usingyieldtoif you wish. However, when such a task waits for an event, it still gets restarted
automatically when the event happens, as you would expect.


**Chapter 24**

**Multi-Threading**

Visit thisblog postfor a presentation of Julia multi-threading features.

### 24.1 Starting Julia with multiple threads

By default, Julia starts up with a single thread of execution. This can be verified by using the command
Threads.nthreads():

```

julia> Threads.nthreads()  
1

```
The number of execution threads is controlled either by using the-t/--threadscommand line argument or
by using theJULIA_NUM_THREADSenvironment variable. When both are specified, then-t/--threadstakes
precedence.

The number of threads can either be specified as an integer (--threads=4) or asauto(--threads=auto),
whereautosets the number of threads to the number of local CPU threads.

```

Julia 1.5  
The-t/--threadscommand line argument requires at least Julia 1.5. In older versions you must  
use the environment variable instead.

Julia 1.7  
Usingautotogether with the environment variableJULIA_NUM_THREADSrequires at least Julia 1.7.

```
Lets start Julia with 4 threads:

```

$ julia --threads 4

```
Let 's verify there are 4 threads at our disposal.

```

julia> Threads.nthreads()  
4

```
But we are currently on the master thread. To check, we use the functionThreads.threadid

#### 263


#### CHAPTER 24. MULTI-THREADING 264

```

julia> Threads.threadid()  
1

Note  
If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):  
export JULIA_NUM_THREADS=4

C shell on Linux/macOS, CMD on Windows:  
set JULIA_NUM_THREADS=4

Powershell on Windows:  
$env:JULIA_NUM_THREADS=4

Note that this must be done before starting Julia.

Note  
The number of threads specified with-t/--threadsis propagated to worker processes that are  
spawned using the-p/--procsor--machine-filecommand line options. For example,julia  
-p2 -t2spawns 1 main process with 2 worker processes, and all three processes have 2 threads  
enabled. For more fine grained control over worker threads useaddprocsand pass-t/--threads  
asexeflags.

```
### 24.2 Data-race freedom.

You are entirely responsible for ensuring that your program is data-race free, and nothing promised here can
be assumed if you do not observe that requirement. The observed results may be highly unintuitive.

The best way to ensure this is to acquire a lock around any access to data that can be observed from multiple
threads. For example, in most cases you should use the following code pattern:

```

julia> lock(lk) do  
use(a)  
end

julia>begin  
lock(lk)  
try  
use(a)  
finally  
unlock(lk)  
end  
end

```
wherelkis a lock (e.g.ReentrantLock()) andadata.

Additionally, Julia is not memory safe in the presence of a data race. Be very careful about reading any data
if another thread might write to it! Instead, always use the lock pattern above when changing data (such as
assigning to a global or closure variable) accessed by other threads.


#### CHAPTER 24. MULTI-THREADING 265

```

Thread1:  
global b = false  
global a = rand()  
global b = true

Thread2:  
while !b; end  
bad_read1(a)# it is NOT safe to access `a` here!

Thread3:  
while !@isdefined(a); end  
bad_read2(a)# it is NOT safe to access `a` here

```
### 24.3 The@threadsMacro.

Let 's work a simple example using our native threads. Let us create an array of zeros:

```

julia> a = zeros(10)  
10-element Vector{Float64}:  
0.0  
0.0  
0.0  
0.0  
0.0  
0.0  
0.0  
0.0  
0.0  
0.0

```
Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into
each location.

Julia supports parallel loops using theThreads.@threadsmacro. This macro is affixed in front of aforloop to
indicate to Julia that the loop is a multi-threaded region:

```

julia> Threads.@threads for i = 1:10  
a[i]= Threads.threadid()  
end

```
The iteration space is split among the threads, after which each thread writes its thread ID to its assigned
locations:

```

julia> a  
10-element Vector{Float64}:  
1.0  
1.0  
1.0  
2.0  
2.0  
2.0  
3.0  
3.0  
4.0  
4.0

```

#### CHAPTER 24. MULTI-THREADING 266

Note thatThreads.@threadsdoes not have an optional reduction parameter like@distributed.

### 24.4 Atomic Operations.

Julia supports accessing and modifying values atomically, that is, in a thread-safe way to avoidrace conditions.
Avalue(whichmustbeofaprimitivetype)canbewrappedasThreads.Atomictoindicateitmustbeaccessed
in this way. Here we can see an example:

```

julia> i = Threads.Atomic{ Int }(0);

julia> ids = zeros(4);

julia> old_is= zeros(4);

julia> Threads.@threads for id in 1:4  
old_is[id]= Threads.atomic_add!(i, id)  
ids[id]= id  
end

julia> old_is  
4-element Vector{Float64}:  
0.0  
1.0  
7.0  
3.0

julia> i[]  
10

julia> ids  
4-element Vector{Float64}:  
1.0  
2.0  
3.0  
4.0

```
Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race
condition. An example of what would happen if we didn't avoid the race:

```

julia>using Base.Threads

julia> nthreads()  
4

julia> acc = Ref (0)  
Base.RefValue{Int64}(0)

julia> @threads for i in 1:1000  
acc[]+= 1  
end

julia> acc[]  
926

```

#### CHAPTER 24. MULTI-THREADING 267

```

julia> acc = Atomic{ Int64 }(0)  
Atomic{Int64}(0)

julia> @threads for i in 1:1000  
atomic_add!(acc,1)  
end

julia> acc[]  
1000

```
### 24.5 Per-field atomics.

We can also use atomics on a more granular level using the@atomic,@atomicswap, and@atomicreplace
macros.

Specific details of the memory model and other details of the design are written in theJulia Atomics Manifesto,
which will later be published formally.

Any field in a struct declaration can be decorated with@atomic, and then any write must be marked with
@atomicalso, and must use one of the defined atomic orderings (:monotonic, :acquire, :release, :acquire_re-
lease, or :sequentially_consistent). Any read of an atomic field can also be annotated with an atomic ordering
constraint, or will be done with monotonic (relaxed) ordering if unspecified.

```

Julia 1.7  
Per-field atomics requires at least Julia 1.7.

```
### 24.6 Side effects and mutable function arguments.

When using multi-threading we have to be careful when using functions that are notpure as we might get a
wrong answer. For instance functions that have aname ending with!by convention modify their arguments
and thus are not pure.

### 24.7 @threadcall

External libraries, such as those called viaccall, pose a problem for Julia's task-based I/O mechanism. If a C
library performs a blocking operation, that prevents the Julia scheduler from executing any other tasks until
the call returns. (Exceptions are calls into custom C code that call back into Julia, which may then yield, or C
code that callsjl_yield(), the C equivalent ofyield.)

The@threadcallmacroprovides a way to avoid stalling execution in such a scenario. It schedules a C function
for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the
threadpool is controlled via environment variableUV_THREADPOOL_SIZE. While waiting for a free thread, and
during function execution once a thread is available, the requesting task (on the main Julia event loop) yields
to other tasks. Note that@threadcalldoes not return until the execution is complete. From a user point of
view, it is therefore a blocking call like other Julia APIs.

It is very important that the called function does not call back into Julia, as it will segfault.

@threadcallmay be removed/changed in future versions of Julia.

### 24.8 Caveats

At this time, most operations in the Julia runtime and standard libraries can be used in a thread-safe manner,
if the user code is data-race free. However, in some areas work on stabilizing thread support is ongoing.


#### CHAPTER 24. MULTI-THREADING 268

Multi-threaded programming has many inherent difficulties, and if a program using threads exhibits unusual
or undesirable behavior (e.g. crashes or mysterious results), thread interactions should typically be suspected
first.

There are a few specific limitations and warnings to be aware of when using threads in Julia:

- Base collection types require manual locking if used simultaneously by multiple threads where at least
    one thread modifies the collection (common examples includepush!on arrays, or inserting items into
    aDict).
- After a task starts running on a certain thread (e.g. via@spawn), it will always be restarted on the
    same thread after blocking. In the future this limitation will be removed, and tasks will migrate between
    threads.
- @threadscurrentlyusesastaticschedule, usingallthreadsandassigningequaliterationcountstoeach.
    In the future the default schedule is likely to change to be dynamic.
- The schedule used by@spawnis nondeterministic and should not be relied on.
- Compute-bound, non-memory-allocating tasks can prevent garbage collection from running in other
    threads that are allocating memory. In these cases it may be necessary to insert a manual call to
    GC.safepoint()to allow GC to run. This limitation will be removed in the future.
- Avoid running top-level operations, e.g. include, orevalof type, method, and module definitions in
    parallel.
- Be aware that finalizers registered by a library may break if threads are enabled. This may require some
    transitional work across the ecosystem before threading can be widely adopted with confidence. See
    the next section for further details.

### 24.9 Safe use of Finalizers

Because finalizers can interrupt any code, they must be very careful in how they interact with any global state.
Unfortunately, the main reason that finalizers are used is to update global state (a pure function is generally
rather pointless as a finalizer). This leads us to a bit of a conundrum. There are a few approaches to dealing
with this problem:

1. When single-threaded, code could call the internaljl_gc_enable_finalizersC function to prevent
    finalizers from being scheduled inside a critical region. Internally, this is used inside some functions
    (such as our C locks) to prevent recursion when doing certain operations (incremental package loading,
    codegen, etc.). The combination of a lock and this flag can be used to make finalizers safe.
2. A second strategy, employed by Base in a couple places, is to explicitly delay a finalizer until it may be
    able to acquire its lock non-recursively. The following example demonstrates how this strategy could be
    applied toDistributed.finalize_ref:

```

function finalize_ref(r::AbstractRemoteRef)  
if r.where> 0 # Check if the finalizer is already run  
if islocked(client_refs)|| !trylock(client_refs)

# delay finalizer for later if we aren't free to acquire the lock

finalizer(finalize_ref, r)  
return nothing  
end  
try # `lock` should always be followed by `try`  
if r.where> 0 # Must check again here

```

#### CHAPTER 24. MULTI-THREADING 269

```

# Do actual cleanup here

r.where= 0  
end  
finally  
unlock(client_refs)  
end  
end  
nothing  
end

```
3. A related third strategy is to use a yield-free queue. We don't currently have a lock-free queue imple-
    mented in Base, butBase.InvasiveLinkedListSynchronized{T}is suitable. This can frequently be
    a good strategy to use for code with event loops. For example, this strategy is employed byGtk.jl
    to manage lifetime ref-counting. In this approach, we don't do any explicit work inside thefinalizer,
    and instead add it to a queue to run at a safer time. In fact, Julia's task scheduler already uses this, so
    defining the finalizer asx -> @spawn do_cleanup(x)is one example of this approach. Note however
    that this doesn't control which threaddo_cleanupruns on, sodo_cleanupwould still need to acquire
    a lock. That doesn't need to be true if you implement your own queue, as you can explicitly only drain
    that queue from your thread.


**Chapter 25**

**Multi-processing and Distributed Computing**

An implementation of distributed memory parallel computing is provided by moduleDistributedas part of
the standard library shipped with Julia.

Most modern computers possess more than one CPU, and several computers can be combined together in a
cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly.
There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of
their access to memory. In a cluster, it's fairly obvious that a given CPU will have fastest access to the RAM
within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore
laptop, due to differences in the speed of main memory and thecache. Consequently, a good multiprocessing
environmentshouldallowcontroloverthe"ownership"ofachunkofmemorybyaparticularCPU.Juliaprovides
a multiprocessing environment based on message passing to allow programs to run on multiple processes in
separate memory domains at once.

Julia's implementation of message passing is different from other environments such as MPI^1. Communication
inJuliaisgenerally"one-sided", meaningthattheprogrammerneedstoexplicitlymanageonlyoneprocessina
two-process operation. Furthermore, these operations typically do not look like"message send" and "message
receive" but rather resemble higher-level operations like calls to user functions.

Distributed programming in Julia is built on two primitives: remote references and remote calls. A remote
reference is an object that can be used from any process to refer to an object stored on a particular process.
A remote call is a request by one process to call a certain function on certain arguments on another (possibly
the same) process.

Remote references come in two flavors:FutureandRemoteChannel.

A remote call returns aFutureto its result. Remote calls return immediately; the process that made the call
proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call
to finish by callingwaiton the returnedFuture, and you can obtain the full value of the result usingfetch.

On the other hand,RemoteChannels are rewritable. For example, multiple processes can co-ordinate their
processing by referencing the same remoteChannel.

Each process has an associated identifier. The process providing the interactive Julia prompt always has anid
equal to 1. The processes used by default for parallel operations are referred to as"workers". When there is
onlyoneprocess, process1isconsideredaworker. Otherwise, workersareconsideredtobeallprocessesother
than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing
methods likepmap. Adding a single process is beneficial if you just wish to do other things in the main process
while a long computation is running on the worker.

Let 's try this out. Starting withjulia -p nprovidesnworker processes on the local machine. Generally
it makes sense fornto equal the number of CPU threads (logical cores) on the machine. Note that the-p
argument implicitly loads moduleDistributed.

#### 270


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 271

```

$ julia-p 2

julia> r = remotecall(rand,2, 2, 2)  
Future(2, 1, 4, nothing)

julia> s = @spawnat2 1 .+ fetch(r)  
Future(2, 1, 5, nothing)

julia> fetch(s)  
2×2 Array { Float64 ,2}:  
1.18526 1.50912  
1.16296 1.60607

```
The first argument toremotecallis the function to call. Most parallel programming in Julia does not reference
specific processes or the number of processes available, butremotecallis considered a low-level interface
providing finer control. The second argument toremotecallis theidof the process that will do the work, and
the remaining arguments will be passed to the function being called.

As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line
we asked it to add 1 to it. The result of both calculations is available in the two futures,rands. The@spawnat
macro evaluates the expression in the second argument on the process specified by the first argument.

Occasionally you might want a remotely-computed value immediately. This typically happens when you read
fromaremoteobjecttoobtaindataneededbythenextlocaloperation. Thefunctionremotecall_fetchexists
for this purpose. It is equivalent tofetch(remotecall(...))but is more efficient.

```

julia> remotecall_fetch(r-> fetch(r)[1, 1], 2, r)  
0.18526337335308085

```
This fetches the array on worker 2 and returns the first value. Note, thatfetchdoesn't move any data in this
case, since it's executed on the worker that owns the array. One can also write:

```

julia> remotecall_fetch(getindex,2, r,1, 1)  
0.10824216411304866

```
Remember thatgetindex(r,1,1)is equivalenttor[1,1], so this call fetches the first element of the future
r.

To make things easier, the symbol:anycan be passed to@spawnat, which picks where to do the operation for
you:

```

julia> r = @spawnat:any rand(2,2)  
Future(2, 1, 4, nothing)

julia> s = @spawnat:any 1 .+ fetch(r)  
Future(3, 1, 5, nothing)

julia> fetch(s)  
2×2 Array{Float64,2}:  
1.38854 1.9098  
1.20939 1.57158

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 272

Note that we used1 .+ fetch(r)instead of1 .+ r. This is because we do not know where the code will run,
so in general afetchmight be required to moverto the process doing the addition. In this case,@spawnatis
smart enough to perform the computation on the process that ownsr, so thefetchwill be a no-op (no work
is done).

(It is worth noting that@spawnatis not built-in but defined in Julia as amacro. It is possible to define your own
such constructs.)

An important thing to remember is that, once fetched, aFuturewill cache its value locally. Furtherfetchcalls
do not entail a network hop. Once all referencingFutures have fetched, the remote stored value is deleted.

@asyncis similar to@spawnat, but only runs tasks on the local process. We use it to create a"feeder" task for
each process. Each task picks the next index that needs to be computed, then waits for its process to finish,
then repeats until we run out of indices. Note that the feeder tasks do not begin to execute until the main
task reaches the end of the@syncblock, at which point it surrenders control and waits for all the local tasks to
complete before returning from the function. As for v0.7 and beyond, the feeder tasks are able to share state
vianextidxbecause they all run on the same process. Even ifTasksare scheduled cooperatively, locking
may still be required in some contexts, as inasynchronous I/O. This means context switches only occur at well-
defined points: in this case, whenremotecall_fetchis called. This is the current state of implementation and
it may change for future Julia versions, as it is intended to make it possible to run up to NTaskson MProcess,
aka M:N Threading. Then a lock acquiring\releasing model fornextidxwill be needed, as it is not safe to let
multiple processes read-write a resource at the same time.

### 25.1 Code Availability and Loading Packages.

Your code must be available on any process that runs it. For example, type the following into the Julia prompt:

```

julia>function rand2(dims...)  
return 2*rand(dims...)  
end

julia> rand2(2,2)  
2×2 Array{Float64,2}:  
0.153756 0.368514  
1.15119 0.918912

julia> fetch(@spawnat:any rand2(2,2))  
ERROR: RemoteException(2, CapturedException(UndefVarError(Symbol("#rand2"))  
Stacktrace:  
[...]

```
Process 1 knew about the functionrand2, but process 2 did not.

Most commonly you'll be loading code from files or packages, and you have a considerable amount of flexibility
in controlling which processes load code. Consider a file,DummyModule.jl, containing the following code:

```

module DummyModule

export MyType, f

mutable struct MyType  
a:: Int  
end

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 273

```

f(x)= x^2+1

println("loaded")

end

```
In order to refer toMyTypeacross all processes,DummyModule.jlneeds to be loaded on every process. Call-
inginclude("DummyModule.jl")loads it only on a single process. To load it on every process, use the
@everywheremacro (starting Julia withjulia -p 2):

```

julia> @everywhereinclude("DummyModule.jl")  
loaded  
From worker 3: loaded  
From worker 2: loaded

```
As usual, this does not bringDummyModuleinto scope on any of the process, which requiresusingorimport.
Moreover, whenDummyModuleis brought into scope on one process, it is not on any other:

```

julia>using .DummyModule

julia> MyType(7)  
MyType(7)

julia> fetch(@spawnat2 MyType(7))  
ERROR: On worker 2:  
UndefVarError: MyType not defined

julia> fetch(@spawnat2 DummyModule.MyType(7))  
MyType(7)

```
However, it's still possible, for instance, to send aMyTypeto a process which has loadedDummyModuleeven if
it's not in scope:

```

julia> put!(RemoteChannel(2), MyType(7))  
RemoteChannel{Channel{Any}}(2, 1, 13)

```
A file can also be preloaded on multiple processes at startup with the-Lflag, and a driver script can be used
to drive the computation:

```

julia -p -L file1.jl -L file2.jl driver.jl

```
The Julia process running the driver script in the example above has anidequal to 1, just like a process
providing an interactive prompt.

Finally,ifDummyModule.jlisnotastandalonefilebutapackage,thenusing DummyModulewillloadDummyModule.jl
on all processes, but only bring it into scope on the process whereusingwas called.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 274

### 25.2 Starting and managing worker processes.

The base Julia installation has in-built support for two types of clusters:

- A local cluster specified with the-poption as shown above.
- A cluster spanning machines using the--machine-fileoption. This uses a passwordlesssshlogin to
    start Julia worker processes (from the same path as the current host) on the specified machines. Each
    machine definition takes the form[count*][user@]host[:port] [bind_addr[:port]].userdefaults
    to current user,portto the standard ssh port.countis the number of workers to spawn on the node,
    and defaults to 1. The optionalbind-to bind_addr[:port]specifies the IP address and port that other
    workers should use to connect to this worker.

Functionsaddprocs,rmprocs,workers,andothersareavailableasaprogrammaticmeansofadding,removing
and querying the processes in a cluster.

```

julia>using Distributed

julia> addprocs(2)  
2-element Array{Int64,1}:  
2  
3

```
ModuleDistributedmust be explicitly loaded on the master process before invokingaddprocs. It is auto-
matically made available on the worker processes.

Note that workers do not run a~/.julia/config/startup.jlstartup script, nor do they synchronize their
global state (such as global variables, new method definitions, and loaded modules) with any of the other
running processes. You may useaddprocs(exeflags="--project")to initialize a worker with a particular
environment, and then@everywhere using <modulename>or@everywhere include("file.jl").

Other types of clusters can be supported by writing your own customClusterManager, as described below in
the ClusterManagerssection.

### 25.3 Data Movement

Sending messages and moving data constitute most of the overhead in a distributed program. Reducing the
number of messages and the amount of data sent is critical to achieving performance and scalability. To this
end, it is important to understand the data movement performed by Julia's various distributed programming
constructs.

fetchcan be considered an explicit data movement operation, since it directly asks that an object be moved
to the local machine.@spawnat(and a few related constructs) also moves data, but this is not as obvious,
hence it can be called an implicit data movement operation. Consider these two approaches to constructing
and squaring a random matrix:

Method 1:

```

julia> A = rand(1000,1000);

julia> Bref= @spawnat:any A^2;

[...]

julia> fetch(Bref);

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 275

Method 2:

```

julia> Bref= @spawnat:any rand(1000,1000)^2;

[...]

julia> fetch(Bref);

```
Thedifferenceseemstrivial, butin factis quitesignificantdue tothe behaviorof@spawnat. In thefirst method,
arandommatrixisconstructedlocally, thensenttoanotherprocesswhereitissquared. Inthesecondmethod,
a random matrix is both constructed and squared on another process. Therefore the second method sends
much less data than the first.

In this toy example, the two methods are easy to distinguish and choose from. However, in a real program
designing data movement might require more thought and likely some measurement. For example, if the first
process needs matrixAthen the first method might be better. Or, if computingAis expensive and only the
current process has it, then moving it to another process might be unavoidable. Or, if the current process
has very little to do between the@spawnatandfetch(Bref), it might be better to eliminate the parallelism
altogether. Or imaginerand(1000,1000)is replaced with a more expensive operation. Then it might make
sense to add another@spawnatstatement just for this step.

### 25.4 Global variables

Expressions executed remotely via@spawnat, or closures specified for remote execution usingremotecall
may refer to global variables. Global bindings under moduleMainare treated a little differently compared to
global bindings in other modules. Consider the following code snippet:

```

A = rand(10,10)  
remotecall_fetch(()->sum(A), 2)

```
In this casesumMUST be defined in the remote process. Note thatAis a global variable defined in the local
workspace. Worker 2 does not have a variable calledAunderMain. The act of shipping the closure()->sum(A)
to worker 2 results inMain.Abeing defined on 2.Main.Acontinues to exist on worker 2 even after the call
remotecall_fetchreturns. Remote calls with embedded global references (underMainmodule only) manage
globals as follows:

- New global bindings are created on destination workers if they are referenced as part of a remote call.
- Global constants are declared as constants on remote nodes too.
- Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value
    has changed. Also, the cluster does not synchronize global bindings across nodes. For example:

```

A = rand(10,10)  
remotecall_fetch(()->sum(A),2) # worker 2  
A = rand(10,10)  
remotecall_fetch(()->sum(A),3) # worker 3  
A = nothing

Executing the above snippet results inMain.Aon worker 2 having a different value fromMain.Aon  
worker 3, while the value ofMain.Aon node 1 is set tonothing.

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 276

As you may have realized, while memory associated with globals may be collected when they are reassigned
on the master, no such action is taken on the workers as the bindings continue to be valid.clear!can be
used to manually reassign specific globals on remote nodes tonothingonce they are no longer required. This
will release any memory associated with them as part of a regular garbage collection cycle.

Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them
altogether if possible. If you must reference globals, consider usingletblocks to localize global variables.

For example:

```

julia> A = rand(10,10);

julia> remotecall_fetch(()->A, 2);

julia> B = rand(10,10);

julia>let B = B  
remotecall_fetch(()->B, 2)  
end ;

julia> @fetchfrom2 InteractiveUtils.varinfo()  
name size summary  
––––––––– ––––––––– ––––––––––––––––––––––  
A 800 bytes 10×10 Array{Float64,2}  
Base Module  
Core Module  
Main Module

```
As can be seen, global variableAis defined on worker 2, butBis captured as a local variable and hence a
binding forBdoes not exist on worker 2.

### 25.5 Parallel Map and Loops

Fortunately, many useful parallel computations do not require data movement. A common example is a Monte
Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can
use@spawnatto flip coins on two processes. First, write the following function incount_heads.jl:

```

function count_heads(n)  
c:: Int = 0  
for i = 1:n  
c += rand( Bool )  
end  
c  
end

```
The functioncount_headssimply adds togethernrandom bits. Here is how we can perform some trials on two
machines, and add together the results:

```

julia> @everywhereinclude_string(Main,$(read("count_heads.jl", String)),"count_heads.jl")

julia> a = @spawnat:any count_heads( 100000000 )  
Future(2, 1, 6, nothing)

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 277

```

julia> b = @spawnat:any count_heads( 100000000 )  
Future(3, 1, 7, nothing)

julia> fetch(a)+fetch(b)  
100001564

```
Thisexampledemonstratesapowerfulandoften-usedparallelprogrammingpattern. Manyiterationsruninde-
pendently over several processes, and then their results are combined using some function. The combination
process is called a reduction, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a
single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pat-
ternx = f(x,v[i]), wherexis the accumulator,fis the reduction function, and thev[i]are the elements
being reduced. It is desirable forfto be associative, so that it does not matter what order the operations are
performed in.

Notice that our use of this pattern withcount_headscan be generalized. We used two explicit@spawnat
statements, which limits the parallelism to two processes. To run on any number of processes, we can use a
parallel for loop, running in distributed memory, which can be written in Julia using@distributedlike this:

```

nheads= @distributed(+) for i = 1:200000000  
Int (rand( Bool ))  
end

```
This construct implements the pattern of assigning iterations to multiple processes, and combining them with
a specified reduction (in this case(+)). The result of each iteration is taken as the value of the last expression
inside the loop. The whole parallel loop expression itself evaluates to the final answer.

Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In par-
ticular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally
visible since iterations run on different processes. Any variables used inside the parallel loop will be copied
and broadcast to each process.

For example, the following code will not work as intended:

```

a = zeros( 100000 )  
@distributed for i = 1:100000  
a[i]= i  
end

```
This code will not initialize all ofa, since each process will have a separate copy of it. Parallel for loops like
these must be avoided. Fortunately,Shared Arrayscan be used to get around this limitation:

```

using SharedArrays

a = SharedArray { Float64 }(10)  
@distributed for i = 1:10  
a[i]= i  
end

```
Using "outside" variables in parallel loops is perfectly reasonable if the variables are read-only:

```

a = randn(1000)  
@distributed(+) for i = 1:100000  
f(a[rand(1: end )])  
end

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 278

Here each iteration appliesfto a randomly-chosen sample from a vectorashared by all processes.

As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes
asynchronously, i.e. it spawns independent tasks on all available workers and returns an array ofFuture
immediately without waiting for completion. The caller can wait for theFuturecompletions at a later point
by callingfetchon them, or wait for completion at the end of the loop by prefixing it with@sync, like@sync
@distributed for.

In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some
range (or, more generally, to all elements in some collection). This is another useful operation called parallel
map, implemented in Julia as thepmapfunction. For example, we could compute the singular values of several
large random matrices in parallel as follows:

```

julia> M = Matrix { Float64 }[rand(1000,1000) for i = 1:10];

julia> pmap(svdvals, M);

```
Julia'spmapis designed for the case where each function call does a large amount of work. In contrast,
@distributed forcan handle situations where each iteration is tiny, perhaps merely summing two num-
bers. Only worker processes are used by bothpmapand@distributed forfor the parallel computation. In
case of@distributed for, the final reduction is done on the calling process.

### 25.6 Remote References and AbstractChannels

Remote references always refer to an implementation of anAbstractChannel.

A concrete implementation of anAbstractChannel(likeChannel), is required to implementput!,take!,
fetch,isreadyandwait. The remote object referred to by aFutureis stored in aChannel{Any}(1), i.e., a
Channelof size 1 capable of holding objects ofAnytype.

RemoteChannel, which is rewritable, can point to any type and size of channels, or any other implementation
of anAbstractChannel.

The constructorRemoteChannel(f::Function, pid)()allows us to construct references to channels holding
morethanonevalueofaspecifictype.fisafunctionexecutedonpidanditmustreturnanAbstractChannel.

For example,RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of typeInt
and size 10. The channel exists on workerpid.

Methodsput!,take!,fetch,isreadyandwaiton aRemoteChannelare proxied onto the backing store on
the remote process.

RemoteChannelcan thus be used to refer to user implementedAbstractChannelobjects. A simple example
of this is provided indictchannel.jlin the Examples repository, which uses a dictionary as its remote store.

### 25.7 Channels and RemoteChannels

- AChannelis local to a process. Worker 2 cannot directly refer to aChannelon worker 3 and vice-versa.
    ARemoteChannel, however, can put and take values across workers.
- ARemoteChannelcan be thought of as a handle to aChannel.
- The process id,pid, associated with aRemoteChannelidentifies the process where the backing store,
    i.e., the backingChannelexists.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 279

- Any process with a reference to aRemoteChannelcan put and take items from the channel. Data is
    automatically sent to (or retrieved from) the process aRemoteChannelis associated with.
- SerializingaChannelalsoserializesanydatapresentinthechannel. Deserializingitthereforeeffectively
    makes a copy of the original object.
- On the other hand, serializing aRemoteChannelonly involves the serialization of an identifier that iden-
    tifies the location and instance ofChannelreferred to by the handle. A deserializedRemoteChannel
    object (on any worker), therefore also points to the same backing store as the original.

The channels example from above can be modified for interprocess communication, as shown below.

We start 4 workers to process a singlejobsremote channel. Jobs, identified by an id (job_id), are written
to the channel. Each remotely executing task in this simulation reads ajob_id, waits for a random amount
of time and writes back a tuple ofjob_id, time taken and its ownpidto the results channel. Finally all the
resultsare printed out on the master process.

```

julia> addprocs(4); # add worker processes

julia>const jobs= RemoteChannel(()-> Channel { Int }(32));

julia>const results= RemoteChannel(()-> Channel { Tuple }(32));

julia> @everywhere function do_work(jobs, results)# define work function everywhere  
whiletrue  
job_id= take!(jobs)  
exec_time= rand()  
sleep(exec_time)# simulates elapsed time doing actual work  
put!(results, (job_id, exec_time, myid()))  
end  
end

julia>function make_jobs(n)  
for i in 1:n  
put!(jobs, i)  
end  
end ;

julia> n = 12;

julia> errormonitor(@asyncmake_jobs(n));# feed the jobs channel with "n" jobs

julia>for p in workers()# start tasks on the workers to process requests in parallel  
remote_do(do_work, p, jobs, results)  
end

julia> @elapsed while n > 0 # print out results  
job_id, exec_time, where= take!(results)  
println(" $job_id finished in $ (round(exec_time; digits=2)) seconds on worker $where ")  
global n = n - 1  
end  
1 finished in 0.18 seconds on worker 4  
2 finished in 0.26 seconds on worker 5  
6 finished in 0.12 seconds on worker 4  
7 finished in 0.18 seconds on worker 4  
5 finished in 0.35 seconds on worker 5

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 280

```

4 finished in 0.68 seconds on worker 2  
3 finished in 0.73 seconds on worker 3  
11 finished in 0.01 seconds on worker 3  
12 finished in 0.02 seconds on worker 3  
9 finished in 0.26 seconds on worker 5  
8 finished in 0.57 seconds on worker 4  
10 finished in 0.58 seconds on worker 2  
0.055971741

```
### Remote References and Distributed Garbage Collection

Objects referred to by remote references can be freed only when all held references in the cluster are deleted.

The node where the value is stored keeps track of which of the workers have a reference to it. Every time a
RemoteChannelor a (unfetched)Futureis serialized to a worker, the node pointed to by the reference is noti-
fied. And every time aRemoteChannelor a (unfetched)Futureis garbage collected locally, the node owning
the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are
only valid in the context of a running cluster. Serializing and deserializing references to and from regularIO
objects is not supported.

Thenotificationsaredoneviasendingof"tracking"messages–an"addreference"messagewhenareferenceis
serializedtoadifferentprocessanda"deletereference"messagewhenareferenceislocallygarbagecollected.

SinceFutures are write-once and cached locally, the act offetching aFuturealso updates reference tracking
information on the node owning the value.

The node which owns the value frees it once all references to it are cleared.

WithFutures, serializing an already fetchedFutureto a different node also sends the value since the original
remote store may have collected the value by this time.

It is important to note that when an object is locally garbage collected depends on the size of the object and
the current memory pressure in the system.

In case of remote references, the size of the local reference object is quite small, while the value stored on
the remote node may be quite large. Since the local object may not be collected immediately, it is a good
practice to explicitly callfinalizeon local instances of aRemoteChannel, or on unfetchedFutures. Since
callingfetchon aFuturealso removes its reference from the remote store, this is not required on fetched
Futures. Explicitly callingfinalizeresults in an immediate message sent to the remote node to go ahead
and remove its reference to the value.

Once finalized, a reference becomes invalid and cannot be used in any further calls.

### 25.8 Local invocations

Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and
when data is stored to aRemoteChannel/Futureon a different node. As expected, this results in a copy of the
serialized objects on the remote node. However, when the destination node is the local node, i.e. the calling
process id is the same as the remote node id, it is executed as a local call. It is usually (not always) executed in
a different task - but there is no serialization/deserialization of data. Consequently, the call refers to the same
object instances as passed - no copies are created. This behavior is highlighted below:

```

julia>using Distributed;

julia> rc = RemoteChannel(()-> Channel (3)); # RemoteChannel created on local node

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 281

```

julia> v = [0];

julia>for i in 1:3  
v[1] = i # Reusing `v`  
put!(rc, v)  
end ;

julia> result= [take!(rc) for _ in 1:3];

julia> println(result);  
Array{Int64,1}[[3], [3], [3]]

julia> println("Num Unique objects : ", length(unique(map(objectid, result))));  
Num Unique objects : 1

julia> addprocs(1);

julia> rc = RemoteChannel(()-> Channel (3), workers()[1]); # RemoteChannel created on remote node

julia> v = [0];

julia>for i in 1:3  
v[1] = i  
put!(rc, v)  
end ;

julia> result= [take!(rc) for _ in 1:3];

julia> println(result);  
Array{Int64,1}[[1], [2], [3]]

julia> println("Num Unique objects : ", length(unique(map(objectid, result))));  
Num Unique objects : 3

```
As can be seen,put!on a locally ownedRemoteChannelwith the same objectvmodifed between calls results
in the same single object instance stored. As opposed to copies ofvbeing created when the node owningrc
is a different node.

It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both
being stored locally and modifed post the call. In such cases it may be appropriate to store adeepcopyof the
object.

This is also true for remotecalls on the local node as seen in the following example:

```

julia>using Distributed; addprocs(1);

julia> v = [0];

julia> v2 = remotecall_fetch(x->(x[1] = 1; x), myid(), v); # Executed on local node

julia> println("v= $v , v2= $v2 , " , v === v2);  
v=[1], v2=[1], true

julia> v = [0];

julia> v2 = remotecall_fetch(x->(x[1] = 1; x), workers()[1], v);# Executed on remote node

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 282

```

julia> println("v= $v , v2= $v2 , " , v === v2);  
v=[0], v2=[1], false

```
As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call
modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.

To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the
arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments
must be passed to the call invoked on the local node. Calls on remote nodes will always operate on copies of
arguments.

### 25.9 Shared Arrays

SharedArraysusesystemsharedmemorytomapthesamearrayacrossmanyprocesses. Whiletherearesome
similarities to aDArray, the behavior of aSharedArrayis quite different. In aDArray, each process has local
access to just a chunk of the data, and no two processes share the same chunk; in contrast, in aSharedArray
each "participating" process has access to the entire array. ASharedArrayis a good choice when you want to
have a large amount of data jointly accessible to two or more processes on the same machine.

Shared Array support is available via moduleSharedArrayswhich must be explicitly loaded on all participating
workers.

SharedArrayindexing (assignment and accessing values) works just as with regular arrays, and is efficient
because the underlying memory is available to the local process. Therefore, most algorithms work naturally
onSharedArrays, albeit in single-process mode. In cases where an algorithm insists on anArrayinput, the
underlyingarraycanberetrievedfromaSharedArraybycallingsdata. ForotherAbstractArraytypes,sdata
just returns the object itself, so it's safe to usesdataon anyArray-type object.

The constructor for a shared array is of the form:

```

SharedArray {T,N}(dims:: NTuple ; init= false , pids= Int [])

```
which creates anN-dimensional shared array of a bits typeTand sizedimsacross the processes specified by
pids. Unlike distributed arrays, a shared array is accessible only from those participating workers specified by
thepidsnamed argument (and the creating process too, if it is on the same host). Note that only elements
that areisbitsare supported in a SharedArray.

If aninitfunction, of signatureinitfn(S::SharedArray), is specified, it is called on all the participating
workers. You can specify that each worker runs theinitfunction on a distinct portion of the array, thereby
parallelizing initialization.

Here 's a brief example:

```

julia>using Distributed

julia> addprocs(3)  
3-element Array{Int64,1}:  
2  
3  
4

julia> @everywhere using SharedArrays

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 283

```

julia> S = SharedArray { Int ,2}((3,4), init= S -> S[localindices(S)]= repeat([myid()],  
↪→ length(localindices(S))))  
3×4 SharedArray{Int64,2}:  
2 2 3 4  
2 3 3 4  
2 3 4 4

julia> S[3,2] = 7  
7

julia> S  
3×4 SharedArray{Int64,2}:  
2 2 3 4  
2 3 3 4  
2 7 4 4

```
SharedArrays.localindicesprovides disjoint one-dimensional ranges of indices, and is sometimes conve-
nient for splitting up tasks among processes. You can, of course, divide the work any way you wish:

```

julia> S = SharedArray { Int ,2}((3,4), init= S -> S[indexpids(S):length(procs(S)):length(S)]=  
↪→ repeat([myid()], length( indexpids(S):length(procs(S)):length(S))))  
3×4 SharedArray{Int64,2}:  
2 2 2 2  
3 3 3 3  
4 4 4 4

```
Since all processes have access to the underlying data, you do have to be careful not to set up conflicts. For
example:

```

@sync begin  
for p in procs(S)  
@async begin  
remotecall_wait(fill!, p, S, p)  
end  
end  
end

```
would result in undefined behavior. Because each process fills the entire array with its ownpid, whichever
process is the last to execute (for any particular element ofS) will have itspidretained.

As a more extended and complex example, consider running the following"kernel " in parallel:

```

q[i,j,t+1] = q[i,j,t]+ u[i,j,t]

```
In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble:
ifq[i,j,t]is near the end of the block assigned to one worker andq[i,j,t+1]is near the beginning of
the block assigned to another, it's very likely thatq[i,j,t]will not be ready at the time it's needed for
computingq[i,j,t+1]. In such cases, one is better off chunking the array manually. Let's split along the
second dimension. Define a function that returns the(irange, jrange)indices assigned to this worker:

```

julia> @everywhere function myrange(q:: SharedArray )  
idx = indexpids(q)

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 284

```

if idx == 0 # This worker is not assigned a piece  
return 1:0, 1:0  
end  
nchunks= length(procs(q))  
splits= [round( Int , s) for s in range(0, stop=size(q,2), length=nchunks+1)]  
1:size(q,1), splits[idx]+1:splits[idx+1]  
end

```
Next, define the kernel:

```

julia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)  
@show(irange, jrange, trange) # display so we can see what's happening  
for t in trange, j in jrange, i in irange  
q[i,j,t+1] = q[i,j,t]+ u[i,j,t]  
end  
q  
end

```
We also define a convenience wrapper for aSharedArrayimplementation

```

julia> @everywhereadvection_shared_chunk!(q, u)=  
advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)

```
Now let's compare three different versions, one that runs in a single process:

```

julia> advection_serial!(q, u)= advection_chunk!(q, u,1:size(q,1), 1:size(q,2), 1:size(q,3)-1);

```
one that uses@distributed:

```

julia>function advection_parallel!(q, u)  
for t = 1:size(q,3)-1  
@sync@distributed for j = 1:size(q,2)  
for i = 1:size(q,1)  
q[i,j,t+1]= q[i,j,t]+ u[i,j,t]  
end  
end  
end  
q  
end ;

```
and one that delegates in chunks:

```

julia>function advection_shared!(q, u)  
@sync begin  
for p in procs(q)  
@asyncremotecall_wait(advection_shared_chunk!, p, q, u)  
end  
end  
q  
end ;

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 285

If we createSharedArrays and time these functions, we get the following results (withjulia -p 4):

```

julia> q = SharedArray { Float64 ,3}((500,500,500));

julia> u = SharedArray { Float64 ,3}((500,500,500));

```
Run the functions once to JIT-compile and@timethem on the second run:

```

julia> @timeadvection_serial!(q, u);  
(irange,jrange,trange) = (1:500,1:500,1:499)  
830.220 milliseconds (216 allocations: 13820 bytes)

julia> @timeadvection_parallel!(q, u);  
2.495 seconds (3999 k allocations: 289 MB, 2.09% gc time)

julia> @timeadvection_shared!(q,u);  
From worker2: (irange,jrange,trange)= (1:500,1:125,1:499)  
From worker4: (irange,jrange,trange)= (1:500,251:375,1:499)  
From worker3: (irange,jrange,trange)= (1:500,126:250,1:499)  
From worker5: (irange,jrange,trange)= (1:500,376:500,1:499)  
238.119 milliseconds (2264 allocations: 169 KB)

```
The biggest advantage ofadvection_shared!is that it minimizes traffic among the workers, allowing each to
compute for an extended time on the assigned piece.

### Shared Arrays and Distributed Garbage Collection

Likeremotereferences, sharedarraysarealsodependentongarbagecollectiononthecreatingnodetorelease
references from all participating workers. Code which creates many short lived shared array objects would
benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles
mapping the shared segment being released sooner.

### 25.10ClusterManagers.

The launching, management and networking of Julia processes into a logical cluster is done via cluster man-
agers. AClusterManageris responsible for

- launching worker processes in a cluster environment
- managing events during the lifetime of each worker
- optionally, providing data transport

A Julia cluster has the following characteristics:

- The initial Julia process, also called themaster, is special and has anidof 1.
- Only themasterprocess can add or remove worker processes.
- All processes can directly communicate with each other.

Connections between workers (using the in-built TCP/IP transport) is established in the following manner:


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 286

- addprocsis called on the master process with aClusterManagerobject.
- addprocscalls the appropriatelaunchmethod which spawns required number of worker processes on
    appropriate machines.
- Each worker starts listening on a free port and writes out its host and port information tostdout.
- The cluster manager captures thestdoutof each worker and makes it available to the master process.
- The master process parses this information and sets up TCP/IP connections to each worker.
- Every worker is also notified of other workers in the cluster.
- Each worker connects to all workers whoseidis less than the worker's ownid.
- In this way a mesh network is established, wherein every worker is directly connected with every other
    worker.

While the default transport layer uses plainTCPSocket, it is possible for a Julia cluster to provide its own
transport.

Julia provides two in-built cluster managers:

- LocalManager, used whenaddprocs()oraddprocs(np::Integer)are called
- SSHManager, used whenaddprocs(hostnames::Array)is called with a list of hostnames

LocalManageris used to launch additional workers on the same host, thereby leveraging multi-core and multi-
processor hardware.

Thus, a minimal cluster manager would need to:

- be a subtype of the abstractClusterManager
- implementlaunch, a method responsible for launching new workers
- implementmanage, which is called at various events during a worker's lifetime (for example, sending an
    interrupt signal)

addprocs(manager::FooManager)requiresFooManagerto implement:

```

function launch(manager::FooManager, params:: Dict , launched:: Array , c :: Condition )  
[...]  
end

function manage(manager::FooManager, id:: Integer , config:: WorkerConfig , op :: Symbol )  
[...]  
end

```
As an example let us see how theLocalManager, the manager responsible for starting workers on the same
host, is implemented:


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 287

```

struct LocalManager<: ClusterManager  
np:: Integer  
end

function launch(manager::LocalManager, params:: Dict , launched:: Array , c :: Condition )  
[...]  
end

function manage(manager::LocalManager, id:: Integer , config:: WorkerConfig , op :: Symbol )  
[...]  
end

```
Thelaunchmethod takes the following arguments:

- manager::ClusterManager: the cluster manager thataddprocsis called with
- params::Dict: all the keyword arguments passed toaddprocs
- launched::Array: the array to append one or moreWorkerConfigobjects to
- c::Condition: the condition variable to be notified as and when workers are launched

Thelaunchmethod is called asynchronously in a separate task. The termination of this task signals that all
requested workers have been launched. Hence thelaunchfunction MUST exit as soon as all the requested
workers have been launched.

Newlylaunchedworkersareconnectedtoeachotherandthemasterprocessinanall-to-allmanner. Specifying
the command line argument--worker[=<cookie>]results in the launched processes initializing themselves
as workers and connections being set up via TCP/IP sockets.

All workers in a cluster share the samecookieas the master. When the cookie is unspecified, i.e, with the
--workeroption, the worker tries to read it from its standard input.LocalManagerandSSHManagerboth pass
the cookie to newly launched workers via their standard inputs.

By default a worker will listen on a free port at the address returned by a call togetipaddr(). A specific
address to listen on may be specified by optional argument--bind-to bind_addr[:port]. This is useful for
multi-homed hosts.

As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case--worker
must NOT be specified. Instead, newly launched workers should callinit_worker(cookie)before using any
of the parallel constructs.

For every worker launched, thelaunchmethod must add aWorkerConfigobject (with appropriate fields ini-
tialized) tolaunched

```

mutable struct WorkerConfig

# Common fields relevant to all cluster managers

io:: Union { IO , Nothing}  
host:: Union { AbstractString , Nothing}  
port:: Union { Integer , Nothing}

# Used when launching additional workers at a host

count:: Union { Int , Symbol , Nothing}  
exename:: Union { AbstractString , Cmd , Nothing}  
exeflags:: Union { Cmd , Nothing}

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 288

```

# External cluster managers can use this to store information at a per-worker level

# Can be a dict if multiple fields need to be stored.

userdata:: Any

# SSHManager / SSH tunnel connections to workers

tunnel:: Union { Bool , Nothing}  
bind_addr:: Union { AbstractString , Nothing}  
sshflags:: Union { Cmd , Nothing}  
max_parallel:: Union { Integer , Nothing}

# Used by Local/SSH managers

connect_at:: Any

[...]  
end

```
Most of the fields inWorkerConfigare used by the inbuilt managers. Custom cluster managers would typically
specify onlyioorhost/port:

- Ifiois specified, it is used to read host/port information. A Julia worker prints out its bind address and
    port at startup. This allows Julia workers to listen on any free port available instead of requiring worker
    ports to be configured manually.
- Ifiois not specified,hostandportare used to connect.
- count,exenameandexeflagsare relevant for launching additional workers from a worker. For example,
    a cluster manager may launch a single worker per node, and use that to launch additional workers.
       **-** countwith an integer valuenwill launch a total ofnworkers.
       **-** countwith a value of:autowill launch as many workers as the number of CPU threads (logical
          cores) on that machine.
       **-** exenameis the name of thejuliaexecutable including the full path.
       **-** exeflagsshould be set to the required command line arguments for new workers.
- tunnel,bind_addr,sshflagsandmax_parallelare used when a ssh tunnel is required to connect to
    the workers from the master process.
- userdatais provided for custom cluster managers to store their own worker-specific information.

manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)is called at different
times during the worker's lifetime with appropriateopvalues:

- with:register/:deregisterwhen a worker is added / removed from the Julia worker pool.
- with:interruptwheninterrupt(workers)is called. TheClusterManagershould signal the appropri-
    ate worker with an interrupt signal.
- with:finalizefor cleanup purposes.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 289

### Cluster Managers with Custom Transports

Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved.
Each Julia process has as many communication tasks as the workers it is connected to. For example, consider
a Julia cluster of 32 processes in an all-to-all mesh network:

- Each Julia process thus has 31 communication tasks.
- Each task handles all incoming messages from a single remote worker in a message-processing loop.
- The message-processing loop waits on anIOobject (for example, aTCPSocketin the default implemen-
    tation), reads an entire message, processes it and waits for the next one.
- Sending messages to a process is done directly from any Julia task–not just communication tasks–again,
    via the appropriateIOobject.

Replacing the default transport requires the new implementation to set up connections to remote workers
and to provide appropriateIOobjects that the message-processing loops can wait on. The manager-specific
callbacks to be implemented are:

```

connect(manager::FooManager, pid:: Integer , config:: WorkerConfig )  
kill(manager::FooManager, pid:: Int , config:: WorkerConfig )

```
Thedefaultimplementation(whichusesTCP/IPsockets)isimplementedasconnect(manager::ClusterManager,
pid::Integer, config::WorkerConfig).

connectshould return a pair ofIOobjects, one for reading data sent from workerpid, and the other to write
data that needs to be sent to workerpid. Custom cluster managers can use an in-memoryBufferStreamas
the plumbing to proxy data between the custom, possibly non-IOtransport and Julia's in-built parallel infras-
tructure.

ABufferStreamis an in-memoryIOBufferwhich behaves like anIO–it is a stream which can be handled
asynchronously.

The folderclustermanager/0mqin the Examples repositorycontains an example of using ZeroMQ to connect
Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all logically
connected to each other–any worker can message any other worker directly without any awareness of 0MQ
being used as the transport layer.

When using custom transports:

- Julia workers must NOT be started with--worker. Starting with--workerwill result in the newly
    launched workers defaulting to the TCP/IP socket transport implementation.
- For every incoming logical connection with a worker,Base.process_messages(rd::IO, wr::IO)()
    must be called. This launches a new task that handles reading and writing of messages from/to the
    worker represented by theIOobjects.
- init_worker(cookie, manager::FooManager)must be called as part of worker process initialization.
- Fieldconnect_at::AnyinWorkerConfigcan be set by the cluster manager whenlaunchis called. The
    value of this field is passed in allconnectcallbacks. Typically, it carries information on how to connect
    to a worker. For example, the TCP/IP socket transport uses this field to specify the(host, port)tuple
    at which to connect to a worker.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 290

kill(manager, pid, config)is called to remove a worker from the cluster. On the master process, the
correspondingIOobjects must be closed by the implementation to ensure proper cleanup. The default imple-
mentation simply executes anexit()call on the specified remote worker.

The Examples folderclustermanager/simpleis an example that shows a simple implementation using UNIX
domain sockets for cluster setup.

### Network Requirements for LocalManager and SSHManager

Julia clusters are designed to be executed on already secured environments on infrastructure such as local
laptops, departmental clusters, or even the cloud. This section covers network security requirements for the
inbuiltLocalManagerandSSHManager:

- The master process does not listen on any port. It only connects out to the workers.
- Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned
    by the OS.
- LocalManager, used byaddprocs(N), by default binds only to the loopback interface. This means that
    workers started later on remote hosts (or by anyone with malicious intentions) are unable to connect
    to the cluster. Anaddprocs(4)followed by anaddprocs(["remote_host"])will fail. Some users may
    need to create a cluster comprising their local system and a few remote systems. This can be done by
    explicitly requestingLocalManagerto bind to an external network interface via therestrictkeyword
    argument:addprocs(4; restrict=false).
- SSHManager,usedbyaddprocs(list_of_remote_hosts),launchesworkersonremotehostsviaSSH.By
    default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connec-
    tions use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled.
    Additional SSH flags or credentials may be specified via keyword argumentsshflags.
- addprocs(list_of_remote_hosts; tunnel=true, sshflags=<ssh keys and other flags>)is use-
    ful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local
    laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon
    EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authen-
    ticated via public key infrastructure (PKI). Authentication credentials can be supplied viasshflags, for
    examplesshflags=`-i <keyfile>`.
    Inanall-to-alltopology(thedefault),allworkersconnecttoeachotherviaplainTCPsockets. Thesecurity
    policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port
    range (varies by OS).
    Securing and encrypting all worker-worker traffic (via SSH) or encrypting individual messages can be
    done via a customClusterManager.
- If you specifymultiplex=trueas an option toaddprocs, SSH multiplexing is used to create a tunnel be-
    tween the master and workers. If you have configured SSH multiplexing on your own and the connection
    has already been established, SSH multiplexing is used regardless ofmultiplexoption. If multiplexing
    is enabled, forwarding is set by using the existing connection (-O forwardoption in ssh). This is bene-
    ficial if your servers require password authentication; you can avoid authentication in Julia by logging in
    to the server ahead ofaddprocs. The control socket will be located at~/.ssh/julia-%r@%h:%pduring
    the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if
    you create multiple processes on a node and enable multiplexing, because in that case processes share
    a single multiplexing TCP connection.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 291

### Cluster Cookie

Allprocessesinaclustersharethesamecookiewhich, bydefault, isarandomlygeneratedstringonthemaster
process:

- cluster_cookie()returns the cookie, whilecluster_cookie(cookie)()sets it and returns the new
    cookie.
- All connections are authenticated on both sides to ensure that only workers started by the master are
    allowed to connect to each other.
- The cookie may be passed to the workers at startup via argument--worker=<cookie>. If argument
    --workeris specified without the cookie, the worker tries to read the cookie from its standard input
    (stdin). Thestdinis closed immediately after the cookie is retrieved.
- ClusterManagerscanretrievethecookieonthemasterbycallingcluster_cookie(). Clustermanagers
    notusingthedefaultTCP/IPtransport(andhencenotspecifying--worker)mustcallinit_worker(cookie,
    manager)with the same cookie as on the master.

Note that environments requiring higher levels of security can implement this via a customClusterManager.
For example, cookies can be pre-shared and hence not specified as a startup argument.

### 25.11Specifying Network Topology (Experimental)

The keyword argumenttopologypassed toaddprocsis used to specify how the workers must be connected
to each other:

- :all_to_all, the default: all workers are connected to each other.
- :master_worker: only the driver process, i.e.pid1, has connections to the workers.
- :custom: thelaunchmethod of the cluster manager specifies the connection topology via the fields
    identandconnect_identsinWorkerConfig. A worker with a cluster-manager-provided identityident
    will connect to all workers specified inconnect_idents.

Keyword argumentlazy=true|falseonly affectstopologyoption:all_to_all. Iftrue, the cluster starts
off with the master connected to all workers. Specific worker-worker connections are established at the first
remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster
communication. Connections are setup depending on the runtime requirements of a parallel program. Default
value forlazyistrue.

Currently, sending a message between unconnected workers results in an error. This behaviour, as with the
functionality and interface, should be considered experimental in nature and may change in future releases.

### 25.12Noteworthy external packages

Outside of Julia parallelism there are plenty of external packages that should be mentioned. For exampleMPI.jl
is a Julia wrapper for theMPIprotocol, orDistributedArrays.jl, as presented inShared Arrays. A mention must
be made of Julia's GPU programming ecosystem, which includes:

1. Low-level (C kernel) based operationsOpenCL.jland CUDAdrv.jlwhich are respectively an OpenCL inter-
    face and a CUDA wrapper.


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 292

2. Low-level (Julia Kernel) interfaces likeCUDAnative.jlwhich is a Julia native CUDA implementation.
3. High-level vendor-specific abstractions likeCuArrays.jland CLArrays.jl
4. High-level libraries likeArrayFire.jland GPUArrays.jl

In the following example we will use bothDistributedArrays.jlandCuArrays.jlto distribute an array
across multiple processes by first casting it throughdistribute()andCuArray().

Remember when importingDistributedArrays.jlto import it across all processes using@everywhere

```

$ ./julia -p 4

julia> addprocs()

julia> @everywhere using DistributedArrays

julia>using CuArrays

julia> B = ones(10_000) ./ 2;

julia> A = ones(10_000) .* π;

julia> C = 2 .* A ./ B;

julia> all(C.≈ 4*π)  
true

julia> typeof(C)  
Array{Float64,1}

julia> dB = distribute(B);

julia> dA = distribute(A);

julia> dC = 2 .* dA ./ dB;

julia> all(dC.≈ 4*π)  
true

julia> typeof(dC)  
DistributedArrays.DArray{Float64,1,Array{Float64,1}}

julia> cuB = CuArray(B);

julia> cuA = CuArray(A);

julia> cuC = 2 .* cuA ./ cuB;

julia> all(cuC.≈ 4*π);  
true

julia> typeof(cuC)  
CuArray{Float64,1}

```
KeepinmindthatsomeJuliafeaturesarenotcurrentlysupportedbyCUDAnative.jl^2 , especiallysomefunctions
likesinwill need to be replaced withCUDAnative.sin(cc: @maleadt).


#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 293

In the following example we will use bothDistributedArrays.jlandCuArrays.jlto distribute an array
across multiple processes and call a generic function on it.

```

function power_method(M, v)  
for i in 1:100  
v = M*v  
v /= norm(v)  
end

return v, norm(M_v) / norm(v) # or (M_v) ./ v  
end

```
power_methodrepeatedly creates a new vector and normalizes it. We have not specified any type signature
in function declaration, let's see if it works with the aforementioned datatypes:

```

julia> M = [2. 1; 1 1];

julia> v = rand(2)  
2-element Array{Float64,1}:  
0.40395  
0.445877

julia> power_method(M,v)  
([0.850651, 0.525731], 2.618033988749895)

julia> cuM = CuArray(M);

julia> cuv = CuArray(v);

julia> curesult= power_method(cuM, cuv);

julia> typeof(curesult)  
CuArray{Float64,1}

julia> dM = distribute(M);

julia> dv = distribute(v);

julia> dC = power_method(dM, dv);

julia> typeof(dC)  
Tuple{DistributedArrays.DArray{Float64,1,Array{Float64,1}},Float64}

```
To end this short exposure to external packages, we can considerMPI.jl, a Julia wrapper of the MPI protocol.
As it would take too long to consider every inner function, it would be better to simply appreciate the approach
used to implement the protocol.

Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process
is reached, performs the ranks' sum

```

import MPI

MPI.Init()

```

#### CHAPTER 25. MULTI-PROCESSING AND DISTRIBUTED COMPUTING 294

```

comm= MPI.COMM_WORLD  
MPI.Barrier(comm)

root= 0  
r = MPI.Comm_rank(comm)

sr = MPI.Reduce(r, MPI.SUM, root, comm)

if (MPI.Comm_rank(comm)== root)  
@printf("sum of ranks: %s\n ", sr)  
end

MPI.Finalize()

mpirun -np 4 ./julia example.jl

```
(^1) In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of
communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard
was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, seehttps://mpi-forum.org/docs.
(^2) Julia GPU man pages


**Chapter 26**

**Running External Programs**

Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing

```

julia> `echo hello`  
`echo hello`

```
differs in several aspects from the behavior in various shells, Perl, or Ruby:

- Instead of immediately running the command, backticks create aCmdobject to represent the command.
    You can use this object to connect the command to others via pipes,runit, andreadorwriteto it.
- When the command is run, Julia does not capture its output unless you specifically arrange for it to.
    Instead, the output of the command by default goes tostdoutas it would usinglibc'ssystemcall.
- The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately
    interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The
    command is run asjulia's immediate child process, usingforkandexeccalls.

```

Note  
The following assumes a Posix environment as on Linux or MacOS. On Windows, many similar  
commands, such asechoanddir, are not external programs and instead are built into the shell  
cmd.exeitself. Oneoptiontorunthesecommandsistoinvokecmd.exe, forexamplecmd /C echo  
hello. Alternatively Julia can be run inside a Posix environment such as Cygwin.

```
Here 's a simple example of running an external program:

```

julia> mycommand= `echo hello`  
`echo hello`

julia> typeof(mycommand)  
Cmd

julia> run(mycommand);  
hello

```
Thehelloistheoutputoftheechocommand,senttostdout. Iftheexternalcommandfailstorunsuccessfully,
the run method throws anErrorException.

If you want to read the output of the external command,readorreadchompcan be used instead:

#### 295


#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 296

```

julia> read(`echo hello`, String)  
"hello\n"

julia> readchomp(`echo hello`)  
"hello"

```
More generally, you can useopento read from or write to an external command.

```

julia> open(`less`, "w", stdout) do io  
for i = 1:3  
println(io, i)  
end  
end  
1  
2  
3

```
The program name and the individual arguments in a command can be accessed and iterated over as if the
command were an array of strings:

```

julia> collect(`echo "foo bar"`)  
2-element Vector{String}:  
"echo"  
"foo bar"

julia> `echo "foo bar"`[2]  
"foo bar"

```
### 26.1 Interpolation.

Suppose you want to do something a bit more complicated and use the name of a file in the variablefileas
an argument to a command. You can use$for interpolation much as you would in a string literal (seeStrings):

```

julia> file= "/etc/passwd"  
"/etc/passwd"

julia> `sort $file`  
`sort /etc/passwd`

```
A common pitfall when running external programs via a shell is that if a file name contains characters that are
special to the shell, they may cause undesirable behavior. Suppose, for example, rather than/etc/passwd,
we wanted to sort the contents of the file/Volumes/External HD/data.csv. Let 's try it:

```

julia> file= "/Volumes/External HD/data.csv"  
"/Volumes/External HD/data.csv"

julia> `sort $file`  
`sort '/Volumes/External HD/data.csv'`

```
How did the file name get quoted? Julia knows thatfileis meant to be interpolated as a single argument,
so it quotes the word for you. Actually, that is not quite accurate: the value offileis never interpreted by a
shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will
even work if you interpolate a value as part of a shell word:


#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 297

```

julia> path= "/Volumes/External HD"  
"/Volumes/External HD"

julia> name= "data"  
"data"

julia> ext = "csv"  
"csv"

julia> `sort $path / $name. $ext`  
`sort '/Volumes/External HD/data.csv'`

```
As you can see, the space in thepathvariable is appropriately escaped. But what if you want to interpolate
multiple words? In that case, just use an array (or any other iterable container):

```

julia> files= ["/etc/passwd","/Volumes/External HD/data.csv"]  
2-element Vector{String}:  
"/etc/passwd"  
"/Volumes/External HD/data.csv"

julia> `grep foo $files`  
`grep foo /etc/passwd '/Volumes/External HD/data.csv'`

```
If you interpolate an array as part of a shell word, Julia emulates the shell's{a,b,c}argument generation:

```

julia> names= ["foo","bar","baz"]  
3-element Vector{String}:  
"foo"  
"bar"  
"baz"

julia> `grep xylophone $names .txt`  
`grep xylophone foo.txt bar.txt baz.txt`

```
Moreover, if you interpolate multiple arrays into the same word, the shell's Cartesian product generation be-
havior is emulated:

```

julia> names= ["foo","bar","baz"]  
3-element Vector{String}:  
"foo"  
"bar"  
"baz"

julia> exts= ["aux","log"]  
2-element Vector{String}:  
"aux"  
"log"

julia> `rm -f $names. $exts`  
`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`

```
Since you can interpolate literal arrays, you can use this generative functionality without needing to create
temporary array objects first:


#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 298

```

julia> `rm -rf $["foo","bar","baz","qux"].$["aux","log","pdf"]`  
`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log ↪→ qux.pdf`

```
### 26.2 Quoting

Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes.
Here 's a simple example of a Perl one-liner at a shell prompt:

```

sh$ perl -le '$|=1; for (0..3) { print }'  
0  
1  
2  
3

```
The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression
into multiple shell words, and so that uses of Perl variables like$|(yes, that's the name of a variable in Perl),
don't cause interpolation. In other instances, you may want to use double quotes so that interpolation does
occur:

```

sh$ first="A"  
sh$ second="B"  
sh$ perl -le '$|=1; print for @ARGV' "1: $first" "2: $second"  
1: A  
2: B

```
In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands
as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the
shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single
string value, and what is a container for multiple values. Let's try the above two examples in Julia:

```

julia> A = `perl -le '$|=1; for (0..3) { print }'`  
`perl -le '$|=1; for (0..3) { print }'`

julia> run(A);  
0  
1  
2  
3

julia> first= "A"; second= "B";

julia> B = `perl -le 'print for @ARGV' "1: $first " "2: $second "`  
`perl -le 'print for @ARGV' '1: A' '2: B'`

julia> run(B);  
1: A  
2: B

```
The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due
to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this,
which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since
Julia shows commands to you before running them, you can easily and safely just examine its interpretation
without doing any damage.


#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 299

### 26.3 Pipelines.

Shell metacharacters, such as|,&, and>, need to be quoted (or escaped) inside of Julia's backticks:

```

julia> run(`echo hello '|' sort`);  
hello | sort

julia> run(`echo hello \| sort`);  
hello | sort

```
This expression invokes theechocommand with three words as arguments:hello,|, andsort. The result is
that a single line is printed:hello | sort. How, then, does one construct a pipeline? Instead of using'|'
inside of backticks, one usespipeline:

```

julia> run(pipeline(`echo hello`, `sort`));  
hello

```
This pipes the output of theechocommand to thesortcommand. Of course, this isn't terribly interesting
since there's only one line to sort, but we can certainly do much more interesting things:

```

julia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))  
210  
211  
212  
213  
214

```
This prints the highest five user IDs on a UNIX system. Thecut,sortandtailcommands are all spawned as
immediate children of the currentjuliaprocess, with no intervening shell process. Julia itself does the work
to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it
retains better control and can do some things that shells cannot.

Julia can run multiple commands in parallel:

```

julia> run(`echo hello`& `echo world`);  
world  
hello

```
The order of the output here is non-deterministic because the twoechoprocesses are started nearly simulta-
neously, and race to make the first write to thestdoutdescriptor they share with each other and thejulia
parent process. Julia lets you pipe the output from both of these processes to another program:

```

julia> run(pipeline(`echo world`& `echo hello`, `sort`));  
hello  
world

```
In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to
by bothechoprocesses, and the other end of the pipe is read from by thesortcommand.

IOredirectioncanbeaccomplishedbypassingkeywordargumentsstdin,stdout, andstderrtothepipeline
function:

```

pipeline(`do_work`, stdout=pipeline(`sort`, "out.txt"), stderr="errs.txt")

```

#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 300

### Avoiding Deadlock in Pipelines

When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the
kernel to buffer all of the data.

For example, when reading all of the output from a command, callread(out, String), notwait(process),
since the former will actively consume all of the data written by the process, whereas the latter will attempt
to store the data in the kernel's buffers while waiting for a reader to be connected.

Another common solution is to separate the reader and writer of the pipeline into separateTasks:

```

writer= @asyncwrite(process,"data")  
reader= @asyncdo_compute(read(process, String))  
wait(writer)  
fetch(reader)

```
(commonly also, reader is not a separate task, since we immediatelyfetchit anyways).

### Complex Example

The combination of a high-level programming language, a first-class command abstraction, and automatic
setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can
be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl
one-liners:

```

julia> prefixer(prefix, sleep)= `perl -nle '$|=1; print "' $prefix ' ", $_ ; sleep ' $sleep ';'`;

julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer("A",2) &  
↪→ prefixer("B",2)));  
B 0  
A 1  
B 2  
A 3  
B 4  
A 5

```
This is a classic example of a single producer feeding two concurrent consumers: oneperlprocess generates
lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing
lineswiththeletter"A",theotherwiththeletter"B". Whichconsumergetsthefirstlineisnon-deterministic,but
once that race has been won, the lines are consumed alternately by one process and then the other. (Setting
$|=1in Perl causes each print statement to flush thestdouthandle, which is necessary for this example to
work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer
process.)

Here is an even more complex multi-stage producer-consumer example:

```

julia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,  
prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3),  
prefixer("A",2) & prefixer("B",2)));  
A X 0  
B Y 1  
A Z 2  
B X 3  
A Y 4  
B Z 5

```

#### CHAPTER 26. RUNNING EXTERNAL PROGRAMS 301

This example is similar to the previous one, except there are two stages of consumers, and the stages have
different latency so they use a different number of parallel workers, to maintain saturated throughput.

We strongly encourage you to try all these examples to see how they work.

### 26.4 CmdObjects

ThebackticksyntaxcreateanobjectoftypeCmd. Suchobjectmayalsobeconstructeddirectlyfromanexisting
Cmdor list of arguments:

```

run( Cmd (`pwd`, dir=".."))  
run( Cmd (["pwd"], detach= true , ignorestatus= true ))

```
This allows you to specify several aspects of theCmd's execution environment via keyword arguments. For
example, thedirkeyword provides control over theCmd's working directory:

```

julia> run( Cmd (`pwd`, dir="/"));  
/

```
And theenvkeyword allows you to set execution environment variables:

```

julia> run( Cmd (`sh -c "echo foo \ $HOWLONG "`, env=("HOWLONG"=> "ever!",)));  
foo ever!

```
See[Cmd](@ref)for additional keyword arguments. Thesetenvandaddenvcommands provide another
means for replacing or adding to theCmdexecution environment variables, respectively:

```

julia> run(setenv(`sh -c "echo foo \ $HOWLONG "`, ( "HOWLONG"=> "ever!",)));  
foo ever!

julia> run(addenv(`sh -c "echo foo \ $HOWLONG "`, "HOWLONG"=> "ever!"));  
foo ever!

```

**Chapter 27**

**Calling C and Fortran Code**

ThoughmostcodecanbewritteninJulia,therearemanyhigh-quality,maturelibrariesfornumericalcomputing
already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient
to call C and Fortran functions. Julia has a"no boilerplate" philosophy: functions can be called directly from
Julia without any"glue" code, code generation, or compilation – even from the interactive prompt. This is
accomplished just by making an appropriate call withccallsyntax, which looks like an ordinary function call.

The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as
shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use
the-sharedand-fPICoptions. The machine instructions generated by Julia's JIT are the same as a native C
call would be, so the resulting overhead is the same as calling a library function from C code.^1

Sharedlibrariesandfunctionsarereferencedbyatupleoftheform(:function, "library")or("function",
"library")wherefunctionis the C-exported function name, andlibraryrefers to the shared library name.
Shared libraries available in the (platform-specific) load path will be resolved by name. The full path to the
library may also be specified.

A function name may be used alone in place of the tuple (just:functionor"function"). In this case the
name is resolved within the current process. This form can be used to call C library functions, functions in the
Julia runtime, or functions in an application linked to Julia.

By default, Fortran compilersgenerate mangled names(for example, converting function names to lowercase
or uppercase, often appending an underscore), and so to call a Fortran function viaccallyou must pass the
mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran
function, allinputsmustbepassedaspointerstoallocatedvaluesontheheaporstack. Thisappliesnotonlyto
arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers
and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling
conventions.

Finally, you can useccallto actually generate a call to the library function. The arguments toccallare:

1. A(:function, "library")pair (most common),
    OR
    a:functionname symbol or"function"name string (for symbols in the current process or libc),
    OR
    a function pointer (for example, fromdlsym).
2. The function's return type
3. A tuple of input types, corresponding to the function signature

#### 302


#### CHAPTER 27. CALLING C AND FORTRAN CODE 303

4. The actual argument values to be passed to the function, if any; each is a separate parameter.

```

Note  
The(:function, "library")pair, return type, and input types must be literal constants (i.e.,  
they can't be variables, but seeNon-constant Function Specificationsbelow).  
The remaining parameters are evaluated at compile time, when the containing method is defined.

Note  
See below for how tomap C types to Julia types.

```
As a complete but simple example, the following calls theclockfunction from the standard C library on most
Unix-derived systems:

```

julia> t = ccall (:clock, Int32 , ())  
2292761

julia> t  
2292761

julia> typeof(t)  
Int32

```
clocktakesno arguments and returnsanInt32. One common mistakeis forgetting that a 1-tuple of argument
types must be written with a trailing comma. For example, to call thegetenvfunction to get a pointer to the
value of an environment variable, one makes a call like this:

```

julia> path= ccall (:getenv, Cstring , ( Cstring ,), "SHELL")  
Cstring(@0x00007fff5fbffc45)

julia> unsafe_string(path)  
"/bin/bash"

```
Note that the argument type tuple must be written as(Cstring,), not(Cstring). This is because(Cstring)
is just the expressionCstringsurrounded by parentheses, rather than a 1-tuple containingCstring:

```

julia> ( Cstring )  
Cstring

julia> ( Cstring ,)  
(Cstring,)

```
In practice, especially when providing reusable functionality, one generally wrapsccalluses in Julia functions
that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if
an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are
notoriously inconsistent about how they indicate error conditions. For example, thegetenvC library function
is wrapped in the following Julia function, which is a simplified version of the actual definition fromenv.jl:


#### CHAPTER 27. CALLING C AND FORTRAN CODE 304

```

function getenv(var:: AbstractString )  
val = ccall (:getenv, Cstring , ( Cstring ,), var)  
if val == C_NULL  
error("getenv: undefined variable: ", var)  
end  
return unsafe_string(val)  
end

```
The Cgetenvfunction indicates an error by returningNULL, but other standard C functions indicate errors
in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an
exception clearly indicating the problem if the caller tries to get a non-existent environment variable:

```

julia> getenv("SHELL")  
"/bin/bash"

julia> getenv("FOOBAR")  
getenv: undefined variable: FOOBAR

```
Here is a slightly more complex example that discovers the local machine's hostname. In this example, the
networking library code is assumed to be in a shared library named"libc". In practice, this function is usually
part of the C standard library, and so the"libc" portion should be omitted, but we wish to show here the usage
of this syntax.

```

function gethostname()  
hostname= Vector { UInt8 }(undef,256) # MAXHOSTNAMELEN  
err = ccall ((:gethostname,"libc"), Int32 ,  
( Ptr { UInt8 }, Csize_t ),  
hostname, sizeof(hostname))  
Base.systemerror("gethostname", err!= 0)  
hostname[ end ] = 0 # ensure null-termination  
return GC.@preservehostname unsafe_string(pointer(hostname))  
end

```
This example first allocates an array of bytes. It then calls the C library functiongethostnameto populate the
array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia
string, assuming that it is a NUL-terminated C string.

It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to
the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an
uninitialized array and passing a pointer to its data to the C function. This is why we don't use theCstring
type here: as the array is uninitialized, it could contain NUL bytes. Converting to aCstringas part of the
ccallchecks for contained NUL bytes and could therefore throw a conversion error.

Dereferencingpointer(hostname)withunsafe_stringis an unsafe operation as it requires access to the
memoryallocatedforhostnamethatmayhavebeeninthemeanwhilegarbagecollected. ThemacroGC.@preserve
prevents this from happening and therefore accessing an invalid memory location.

### 27.1 Creating C-Compatible Julia Function Pointers.

It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example,
to match C prototypes of the form:

```

typedef returntype (*functiontype)(argumenttype, ...)

```

#### CHAPTER 27. CALLING C AND FORTRAN CODE 305

Themacro@cfunctiongeneratestheC-compatiblefunctionpointerforacalltoaJuliafunction. Thearguments
to@cfunctionare:

1. A Julia function
2. The function's return type
3. A tuple of input types, corresponding to the function signature

```

Note  
As withccall, the return type and tuple of input types must be literal constants.

Note  
Currently,onlytheplatform-defaultCcallingconventionissupported. Thismeansthat@cfunction-  
generated pointers cannot be used in calls where WINAPI expects astdcallfunction on 32-bit  
Windows, but can be used on WIN64 (wherestdcallis unified with the C calling convention).

Note  
Callback functions exposed via@cfunctionshould not throw errors, as that will return control to  
the Julia runtime unexpectedly and may leave the program in an undefined state.

```
A classic example is the standard C libraryqsortfunction, declared as:

```

void qsort(void _base, size_t nmemb, size_t size,  
int (_compare)(const void_, const void_));

```
Thebaseargument is a pointer to an array of lengthnmemb, with elements ofsizebytes each.compareis a
callback function which takes pointers to two elementsaandband returns an integer less/greater than zero
ifashould appear before/afterb(or zero if any order is permitted).

Now, suppose that we have a 1-d arrayAof values in Julia that we want to sort using theqsortfunction (rather
than Julia's built-insortfunction). Before we consider callingqsortand passing arguments, we need to write
a comparison function:

```

julia>function mycompare(a, b):: Cint  
return (a < b)? -1 : ((a > b)? +1 : 0)  
end  
mycompare (generic function with 1 method)

```
qsortexpects a comparison function that return a Cint, so we annotate the return type to beCint.

In order to pass this function to C, we obtain its address using the macro@cfunction:

```

julia> mycompare_c= @cfunction(mycompare, Cint , ( Ref { Cdouble }, Ref { Cdouble }));

```
@cfunctionrequires three arguments: the Julia function (mycompare), the return type (Cint), and a literal
tuple of the input argument types, in this case to sort an array ofCdouble(Float64) elements.

The final call toqsortlooks like this:


#### CHAPTER 27. CALLING C AND FORTRAN CODE 306

```

julia> A = [1.3, -2.7, 4.4, 3.1]  
4-element Vector{Float64}:  
1.3  
-2.7  
4.4  
3.1

julia>ccall (:qsort, Cvoid, ( Ptr { Cdouble }, Csize_t , Csize_t , Ptr {Cvoid}),  
A, length(A), sizeof(eltype(A)), mycompare_c)

julia> A  
4-element Vector{Float64}:  
-2.7  
1.3  
3.1  
4.4

```
As the example shows, the original Julia arrayAhas now been sorted:[-2.7, 1.3, 3.1, 4.4]. Note that
Julia takes care of converting the array to aPtr{Cdouble}), computing the size of the element type in bytes,
and so on.

For fun, try inserting aprintln("mycompare($a, $b)")line intomycompare, which will allow you to see the
comparisons thatqsortis performing (and to verify that it is really calling the Julia function that you passed
to it).

### 27.2 Mapping C Types to Julia.

It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code
that works correctly on one system to fail or produce indeterminate results on a different system.

Note that no C header files are used anywhere in the process of calling C functions: you are responsible for
making sure that your Julia types and call signatures accurately reflect those in the C header file.^2

### Automatic Type Conversion

Julia automatically inserts calls to theBase.cconvertfunction to convert each argument to the specified type.
For example, the following call:

```

ccall ((:foo,"libfoo"), Cvoid, ( Int32 , Float64 ), x, y)

```
will behave as if it were written like this:

```

ccall ((:foo,"libfoo"), Cvoid, ( Int32 , Float64 ),  
Base.unsafe_convert( Int32 , Base.cconvert( Int32 , x)),  
Base.unsafe_convert( Float64 , Base.cconvert( Float64 , y)))

```
Base.cconvertnormally just callsconvert, but can be defined to return an arbitrary new object more appro-
priate for passing to C. This should be used to perform all allocations of memory that will be accessed by the
C code. For example, this is used to convert anArrayof objects (e.g. strings) to an array of pointers.

Base.unsafe_converthandles conversion toPtrtypes. It is considered unsafe because converting an object
to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.


#### CHAPTER 27. CALLING C AND FORTRAN CODE 307

### Type Correspondences

First, let's review some relevant Julia type terminology:

```

Syntax /  
Keyword

Example Description

mutable  
struct

BitSet "Leaf Type" :: A group of related data that includes a type-tag, is  
managed by the Julia GC, and is defined by object-identity. The type  
parameters of a leaf type must be fully defined (noTypeVarsare  
allowed) in order for the instance to be constructed.  
abstract  
type

Any,  
AbstractArray{T,  
N},Complex{T}

"Super Type" :: A super-type (not a leaf-type) that cannot be  
instantiated, but can be used to describe a group of types.

T{A} Vector{Int} "Type Parameter" :: A specialization of a type (typically used for dispatch  
or storage optimization).  
"TypeVar" :: TheTin the type parameter declaration is referred to as a  
TypeVar (short for type variable).  
primitive  
type

Int,Float64 "Primitive Type" :: A type with no fields, but a size. It is stored and  
defined by-value.  
struct Pair{Int, Int} "Struct" :: A type with all fields defined to be constant. It is defined  
by-value, and may be stored with a type-tag.  
ComplexF64  
(isbits)

"Is-Bits " :: Aprimitive type, or astructtype where all fields are other  
isbitstypes. It is defined by-value, and is stored without a type-tag.  
struct  
...;  
end

nothing "Singleton" :: a Leaf Type or Struct with no fields.

(...)or  
tuple(...)

(1, 2, 3) "Tuple " :: an immutable data-structure similar to an anonymous struct  
type, or a constant array. Represented as either an array or a struct.

```
### Bits Types

There are several special types to be aware of, as no other type can be defined to behave the same:

- Float32
    Exactly corresponds to thefloattype in C (orREAL*4in Fortran).
- Float64
    Exactly corresponds to thedoubletype in C (orREAL*8in Fortran).
- ComplexF32
    Exactly corresponds to thecomplex floattype in C (orCOMPLEX*8in Fortran).
- ComplexF64
    Exactly corresponds to thecomplex doubletype in C (orCOMPLEX*16in Fortran).
- Signed
    Exactly corresponds to thesignedtype annotation in C (or anyINTEGERtype in Fortran). Any Julia type
    that is not a subtype ofSignedis assumed to be unsigned.
- Ref{T}
    Behaves like aPtr{T}that can manage its memory via the Julia GC.


#### CHAPTER 27. CALLING C AND FORTRAN CODE 308

- Array{T,N}
    When an array is passed to C as aPtr{T}argument, it is not reinterpret-cast: Julia requires that the
    element type of the array matchesT, and the address of the first element is passed.
    Therefore, if anArraycontains data in the wrong format, it will have to be explicitly converted using a
    call such astrunc(Int32, a).
    TopassanarrayAasapointerofadifferenttypewithoutconvertingthedatabeforehand(forexample,to
    pass aFloat64array to a function that operates on uninterpreted bytes), you can declare the argument
    asPtr{Cvoid}.
    If an array of eltypePtr{T}is passed as aPtr{Ptr{T}}argument,Base.cconvertwill attempt to first
    make a null-terminated copy of the array with each element replaced by itsBase.cconvertversion.
    This allows, for example, passing anargvpointer array of typeVector{String}to an argument of type
    Ptr{Ptr{Cchar}}.

On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows.
Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help when
writing portable code (and remembering that anintin C is not the same as anIntin Julia).

**System Independent Types**

TheCstringtypeisessentiallyasynonymforPtr{UInt8}, excepttheconversiontoCstringthrowsanerrorif
the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if
the C routine treats NUL as the terminator). If you are passing achar*to a C routine that does not assume NUL
termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string
does not contain NUL and want to skip the check, you can usePtr{UInt8}as the argument type.Cstring
can also be used as theccallreturn type, but in that case it obviously does not introduce any extra checks
and is only meant to improve readability of the call.

**System Dependent Types**

```

Note  
When calling Fortran, all inputs must be passed by pointers to heap- or stack-allocated values,  
so all type correspondences above should contain an additionalPtr{..} orRef{..} wrapper  
around their type specification.

Warning  
For string arguments (char_) the Julia type should beCstring(if NUL- terminated data is ex-  
pected), or eitherPtr{Cchar}orPtr{UInt8}otherwise (these two pointer types have the same  
effect), as described above, notString. Similarly, for array arguments (T[]orT_), the Julia type  
should again bePtr{T}, notVector{T}.

Warning  
Julia'sChartype is 32 bits, which is not the same as the wide character type (wchar_torwint_t)  
on all platforms.

Warning  
A return type ofUnion{}means the function will not return, i.e., C++11[[noreturn]]or C11  
_Noreturn(e.g.jl_throworlongjmp). Do not use this for functions that return no value (void)  
but do return, useCvoidinstead.

```

#### CHAPTER 27. CALLING C AND FORTRAN CODE 309

```

C name Fortran  
name

Standard  
Julia  
Alias

Julia Base Type

unsigned char CHARACTER Cuchar UInt8  
bool(_Bool in C99+) Cuchar UInt8  
short INTEGER_2,  
LOGICAL_2

Cshort Int16

unsigned short Cushort UInt16  
int,BOOL(C, typical) INTEGER_4,  
LOGICAL_4

Cint Int32

unsigned int Cuint UInt32  
long long INTEGER_8,  
LOGICAL_8

Clonglong Int64

unsigned long long CulonglongUInt64  
intmax_t Cintmax_t Int64  
uintmax_t Cuintmax_tUInt64  
float REAL_4i Cfloat Float32  
double REAL_8 Cdouble Float64  
complex float COMPLEX_8 ComplexF32Complex{Float32}  
complex double COMPLEX_16 ComplexF64Complex{Float64}  
ptrdiff_t Cptrdiff_tInt  
ssize_t Cssize_t Int  
size_t Csize_t UInt  
void Cvoid  
voidand[[noreturn]]  
or_Noreturn

Union{}

void* Ptr{Cvoid}(or similarlyRef{Cvoid})  
T*(where T represents an  
appropriately defined  
type)

Ref{T}(T may be safely mutated only if T is an  
isbits type)

char*(orchar[], e.g. a  
string)

CHARACTER*N Cstringif NUL-terminated, orPtr{UInt8}if not

char__(or_char[]) Ptr{Ptr{UInt8}}  
jl_value_t_(any Julia  
Type)

Any

jl_value_t* const*(a  
reference to a Julia value)

Ref{Any}(const, since mutation would require a  
write barrier, which is not possible to insert  
correctly)  
va_arg Not supported  
...(variadic function  
specification)

T...(whereTis one of the above types, when  
using theccallfunction)  
...(variadic function  
specification)

; va_arg1::T, va_arg2::S, etc.(only  
supported with@ccallmacro)

Note  
Forwchar_t*arguments, the Julia type should beCwstring(if the C routine expects a NUL-  
terminated string), orPtr{Cwchar_t}otherwise. Note also that UTF-8 string data in Julia is inter-  
nally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without  
making a copy (but using theCwstringtype will cause an error to be thrown if the string itself  
contains NUL characters).

```

#### CHAPTER 27. CALLING C AND FORTRAN CODE 310

```

C name Standard Julia Alias Julia Base Type  
char Cchar Int8(x86, x86_64),UInt8(powerpc, arm)  
long Clong Int(UNIX),Int32(Windows)  
unsigned long Culong UInt(UNIX),UInt32(Windows)  
wchar_t Cwchar_t Int32(UNIX),UInt16(Windows)

Note  
C functions that take an argument of typechar**can be called by using aPtr{Ptr{UInt8}}type  
within Julia. For example, C functions of the form:  
int main(int argc, char **argv);

can be called via the following Julia code:

argv= [ "a.out", "arg1", "arg2"]  
ccall (:main, Int32 , ( Int32 , Ptr { Ptr { UInt8 }}), length(argv), argv)

Note  
For Fortran functions taking variable length strings of typecharacter(len=_)the string lengths  
are provided as hidden arguments. Type and position of these arguments in the list are compiler  
specific, where compiler vendors usually default to usingCsize_tas type and append the hidden  
arguments at the end of the argument list. While this behaviour is fixed for some compilers  
(GNU), others optionally permit placing hidden arguments directly after the character argument  
(Intel, PGI). For example, Fortran subroutines of the form  
subroutine test(str1, str2)  
character(len=_) :: str1,str2

can be called via the following Julia code, where the lengths are appended

str1= "foo"  
str2= "bar"  
ccall (:test, Cvoid, ( Ptr { UInt8 }, Ptr { UInt8 }, Csize_t , Csize_t ),  
str1, str2, sizeof(str1), sizeof(str2))

Warning  
Fortran compilers may also add other hidden arguments for pointers, assumed-shape (:) and  
assumed-size (*) arrays. Such behaviour can be avoided by usingISO_C_BINDINGand including  
bind(c)inthedefinitionofthesubroutine,whichisstronglyrecommendedforinteroperablecode.  
In this case there will be no hidden arguments, at the cost of some language features (e.g. only  
character(len=1)will be permitted to pass strings).

Note  
A C function declared to returnCvoidwill return the valuenothingin Julia.

```
### Struct Type Correspondences

Composite types such asstructin C orTYPEin Fortran90 (orSTRUCTURE/RECORDin some variants of F77),
can be mirrored in Julia by creating astructdefinition with the same field layout.

When used recursively,isbitstypes are stored inline. All other types are stored as a pointer to the data.
When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to


#### CHAPTER 27. CALLING C AND FORTRAN CODE 311

manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare anisbits
struct type and use that instead. Unnamed structs are not possible in the translation to Julia.

Packed structs and union declarations are not supported by Julia.

You can get an approximation of aunionif you know, a priori, the field that will have the greatest size (po-
tentially including padding). When translating your fields to Julia, declare the Julia field to be only of that
type.

Arrays of parameters can be expressed withNTuple. For example, the struct in C notation written as

```

struct B {  
int A[3];  
};

b_a_2 = B.A[2];

```
can be written in Julia as

```

struct B  
A:: NTuple {3, Cint }  
end

b_a_2= B.A[3] # note the difference in indexing (1-based in Julia, 0-based in C)

```
Arraysofunknownsize(C99-compliantvariablelengthstructsspecifiedby[]or[0])arenotdirectlysupported.
Oftenthebestwaytodealwiththeseistodealwiththebyteoffsetsdirectly. Forexample, ifaClibrarydeclared
a proper string type and returned a pointer to it:

```

struct String {  
int strlen;  
char data[];  
};

```
In Julia, we can access the parts independently to make a copy of that string:

```

str = from_c:: Ptr {Cvoid}  
len = unsafe_load( Ptr { Cint }(str))  
unsafe_string(str+ Core.sizeof( Cint ), len)

```
### Type Parameters

The type arguments toccalland@cfunctionare evaluated statically, when the method containing the usage
is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local
variables.

This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its
functions can only accept argument types with a statically-known, fixed signature.

However, while the type layout must be known statically to compute the intended C ABI, the static parameters
of the function are considered to be part of this static environment. The static parameters of the function
may be used as type parameters in the call signature, as long as they don't affect the layout of the type.
For example,f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)is valid, sincePtris always a
word-size primitive type. But,g(x::T) where {T} = ccall(:notvalid, T, (T,), x)is not valid, since the
type layout ofTis not known statically.


#### CHAPTER 27. CALLING C AND FORTRAN CODE 312

### SIMD Values

Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.

If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is
a homogeneous tuple ofVecElementthat naturally maps to the SIMD type. Specifically:

- The tuple must be the same size as the SIMD type. For example, a tuple representing an
    __m128on x86 must have a size of 16 bytes.
- The element type of the tuple must be an instance ofVecElement{T}whereTis a primitive
    type that is 1, 2, 4 or 8 bytes.

For instance, consider this C routine that uses AVX intrinsics:

```

#include <immintrin.h>

__m256 dist( __m256 a, __m256 b ) {  
return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),  
_mm256_mul_ps(b, b)));  
}

```
The following Julia code callsdistusingccall:

```

const m256= NTuple {8, VecElement{ Float32 }}

a = m256(ntuple(i-> VecElement(sin( Float32 (i))),8))  
b = m256(ntuple(i-> VecElement(cos( Float32 (i))),8))

function call_dist(a::m256, b::m256)  
ccall ((:dist,"libdist"), m256, (m256, m256), a, b)  
end

println(call_dist(a,b))

```
The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts
without AVX support.

### Memory Ownership

**malloc/free**

Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup rou-
tines in the libraries being used, just like in any C program. Do not try to free an object received from a C
library withLibc.freein Julia, as this may result in thefreefunction being called via the wrong library and
cause the process to abort. The reverse (passing an object allocated in Julia to be freed by an external library)
is equally invalid.

### When to use T, Ptr{T} and Ref{T}

In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type
Tinside theccall, as they are passed by value. For C code accepting pointers,Ref{T}should generally be
used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C
through the implicit call toBase.cconvert. In contrast, pointers returned by the C function called should be
declared to be of output typePtr{T}, reflecting that the memory pointed to is managed by C only. Pointers


#### CHAPTER 27. CALLING C AND FORTRAN CODE 313

containedinCstructsshouldberepresentedasfieldsoftypePtr{T}withinthecorrespondingJuliastructtypes
designed to mimic the internal structure of corresponding C structs.

In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type
Ref{T}, as Fortran passes all variables by pointers to memory locations. The return type should either be
Cvoidfor Fortran subroutines, or aTfor Fortran functions returning the typeT.

### 27.3 Mapping C Functions to Julia.

### ccall/@cfunctionargument translation guide

For translating a C argument list to Julia:

- T, whereTis one of the primitive types:char,int,long,short,float,double,complex,enumor any
    of theirtypedefequivalents
       **-** T, whereTis an equivalent Julia Bits Type (per the table above)
       **-** ifTis anenum, the argument type should be equivalent toCintorCuint
       **-** argument value will be copied (passed by value)
- struct T(including typedef to a struct)
    **-** T, whereTis a Julia leaf type
    **-** argument value will be copied (passed by value)
- void*
    **-** depends on how this parameter is used, first translate this to the intended pointer type, then
       determine the Julia equivalent using the remaining rules in this list
    **-** this argument may be declared asPtr{Cvoid}, if it really is just an unknown pointer
- jl_value_t*
    **-** Any
    **-** argument value must be a valid Julia object
- jl_value_t* const*
    **-** Ref{Any}
    **-** argument list must be a valid Julia object (orC_NULL)
    **-** cannotbeusedforanoutputparameter, unlesstheuserisabletoseparatelyarrangefortheobject
       to be GC-preserved
- T*
    **-** Ref{T}, whereTis the Julia type corresponding toT
    **-** argument value will be copied if it is aninlinealloctype (which includesisbitsotherwise, the
       value must be a valid Julia object
- T (*)(...)(e.g. a pointer to a function)
    **-** Ptr{Cvoid}(you may need to use@cfunctionexplicitly to create this pointer)


#### CHAPTER 27. CALLING C AND FORTRAN CODE 314

- ...(e.g. a vararg)

```

forccall:T..., whereTis the single Julia type of all remaining arguments

```
for@ccall :; va_arg1::T, va_arg2::S, etc, whereTandSare the Julia type (i.e. separate the regular
arguments from varargs with a;)

**-** currently unsupported by@cfunction
- va_arg
**-** not supported byccallor@cfunction

### ccall/@cfunctionreturn type translation guide

For translating a C return type to Julia:

- void
    **-** Cvoid(this will return the singleton instancenothing::Cvoid)
- T, whereTis one of the primitive types:char,int,long,short,float,double,complex,enumor any
    of theirtypedefequivalents
       **-** T, whereTis an equivalent Julia Bits Type (per the table above)
       **-** ifTis anenum, the argument type should be equivalent toCintorCuint
       **-** argument value will be copied (returned by-value)
- struct T(including typedef to a struct)
    **-** T, whereTis a Julia Leaf Type
    **-** argument value will be copied (returned by-value)
- void*
    **-** depends on how this parameter is used, first translate this to the intended pointer type, then
       determine the Julia equivalent using the remaining rules in this list
    **-** this argument may be declared asPtr{Cvoid}, if it really is just an unknown pointer
- jl_value_t*
    **-** Any
    **-** argument value must be a valid Julia object
- jl_value_t**
    **-** Ptr{Any}(Ref{Any}is invalid as a return type)
- T*
    **-** If the memory is already owned by Julia, or is anisbitstype, and is known to be non-null:
       ∗Ref{T}, whereTis the Julia type corresponding toT
       ∗ a return type ofRef{Any}is invalid, it should either beAny(corresponding tojl_value_t*)
          orPtr{Any}(corresponding tojl_value_t**)


#### CHAPTER 27. CALLING C AND FORTRAN CODE 315

```

∗ C MUST NOT modify the memory returned viaRef{T}ifTis anisbitstype

```
**-** If the memory is owned by C:
    ∗Ptr{T}, whereTis the Julia type corresponding toT
- T (*)(...)(e.g. a pointer to a function)
**-** Ptr{Cvoid}(you may need to use@cfunctionexplicitly to create this pointer)

### Passing Pointers for Modifying Inputs

Because C doesn't support multiple return values, often C functions will take pointers to data that the function
will modify. To accomplish this within accall, you need to first encapsulate the value inside aRef{T}of the
appropriate type. When you pass thisRefobject as an argument, Julia will automatically pass a C pointer to
the encapsulated data:

```

width= Ref { Cint }(0)  
range= Ref { Cfloat }(0)  
ccall (:foo, Cvoid, ( Ref { Cint }, Ref { Cfloat }), width, range)

```
Upon return, the contents ofwidthandrangecan be retrieved (if they were changed byfoo) bywidth[]and
range[]; that is, they act like zero-dimensional arrays.

### 27.4 C Wrapper Examples

Let 's start with a simple example of a C wrapper that returns aPtrtype:

```

mutable struct gsl_permutation  
end

# The corresponding C signature is

# gsl_permutation * gsl_permutation_alloc (size_t n);

function permutation_alloc(n:: Integer )  
output_ptr= ccall (  
(:gsl_permutation_alloc,:libgsl),# name of C function and library  
Ptr {gsl_permutation}, # output type  
( Csize_t ,), # tuple of input types  
n # name of Julia variable to pass in  
)  
if output_ptr== C_NULL# Could not allocate memory  
throw( OutOfMemoryError ())  
end  
return output_ptr  
end

```
The GNU Scientific Library(here assumed to be accessible through:libgsl) defines an opaque pointer,
gsl_permutation *, as the return type of the C functiongsl_permutation_alloc. As user code never has to
look inside thegsl_permutationstruct, the corresponding Julia wrapper simply needs a new type declaration,
gsl_permutation, that has no internal fields and whose sole purpose is to be placed in the type parameter of
aPtrtype. The return type of theccallis declared asPtr{gsl_permutation}, since the memory allocated
and pointed to byoutput_ptris controlled by C.

The inputnis passed by value, and so the function's input signature is simply declared as(Csize_t,)with-
out anyReforPtrnecessary. (If the wrapper was calling a Fortran function instead, the corresponding


#### CHAPTER 27. CALLING C AND FORTRAN CODE 316

function input signature would instead be(Ref{Csize_t},), since Fortran variables are passed by point-
ers.) Furthermore,ncan be any type that is convertible to aCsize_tinteger; theccallimplicitly calls
Base.cconvert(Csize_t, n).

Here is a second example wrapping the corresponding destructor:

```

# The corresponding C signature is

# void gsl_permutation_free (gsl_permutation * p);

function permutation_free(p:: Ref {gsl_permutation})  
ccall (  
(:gsl_permutation_free,:libgsl),# name of C function and library  
Cvoid, # output type  
( Ref {gsl_permutation},), # tuple of input types  
p # name of Julia variable to pass in  
)  
end

```
Here, the inputpis declared to be of typeRef{gsl_permutation}, meaning that the memory thatppoints to
maybemanagedbyJuliaorbyC.ApointertomemoryallocatedbyCshouldbeoftypePtr{gsl_permutation},
but it is convertible usingBase.cconvertand therefore

Now if you look closely enough at this example, you may notice that it is incorrect, given our explanation above
of preferred declaration types. Do you see it? The function we are calling is going to free the memory. This
type of operation cannot be given a Julia object (it will crash or cause memory corruption). Therefore, it may
be preferable to declare theptype asPtr{gsl_permutation }, to make it harder for the user to mistakenly
pass another sort of object there than one obtained viagsl_permutation_alloc.

IftheCwrapperneverexpectstheusertopasspointerstomemorymanagedbyJulia,thenusingp::Ptr{gsl_permutation}
for the method signature of the wrapper and similarly in theccallis also acceptable.

Here is a third example passing Julia arrays:

```

# The corresponding C signature is

# int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,

# double result_array[])

function sf_bessel_Jn_array(nmin:: Integer , nmax:: Integer , x :: Real )  
if nmax< nmin  
throw( DomainError ())  
end  
result_array= Vector { Cdouble }(undef, nmax- nmin+ 1)  
errorcode= ccall (  
(:gsl_sf_bessel_Jn_array,:libgsl),# name of C function and library  
Cint , # output type  
( Cint , Cint , Cdouble , Ref { Cdouble }),# tuple of input types  
nmin, nmax, x, result_array # names of Julia variables to pass in  
)  
if errorcode!= 0  
error("GSL error code $errorcode ")  
end  
return result_array  
end

```
TheCfunctionwrappedreturnsanintegererrorcode; theresultsoftheactualevaluationoftheBesselJfunction
populate the Julia arrayresult_array. This variable is declared as aRef{Cdouble}, since its memory is
allocated and managed by Julia. The implicit call toBase.cconvert(Ref{Cdouble}, result_array)unpacks
the Julia pointer to a Julia array data structure into a form understandable by C.


#### CHAPTER 27. CALLING C AND FORTRAN CODE 317

### 27.5 Fortran Wrapper Example.

The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot
product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia
to Fortran. On every argument type, we specifyReforPtr. This mangling convention may be specific to your
fortran compiler and operating system, and is likely undocumented. However, wrapping each in aRef(orPtr,
where equivalent) is a frequent requirement of Fortran compiler implementations:

```

function compute_dot(DX:: Vector { Float64 }, DY:: Vector { Float64 })  
@assertlength(DX)== length(DY)  
n = length(DX)  
incx= incy= 1  
product= ccall ((:ddot_,"libLAPACK"),  
Float64 ,  
( Ref { Int32 }, Ptr { Float64 }, Ref { Int32 }, Ptr { Float64 }, Ref { Int32 }),  
n, DX, incx, DY, incy)  
return product  
end

```
### 27.6 Garbage Collection Safety.

When passing data to accall, it is best to avoid using thepointerfunction. Instead define a convert method
and pass the variables directly to theccall.ccallautomatically arranges that all of its arguments will be
preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated
by Julia, after theccallreturns, you must ensure that the object remains visible to the garbage collector. The
suggested way to do this is to make a global variable of typeArray{Ref,1}to hold these values, until the C
library notifies you that it is finished with them.

Whenever you have created a pointer to Julia data, you must ensure the original data exists until you have
finishedusingthepointer. ManymethodsinJuliasuchasunsafe_loadandStringmakecopiesofdatainstead
of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A
notable exception isunsafe_wrapwhich, for performance reasons, shares (or can be told to take ownership
of) the underlying buffer.

The garbage collector does not guarantee any order of finalization. That is, ifacontained a reference toband
bothaandbare due for garbage collection, there is no guarantee thatbwould be finalized aftera. If proper
finalization ofadepends onbbeing valid, it must be handled in other ways.

### 27.7 Non-constant Function Specifications

In some cases, the exact name or path of the needed library is not known in advance and must be computed at
run time. To handle such cases, the library component of a(name, library)specification can be a function
call, e.g.(:dgemm_, find_blas()). The call expression will be executed when theccallitself is executed.
However, it is assumed that the library location does not change once it is determined, so the result of the
call can be cached and reused. Therefore, the number of times the expression executes is unspecified, and
returning different values for multiple calls results in unspecified behavior.

If even more flexibility is needed, it is possible to use computed values as function names by staging through
evalas follows:

```

@eval ccall(($(string("a", "b")), "lib"), ...

```
This expression constructs a name usingstring, then substitutes this name into a newccallexpression,
which is then evaluated. Keep in mind thatevalonly operates at the top level, so within this expression local


#### CHAPTER 27. CALLING C AND FORTRAN CODE 318

variables will not be available (unless their values are substituted with$). For this reason,evalis typically only
used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A
similar example can be constructed for@cfunction.

However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep
reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.

### 27.8 Indirect Calls.

The first argument toccallcan also be an expression evaluated at run time. In this case, the expression must
evaluate to aPtr, which will be used as the address of the native function to call. This behavior occurs when
the firstccallargument contains references to non-constants, such as local variables, function arguments, or
non-constant globals.

For example, you might look up the function viadlsym, then cache it in a shared reference for that session.
For example:

```

macro dlsym(func, lib)  
z = Ref { Ptr {Cvoid}}(C_NULL)  
quote  
let zlocal= $z[]  
if zlocal== C_NULL  
zlocal= dlsym($(esc(lib)):: Ptr {Cvoid},$(esc(func))):: Ptr {Cvoid}  
$z[] = zlocal  
end  
zlocal  
end  
end  
end

mylibvar= Libdl.dlopen("mylib")  
ccall (@dlsym("myfunc", mylibvar), Cvoid, ())

```
### 27.9 Closure cfunctions.

The first argument to@cfunctioncan be marked with a$, in which case the return value will instead be a
struct CFunctionwhich closes over the argument. You must ensure that this return object is kept alive until
all uses of it are done. The contents and code at the cfunction pointer will be erased via afinalizerwhen
this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but
can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.

```

function qsort(a:: Vector {T}, cmp) where T  
isbits(T)|| throw( ArgumentError ("this method can only qsort isbits arrays"))  
callback= @cfunction$cmp Cint ( Ref {T}, Ref {T})

# Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}

# (and protected against finalization) by the ccall

ccall (:qsort, Cvoid, ( Ptr {T}, Csize_t , Csize_t , Ptr {Cvoid}),  
a, length(a), Base.elsize(a), callback)

# We could instead use:

# GC.@preserve callback begin

# use(Base.unsafe_convert(Ptr{Cvoid}, callback))

# end

# if we needed to use it outside of a `ccall`

return a  
end

```

#### CHAPTER 27. CALLING C AND FORTRAN CODE 319

```

Note  
Closure@cfunctionrely on LLVM trampolines, which are not available on all platforms (for exam-  
ple ARM and PowerPC).

```
### 27.10Closing a Library.

It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing
C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make
an edit, recompile, and load in the new changes. One can either restart Julia or use theLibdlfunctions to
manage the library explicitly, such as:

```

lib = Libdl.dlopen("./my_lib.so") # Open the library explicitly.  
sym = Libdl.dlsym(lib,:my_fcn) # Get a symbol for the function to call.  
ccall (sym,...) # Use the pointer `sym` instead of the (symbol, library) tuple (remaining arguments  
↪→ are the same).  
Libdl.dlclose(lib)# Close the library explicitly.

```
Note that when usingccallwith the tuple input (e.g.,ccall((:my_fcn, "./my_lib.so"), ...)), the library
is opened implicitly and it may not be explicitly closed.

### 27.11Calling Convention.

The second argument toccallcan optionally be a calling convention specifier (immediately preceding return
type). Without any specifier, the platform-default C calling convention is used. Other supported conventions
are:stdcall,cdecl,fastcall, andthiscall(no-op on 64-bit Windows). For example (frombase/libc.jl)
we see the samegethostnameccallas above, but with the correct signature for Windows:

```

hn = Vector { UInt8 }(undef,256)  
err = ccall (:gethostname, stdcall, Int32 , ( Ptr { UInt8 }, UInt32 ), hn, length(hn))

```
For more information, please see theLLVM Language Reference.

There is one additional special calling conventionllvmcall, which allows inserting calls to LLVM intrinsics
directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for
CUDA , we need to be able to read the thread index:

```

ccall ("llvm.nvvm.read.ptx.sreg.tid.x", llvmcall, Int32 , ())

```
As with anyccall, it is essential to get the argument signature exactly correct. Also, note that there is no
compatibilitylayerthatensurestheintrinsicmakessenseandworksonthecurrenttarget,unliketheequivalent
Julia functions exposed byCore.Intrinsics.

### 27.12Accessing Global Variables

Global variables exported by native libraries can be accessed by name using thecglobalfunction. The argu-
ments tocglobalare a symbol specification identical to that used byccall, and a type describing the value
stored in the variable:

```

julia> cglobal((:errno,:libc), Int32 )  
Ptr{Int32} @0x00007f418d0816b8

```

#### CHAPTER 27. CALLING C AND FORTRAN CODE 320

The result is a pointer giving the address of the value. The value can be manipulated through this pointer using
unsafe_loadandunsafe_store!.

```

Note  
Thiserrnosymbol may not be found in a library named"libc", as this is an implementation detail  
of your system compiler. Typically standard library symbols should be accessed just by name,  
allowing the compiler to fill in the correct one. Also, however, theerrnosymbol shown in this  
example is special in most compilers, and so the value seen here is probably not what you expect  
orwant. CompilingtheequivalentcodeinConanymulti-threaded-capablesystemwouldtypically  
actually call a different function (via macro preprocessor overloading), and may give a different  
result than the legacy value printed here.

```
### 27.13Accessing Data through a Pointer.

The following methods are described as"unsafe" because a bad pointer or type declaration can cause Julia to
terminate abruptly.

Given aPtr{T}, the contents of typeTcan generally be copied from the referenced memory into a Julia
object usingunsafe_load(ptr, [index]). The index argument is optional (default is 1), and follows the
Julia-convention of 1-based indexing. This function is intentionally similar to the behavior ofgetindexand
setindex!(e.g.[]access syntax).

The return value will be a new object initialized to contain a copy of the contents of the referenced memory.
The referenced memory can safely be freed or released.

IfTisAny, then the memory is assumed to contain a reference to a Julia object (ajl_value_t*), the result
will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure
that the object was always visible to the garbage collector (pointers do not count, but the new reference does)
to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia,
the new object will never be finalized by Julia's garbage collector. If thePtritself is actually ajl_value_t*, it
can be converted back to a Julia object reference byunsafe_pointer_to_objref(ptr). (Julia valuesvcan be
converted tojl_value_t*pointers, asPtr{Cvoid}, by callingpointer_from_objref(v).)

Thereverseoperation(writingdatatoaPtr{T}),canbeperformedusingunsafe_store!(ptr, value, [index]).
Currently, this is only supported for primitive types or other pointer-free (isbits) immutable struct types.

Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that
it can be resolved.

Ifthepointerofinterestisaplain-dataarray(primitivetypeorimmutablestruct),thefunctionunsafe_wrap(Array,
ptr,dims, own = false)may be more useful. The final parameter should be true if Julia should"take own-
ership" of the underlying buffer and callfree(ptr)when the returnedArrayobject is finalized. If theown
parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is com-
plete.

Arithmetic on thePtrtype in Julia (e.g. using+) does not behave the same as C's pointer arithmetic. Adding
an integer to aPtrin Julia always moves the pointer by some number of bytes, not elements. This way, the
address values obtained from pointer arithmetic do not depend on the element types of pointers.

### 27.14Thread-safety

Some C libraries execute their callbacks from a different thread, and since Julia isn't thread-safe you'll need to
take some extra precautions. In particular, you'll need to set up a two-layered system: the C callback should
onlyschedule(viaJulia'seventloop)theexecutionofyour"real "callback. Todothis,createanAsyncCondition
object andwaiton it:


#### CHAPTER 27. CALLING C AND FORTRAN CODE 321

```

cond= Base.AsyncCondition()  
wait(cond)

```
The callback you pass to C should only execute accallto:uv_async_send, passingcond.handleas the
argument, taking care to avoid any allocations or other interactions with the Julia runtime.

Note that events may be coalesced, so multiple calls touv_async_sendmay result in a single wakeup notifi-
cation to the condition.

### 27.15More About Callbacks

For more details on how to pass callbacks to C libraries, see thisblog post.

### 27.16C++.

For direct C++ interfacing, see theCxx package. For tools to create C++ bindings, see theCxxWrappackage.

(^1) Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library
functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native
language.
(^2) The Clang packagecan be used to auto-generate Julia code from a C header file.


**Chapter 28**

**Handling Operating System Variation**

When writing cross-platform applications or libraries, it is often necessary to allow for differences between
operating systems. The variableSys.KERNELcan be used to handle such cases. There are several functions
in theSysmodule intended to make this easier, such asisunix,islinux,isapple,isbsd,isfreebsd, and
iswindows. These may be used as follows:

```

if Sys.iswindows()  
windows_specific_thing(a)  
end

```
Note thatislinux,isapple, andisfreebsdare mutually exclusive subsets ofisunix. Additionally, there is
a macro@staticwhich makes it possible to use these functions to conditionally hide invalid code, as demon-
strated in the following examples.

Simple blocks:

```

ccall((@static Sys.iswindows()? :_fopen : :fopen), ...)

```
Complex blocks:

```

@static if Sys.islinux()  
linux_specific_thing(a)  
else  
generic_thing(a)  
end

```
When chaining conditionals (includingif/elseif/end), the@staticmust be repeated for each level (paren-
theses optional, but recommended for readability):

```

@staticSys.iswindows()? :a : (@staticSys.isapple()? :b : :c)

```
#### 322


**Chapter 29**

**Environment Variables**

Julia can be configured with a number of environment variables, set either in the usual way for each operating
system, or in a portable way from within Julia. Supposing that you want to set the environment variable
JULIA_EDITORtovim, you can typeENV["JULIA_EDITOR"] = "vim"(for instance, in the REPL) to make this
change on a case by case basis, or add the same to the user configuration file~/.julia/config/startup.jl
in the user's home directory to have a permanent effect. The current value of the same environment variable
can be determined by evaluatingENV["JULIA_EDITOR"].

The environment variables that Julia uses generally start withJULIA. IfInteractiveUtils.versioninfois
called with the keywordverbose=true, then the output will list any defined environment variables relevant for
Julia, including those which includeJULIAin their names.

```

Note  
Some variables, such asJULIA_NUM_THREADSandJULIA_PROJECT, need to be set before Julia  
starts, therefore adding these to~/.julia/config/startup.jlis too late in the startup process.  
InBash,environmentvariablescaneitherbesetmanuallybyrunning,e.g.,export JULIA_NUM_THREADS=4  
before starting Julia, or by adding the same command to~/.bashrcor~/.bash_profileto set  
the variable each time Bash is started.

```
### 29.1 File locations.

### JULIA_BINDIR

The absolute path of the directory containing the Julia executable, which sets the global variableSys.BINDIR.
If$JULIA_BINDIRis not set, then Julia determines the valueSys.BINDIRat run-time.

The executable itself is one of

```

$JULIA_BINDIR/julia  
$JULIA_BINDIR/julia-debug

```
by default.

The global variableBase.DATAROOTDIRdetermines a relative path fromSys.BINDIRto the data directory as-
sociated with Julia. Then the path

```

$JULIA_BINDIR/$DATAROOTDIR/julia/base

```
determines the directory in which Julia initially searches for source files (viaBase.find_source_file()).

Likewise, the global variableBase.SYSCONFDIRdetermines a relative path to the configuration file directory.
Then Julia searches for astartup.jlfile at

#### 323


#### CHAPTER 29. ENVIRONMENT VARIABLES 324

```

$JULIA_BINDIR/$SYSCONFDIR/julia/startup.jl  
$JULIA_BINDIR/../etc/julia/startup.jl

```
by default (viaBase.load_julia_startup()).

For example, a Linux installation with a Julia executable located at/bin/julia, aDATAROOTDIRof../share,
and aSYSCONFDIRof../etcwill haveJULIA_BINDIRset to/bin, a source-file search path of

```

/share/julia/base

```
and a global configuration search path of

```

/etc/julia/startup.jl

```
### JULIA_PROJECT

A directory path that indicates which project should be the initial active project. Setting this environment
variable has the same effect as specifying the--projectstart-up option, but--projecthas higher prece-
dence. If the variable is set to@. then Julia tries to find a project directory that containsProject.tomlor
JuliaProject.tomlfile from the current directory and its parents. See also the chapter onCode Loading.

```

Note  
JULIA_PROJECTmust be defined before starting julia; defining it instartup.jlis too late in the  
startup process.

```
### JULIA_LOAD_PATH

TheJULIA_LOAD_PATHenvironment variable is used to populate the global JuliaLOAD_PATHvariable, which
determines which packages can be loaded viaimportandusing(see Code Loading).

UnliketheshellPATHvariable,emptyentriesinJULIA_LOAD_PATHareexpandedtothedefaultvalueofLOAD_PATH,
["@", "@v#.#", "@stdlib"]when populatingLOAD_PATH. This allows easy appending, prepending, etc. of
the load path value in shell scripts regardless of whetherJULIA_LOAD_PATHis already set or not. For example,
to prepend the directory/foo/bartoLOAD_PATHjust do

```

export JULIA_LOAD_PATH="/foo/bar:$JULIA_LOAD_PATH"

```
If theJULIA_LOAD_PATHenvironment variable is already set, its old value will be prepended with/foo/bar.
On the other hand, ifJULIA_LOAD_PATHis not set, then it will be set to/foo/bar:which will expand to
aLOAD_PATHvalue of["/foo/bar", "@", "@v#.#", "@stdlib"]. IfJULIA_LOAD_PATHis set to the empty
string, it expands to an emptyLOAD_PATHarray. In other words, the empty string is interpreted as a zero-
element array, not a one-element array of the empty string. This behavior was chosen so that it would be
possible to set an empty load path via the environment variable. If you want the default load path, either
unset the environment variable or if it must have a value, set it to the string:.

```

Note  
On Windows, path elements are separated by the;character, as is the case with most path lists  
on Windows. Replace:with;in the above paragraph.

```

#### CHAPTER 29. ENVIRONMENT VARIABLES 325

### JULIA_DEPOT_PATH

TheJULIA_DEPOT_PATHenvironment variable is used to populate the global JuliaDEPOT_PATHvariable, which
controls where the package manager, as well as Julia's code loading mechanisms, look for package registries,
installed packages, named environments, repo clones, cached compiled package images, configuration files,
and the default location of the REPL's history file.

Unlike the shellPATHvariable but similar toJULIA_LOAD_PATH, empty entries inJULIA_DEPOT_PATHare ex-
panded to the default value ofDEPOT_PATH. This allows easy appending, prepending, etc. of the depot path
value in shell scripts regardless of whetherJULIA_DEPOT_PATHis already set or not. For example, to prepend
the directory/foo/bartoDEPOT_PATHjust do

```

export JULIA_DEPOT_PATH="/foo/bar:$JULIA_DEPOT_PATH"

```
If theJULIA_DEPOT_PATHenvironment variable is already set, its old value will be prepended with/foo/bar.
On the other hand, ifJULIA_DEPOT_PATHis not set, then it will be set to/foo/bar:which will have the effect
of prepending/foo/barto the default depot path. IfJULIA_DEPOT_PATHis set to the empty string, it expands
to an emptyDEPOT_PATHarray. In other words, the empty string is interpreted as a zero-element array, not a
one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty
depot path via the environment variable. If you want the default depot path, either unset the environment
variable or if it must have a value, set it to the string:.

```

Note  
On Windows, path elements are separated by the;character, as is the case with most path lists  
on Windows. Replace:with;in the above paragraph.

```
### JULIA_HISTORY

The absolute pathREPL.find_hist_file()of the REPL's history file. If$JULIA_HISTORYis not set, then
REPL.find_hist_file()defaults to

```

$(DEPOT_PATH[1])/logs/repl_history.jl

```
### JULIA_PKG_SERVER

UsedbyPkg.jl,fordownloadingpackagesandupdatingtheregistry. Bydefault,Pkguseshttps://pkg.julialang.org
to fetch Julia packages. You can use this environment variable to select a different server. In addition, you can
disable the use of the PkgServer protocol, and instead access the packages directly from their hosts (GitHub,
GitLab, etc.) by setting:

```

export JULIA_PKG_SERVER=""

```
### 29.2 External applications

### JULIA_SHELL

The absolute path of the shell with which Julia should execute external commands (viaBase.repl_cmd()).
Defaults to the environment variable$SHELL, and falls back to/bin/shif$SHELLis unset.

```

Note  
On Windows, this environment variable is ignored, and external commands are executed directly.

```

#### CHAPTER 29. ENVIRONMENT VARIABLES 326

### JULIA_EDITOR

The editor returned byInteractiveUtils.editor()and used in, e.g.,InteractiveUtils.edit, referring to
the command of the preferred editor, for instancevim.

$JULIA_EDITORtakesprecedenceover$VISUAL,whichinturntakesprecedenceover$EDITOR.Ifnoneofthese
environmentvariablesisset,thentheeditoristakentobeopenonWindowsandOSX,or/etc/alternatives/editor
if it exists, oremacsotherwise.

### 29.3 Parallelization

### JULIA_CPU_THREADS

Overrides the global variableBase.Sys.CPU_THREADS, the number of logical CPU cores available.

### JULIA_WORKER_TIMEOUT

AFloat64that sets the value ofDistributed.worker_timeout()(default:60.0). This function gives the
number of seconds a worker process will wait for a master process to establish a connection before dying.

### JULIA_NUM_THREADS

Anunsigned64-bitinteger(uint64_t)thatsetsthemaximumnumberofthreadsavailabletoJulia. If$JULIA_NUM_THREADS
is not positive or is not set, or if the number of CPU threads cannot be determined through system calls, then
the number of threads is set to 1.

If$JULIA_NUM_THREADSis set toauto, then the number of threads will be set to the number of CPU threads.

```

Note  
JULIA_NUM_THREADSmust be defined before starting julia; defining it instartup.jlis too late in  
the startup process.

Julia 1.5  
In Julia 1.5 and above the number of threads can also be specified on startup using the-t/--  
threadscommand line argument.

Julia 1.7  
Theautovalue for$JULIA_NUM_THREADSrequires Julia 1.7 or above.

```
### JULIA_THREAD_SLEEP_THRESHOLD

If set to a string that starts with the case-insensitive substring"infinite", then spinning threads never sleep.
Otherwise,$JULIA_THREAD_SLEEP_THRESHOLDis interpreted as an unsigned 64-bit integer (uint64_t) and
gives, in nanoseconds, the amount of time after which spinning threads should sleep.

### JULIA_EXCLUSIVE

If set to anything besides 0 , then Julia's thread policy is consistent with running on a dedicated machine: the
masterthreadisonproc0, andthreadsareaffinitized. Otherwise, Julialetstheoperatingsystemhandlethread
policy.


#### CHAPTER 29. ENVIRONMENT VARIABLES 327

### 29.4 REPL formatting

Environment variables that determine how REPL output should be formatted at the terminal. Generally, these
variables should be set toANSI terminal escape sequences. Julia provides a high-level interface with much of
the same functionality; see the section onThe Julia REPL.

### JULIA_ERROR_COLOR

The formattingBase.error_color()(default: light red,"\033[91m") that errors should have at the terminal.

### JULIA_WARN_COLOR

The formattingBase.warn_color()(default: yellow,"\033[93m") that warnings should have at the terminal.

### JULIA_INFO_COLOR

The formattingBase.info_color()(default: cyan,"\033[36m") that info should have at the terminal.

### JULIA_INPUT_COLOR

The formattingBase.input_color()(default: normal,"\033[0m") that input should have at the terminal.

### JULIA_ANSWER_COLOR

The formattingBase.answer_color()(default: normal,"\033[0m") that output should have at the terminal.

### 29.5 Debugging and profiling.

### JULIA_DEBUG

Enable debug logging for a file or module, seeLoggingfor more information.

### JULIA_GC_ALLOC_POOL,JULIA_GC_ALLOC_OTHER,JULIA_GC_ALLOC_PRINT

If set, these environment variables take strings that optionally start with the character'r', followed by a string
interpolation of a colon-separated list of three signed 64-bit integers (int64_t). This triple of integersa:b:c
represents the arithmetic sequencea,a + b,a + 2*b, ...c.

- If it 's thenth time thatjl_gc_pool_alloc()has been called, andnbelongs to the arithmetic sequence
    represented by$JULIA_GC_ALLOC_POOL, then garbage collection is forced.
- If it 's thenth time thatmaybe_collect()has been called, andnbelongs to the arithmetic sequence
    represented by$JULIA_GC_ALLOC_OTHER, then garbage collection is forced.
- If it 's thenth time thatjl_gc_collect()has been called, andnbelongs to the arithmetic sequence
    represented by$JULIA_GC_ALLOC_PRINT, then counts for the number of calls tojl_gc_pool_alloc()
    andmaybe_collect()are printed.

If the value of the environment variable begins with the character'r', then the interval between garbage
collection events is randomized.

```

Note  
These environment variables only have an effect if Julia was compiled with garbage-collection  
debugging (that is, ifWITH_GC_DEBUG_ENVis set to 1 in the build configuration).

```

#### CHAPTER 29. ENVIRONMENT VARIABLES 328

### JULIA_GC_NO_GENERATIONAL

If set to anything besides 0 , then the Julia garbage collector never performs"quick sweeps" of memory.

```

Note  
This environment variable only has an effect if Julia was compiled with garbage-collection debug-  
ging (that is, ifWITH_GC_DEBUG_ENVis set to 1 in the build configuration).

```
### JULIA_GC_WAIT_FOR_DEBUGGER

Ifsettoanythingbesides 0 ,thentheJuliagarbagecollectorwillwaitforadebuggertoattachinsteadofaborting
whenever there's a critical error.

```

Note  
This environment variable only has an effect if Julia was compiled with garbage-collection debug-  
ging (that is, ifWITH_GC_DEBUG_ENVis set to 1 in the build configuration).

```
### ENABLE_JITPROFILING

If set to anything besides 0 , then the compiler will create and register an event listener for just-in-time (JIT)
profiling.

```

Note  
This environment variable only has an effect if Julia was compiled with JIT profiling support, using  
either

```
- Intel's VTune™ Amplifier(USE_INTEL_JITEVENTSset to 1 in the build configuration), or
- OProfile(USE_OPROFILE_JITEVENTSset to 1 in the build configuration).
- Perf (USE_PERF_JITEVENTSset to 1 in the build configuration). This integration is enabled
    by default.

### ENABLE_GDBLISTENER

If set to anything besides 0 enables GDB registration of Julia code on release builds. On debug builds of Julia
this is always enabled. Recommended to use with-g 2.

### JULIA_LLVM_ARGS

Arguments to be passed to the LLVM backend.


**Chapter 30**

**Embedding Julia**

As we have seen inCalling C and Fortran Code, Julia has a simple and efficient way to call functions written in
C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used
to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has
a C API to make this possible. As almost all programming languages have some way to call C functions, the
Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).

### 30.1 High-Level Embedding.

**Note** : ThissectioncoversembeddingJuliacodeinConUnix-likeoperatingsystems. FordoingthisonWindows,
please see the section following this.

We start with a simple C program that initializes Julia and calls some Julia code:

```

#include <julia.h>  
JULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you  
want fast code.

int main(int argc, char _argv[])  
{  
/_ required: setup the Julia context */  
jl_init();

/* run Julia commands */  
jl_eval_string("print(sqrt(2.0))");

/* strongly recommended: notify Julia that the  
program is about to terminate. this allows  
Julia time to cleanup pending write requests  
and run all finalizers  
*/  
jl_atexit_hook(0);  
return 0;  
}

```
In order to build this program you have to put the path to the Julia header into the include path and link against
libjulia. For instance, when Julia is installed to$JULIA_DIR, one can compile the above test programtest.c
withgccusing:

```

gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -  
ljulia

```
#### 329


#### CHAPTER 30. EMBEDDING JULIA 330

Alternatively, look at theembedding.cprogram in the Julia source tree in thetest/embedding/folder. The file
cli/loader_exe.cprogram is another simple example of how to setjl_optionsoptions while linking against
libjulia.

The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by
callingjl_init, which tries to automatically determine Julia's install location. If you need to specify a custom
location, or specify which system image to load, usejl_init_with_imageinstead.

The second statement in the test program evaluates a Julia statement using a call tojl_eval_string.

Before the program terminates, it is strongly recommended to calljl_atexit_hook. The above example
program calls this before returning frommain.

```

Note  
Currently, dynamically linking with thelibjuliashared library requires passing theRTLD_GLOBAL  
option. In Python, this looks like:

> > > julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)  
> > > julia.jl_init.argtypes = []  
> > > julia.jl_init()  
> > > 250593296

Note  
If the julia program needs to access symbols from the main executable, it may be necessary to  
add-Wl,--export-dynamiclinker flag at compile time on Linux in addition to the ones generated  
byjulia-config.jldescribed below. This is not necessary when compiling a shared library.

```
### Using julia-config to automatically determine build parameters

The scriptjulia-config.jlwas created to aid in determining what build parameters are required by a pro-
gramthatusesembeddedJulia. Thisscriptusesthebuildparametersandsystemconfigurationoftheparticular
Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact
with that distribution. This script is located in the Julia shared data directory.

**Example**

```

#include <julia.h>

int main(int argc, char *argv[])  
{  
jl_init();  
(void)jl_eval_string("println(sqrt(2.0))");  
jl_atexit_hook(0);  
return 0;  
}

```
**On the command line**

Asimpleuseofthisscriptisfromthecommandline. Assumingthatjulia-config.jlislocatedin/usr/local/julia/share/julia,
it can be invoked on the command line directly and takes any combination of 3 flags:

```

/usr/local/julia/share/julia/julia-config.jl  
Usage: julia-config [--cflags|--ldflags|--ldlibs]

```

#### CHAPTER 30. EMBEDDING JULIA 331

If the above example source is saved in the fileembed_example.c, then the following command will compile it
into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substituteclangfor
gcc.:

```

/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c

```
**Use in Makefiles**

But in general, embedding projects will be more complicated than the above, and so the following allows
general makefile support as well – assuming GNU make because of the use of the **shell** macro expansions.
Additionally, though many timesjulia-config.jlmay be found in the directory/usr/local, this is not
necessarily the case, but Julia can be used to locatejulia-config.jltoo, and the makefile can be used to
take advantage of that. The above example is extended to use a Makefile:

```

JL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia"))')  
CFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)  
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)  
LDFLAGS += $(shell $(JL_SHARE)/julia-config.jl --ldflags)  
LDLIBS += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example

```
Now the build command is simplymake.

### 30.2 High-Level Embedding on Windows with Visual Studio

If theJULIA_DIRenvironment variable hasn't been setup, add it using the System panel before starting Visual
Studio. Thebinfolder under JULIA_DIR should be on the system PATH.

We start by opening Visual Studio and creating a new Console Application project. To the'stdafx.h' header file,
add the following lines at the end:

```

#include <julia.h>

```
Then, replace the main() function in the project with this code:

```

int main(int argc, char _argv[])  
{  
/_ required: setup the Julia context */  
jl_init();

/* run Julia commands */  
jl_eval_string("print(sqrt(2.0))");

/* strongly recommended: notify Julia that the  
program is about to terminate. this allows  
Julia time to cleanup pending write requests  
and run all finalizers  
*/  
jl_atexit_hook(0);  
return 0;  
}

```
The next step is to set up the project to find the Julia include files and the libraries. It's important to know
whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to
the Julia installation before proceeding.


#### CHAPTER 30. EMBEDDING JULIA 332

UsingtheprojectPropertiesdialog, gotoC/C++|Generalandadd$(JULIA_DIR)\include\julia\totheAddi-
tionalIncludeDirectoriesproperty. Then, gototheLinker|Generalsectionandadd$(JULIA_DIR)\libtothe
AdditionalLibraryDirectoriesproperty. Finally,underLinker|Input,addlibjulia.dll.a;libopenlibm.dll.a;
to the list of libraries.

At this point, the project should build and run.

### 30.3 Converting Types

Real applications will not just need to execute expressions, but also return their values to the host program.
jl_eval_stringreturnsajl_value_t*, whichisapointertoaheap-allocatedJuliaobject. Storingsimpledata
types likeFloat64in this way is calledboxing, and extracting the stored primitive data is calledunboxing.
Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks
as follows:

```

jl_value_t *ret = jl_eval_string("sqrt(2.0)");

if (jl_typeis(ret, jl_float64_type)) {  
double ret_unboxed = jl_unbox_float64(ret);  
printf("sqrt(2.0) in C: %e \n", ret_unboxed);  
}  
else {  
printf("ERROR: unexpected return type from sqrt(::Float64)\n");  
}

```
In order to check whetherretis of a specific Julia type, we can use thejl_isa,jl_typeis, orjl_is_...
functions. Bytypingtypeof(sqrt(2.0))intotheJuliashellwecanseethatthereturntypeisFloat64(double
in C). To convert the boxed Julia value into a C double thejl_unbox_float64function is used in the above
code snippet.

Correspondingjl_box_...functions are used to convert the other way:

```

jl_value_t *a = jl_box_float64(3.0);  
jl_value_t *b = jl_box_float32(3.0f);  
jl_value_t *c = jl_box_int32(3);

```
As we will see next, boxing is required to call Julia functions with specific arguments.

### 30.4 Calling Julia Functions.

Whilejl_eval_stringallows C to obtain the result of a Julia expression, it does not allow passing arguments
computed in C to Julia. For this you will need to invoke Julia functions directly, usingjl_call:

```

jl_function_t *func = jl_get_function(jl_base_module, "sqrt");  
jl_value_t *argument = jl_box_float64(2.0);  
jl_value_t *ret = jl_call1(func, argument);

```
In the first step, a handle to the Julia functionsqrtis retrieved by callingjl_get_function. The first argument
passed tojl_get_functionis a pointer to theBasemodule in whichsqrtis defined. Then, the double value
is boxed usingjl_box_float64. Finally, in the last step, the function is called usingjl_call1. jl_call0,
jl_call2, andjl_call3functions also exist, to conveniently handle different numbers of arguments. To pass
more arguments, usejl_call:

```

jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)

```
Its second argumentargsis an array ofjl_value_t*arguments andnargsis the number of arguments.


#### CHAPTER 30. EMBEDDING JULIA 333

### 30.5 Memory Management

As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible
for freeing these objects.

Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that
we are holding a reference to a Julia value from C. This means the GC can free objects out from under you,
rendering pointers invalid.

The GC can only run when Julia objects are allocated. Calls likejl_box_float64perform allocation, and
allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers
in betweenjl_...calls. But in order to make sure that values can survivejl_...calls, we have to tell Julia
that we still hold a reference to Juliaroot values, a process called"GC rooting". Rooting a value will ensure that
the garbage collector does not accidentally identify this value as unused and free the memory backing that
value. This can be done using theJL_GC_PUSHmacros:

```

jl_value_t *ret = jl_eval_string("sqrt(2.0)");  
JL_GC_PUSH1(&ret);  
// Do something with ret  
JL_GC_POP();

```
TheJL_GC_POPcall releases the references established by the previousJL_GC_PUSH. Note thatJL_GC_PUSH
stores references on the C stack, so it must be exactly paired with aJL_GC_POPbefore the scope is exited.
That is, before the function returns, or control flow otherwise leaves the block in which theJL_GC_PUSHwas
invoked.

SeveralJuliavaluescanbepushedatonceusingtheJL_GC_PUSH2,JL_GC_PUSH3,JL_GC_PUSH4,JL_GC_PUSH5
, andJL_GC_PUSH6macros. To push an array of Julia values one can use theJL_GC_PUSHARGSmacro, which
can be used as follows:

```

jl_value_t **args;  
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects  
args[0] = some_value;  
args[1] = some_other_value;  
// Do something with args (e.g. call jl_... functions)  
JL_GC_POP();

```
Each scope must have only one call toJL_GC_PUSH*. Hence, if all variables cannot be pushed once by a single
call toJL_GC_PUSH*, or if there are more than 6 variables to be pushed and using an array of arguments is not
an option, then one can use inner blocks:

```

jl_value_t *ret1 = jl_eval_string("sqrt(2.0)");  
JL_GC_PUSH1(&ret1);  
jl_value_t *ret2 = 0;  
{  
jl_function_t *func = jl_get_function(jl_base_module, "exp");  
ret2 = jl_call1(func, ret1);  
JL_GC_PUSH1(&ret2);  
// Do something with ret2.  
JL_GC_POP(); // This pops ret2.  
}  
JL_GC_POP(); // This pops ret1.

```
If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to
useJL_GC_PUSH*. In this case, it is necessary to create and keep a reference to the variable in the Julia global
scope. One simple way to accomplish this is to use a globalIdDictthat will hold the references, avoiding
deallocation by the GC. However, this method will only work properly with mutable types.


#### CHAPTER 30. EMBEDDING JULIA 334

```

// This functions shall be executed only once, during the initialization.  
jl_value_t* refs = jl_eval_string("refs = IdDict()");  
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");

...

// `var` is the variable we want to protect between function calls.  
jl_value_t* var = 0;

...

// `var` is a `Vector{Float64}`, which is mutable.  
var = jl_eval_string("[sqrt(2.0); sqrt(4.0); sqrt(6.0)]");

// To protect `var`, add its reference to `refs`.  
jl_call3(setindex, refs, var, var);

```
If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in
aRefValue{Any}before it is pushed toIdDict. In this approach, the container has to be created or filled in
via C code using, for example, the functionjl_new_struct. If the container is created byjl_call*, then you
will need to reload the pointer to be used in C code.

```

// This functions shall be executed only once, during the initialization.  
jl_value_t* refs = jl_eval_string("refs = IdDict()");  
jl_function_t* setindex = jl_get_function(jl_base_module, "setindex!");  
jl_datatype_t* reft = (jl_datatype_t*)jl_eval_string("Base.RefValue{Any}");

...

// `var` is the variable we want to protect between function calls.  
jl_value_t* var = 0;

...

// `var` is a `Float64`, which is immutable.  
var = jl_eval_string("sqrt(2.0)");

// Protect `var` until we add its reference to `refs`.  
JL_GC_PUSH1(&var);

// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.  
jl_value_t* rvar = jl_new_struct(reft, var);  
JL_GC_POP();

jl_call3(setindex, refs, rvar, rvar);

```
The GC can be allowed to deallocate a variable by removing the reference to it fromrefsusing the function
delete!, provided that no other reference to the variable is kept anywhere:

```

jl_function_t* delete = jl_get_function(jl_base_module, "delete!");  
jl_call2(delete, refs, rvar);

```
As an alternative for very simple cases, it is possible to just create a global container of typeVector{Any}and
fetch the elements from that when necessary, or even to create one global variable per pointer using

```

jl_set_global(jl_main_module, jl_symbol("var"), var);

```

#### CHAPTER 30. EMBEDDING JULIA 335

### Updating fields of GC-managed objects

The garbage collector operates under the assumption that it is aware of every old-generation object pointing
to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to
the collector with thejl_gc_wb(write barrier) function like so:

```

jl_value_t *parent = some_old_value, _child = some_young_value;  
((some_specific_type_)parent)->field = child;  
jl_gc_wb(parent, child);

```
It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted
after all explicit stores. One notable exception is if theparentobject was just allocated and garbage collection
was not run since then. Remember that mostjl_...functions can sometimes invoke garbage collection.

The write barrier is also necessary for arrays of pointers when updating their data directly. For example:

```

jl_array_t *some_array = ...; // e.g. a Vector{Any}  
void **data = (void**)jl_array_data(some_array);  
jl_value_t *some_value = ...;  
data[0] = some_value;  
jl_gc_wb(some_array, some_value);

```
### Manipulating the Garbage Collector

There are some functions to control the GC. In normal use cases, these should not be necessary.

```

Function Description  
jl_gc_collect() Force a GC run  
jl_gc_enable(0) Disable the GC, return previous state as int  
jl_gc_enable(1) Enable the GC, return previous state as int  
jl_gc_is_enabled() Return current state as int

```
### 30.6 Working with Arrays.

Julia and C can share array data without copying. The next example will show how this works.

Julia arrays are represented in C by the datatypejl_array_t*. Basically,jl_array_tis a struct that contains:

- Information about the datatype
- A pointer to the data block
- Information about the sizes of the array

To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is
done by:

```

jl_value_t* array_type = jl_apply_array_type((jl_value_t_)jl_float64_type, 1);  
jl_array_t_ x = jl_alloc_array_1d(array_type, 10);

```
Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:

```

double _existingArray = (double_)malloc(sizeof(double)*10);  
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);

```

#### CHAPTER 30. EMBEDDING JULIA 336

The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is
non-zero, the GC will callfreeon the data pointer when the array is no longer referenced.

In order to access the data of x, we can usejl_array_data:

```

double _xData = (double_)jl_array_data(x);

```
Now we can fill the array:

```

for(size_t i=0; i<jl_array_len(x); i++)  
xData[i] = i;

```
Now let us call a Julia function that performs an in-place operation onx:

```

jl_function_t _func = jl_get_function(jl_base_module, "reverse!");  
jl_call1(func, (jl_value_t_)x);

```
By printing the array, one can verify that the elements ofxare now reversed.

### Accessing Returned Arrays

IfaJuliafunctionreturnsanarray,thereturnvalueofjl_eval_stringandjl_callcanbecasttoajl_array_t*:

```

jl_function_t _func = jl_get_function(jl_base_module, "reverse");  
jl_array_t _y = (jl_array_t_)jl_call1(func, (jl_value_t_)x);

```
Now the content ofycan be accessed as before usingjl_array_data. As always, be sure to keep a reference
to the array while it is in use.

### Multidimensional Arrays

Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a
2D array and accesses its properties:

```

// Create 2D array of float64 type  
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);  
jl_array_t *x = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer  
double _p = (double_)jl_array_data(x);  
// Get number of dimensions  
int ndims = jl_array_ndims(x);  
// Get the size of the i-th dim  
size_t size0 = jl_array_dim(x,0);  
size_t size1 = jl_array_dim(x,1);

// Fill array with data  
for(size_t i=0; i<size1; i++)  
for(size_t j=0; j<size0; j++)  
p[j + size0*i] = i + j;

```
Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling
jl_array_dim) in order to read as idiomatic C code.


#### CHAPTER 30. EMBEDDING JULIA 337

### 30.7 Exceptions.

Julia code can throw exceptions. For example, consider:

```

jl_eval_string("this_function_does_not_exist()");

```
This call will appear to do nothing. However, it is possible to check whether an exception was thrown:

```

if (jl_exception_occurred())  
printf("%s \n", jl_typeof_str(jl_exception_occurred()));

```
If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes
sense to wrap each call intolibjuliawith a function that checks whether an exception was thrown, and then
rethrows the exception in the host language.

### Throwing Julia Exceptions

When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to
indicate errors. A typical type check looks like:

```

if (!jl_typeis(val, jl_float64_type)) {  
jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);  
}

```
General exceptions can be raised using the functions:

```

void jl_error(const char *str);  
void jl_errorf(const char *fmt, ...);

```
jl_errortakes a C string, andjl_errorfis called likeprintf:

```

jl_errorf("argument x = %d is too large", x);

```
where in this examplexis assumed to be an integer.


**Chapter 31**

**Code Loading**

```

Note  
This chapter covers the technical details of package loading. To install packages, usePkg, Julia 's  
built-inpackagemanager,toaddpackagestoyouractiveenvironment. Tousepackagesalreadyin  
your active environment, writeimport Xorusing X, as described in theModules documentation.

```
### 31.1 Definitions.

Julia has two mechanisms for loading code:

1. **Codeinclusion:** e.g.include("source.jl"). Inclusionallowsyoutosplitasingleprogramacrossmul-
    tiple source files. The expressioninclude("source.jl")causes the contents of the filesource.jlto
    beevaluatedintheglobalscopeofthemodulewheretheincludecalloccurs. Ifinclude("source.jl")
    is called multiple times,source.jlis evaluated multiple times. The included path,source.jl, is inter-
    preted relative to the file where theincludecall occurs. This makes it simple to relocate a subtree of
    source files. In the REPL, included paths are interpreted relative to the current working directory,pwd().
2. **Package loading:** e.g.import Xorusing X.Theimportmechanismallowsyoutoloadapackage—i.e.
    anindependent, reusablecollectionofJuliacode, wrappedinamodule—andmakestheresultingmodule
    available by the nameXinside of the importing module. If the sameXpackage is imported multiple
    times in the same Julia session, it is only loaded the first time—on subsequent imports, the importing
    module gets a reference to the same module. Note though, thatimport Xcan load different packages
    in different contexts:Xcan refer to one package namedXin the main project but potentially to different
    packages also namedXin each dependency. More on this below.

Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller.
Packageloadingisbuiltontopofcodeinclusionandservesadifferentpurpose. Therestofthischapterfocuses
on the behavior and mechanics of package loading.

A package is a source tree with a standard layout providing functionality that can be reused by other Julia
projects. A package is loaded byimport Xorusing Xstatements. These statements also make the module
namedX—which results from loading the package code—available within the module where the import state-
ment occurs. The meaning ofXinimport Xis context-dependent: whichXpackage is loaded depends on what
code the statement occurs in. Thus, handling ofimport Xhappens in two stages: first, it determines **what**
package is defined to beXin this context; second, it determines **where** that particularXpackage is found.

These questions are answered by searching through the project environments listed inLOAD_PATHfor project
files (Project.tomlorJuliaProject.toml), manifest files (Manifest.tomlorJuliaManifest.toml), or fold-
ers of source files.

#### 338


#### CHAPTER 31. CODE LOADING 339

### 31.2 Federation of packages

Most of the time, a package is uniquely identifiable simply from its name. However, sometimes a project might
encounterasituationwhereitneedstousetwodifferentpackagesthatsharethesamename. Whileyoumight
be able fix this by renaming one of the packages, being forced to do so can be highly disruptive in a large,
shared code base. Instead, Julia's code loading mechanism allows the same package name to refer to different
packages in different components of an application.

Julia supports federated package management, which means that multiple independent parties can maintain
both public and private packages and registries of packages, and that projects can depend on a mix of public
and private packages from different registries. Packages from various registries are installed and managed
using a common set of tools and workflows. ThePkgpackage manager that ships with Julia lets you install
and manage your projects' dependencies. It assists in creating and manipulating project files (which describe
what other projects that your project depends on), and manifest files (which snapshot exact versions of your
project's complete dependency graph).

One consequence of federation is that there cannot be a central authority for package naming. Different enti-
ties may use the same name to refer to unrelated packages. This possibility is unavoidable since these entities
do not coordinate and may not even know about each other. Because of the lack of a central naming authority,
a single project may end up depending on different packages that have the same name. Julia's package load-
ing mechanism does not require package names to be globally unique, even within the dependency graph of
a single project. Instead, packages are identified byuniversally unique identifiers(UUIDs), which get assigned
when each package is created. Usually you won't have to work directly with these somewhat cumbersome
128-bit identifiers sincePkgwill take care of generating and tracking them for you. However, these UUIDs
provide the definitive answer to the question of"what package doesXrefer to?"

Sincethedecentralizednaming problemissomewhatabstract, itmayhelpto walkthroughaconcretescenario
to understand the issue. Suppose you're developing an application calledApp, which uses two packages:Pub
andPriv.Privis a private package that you created, whereasPubis a public package that you use but don't
control. When you createdPriv, there was no public package by the namePriv. Subsequently, however, an
unrelated package also namedPrivhas been published and become popular. In fact, thePubpackage has
started to use it. Therefore, when you next upgradePubto get the latest bug fixes and features,Appwill end
up depending on two different packages namedPriv—through no action of yours other than upgrading.App
has a direct dependency on your privatePrivpackage, and an indirect dependency, throughPub, on the new
publicPrivpackage. Since these twoPrivpackages are different but are both required forAppto continue
working correctly, the expressionimport Privmust refer to differentPrivpackages depending on whether it
occurs inApp's code or inPub's code. To handle this, Julia's package loading mechanism distinguishes the two
Privpackages by their UUID and picks the correct one based on its context (the module that calledimport).
How this distinction works is determined by environments, as explained in the following sections.

### 31.3 Environments

An environment determines whatimport Xandusing Xmean in various code contexts and what files these
statements cause to be loaded. Julia understands two kinds of environments:

1. **A project environment** is a directory with a project file and an optional manifest file, and forms an ex-
    plicit environment. The project file determines what the names and identities of the direct dependencies
    of a project are. The manifest file, if present, gives a complete dependency graph, including all direct
    and indirect dependencies, exact versions of each dependency, and sufficient information to locate and
    load the correct version.
2. **A package directory** is a directory containing the source trees of a set of packages as subdirectories,
    and forms an implicit environment. IfXis a subdirectory of a package directory andX/src/X.jlexists,


#### CHAPTER 31. CODE LOADING 340

```

then the packageXis available in the package directory environment andX/src/X.jlis the source file  
by which it is loaded.

```
These can be intermixed to create **a stacked environment** : an ordered set of project environments and
package directories, overlaid to make a single composite environment. The precedence and visibility rules
then combine to determine which packages are available and where they get loaded from. Julia's load path
forms a stacked environment, for example.

These environment each serve a different purpose:

- Project environments provide **reproducibility**. By checking a project environment into version con-
    trol—e.g. a git repository—along with the rest of the project's source code, you can reproduce the exact
    stateoftheprojectandallofitsdependencies. Themanifestfile,inparticular,capturestheexactversion
    of every dependency, identified by a cryptographic hash of its source tree, which makes it possible for
    Pkgto retrieve the correct versions and be sure that you are running the exact code that was recorded
    for all dependencies.
- Package directories provide **convenience** when a full carefully-tracked project environment is unnec-
    essary. They are useful when you want to put a set of packages somewhere and be able to directly use
    them, without needing to create a project environment for them.
- Stacked environments allow for **adding** tools to the primary environment. You can push an environment
    of development tools onto the end of the stack to make them available from the REPL and scripts, but
    not from inside packages.

At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving
the meaning ofimport X, the roots and graph maps are used to determine the identity ofX, while the paths
map is used to locate the source code ofX. The specific roles of the three maps are:

- **roots:** name::Symbol⟶uuid::UUID
    An environment's roots map assigns package names to UUIDs for all the top-level dependencies that the
    environment makes available to the main project (i.e. the ones that can be loaded inMain). When Julia
    encountersimport Xin the main project, it looks up the identity ofXasroots[:X].
- **graph:** context::UUID⟶name::Symbol⟶uuid::UUID
    An environment's graph is a multilevel map which assigns, for eachcontextUUID, a map from names
    to UUIDs, similar to the roots map but specific to thatcontext. When Julia seesimport Xin the code of
    the package whose UUID iscontext, it looks up the identity ofXasgraph[context][:X]. In particular,
    this means thatimport Xcan refer to different packages depending oncontext.
- **paths:** uuid::UUID×name::Symbol⟶path::String
    The paths map assigns to each package UUID-name pair, the location of that package's entry-point
    source file. After the identity ofXinimport Xhas been resolved to a UUID via roots or graph (depending
    on whether it is loaded from the main project or a dependency), Julia determines what file to load to
    acquireXby looking uppaths[uuid,:X]in the environment. Including this file should define a module
    namedX. Once this package is loaded, any subsequent import resolving to the sameuuidwill create a
    new binding to the already-loaded package module.

Each kind of environment defines these three maps differently, as detailed in the following sections.


#### CHAPTER 31. CODE LOADING 341

```

Note  
For ease of understanding, the examples throughout this chapter show full data structures for  
roots, graph and paths. However, Julia's package loading code does not explicitly create these.  
Instead, it lazily computes only as much of each structure as it needs to load a given package.

```
### Project environments

AprojectenvironmentisdeterminedbyadirectorycontainingaprojectfilecalledProject.toml,andoptionally
amanifestfilecalledManifest.toml. ThesefilesmayalsobecalledJuliaProject.tomlandJuliaManifest.toml,
in which caseProject.tomlandManifest.tomlare ignored. This allows for coexistence with other tools that
might consider files calledProject.tomlandManifest.tomlsignificant. For pure Julia projects, however, the
namesProject.tomlandManifest.tomlare preferred.

The roots, graph and paths maps of a project environment are defined as follows:

**The roots map** of the environment is determined by the contents of the project file, specifically, its top-level
nameanduuidentries and its[deps]section (all optional). Consider the following example project file for the
hypothetical application,App, as described earlier:

```

name = "App"  
uuid = "8f986787-14fe-4607-ba5d-fbff2944afa9"

[deps]  
Priv = "ba13f791-ae1d-465a-978b-69c3ad90f72b"  
Pub = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"

```
This project file implies the following roots map, if it was represented by a Julia dictionary:

```

roots= Dict (  
:App => UUID("8f986787-14fe-4607-ba5d-fbff2944afa9"),  
:Priv=> UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"),  
:Pub => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),  
)

```
Given this roots map, inApp's code the statementimport Privwill cause Julia to look uproots[:Priv], which
yieldsba13f791-ae1d-465a-978b-69c3ad90f72b, the UUID of thePrivpackage that is to be loaded in that
context. This UUID identifies whichPrivpackage to load and use when the main application evaluatesimport
Priv.

**Thedependencygraph** ofaprojectenvironmentisdeterminedbythecontentsofthemanifestfile,ifpresent.
If there is no manifest file, graph is empty. A manifest file contains a stanza for each of a project's direct or
indirect dependencies. For each dependency, the file lists the package's UUID and a source tree hash or an
explicit path to the source code. Consider the following example manifest file forApp:

```

[[Priv]] # the private one  
deps = ["Pub", "Zebra"]  
uuid = "ba13f791-ae1d-465a-978b-69c3ad90f72b"  
path = "deps/Priv"

[[Priv]] # the public one  
uuid = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"  
git-tree-sha1 = "1bf63d3be994fe83456a03b874b409cfd59a6373"  
version = "0.1.5"

[[Pub]]

```

#### CHAPTER 31. CODE LOADING 342

```

uuid = "c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"  
git-tree-sha1 = "9ebd50e2b0dd1e110e842df3b433cb5869b0dd38"  
version = "2.1.4"

[Pub.deps]  
Priv = "2d15fe94-a1f7-436c-a4d8-07a9a496e01c"  
Zebra = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"

[[Zebra]]  
uuid = "f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"  
git-tree-sha1 = "e808e36a5d7173974b90a15a353b564f3494092f"  
version = "3.4.2"

```
This manifest file describes a possible complete dependency graph for theAppproject:

- There are two different packages namedPrivthat the application uses. It uses a private package,
    which is a root dependency, and a public one, which is an indirect dependency throughPub. These are
    differentiated by their distinct UUIDs, and they have different deps:
       **-** The privatePrivdepends on thePubandZebrapackages.
       **-** The publicPrivhas no dependencies.
- The application also depends on thePubpackage, which in turn depends on the publicPrivand the
    sameZebrapackage that the privatePrivpackage depends on.

This dependency graph represented as a dictionary, looks like this:

```

graph= Dict (

# Priv – the private one:

UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b") => Dict (  
:Pub => UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"),  
:Zebra=> UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),  
),

# Priv – the public one:

UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c") => Dict (),

# Pub:

UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1") => Dict (  
:Priv => UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"),  
:Zebra=> UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"),  
),

# Zebra:

UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62") => Dict (),  
)

```
Giventhisdependencygraph,whenJuliaseesimport PrivinthePubpackage—whichhasUUIDc07ecb7d-0dc9-4db7-
8803-fadaaeaf08e1—it looks up:

```

graph[UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1")][:Priv]

```
and gets2d15fe94-a1f7-436c-a4d8-07a9a496e01c, which indicates that in the context of thePubpackage,
import Privrefers to the publicPrivpackage, rather than the private one which the app depends on directly.


#### CHAPTER 31. CODE LOADING 343

ThisishowthenamePrivcanrefertodifferentpackagesinthemainprojectthanitdoesinoneofitspackage's
dependencies, which allows for duplicate names in the package ecosystem.

What happens ifimport Zebrais evaluated in the mainAppcode base? SinceZebradoes not appear in
the project file, the import will fail even thoughZebradoes appear in the manifest file. Moreover, ifimport
ZebraoccursinthepublicPrivpackage—theonewithUUID2d15fe94-a1f7-436c-a4d8-07a9a496e01c—then
that would also fail since thatPrivpackage has no declared dependencies in the manifest file and therefore
cannot load any packages. TheZebrapackage can only be loaded by packages for which it appear as an
explicit dependency in the manifest file: thePubpackage and one of thePrivpackages.

**The paths map** of a project environment is extracted from the manifest file. The path of a packageuuid
namedXis determined by these rules (in order):

1. If the project file in the directory matchesuuidand nameX, then either:
    **-** It has a toplevelpathentry, thenuuidwill be mapped to that path, interpreted relative to the
       directory containing the project file.
    **-** Otherwise,uuidis mapped tosrc/X.jlrelative to the directory containing the project file.
2. If the above is not the case and the project file has a corresponding manifest file and the manifest
    contains a stanza matchinguuidthen:
       **-** If it has apathentry, use that path (relative to the directory containing the manifest file).
       **-** Ifithasagit-tree-sha1entry,computeadeterministichashfunctionofuuidandgit-tree-sha1—call
          itslug—andlookforadirectorynamedpackages/X/$slugineachdirectoryintheJuliaDEPOT_PATH
          global array. Use the first such directory that exists.

If any of these result in success, the path to the source code entry point will be either that result, the relative
pathfromthatresultplussrc/X.jl; otherwise, thereisnopathmappingforuuid. WhenloadingX,ifnosource
codepathisfound,thelookupwillfail,andtheusermaybepromptedtoinstalltheappropriatepackageversion
or to take other corrective action (e.g. declaringXas a dependency).

Intheexamplemanifestfileabove,tofindthepathofthefirstPrivpackage—theonewithUUIDba13f791-ae1d-
465a-978b-69c3ad90f72b—Julia looks for its stanza in the manifest file, sees that it has apathentry, looks at
deps/PrivrelativetotheAppprojectdirectory—let'ssupposetheAppcodelivesin/home/me/projects/App—sees
that/home/me/projects/App/deps/Privexists and therefore loadsPrivfrom there.

If, on the other hand, Julia was loading the otherPrivpackage—the one with UUID2d15fe94-a1f7-436c-
a4d8-07a9a496e01c—it finds its stanza in the manifest, see that it does not have apathentry, but that it does
have agit-tree-sha1entry. It then computes theslugfor this UUID/SHA-1 pair, which isHDkrT(the exact
details of this computation aren't important, but it is consistent and deterministic). This means that the path
to thisPrivpackage will bepackages/Priv/HDkrT/src/Priv.jlin one of the package depots. Suppose the
contents ofDEPOT_PATHis["/home/me/.julia", "/usr/local/julia"], then Julia will look at the following
paths to see if they exist:

1. /home/me/.julia/packages/Priv/HDkrT
2. /usr/local/julia/packages/Priv/HDkrT

JuliausesthefirstofthesethatexiststotrytoloadthepublicPrivpackagefromthefilepackages/Priv/HDKrT/src/Priv.jl
in the depot where it was found.

Here is a representation of a possible paths map for our exampleAppproject environment, as provided in the
Manifest given above for the dependency graph, after searching the local file system:


#### CHAPTER 31. CODE LOADING 344

```

paths= Dict (

# Priv – the private one:

(UUID("ba13f791-ae1d-465a-978b-69c3ad90f72b"), :Priv)=>

# relative entry-point inside `App` repo:

"/home/me/projects/App/deps/Priv/src/Priv.jl",

# Priv – the public one:

(UUID("2d15fe94-a1f7-436c-a4d8-07a9a496e01c"), :Priv)=>

# package installed in the system depot:

"/usr/local/julia/packages/Priv/HDkr/src/Priv.jl",

# Pub:

(UUID("c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1"), :Pub)=>

# package installed in the user depot:

"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl",

# Zebra:

(UUID("f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62"), :Zebra)=>

# package installed in the system depot:

"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl",  
)

```
This example map includes three different kinds of package locations (the first and third are part of the default
load path):

1. The privatePrivpackage is"vendored" inside theApprepository.
2. The publicPrivandZebrapackages are in the system depot, where packages installed and managed
    by the system administrator live. These are available to all users on the system.
3. ThePubpackage is in the user depot, where packages installed by the user live. These are only available
    to the user who installed them.

### Package directories

Package directories provide a simpler kind of environment without the ability to handle name collisions. In
a package directory, the set of top-level packages is the set of subdirectories that"look like" packages. A
packageXexists in a package directory if the directory contains one of the following"entry point" files:

- X.jl
- X/src/X.jl
- X.jl/src/X.jl

Which dependencies a package in a package directory can import depends on whether the package contains
a project file:

- If it has a project file, it can only import those packages which are identified in the[deps]section of the
    project file.
- If it does not have a project file, it can import any top-level package—i.e. the same packages that can
    be loaded inMainor the REPL.

**The roots map** is determined by examining the contents of the package directory to generate a list of all
packages that exist. Additionally, a UUID will be assigned to each entry as follows: For a given package found
inside the folderX...


#### CHAPTER 31. CODE LOADING 345

1. IfX/Project.tomlexists and has auuidentry, thenuuidis that value.
2. IfX/Project.tomlexistsandbutdoesnothaveatop-levelUUIDentry,uuidisadummyUUIDgenerated
    by hashing the canonical (real) path toX/Project.toml.
3. Otherwise (ifProject.tomldoes not exist), thenuuidis the all-zeronil UUID.

**The dependency graph** of a project directory is determined by the presence and contents of project files in
the subdirectory of each package. The rules are:

- If a package subdirectory has no project file, then it is omitted from graph and import statements in its
    code are treated as top-level, the same as the main project and REPL.
- If a package subdirectory has a project file, then the graph entry for its UUID is the[deps]map of the
    project file, which is considered to be empty if the section is absent.

As an example, suppose a package directory has the following structure and content:

```

Aardvark/  
src/Aardvark.jl:  
import Bobcat  
import Cobra

Bobcat/  
Project.toml:  
[deps]  
Cobra = "4725e24d-f727-424b-bca0-c4307a3456fa"  
Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

src/Bobcat.jl:  
import Cobra  
import Dingo

Cobra/  
Project.toml:  
uuid = "4725e24d-f727-424b-bca0-c4307a3456fa"  
[deps]  
Dingo = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

src/Cobra.jl:  
import Dingo

Dingo/  
Project.toml:  
uuid = "7a7925be-828c-4418-bbeb-bac8dfc843bc"

src/Dingo.jl:

# no imports

```
Here is a corresponding roots structure, represented as a dictionary:

```

roots= Dict (  
:Aardvark=> UUID("00000000-0000-0000-0000-000000000000"), # no project file, nil UUID  
:Bobcat => UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), # dummy UUID based on path  
:Cobra => UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), # UUID from project file  
:Dingo => UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), # UUID from project file  
)

```

#### CHAPTER 31. CODE LOADING 346

Here is the corresponding graph structure, represented as a dictionary:

```

graph= Dict (

# Bobcat:

UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf") => Dict (  
:Cobra=> UUID("4725e24d-f727-424b-bca0-c4307a3456fa"),  
:Dingo=> UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),  
),

# Cobra:

UUID("4725e24d-f727-424b-bca0-c4307a3456fa") => Dict (  
:Dingo=> UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"),  
),

# Dingo:

UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc") => Dict (),  
)

```
A few general rules to note:

1. A package without a project file can depend on any top-level dependency, and since every package in
    a package directory is available at the top-level, it can import all packages in the environment.
2. A package with a project file cannot depend on one without a project file since packages with project
    files can only load packages ingraphand packages without project files do not appear ingraph.
3. A package with a project file but no explicit UUID can only be depended on by packages without project
    files since dummy UUIDs assigned to these packages are strictly internal.

Observe the following specific instances of these rules in our example:

- Aardvarkcan import on any ofBobcat,CobraorDingo; it does importBobcatandCobra.
- Bobcatcan and does import bothCobraandDingo, which both have project files with UUIDs and are
    declared as dependencies inBobcat's[deps]section.
- Bobcatcannot depend onAardvarksinceAardvarkdoes not have a project file.
- Cobracan and does importDingo, which has a project file and UUID, and is declared as a dependency
    inCobra's[deps]section.
- Cobracannot depend onAardvarkorBobcatsince neither have real UUIDs.
- Dingocannot import anything because it has a project file without a[deps]section.

**The paths map** in a package directory is simple: it maps subdirectory names to their corresponding entry-
point paths. In other words, if the path to our example project directory is/home/me/animalsthen thepaths
map could be represented by this dictionary:

```

paths= Dict (  
(UUID("00000000-0000-0000-0000-000000000000"), :Aardvark)=>  
"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl",  
(UUID("85ad11c7-31f6-5d08-84db-0a4914d4cadf"), :Bobcat)=>  
"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl",  
(UUID("4725e24d-f727-424b-bca0-c4307a3456fa"), :Cobra)=>  
"/home/me/AnimalPackages/Cobra/src/Cobra.jl",

```

#### CHAPTER 31. CODE LOADING 347

```

(UUID("7a7925be-828c-4418-bbeb-bac8dfc843bc"), :Dingo)=>  
"/home/me/AnimalPackages/Dingo/src/Dingo.jl",  
)

```
Since all packages in a package directory environment are, by definition, subdirectories with the expected
entry-point files, theirpathsmap entries always have this form.

### Environment stacks

Thethirdandfinalkindofenvironmentisonethatcombinesotherenvironmentsbyoverlayingseveralofthem,
making the packages in each available in a single composite environment. These composite environments are
called environment stacks. The JuliaLOAD_PATHglobal defines an environment stack—the environment in
which the Julia process operates. If you want your Julia process to have access only to the packages in one
project or package directory, make it the only entry inLOAD_PATH. It is often quite useful, however, to have
access to some of your favorite tools—standard libraries, profilers, debuggers, personal utilities, etc.—even if
they are not dependencies of the project you're working on. By adding an environment containing these tools
to the load path, you immediately have access to them in top-level code without needing to add them to your
project.

Themechanismforcombiningtheroots, graphandpathsdatastructuresofthecomponentsofanenvironment
stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key
collisions. In other words, if we havestack = [env₁, env₂, ...]then we have:

```

roots= reduce(merge, reverse([roots₁, roots₂, ...]))  
graph= reduce(merge, reverse([graph₁, graph₂, ...]))  
paths= reduce(merge, reverse([paths₁, paths₂, ...]))

```
The subscriptedrootsᵢ,graphᵢandpathsᵢvariables correspond to the subscripted environments,envᵢ,
contained instack. Thereverseis present becausemergefavors the last argument rather than first when
there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of
this design:

1. The primary environment—i.e. the first environment in a stack—is faithfully embedded in a stacked
    environment. The full dependency graph of the first environment in a stack is guaranteed to be included
    intact in the stacked environment including the same versions of all dependencies.
2. Packages in non-primary environments can end up using incompatible versions of their dependencies
    eveniftheirownenvironmentsareentirelycompatible. Thiscanhappenwhenoneoftheirdependencies
    is shadowed by a version in an earlier environment in the stack (either by graph or path, or both).

Since the primary environment is typically the environment of a project you're working on, while environments
later in the stack contain additional tools, this is the right trade-off: it's better to break your development tools
but keep the project working. When such incompatibilities occur, you'll typically want to upgrade your dev
tools to versions that are compatible with the main project.

### 31.4 Conclusion.

Federated package management and precise software reproducibility are difficult but worthy goals in a pack-
age system. In combination, these goals lead to a more complex package loading mechanism than most
dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated
with static languages. Typically, Julia users should be able to use the built-in package manager to manage


#### CHAPTER 31. CODE LOADING 348

their projects without needing a precise understanding of these interactions. A call toPkg.add("X")will add
to the appropriate project and manifest files, selected viaPkg.activate("Y"), so that a future call toimport
Xwill loadXwithout further thought.


**Chapter 32**

**Profiling**

TheProfilemodule provides tools to help developers improve the performance of their code. When used,
it takes measurements on running code, and produces output that helps you understand how much time is
spent on individual line(s). The most common usage is to identify"bottlenecks" as targets for optimization.

Profileimplements what is known as a"sampling" or statistical profiler. It works by periodically taking a
backtrace during the execution of any task. Each backtrace captures the currently-running function and line
number, plus the complete chain of function calls that led to this line, and hence is a"snapshot" of the current
state of execution.

If much of your run time is spent executing a particular line of code, this line will show up frequently in the set
of all backtraces. In other words, the"cost" of a given line–or really, the cost of the sequence of function calls
up to and including this line–is proportional to how often it appears in the set of all backtraces.

A sampling profiler does not provide complete line-by-line coverage, because the backtraces occur at intervals
(bydefault,1msonUnixsystemsand10msonWindows,althoughtheactualschedulingissubjecttooperating
system load). Moreover, as discussed further below, because samples are collected at a sparse subset of all
execution points, the data collected by a sampling profiler is subject to statistical noise.

Despite these limitations, sampling profilers have substantial strengths:

- You do not have to make any modifications to your code to take timing measurements.
- It can profile into Julia's core code and even (optionally) into C and Fortran libraries.
- By running"infrequently" there is very little performance overhead; while profiling, your code can run
    at nearly native speed.

For these reasons, it's recommended that you try using the built-in sampling profiler before considering any
alternatives.

### 32.1 Basic usage

Let 's work with a simple test case:

```

julia>function myfunc()  
A = rand(200, 200, 400)  
maximum(A)  
end

```
#### 349


#### CHAPTER 32. PROFILING 350

It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's
JIT-compiler):

```

julia> myfunc()# run once to force compilation

```
Now we're ready to profile this function:

```

julia>using Profile

julia> @profilemyfunc()

```
To see the profiling results, there are several graphical browsers. One"family" of visualizers is based on
FlameGraphs.jl, with each family member providing a different user interface:

- Juno is a full IDE with built-in support for profile visualization
- ProfileView.jlis a stand-alone visualizer based on GTK
- ProfileVega.jluses VegaLight and integrates well with Jupyter notebooks
- StatProfilerHTMLproduces HTML and presents some additional summaries, and also integrates well with
    Jupyter notebooks
- ProfileSVGrenders SVG

An entirely independent approach to profile visualization isPProf.jl , which uses the externalpproftool.

Here, though, we'll use the text-based display that comes with the standard library:

```

julia> Profile.print()  
80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()  
80 ./REPL.jl:97; macro expansion  
80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)  
80 ./boot.jl:235; eval(::Module, ::Any)  
80 ./:?; anonymous  
80 ./profile.jl:23; macro expansion  
52 ./REPL[1]:2; myfunc()  
38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...  
38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...  
14 ./random.jl:278; rand  
14 ./random.jl:277; rand  
14 ./random.jl:366; rand  
14 ./random.jl:369; rand  
28 ./REPL[1]:3; myfunc()  
28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...  
3 ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...  
25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...

```
Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate
the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each
line, the first"field" is the number of backtraces (samples) taken at this line or in any functions executed by
this line. The second field is the file name and line number and the third field is the function name. Note that


#### CHAPTER 32. PROFILING 351

the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this
example yourself.

In this example, we can see that the top level function called is in the fileevent.jl. This is the function
that runs the REPL when you launch Julia. If you examine line 97 ofREPL.jl, you 'll see this is where the
functioneval_user_input()is called. This is the function that evaluates what you type at the REPL, and
since we're working interactively these functions were invoked when we entered@profile myfunc(). The
next line reflects actions taken in the@profilemacro.

The first line shows that 80 backtraces were taken at line 73 ofevent.jl, but it's not that this line was"ex-
pensive" on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call
toeval_user_input, and so on. To find out which operations are actually taking the time, we need to look
deeper in the call chain.

The first"important" line in this output is this one:

```

52 ./REPL[1]:2; myfunc()

```
REPLrefers to the fact that we definedmyfuncin the REPL, rather than putting it in a file; if we had used a file,
this would show the file name. The[1]shows that the functionmyfuncwas the first expression evaluated in
this REPL session. Line 2 ofmyfunc()contains the call torand, and there were 52 (out of 80) backtraces that
occurred at this line. Below that, you can see a call todsfmt_fill_array_close_open!insidedSFMT.jl.

A little further down, you see:

```

28 ./REPL[1]:3; myfunc()

```
Line 3 ofmyfunccontains the call tomaximum, and there were 28 (out of 80) backtraces taken here. Below
that, you can see the specific places inbase/reduce.jlthat carry out the time-consuming operations in the
maximumfunction for this type of input data.

Overall, we can tentatively conclude that generating the random numbers is approximately twice as expensive
as finding the maximum element. We could increase our confidence in this result by collecting more samples:

```

julia> @profile( for i = 1:100; myfunc(); end )

julia> Profile.print()  
[....]  
3821 ./REPL[1]:2; myfunc()  
3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...  
3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...  
310 ./random.jl:278; rand  
[....]  
2893 ./REPL[1]:3; myfunc()  
2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...  
[....]

```
In general, if you haveNsamples collected at a line, you can expect an uncertainty on the order ofsqrt(N)
(barring other sources of noise, like how busy the computer is with other tasks). The major exception to this
rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage
collector is written in C, such events can be detected using theC=trueoutput mode described below, or by
using ProfileView.jl.)

This illustrates the default"tree " dump; an alternative is the"flat" dump, which accumulates counts indepen-
dent of their nesting:


#### CHAPTER 32. PROFILING 352

```

julia> Profile.print(format=:flat)  
Count File Line Function  
6714 ./ -1 anonymous  
6714 ./REPL.jl 66 eval_user_input(::Any, ::Base.REPL.REPLBackend)  
6714 ./REPL.jl 97 macro expansion  
3821 ./REPL[1] 2 myfunc()  
2893 ./REPL[1] 3 myfunc()  
6714 ./REPL[7] 1 macro expansion  
6714 ./boot.jl 235 eval(::Module, ::Any)  
3511 ./dSFMT.jl 84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...  
6714 ./event.jl 73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()  
6714 ./profile.jl 23 macro expansion  
3511 ./random.jl 431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...  
310 ./random.jl 277 rand  
310 ./random.jl 278 rand  
310 ./random.jl 366 rand  
310 ./random.jl 369 rand  
2893 ./reduce.jl 270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...  
5 ./reduce.jl 420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...  
253 ./reduce.jl 426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...  
2592 ./reduce.jl 428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...  
43 ./reduce.jl 429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...

```
If your code has recursion, one potentially-confusing point is that a line in a"child" function can accumulate
more counts than there are total backtraces. Consider the following function definitions:

```

dumbsum(n:: Integer ) = n == 1? 1 : 1 + dumbsum(n-1)  
dumbsum3()= dumbsum(3)

```
If you were to profiledumbsum3, and a backtrace was taken while it was executingdumbsum(1), the backtrace
would look like this:

```

dumbsum3  
dumbsum(3)  
dumbsum(2)  
dumbsum(1)

```
Consequently, this child function gets 3 counts, even though the parent only gets one. The"tree " representa-
tion makes this much clearer, and for this reason (among others) is probably the most useful way to view the
results.

### 32.2 Accumulation and clearing

Results from@profileaccumulate in a buffer; if you run multiple pieces of code under@profile, then
Profile.print()will show you the combined results. This can be very useful, but sometimes you want
to start fresh; you can do so withProfile.clear().

### 32.3 Options for controlling the display of profile results.

Profile.printhas more options than we've described so far. Let's see the full declaration:

```

function print(io:: IO = stdout, data= fetch(); kwargs...)

```

#### CHAPTER 32. PROFILING 353

Let 's first discuss the two positional arguments, and later the keyword arguments:

- io– Allows you to save the results to a buffer, e.g. a file, but the default is to print tostdout(the
    console).
- data– Contains the data you want to analyze; by default that is obtained fromProfile.fetch(), which
    pulls out the backtraces from a pre-allocated buffer. For example, if you want to profile the profiler, you
    could say:

```

data= copy(Profile.fetch())  
Profile.clear()  
@profileProfile.print(stdout, data)# Prints the previous results  
Profile.print() # Prints results from Profile.print()

```
The keyword arguments can be any combination of:

- format– Introduced above, determines whether backtraces are printed with (default,:tree) or without
    (:flat) indentation indicating tree structure.
- C– Iftrue, backtraces from C and Fortran code are shown (normally they are excluded). Try running
    the introductory example withProfile.print(C = true). This can be extremely helpful in deciding
    whether it's Julia code or C code that is causing a bottleneck; settingC = truealso improves the inter-
    pretability of the nesting, at the cost of longer profile dumps.
- combine–Somelinesofcodecontainmultipleoperations;forexample,s += A[i]containsbothanarray
    reference (A[i]) and a sum operation. These correspond to different lines in the generated machine
    code, and hence there may be two or more different addresses captured during backtraces on this line.
    combine = truelumps them together, and is probably what you typically want, but you can generate
    an output separately for each unique instruction pointer withcombine = false.
- maxdepth– Limits frames at a depth higher thanmaxdepthin the:treeformat.
- sortedby– Controls the order in:flatformat. :filefuncline(default) sorts by the source line,
    whereas:countsorts in order of number of collected samples.
- noisefloor– Limits frames that are below the heuristic noise floor of the sample (only applies to format
    :tree). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which
    n <= noisefloor * √N, wherenis the number of samples on this line, andNis the number of samples
    for the callee.
- mincount– Limits frames with less thanmincountoccurrences.

File/function names are sometimes truncated (with...), and indentation is truncated with a+nat the begin-
ning, wherenis the number of extra spaces that would have been inserted, had there been room. If you want
a complete profile of deeply-nested code, often a good idea is to save to a file using a widedisplaysizein an
IOContext:

```

open("/tmp/prof.txt", "w") do s  
Profile.print(IOContext(s,:displaysize=> (24, 500)))  
end

```

#### CHAPTER 32. PROFILING 354

### 32.4 Configuration

@profilejust accumulates backtraces, and the analysis happens when you callProfile.print(). For a long-
running computation, it's entirely possible that the pre-allocated buffer for storing backtraces will be filled. If
that happens, the backtraces stop but your computation continues. As a consequence, you may miss some
important profiling data (you will get a warning when that happens).

You can obtain and configure the relevant parameters this way:

```

Profile.init()# returns the current settings  
Profile.init(n= 10^7, delay= 0.01)

```
nisthetotalnumberofinstructionpointersyoucanstore, withadefaultvalueof10^6. Ifyourtypicalbacktrace
is 20 instruction pointers, then you can collect 50000 backtraces, which suggests a statistical uncertainty of
less than 1%. This may be good enough for most applications.

Consequently, you are more likely to need to modifydelay, expressed in seconds, which sets the amount of
time that Julia gets between snapshots to perform the requested computations. A very long-running job might
not need frequent backtraces. The default setting isdelay = 0.001. Of course, you can decrease the delay
as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount
of time needed to take a backtrace (~30 microseconds on the author's laptop).

### 32.5 Memory allocation analysis

Oneofthemostcommontechniquestoimproveperformanceistoreducememoryallocation. Thetotalamount
of allocation can be measured with@timeand@allocated, and specific lines triggering allocation can often
be inferred from profiling via the cost of garbage collection that these lines incur. However, sometimes it is
more efficient to directly measure the amount of memory allocated by each line of code.

To measure allocation line-by-line, start Julia with the--track-allocation=<setting>command-line option,
for which you can choosenone(the default, do not measure allocation),user(measure memory allocation
everywhere except Julia's core code), orall(measure memory allocation at each line of Julia code). Allocation
gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text
fileswith.memappendedafterthefilename, residinginthesamedirectoryasthesourcefile. Eachlineliststhe
total number of bytes allocated. TheCoveragepackagecontains some elementary analysis tools, for example
to sort the lines in order of number of bytes allocated.

Ininterpretingtheresults,thereareafewimportantdetails. Undertheusersetting,thefirstlineofanyfunction
directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More
significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia
(and compilation usually requires memory allocation). The recommended procedure is to force compilation
by executing all the commands you want to analyze, then callProfile.clear_malloc_data()to reset all
allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the.mem
files.

### 32.6 External Profiling.

Currently Julia supportsIntel VTune,OProfileandperfas external profiling tools.

Dependingonthetoolyouchoose,compilewithUSE_INTEL_JITEVENTS,USE_OPROFILE_JITEVENTSandUSE_PERF_JITEVENTS
set to 1 inMake.user. Multiple flags are supported.

Before running Julia set the environment variableENABLE_JITPROFILINGto 1.


#### CHAPTER 32. PROFILING 355

Now you have a multitude of ways to employ those tools! For example withOProfileyou can try a simple
recording :

```

> ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl  
> opreport -l `which ./julia`

```
Or similary withperf:

```

$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf -k 1 ./julia /test/fastmath  
.jl  
$ perf inject --jit --input /tmp/perf.data --output /tmp/perf-jit.data  
$ perf report --call-graph -G -i /tmp/perf-jit.data

```
There are many more interesting things that you can measure about your program, to get a comprehensive
list please read theLinux perf examples page.

Remember that perf saves for each execution aperf.datafile that, even for small programs, can get quite
large. Also the perf LLVM module saves temporarily debug objects in~/.debug/jit, remember to clean that
folder frequently.


**Chapter 33**

**Stack Traces**

TheStackTracesmodule provides simple stack traces that are both human readable and easy to use pro-
grammatically.

### 33.1 Viewing a stack trace

The primary function used to obtain a stack trace isstacktrace:

```

6-element Array{Base.StackTraces.StackFrame,1}:  
top-level scope  
eval at boot.jl:317 [inlined]  
eval(::Module, ::Expr) at REPL.jl:5  
eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
macro expansion at REPL.jl:116 [inlined]  
(::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92

```
Callingstacktrace()returnsavectorofStackTraces.StackFrames. Foreaseofuse,thealiasStackTraces.StackTrace
can be used in place ofVector{StackFrame}. (Examples with[...]indicate that output may vary depending
on how the code is run.)

```

julia> example()= stacktrace()  
example (generic function with 1 method)

julia> example()  
7-element Array{Base.StackTraces.StackFrame,1}:  
example() at REPL[1]:1  
top-level scope  
eval at boot.jl:317 [inlined]  
[...]

julia> @noinlinechild()= stacktrace()  
child (generic function with 1 method)

julia> @noinlineparent()= child()  
parent (generic function with 1 method)

julia> grandparent()= parent()  
grandparent (generic function with 1 method)

```
#### 356


#### CHAPTER 33. STACK TRACES 357

```

julia> grandparent()  
9-element Array{Base.StackTraces.StackFrame,1}:  
child() at REPL[3]:1  
parent() at REPL[4]:1  
grandparent() at REPL[5]:1  
[...]

```
Notethatwhencallingstacktrace()you'lltypicallyseeaframewitheval at boot.jl. Whencallingstacktrace()
from the REPL you'll also have a few extra frames in the stack fromREPL.jl, usually looking something like
this:

```

julia> example()= stacktrace()  
example (generic function with 1 method)

julia> example()  
7-element Array{Base.StackTraces.StackFrame,1}:  
example() at REPL[1]:1  
top-level scope  
eval at boot.jl:317 [inlined]  
eval(::Module, ::Expr) at REPL.jl:5  
eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
macro expansion at REPL.jl:116 [inlined]  
(::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92

```
### 33.2 Extracting useful information

EachStackTraces.StackFramecontains the function name, file name, line number, lambda info, a flag indi-
cating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions
do not appear in the stack trace), and an integer representation of the pointer returned bybacktrace:

```

julia> frame= stacktrace()[3]  
eval(::Module, ::Expr) at REPL.jl:5

julia> frame.func  
:eval

julia> frame.file  
Symbol("~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl")

julia> frame.line  
5

julia> frame.linfo  
MethodInstance for eval(::Module, ::Expr)

julia> frame.inlined  
false

julia> frame.from_c  
false

julia> frame.pointer  
0x00007f92d6293171

```
This makes stack trace information available programmatically for logging, error handling, and more.


#### CHAPTER 33. STACK TRACES 358

### 33.3 Error handling

While having easy access to information about the current state of the callstack can be helpful in many places,
the most obvious application is in error handling and debugging.

```

julia> @noinlinebad_function()= undeclared_variable  
bad_function (generic function with 1 method)

julia> @noinlineexample()= try  
bad_function()  
catch  
stacktrace()  
end  
example (generic function with 1 method)

julia> example()  
7-element Array{Base.StackTraces.StackFrame,1}:  
example() at REPL[2]:4  
top-level scope  
eval at boot.jl:317 [inlined]  
[...]

```
You may notice that in the example above the first stack frame points at line 4, wherestacktraceis called,
rather than line 2, where bad_function is called, andbad_function's frame is missing entirely. This is un-
derstandable, given thatstacktraceis called from the context of the catch. While in this example it's fairly
easy to find the actual source of the error, in complex cases tracking down the source of the error becomes
nontrivial.

This can be remedied by passing the result ofcatch_backtracetostacktrace. Instead of returning callstack
information for the current context,catch_backtracereturns stack information for the context of the most
recent exception:

```

julia> @noinlinebad_function()= undeclared_variable  
bad_function (generic function with 1 method)

julia> @noinlineexample()= try  
bad_function()  
catch  
stacktrace(catch_backtrace())  
end  
example (generic function with 1 method)

julia> example()  
8-element Array{Base.StackTraces.StackFrame,1}:  
bad_function() at REPL[1]:1  
example() at REPL[2]:2  
[...]

```
Notice that the stack trace now indicates the appropriate line number and the missing frame.

```

julia> @noinlinechild()= error("Whoops!")  
child (generic function with 1 method)

julia> @noinlineparent()= child()

```

#### CHAPTER 33. STACK TRACES 359

```

parent (generic function with 1 method)

julia> @noinline function grandparent()  
try  
parent()  
catch err  
println("ERROR: ", err.msg)  
stacktrace(catch_backtrace())  
end  
end  
grandparent (generic function with 1 method)

julia> grandparent()  
ERROR: Whoops!  
10-element Array{Base.StackTraces.StackFrame,1}:  
error at error.jl:33 [inlined]  
child() at REPL[1]:1  
parent() at REPL[2]:1  
grandparent() at REPL[3]:3  
[...]

```
### 33.4 Exception stacks andcurrent_exceptions.

```

Julia 1.1  
Exception stacks requires at least Julia 1.1.

```
While handling an exception further exceptions may be thrown. It can be useful to inspect all these exceptions
to identify the root cause of a problem. The julia runtime supports this by pushing each exception onto an
internal exception stack as it occurs. When the code exits acatchnormally, any exceptions which were
pushed onto the stack in the associatedtryare considered to be successfully handled and are removed from
the stack.

The stack of current exceptions can be accessed using thecurrent_exceptionsfunction. For example,

```

julia>try  
error("(A) The root cause")  
catch  
try  
error("(B) An exception while handling the exception")  
catch  
for (exc, bt) in current_exceptions()  
showerror(stdout, exc, bt)  
println(stdout)  
end  
end  
end  
(A) The root cause  
Stacktrace:  
[1] error(::String) at error.jl:33  
[2] top-level scope at REPL[7]:2  
[3] eval(::Module, ::Any) at boot.jl:319  
[4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
[5] macro expansion at REPL.jl:117 [inlined]  
[6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259

```

#### CHAPTER 33. STACK TRACES 360

```

(B) An exception while handling the exception  
Stacktrace:  
[1] error(::String) at error.jl:33  
[2] top-level scope at REPL[7]:5  
[3] eval(::Module, ::Any) at boot.jl:319  
[4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
[5] macro expansion at REPL.jl:117 [inlined]  
[6] (::getfield(REPL, Symbol("##26#27")){REPL.REPLBackend})() at task.jl:259

```
In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After
exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from
the stack and are no longer accessible.

The exception stack is stored on theTaskwhere the exceptions occurred. When a task fails with uncaught
exceptions,current_exceptions(task)may be used to inspect the exception stack for that task.

### 33.5 Comparison withbacktrace.

A call tobacktracereturns a vector ofUnion{Ptr{Nothing}, Base.InterpreterIP}, which may then be
passed intostacktracefor translation:

```

julia> trace= backtrace()  
18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:  
Ptr{Nothing} @0x00007fd8734c6209  
Ptr{Nothing} @0x00007fd87362b342  
Ptr{Nothing} @0x00007fd87362c136  
Ptr{Nothing} @0x00007fd87362c986  
Ptr{Nothing} @0x00007fd87362d089  
Base.InterpreterIP(CodeInfo(:(begin  
Core.SSAValue(0) = backtrace()  
trace = Core.SSAValue(0)  
return Core.SSAValue(0)  
end)), 0x0000000000000000)  
Ptr{Nothing} @0x00007fd87362e4cf  
[...]

julia> stacktrace(trace)  
6-element Array{Base.StackTraces.StackFrame,1}:  
top-level scope  
eval at boot.jl:317 [inlined]  
eval(::Module, ::Expr) at REPL.jl:5  
eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
macro expansion at REPL.jl:116 [inlined]  
(::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92

```
Notice that the vector returned bybacktracehad 18 elements, while the vector returned bystacktraceonly
has 6. This is because, by default,stacktraceremoves any lower-level C functions from the stack. If you want
to include stack frames from C calls, you can do it like this:

```

julia> stacktrace(trace, true )  
21-element Array{Base.StackTraces.StackFrame,1}:  
jl_apply_generic at gf.c:2167  
do_call at interpreter.c:324  
eval_value at interpreter.c:416

```

#### CHAPTER 33. STACK TRACES 361

```

eval_body at interpreter.c:559  
jl_interpret_toplevel_thunk_callback at interpreter.c:798  
top-level scope  
jl_interpret_toplevel_thunk at interpreter.c:807  
jl_toplevel_eval_flex at toplevel.c:856  
jl_toplevel_eval_in at builtins.c:624  
eval at boot.jl:317 [inlined]  
eval(::Module, ::Expr) at REPL.jl:5  
jl_apply_generic at gf.c:2167  
eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85  
jl_apply_generic at gf.c:2167  
macro expansion at REPL.jl:116 [inlined]  
(::getfield(REPL, Symbol("##28#29")){REPL.REPLBackend})() at event.jl:92  
jl_fptr_trampoline at gf.c:1838  
jl_apply_generic at gf.c:2167  
jl_apply at julia.h:1540 [inlined]  
start_task at task.c:268  
ip:0xffffffffffffffff

```
Individual pointers returned bybacktracecan be translated intoStackTraces.StackFrames by passing them
intoStackTraces.lookup:

```

julia> pointer= backtrace()[1];

julia> frame= StackTraces.lookup(pointer)  
1-element Array{Base.StackTraces.StackFrame,1}:  
jl_apply_generic at gf.c:2167

julia> println("The top frame is from $ (frame[1].func)!")  
The top frame is from jl_apply_generic!

```

**Chapter 34**

**Performance Tips**

In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast
as possible.

### 34.1 Performance critical code should be inside a function.

Any code that is performance critical should be inside a function. Code inside functions tends to run much
faster than top level code, due to how Julia's compiler works.

The use of functions is not only important for performance: functions are more reusable and testable, and
clarify what steps are being done and what their inputs and outputs are,Write functions, not just scriptsis also
a recommendation of Julia's Styleguide.

The functions should take arguments, instead of operating directly on global variables, see the next point.

### 34.2 Avoid global variables.

A global variable might have its value, and therefore its type, change at any point. This makes it difficult for
the compiler to optimize code using global variables. Variables should be local, or passed as arguments to
functions, whenever possible.

Wefindthatglobalnamesarefrequentlyconstants, anddeclaringthemassuchgreatlyimprovesperformance:

```

const DEFAULT_VAL= 0

```
Uses of non-constant globals can be optimized by annotating their types at the point of use:

```

global x = rand(1000)

function loop_over_global()  
s = 0.0  
for i in x:: Vector { Float64 }  
s += i  
end  
return s  
end

```
Passing arguments to functions is better style. It leads to more reusable code and clarifies what the inputs and
outputs are.

#### 362


#### CHAPTER 34. PERFORMANCE TIPS 363

```

Note  
All code in the REPL is evaluated in global scope, so a variable defined and assigned at top level  
will be a global variable. Variables defined at top level scope inside modules are also global.

```
In the following REPL session:

```

julia> x = 1.0

```
is equivalent to:

```

julia>global x = 1.0

```
so all the performance issues discussed previously apply.

### 34.3 Measure performance with@timeand pay attention to memory allocation.

A useful tool for measuring performance is the@timemacro. We here repeat the example with the global
variable above, but this time with the type annotation removed:

```

julia> x = rand(1000);

julia>function sum_global()  
s = 0.0  
for i in x  
s += i  
end  
return s  
end ;

julia> @timesum_global()  
0.011539 seconds (9.08 k allocations: 373.386 KiB, 98.69% compilation time)  
523.0007221951678

julia> @timesum_global()  
0.000091 seconds (3.49 k allocations: 70.156 KiB)  
523.0007221951678

```
Onthefirstcall(@time sum_global())thefunctiongetscompiled. (Ifyou'venotyetused@timeinthissession,
it will also compile functions needed for timing.) You should not take the results of this run seriously. For the
second run, note that in addition to reporting the time, it also indicated that a significant amount of memory
was allocated. We are here just computing a sum over all elements in a vector of 64-bit floats so there should
be no need to allocate memory (at least not on the heap which is what@timereports).

Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem
with type-stability or creating many small temporary arrays. Consequently, in addition to the allocation itself,
it's very likely that the code generated for your function is far from optimal. Take such indications seriously
and follow the advice below.

If we instead passxas an argument to the function it no longer allocates memory (the allocation reported
below is due to running the@timemacro in global scope) and is significantly faster after the first call:


#### CHAPTER 34. PERFORMANCE TIPS 364

```

julia> x = rand(1000);

julia>function sum_arg(x)  
s = 0.0  
for i in x  
s += i  
end  
return s  
end ;

julia> @timesum_arg(x)  
0.007551 seconds (3.98 k allocations: 200.548 KiB, 99.77% compilation time)  
523.0007221951678

julia> @timesum_arg(x)  
0.000006 seconds (1 allocation: 16 bytes)  
523.0007221951678

```
The 1 allocation seen is from running the@timemacro itself in global scope. If we instead run the timing in a
function, we can see that indeed no allocations are performed:

```

julia> time_sum(x)= @timesum_arg(x);

julia> time_sum(x)  
0.000002 seconds  
523.0007221951678

```
Insomesituations, yourfunctionmayneedtoallocatememoryaspartofitsoperation, andthiscancomplicate
the simple picture above. In such cases, consider using one of thetools below to diagnose problems, or write
a version of your function that separates allocation from its algorithmic aspects (seePre-allocating outputs).

```

Note  
For more serious benchmarking, consider theBenchmarkTools.jlpackage which among other  
things evaluates the function multiple times in order to reduce noise.

```
### 34.4 Tools.

Julia and its package ecosystem includes tools that may help you diagnose problems and improve the perfor-
mance of your code:

- Profilingallows you to measure the performance of your running code and identify lines that serve as
    bottlenecks. For complex projects, theProfileViewpackage can help you visualize your profiling results.
- The Traceurpackage can help you find common performance problems in your code.
- Unexpectedly-large memory allocations–as reported by@time,@allocated, or the profiler (through calls
    to the garbage-collection routines)–hint that there might be issues with your code. If you don't see
    another reason for the allocations, suspect a type problem. You can also start Julia with the--track-
    allocation=useroption and examine the resulting*.memfiles to see information about where those
    allocations occur. SeeMemory allocation analysis.
- @code_warntypegenerates a representation of your code that can be helpful in finding expressions that
    result in type uncertainty. See@code_warntypebelow.


#### CHAPTER 34. PERFORMANCE TIPS 365

### 34.5 Avoid containers with abstract type parameters

Whenworkingwithparameterizedtypes, includingarrays,itisbesttoavoidparameterizingwithabstracttypes
where possible.

Consider the following:

```

julia> a = Real []  
Real[]

julia> push!(a,1); push!(a,2.0); push!(a,π)  
3-element Vector{Real}:  
1  
2.0  
π = 3.1415926535897...

```
Becauseais an array of abstract typeReal, it must be able to hold anyRealvalue. SinceRealobjects can
be of arbitrary size and structure,amust be represented as an array of pointers to individually allocatedReal
objects. However, if we instead only allow numbers of the same type, e.g.Float64, to be stored inathese
can be stored more efficiently:

```

julia> a = Float64 []  
Float64[]

julia> push!(a,1); push!(a,2.0); push!(a, π)  
3-element Vector{Float64}:  
1.0  
2.0  
3.141592653589793

```
Assigning numbers intoawill now convert them toFloat64andawill be stored as a contiguous block of 64-bit
floating-point values that can be manipulated efficiently.

If you cannot avoid containers with abstract value types, it is sometimes better to parametrize withAnyto
avoid runtime type checking. E.g.IdDict{Any, Any}performs better thanIdDict{Type, Vector}

See also the discussion underParametric Types.

### 34.6 Type declarations

In many languages with optional type declarations, adding declarations is the principal way to make code run
faster. This is not the case in Julia. In Julia, the compiler generally knows the types of all function arguments,
local variables, and expressions. However, there are a few specific instances where declarations are helpful.

### Avoid fields with abstract type

Types can be declared without specifying the types of their fields:

```

julia> struct MyAmbiguousType  
a  
end

```

#### CHAPTER 34. PERFORMANCE TIPS 366

This allowsato be of any type. This can often be useful, but it does have a downside: for objects of type
MyAmbiguousType, the compiler will not be able to generate high-performance code. The reason is that the
compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little
can be inferred about an object of typeMyAmbiguousType:

```

julia> b = MyAmbiguousType("Hello")  
MyAmbiguousType("Hello")

julia> c = MyAmbiguousType(17)  
MyAmbiguousType(17)

julia> typeof(b)  
MyAmbiguousType

julia> typeof(c)  
MyAmbiguousType

```
The values ofbandchave the same type, yet their underlying representation of data in memory is very
different. Even if you stored just numeric values in fielda, the fact that the memory representation of aUInt8
differs from aFloat64also means that the CPU needs to handle them using two different kinds of instructions.
Since the required information is not available in the type, such decisions have to be made at run-time. This
slows performance.

You can do better by declaring the type ofa. Here, we are focused on the case whereamight be any one of
several types, in which case the natural solution is to use parameters. For example:

```

julia> mutable struct MyType{T<: AbstractFloat }  
a::T  
end

```
This is a better choice than

```

julia> mutable struct MyStillAmbiguousType  
a:: AbstractFloat  
end

```
because the first version specifies the type ofafrom the type of the wrapper object. For example:

```

julia> m = MyType(3.2)  
MyType{Float64}(3.2)

julia> t = MyStillAmbiguousType(3.2)  
MyStillAmbiguousType(3.2)

julia> typeof(m)  
MyType{Float64}

julia> typeof(t)  
MyStillAmbiguousType

```
The type of fieldacan be readily determined from the type ofm, but not from the type oft. Indeed, intit's
possible to change the type of the fielda:


#### CHAPTER 34. PERFORMANCE TIPS 367

```

julia> typeof(t.a)  
Float64

julia> t.a = 4.5f0  
4.5f0

julia> typeof(t.a)  
Float32

```
In contrast, oncemis constructed, the type ofm.acannot change:

```

julia> m.a = 4.5f0  
4.5f0

julia> typeof(m.a)  
Float64

```
The fact that the type ofm.ais known fromm's type—coupled with the fact that its type cannot change mid-
function—allows the compiler to generate highly-optimized code for objects likembut not for objects liket.

Of course, all of this is true only if we constructmwith a concrete type. We can break this by explicitly con-
structing it with an abstract type:

```

julia> m = MyType{ AbstractFloat }(3.2)  
MyType{AbstractFloat}(3.2)

julia> typeof(m.a)  
Float64

julia> m.a = 4.5f0  
4.5f0

julia> typeof(m.a)  
Float32

```
For all practical purposes, such objects behave identically to those ofMyStillAmbiguousType.

It's quite instructive to compare the sheer amount code generated for a simple function

```

func(m::MyType)= m.a+1

```
using

```

code_llvm(func, Tuple {MyType{ Float64 }})  
code_llvm(func, Tuple {MyType{ AbstractFloat }})

```
For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is
fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time.
This results in shorter and faster code.


#### CHAPTER 34. PERFORMANCE TIPS 368

### Avoid fields with abstract containers

The same best practices also work for container types:

```

julia> struct MySimpleContainer{A<: AbstractVector }  
a::A  
end

julia> struct MyAmbiguousContainer{T}  
a:: AbstractVector {T}  
end

```
For example:

```

julia> c = MySimpleContainer(1:3);

julia> typeof(c)  
MySimpleContainer{UnitRange{Int64}}

julia> c = MySimpleContainer([1:3;]);

julia> typeof(c)  
MySimpleContainer{Vector{Int64}}

julia> b = MyAmbiguousContainer(1:3);

julia> typeof(b)  
MyAmbiguousContainer{Int64}

julia> b = MyAmbiguousContainer([1:3;]);

julia> typeof(b)  
MyAmbiguousContainer{Int64}

```
ForMySimpleContainer, the object is fully-specified by its type and parameters, so the compiler can generate
optimized functions. In most instances, this will probably suffice.

While the compiler can now do its job perfectly well, there are cases where you might wish that your code
could do different things depending on the element type ofa. Usually the best way to achieve this is to wrap
your specific operation (here,foo) in a separate function:

```

julia>function sumfoo(c::MySimpleContainer)  
s = 0  
for x in c.a  
s += foo(x)  
end  
s  
end  
sumfoo (generic function with 1 method)

julia> foo(x:: Integer ) = x  
foo (generic function with 1 method)

julia> foo(x:: AbstractFloat ) = round(x)  
foo (generic function with 2 methods)

```

#### CHAPTER 34. PERFORMANCE TIPS 369

This keeps things simple, while allowing the compiler to generate optimized code in all cases.

However, there are cases where you may need to declare different versions of the outer function for different
element types or types of theAbstractVectorof the fieldainMySimpleContainer. You could do it like this:

```

julia>function myfunc(c::MySimpleContainer{<: AbstractArray {<: Integer }})  
return c.a[1]+1  
end  
myfunc (generic function with 1 method)

julia>function myfunc(c::MySimpleContainer{<: AbstractArray {<: AbstractFloat }})  
return c.a[1]+2  
end  
myfunc (generic function with 2 methods)

julia>function myfunc(c::MySimpleContainer{ Vector {T}}) where T<: Integer  
return c.a[1]+3  
end  
myfunc (generic function with 3 methods)

julia> myfunc(MySimpleContainer(1:3))  
2

julia> myfunc(MySimpleContainer(1.0:3))  
3.0

julia> myfunc(MySimpleContainer([1:3;]))  
4

```
### Annotate values taken from untyped locations

Itisoftenconvenienttoworkwithdatastructuresthatmaycontainvaluesofanytype(arraysoftypeArray{Any}).
But, if you're using one of these structures and happen to know the type of an element, it helps to share this
knowledge with the compiler:

```

function foo(a:: Array { Any ,1})  
x = a[1]:: Int32  
b = x+1  
...  
end

```
Here, we happened to know that the first element ofawould be anInt32. Making an annotation like this has
the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching
certain bugs earlier.

Inthecasethatthetypeofa[1]isnotknownprecisely,xcanbedeclaredviax = convert(Int32, a[1])::Int32.
The use of theconvertfunction allowsa[1]to be any object convertible to anInt32(such asUInt8), thus
increasing the genericity of the code by loosening the type requirement. Notice thatconvertitself needs a
type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce
the type of the return value of a function, evenconvert, unless the types of all the function's arguments are
known.

Type annotation will not enhance (and can actually hinder) performance if the type is abstract, or constructed
at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and
the type-check itself takes time. For example, in the code:


#### CHAPTER 34. PERFORMANCE TIPS 370

```

function nr(a, prec)  
ctype= prec== 32? Float32 : Float64  
b = Complex {ctype}(a)  
c = (b + 1.0f0):: Complex {ctype}  
abs(c)  
end

```
the annotation ofcharms performance. To write performant code involving types constructed at run-time,
use thefunction-barrier techniquediscussed below, and ensure that the constructed type appears among the
argument types of the kernel function so that the kernel operations are properly specialized by the compiler.
For example, in the above snippet, as soon asbis constructed, it can be passed to another functionk, the
kernel. If, for example, functionkdeclaresbas an argument of typeComplex{T}, whereTis a type parameter,
then a type annotation appearing in an assignment statement withinkof the form:

```

c = (b + 1.0f0):: Complex {T}

```
does not hinder performance (but does not help either) since the compiler can determine the type ofcat the
timekis compiled.

### Be aware of when Julia avoids specializing

As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases:
Type,Function, andVararg. Julia will always specialize when the argument is used within the method, but
not if the argument is just passed through to another function. This usually has no performance impact at
runtime andimproves compiler performance. If you find it does have a performance impact at runtime in your
case, you can trigger specialization by adding a type parameter to the method declaration. Here are some
examples:

This will not specialize:

```

function f_type(t) # or t::Type  
x = ones(t,10)  
return sum(map(sin, x))  
end

```
but this will:

```

function g_type(t:: Type {T}) where T  
x = ones(T,10)  
return sum(map(sin, x))  
end

```
These will not specialize:

```

f_func(f, num)= ntuple(f, div(num,2))  
g_func(g:: Function , num)= ntuple(g, div(num,2))

```
but this will:

```

h_func(h::H, num) where {H}= ntuple(h, div(num,2))

```

#### CHAPTER 34. PERFORMANCE TIPS 371

This will not specialize:

```

f_vararg(x:: Int ...) = tuple(x...)

```
but this will:

```

g_vararg(x:: Vararg { Int , N}) where {N}= tuple(x...)

```
One only needs to introduce a single type parameter to force specialization, even if the other types are un-
constrained. For example, this will also specialize, and is useful when the arguments are not all of the same
type:

```

h_vararg(x:: Vararg { Any , N}) where {N}= tuple(x...)

```
Note that@code_typedand friends will always show you specialized code, even if Julia would not normally
specialize that method call. You need to check themethod internalsif you want to see whether specializa-
tions are generated when argument types are changed, i.e., if(@which f(...)).specializationscontains
specializations for the argument in question.

### 34.7 Break functions into multiple definitions

Writing a function as many small definitions allows the compiler to directly call the most applicable code, or
even inline it.

Here is an example of a"compound function" that should really be written as multiple definitions:

```

using LinearAlgebra

function mynorm(A)  
if isa(A, Vector )  
return sqrt(real(dot(A,A)))  
elseif isa(A, Matrix )  
return maximum(svdvals(A))  
else  
error("mynorm: invalid argument")  
end  
end

```
This can be written more concisely and efficiently as:

```

norm(x:: Vector ) = sqrt(real(dot(x, x)))  
norm(A:: Matrix ) = maximum(svdvals(A))

```
It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code
written as themynormexample.


#### CHAPTER 34. PERFORMANCE TIPS 372

### 34.8 Write"type-stable" functions

Whenpossible,ithelpstoensurethatafunctionalwaysreturnsavalueofthesametype. Considerthefollowing
definition:

```

pos(x)= x < 0? 0 : x

```
Although this seems innocent enough, the problem is that 0 is an integer (of typeInt) andxmight be of any
type. Thus, depending on the value ofx, this function might return a value of either of two types. This behavior
is allowed, and may be desirable in some cases. But it can easily be fixed as follows:

```

pos(x)= x < 0? zero(x): x

```
There is also aoneunitfunction, and a more generaloftype(x, y)function, which returnsyconverted to the
type ofx.

### 34.9 Avoid changing the type of a variable.

An analogous"type-stability" problem exists for variables used repeatedly within a function:

```

function foo()  
x = 1  
for i = 1:10  
x /= rand()  
end  
return x  
end

```
Local variablexstarts as an integer, and after one loop iteration becomes a floating-point number (the result
of/operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several
possible fixes:

- Initializexwithx = 1.0
- Declare the type ofxexplicitly asx::Float64 = 1
- Use an explicit conversion byx = oneunit(Float64)
- Initialize with the first loop iteration, tox = 1 / rand(), then loopfor i = 2:10

### 34.10Separate kernel functions (aka, function barriers).

Many functions follow a pattern of performing some set-up work, and then running many iterations to perform
a core computation. Where possible, it is a good idea to put these core computations in separate functions.
For example, the following contrived function returns an array of a randomly-chosen type:

```

julia>function strange_twos(n)  
a = Vector {rand( Bool )? Int64 : Float64 }(undef, n)  
for i = 1:n  
a[i]= 2  
end

```

#### CHAPTER 34. PERFORMANCE TIPS 373

```

return a  
end ;

julia> strange_twos(3)  
3-element Vector{Int64}:  
2  
2  
2

```
This should be written as:

```

julia>function fill_twos!(a)  
for i = eachindex(a)  
a[i]= 2  
end  
end ;

julia>function strange_twos(n)  
a = Vector {rand( Bool )? Int64 : Float64 }(undef, n)  
fill_twos!(a)  
return a  
end ;

julia> strange_twos(3)  
3-element Vector{Int64}:  
2  
2  
2

```
Julia's compiler specializes code for argument types at function boundaries, so in the original implementation
it does not know the type ofaduring the loop (since it is chosen randomly). Therefore the second version is
generally faster since the inner loop can be recompiled as part offill_twos!for different types ofa.

The second form is also often better style and can lead to more code reuse.

This pattern is used in several places in Julia Base. For example, seevcatandhcatinabstractarray.jl, or
thefill!function, which we could have used instead of writing our ownfill_twos!.

Functions likestrange_twosoccur when dealing with data of uncertain type, for example data loaded from an
input file that might contain either integers, floats, strings, or something else.

### 34.11Types with values-as-parameters

Let 'ssayyouwanttocreateanN-dimensionalarraythathassize3alongeachaxis. Sucharrayscanbecreated
like this:

```

julia> A = fill(5.0, ( 3, 3))  
3×3 Matrix{Float64}:  
5.0 5.0 5.0  
5.0 5.0 5.0  
5.0 5.0 5.0

```
This approach works very well: the compiler can figure out thatAis anArray{Float64,2}because it knows
the type of the fill value (5.0::Float64) and the dimensionality ((3, 3)::NTuple{2,Int}). This implies that
the compiler can generate very efficient code for any future usage ofAin the same function.


#### CHAPTER 34. PERFORMANCE TIPS 374

But now let's say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might
be tempted to write a function

```

julia>function array3(fillval, N)  
fill(fillval, ntuple(d->3, N))  
end  
array3 (generic function with 1 method)

julia> array3(5.0, 2)  
3×3 Matrix{Float64}:  
5.0 5.0 5.0  
5.0 5.0 5.0  
5.0 5.0 5.0

```
This works, but (as you can verify for yourself using@code_warntype array3(5.0, 2)) the problem is that the
outputtypecannotbeinferred: theargumentNisavalueoftypeInt,andtype-inferencedoesnot(andcannot)
predict its value in advance. This means that code using the output of this function has to be conservative,
checking the type on each access ofA; such code will be very slow.

Now, one very good way to solve such problems is by using thefunction-barrier technique. However, in some
cases you might want to eliminate the type-instability altogether. In such cases, one approach is to pass the
dimensionality as a parameter, for example throughVal{T}()(see "Value types"):

```

julia>function array3(fillval,:: Val {N}) where N  
fill(fillval, ntuple(d->3, Val (N)))  
end  
array3 (generic function with 1 method)

julia> array3(5.0, Val (2))  
3×3 Matrix{Float64}:  
5.0 5.0 5.0  
5.0 5.0 5.0  
5.0 5.0 5.0

```
Julia has a specialized version ofntuplethat accepts aVal{::Int}instance as the second parameter; by
passingNas a type-parameter, you make its"value" known to the compiler. Consequently, this version of
array3allows the compiler to predict the return type.

However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you
calledarray3from a function like this:

```

function call_array3(fillval, n)  
A = array3(fillval, Val (n))  
end

```
Here, you've created the same problem all over again: the compiler can't guess whatnis, so it doesn't know
the type ofVal(n). Attempting to useVal, but doing so incorrectly, can easily make performance worse in
many situations. (Only in situations where you're effectively combiningValwith the function-barrier trick, to
make the kernel function more efficient, should code like the above be used.)

An example of correct usage ofValwould be:


#### CHAPTER 34. PERFORMANCE TIPS 375

```

function filter3(A:: AbstractArray {T,N}) where {T,N}  
kernel= array3(1, Val (N))  
filter(A, kernel)  
end

```
In this example,Nis passed as a parameter, so its"value" is known to the compiler. Essentially,Val(T)works
only whenTis either hard-coded/literal (Val(3)) or already specified in the type-domain.

### 34.12The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)

Once one learns to appreciate multiple dispatch, there's an understandable tendency to go overboard and try
to use it for everything. For example, you might imagine using it to store information, e.g.

```

struct Car{Make, Model}  
year::Int  
...more fields...  
end

```
and then dispatch on objects likeCar{:Honda,:Accord}(year, args...).

This might be worthwhile when either of the following are true:

- You require CPU-intensive processing on eachCar, and it becomes vastly more efficient if you know the
    MakeandModelat compile time and the total number of differentMakeorModelthat will be used is not
    too large.
- You have homogenous lists of the same type ofCarto process, so that you can store them all in an
    Array{Car{:Honda,:Accord},N}.

When the latter holds, a function processing such a homogenous array can be productively specialized: Julia
knows the type of each element in advance (all objects in the container have the same concrete type), so Julia
can "look up" the correct method calls when the function is being compiled (obviating the need to check at
run-time) and thereby emit efficient code for processing the whole list.

When these do not hold, then it's likely that you'll get no benefit; worse, the resulting"combinatorial explosion
of types" will be counterproductive. Ifitems[i+1]has a different type thanitem[i], Julia has to look up the
type at run-time, search for the appropriate method in method tables, decide (via type intersection) which
one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In
essence, you're asking the full type- system and JIT-compilation machinery to basically execute the equivalent
of a switch statement or dictionary lookup in your own code.

Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a"switch" statement
can be foundon the mailing list.

Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized func-
tions for each differentCar{Make, Model}; if you have hundreds or thousands of such types, then every func-
tion that accepts such an object as a parameter (from a customget_yearfunction you might write yourself,
to the genericpush!function in Julia Base) will have hundreds or thousands of variants compiled for it. Each
of these increases the size of the cache of compiled code, the length of internal lists of methods, etc. Excess
enthusiasm for values-as-parameters can easily waste enormous resources.


#### CHAPTER 34. PERFORMANCE TIPS 376

### 34.13Access arrays in memory order, along columns.

Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one
column at a time. This can be verified using thevecfunction or the syntax[:]as shown below (notice that
the array is ordered[1 3 2 4], not[1 2 3 4]):

```

julia> x = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> x[:]  
4-element Vector{Int64}:  
1  
3  
2  
4

```
This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few).
The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and
Python(numpy)amongotherlanguages. Rememberingtheorderingofarrayscanhavesignificantperformance
effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first
index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is
the first to appear in a slice expression. Keep in mind that indexing an array with:is an implicit loop that
iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows,
for example.

Consider the following contrived example. Imagine we wanted to write a function that accepts aVectorand
returns a squareMatrixwith either the rows or the columns filled with copies of the input vector. Assume
that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code
can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the
recommended call to the built-inrepeat):

```

function copy_cols(x:: Vector {T}) where T  
inds= axes(x,1)  
out = similar( Array {T}, inds, inds)  
for i = inds  
out[:, i]= x  
end  
return out  
end

function copy_rows(x:: Vector {T}) where T  
inds= axes(x,1)  
out = similar( Array {T}, inds, inds)  
for i = inds  
out[i,:] = x  
end  
return out  
end

function copy_col_row(x:: Vector {T}) where T  
inds= axes(x,1)  
out = similar( Array {T}, inds, inds)

```

#### CHAPTER 34. PERFORMANCE TIPS 377

```

for col = inds, row= inds  
out[row, col]= x[row]  
end  
return out  
end

function copy_row_col(x:: Vector {T}) where T  
inds= axes(x,1)  
out = similar( Array {T}, inds, inds)  
for row = inds, col= inds  
out[row, col]= x[col]  
end  
return out  
end

```
Now we will time each of these functions using the same random 10000 by 1 input vector:

```

julia> x = randn( 10000 );

julia> fmt(f)= println(rpad(string(f)*": " , 14, ' ' ), @elapsedf(x))

julia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);  
copy_cols: 0.331706323  
copy_rows: 1.799009911  
copy_col_row: 0.415630047  
copy_row_col: 1.721531501

```
Notice thatcopy_colsis much faster thancopy_rows. This is expected becausecopy_colsrespects the
column-based memory layout of theMatrixand fills it one column at a time. Additionally,copy_col_rowis
much faster thancopy_row_colbecause it follows our rule of thumb that the first element to appear in a slice
expression should be coupled with the inner-most loop.

### 34.14Pre-allocating outputs.

If your function returns anArrayor some other complex type, it may have to allocate memory. Unfortunately,
oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.

Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output.
As a trivial example, compare

```

julia>function xinc(x)  
return [x, x+1, x +2]  
end ;

julia>function loopinc()  
y = 0  
for i = 1:10^7  
ret = xinc(i)  
y += ret[2]  
end  
return y  
end ;

```
with


#### CHAPTER 34. PERFORMANCE TIPS 378

```

julia>function xinc!(ret:: AbstractVector {T}, x::T) where T  
ret[1] = x  
ret[2] = x+1  
ret[3] = x+2  
nothing  
end ;

julia>function loopinc_prealloc()  
ret = Vector { Int }(undef,3)  
y = 0  
for i = 1:10^7  
xinc!(ret, i)  
y += ret[2]  
end  
return y  
end ;

```
Timing results:

```

julia> @timeloopinc()  
0.529894 seconds (40.00 M allocations: 1.490 GiB, 12.14% gc time)  
50000015000000

julia> @timeloopinc_prealloc()  
0.030850 seconds (6 allocations: 288 bytes)  
50000015000000

```
Preallocation has other advantages, for example by allowing the caller to control the"output" type from an
algorithm. In the example above, we could have passed aSubArrayrather than anArray, had we so desired.

Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some
judgment may be required. However, for"vectorized" (element-wise) functions, the convenient syntaxx .=
f.(y)can be used for in-place operations with fused loops and no temporary arrays (see thedot syntax for
vectorizing functions).

### 34.15More dots: Fuse vectorized operations

Juliahasaspecialdotsyntaxthatconvertsanyscalarfunctionintoa"vectorized"functioncall,andanyoperator
into a "vectorized" operator, with the special property that nested"dot calls" are fusing: they are combined at
the syntax level into a single loop, without allocating temporary arrays. If you use.=and similar assignment
operators, the result can also be stored in-place in a pre-allocated array (see above).

In a linear-algebra context, this means that even though operations likevector + vectorandvector *
scalararedefined,itcanbeadvantageoustoinsteadusevector .+ vectorandvector .* scalarbecause
the resulting loops can be fused with surrounding computations. For example, consider the two functions:

```

julia> f(x)= 3x.^2 + 4x + 7x.^3;

julia> fdot(x)=@. 3x^2 + 4x + 7x^3 # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3;

```
Bothfandfdotcomputethesamething. However,fdot(definedwiththehelpofthe@.macro)issignificantly
faster when applied to an array:


#### CHAPTER 34. PERFORMANCE TIPS 379

```

julia> x = rand(10^6);

julia> @timef(x);  
0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)

julia> @timefdot(x);  
0.002790 seconds (6 allocations: 7.630 MiB)

julia> @timef.(x);  
0.002626 seconds (8 allocations: 7.630 MiB)

```
That is,fdot(x)is ten times faster and allocates 1/6 the memory off(x), because each*and+operation in
f(x)allocates a new temporary array and executes in a separate loop. (Of course, if you just dof.(x)then it
is as fast asfdot(x)in this example, but in many contexts it is more convenient to just sprinkle some dots in
your expressions rather than defining a separate function for each vectorized operation.)

### 34.16Consider using views for slices

In Julia, an array"slice" expression likearray[1:5, :]creates a copy of that data (except on the left-hand
side of an assignment, wherearray[1:5, :] = ... assigns in-place to that portion ofarray). If you are
doing many operations on the slice, this can be good for performance because it is more efficient to work with
a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just
doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.

An alternative is to create a"view" of the array, which is an array object (aSubArray) that actually references
the data of the original array in-place, without making a copy. (If you write to a view, it modifies the original ar-
ray's data as well.) This can be done for individual slices by callingview, or more simply for a whole expression
or block of code by putting@viewsin front of that expression. For example:

```

julia> fcopy(x)= sum(x[2: end -1]);

julia> @viewsfview(x)= sum(x[2: end -1]);

julia> x = rand(10^6);

julia> @timefcopy(x);  
0.003051 seconds (3 allocations: 7.629 MB)

julia> @timefview(x);  
0.001020 seconds (1 allocation: 16 bytes)

```
Notice both the 3× speedup and the decreased memory allocation of thefviewversion of the function.

### 34.17Copying data is not always bad

Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory ac-
cesses due to caching. These are the same reasons that it is recommended to access arrays in column-major
order(seeabove). Irregularaccesspatternsandnon-contiguousviewscandrasticallyslowdowncomputations
on arrays because of non-sequential memory access.

Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup,
such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-
shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even
with the cost of the copying operation.


#### CHAPTER 34. PERFORMANCE TIPS 380

```

julia>using Random

julia> x = randn(1_000_000);

julia> inds= shuffle(1:1_000_000)[1:800000];

julia> A = randn(50, 1_000_000);

julia> xtmp= zeros(800_000);

julia> Atmp= zeros(50, 800_000);

julia> @timesum(view(A,:, inds)* view(x, inds))  
0.412156 seconds (14 allocations: 960 bytes)  
-4256.759568345458

julia> @time begin  
copyto!(xtmp, view(x, inds))  
copyto!(Atmp, view(A,:, inds))  
sum(Atmp* xtmp)  
end  
0.285923 seconds (14 allocations: 960 bytes)  
-4256.759568345134

```
Provided there is enough memory for the copies, the cost of copying the view to an array is far outweighed by
the speed boost from doing the matrix multiplication on a contiguous array.

### 34.18Consider StaticArrays.jl for small fixed-size vector/matrix operations.

If your application involves many small (< 100element) arrays of fixed sizes (i.e. the size is known prior to
execution), then you might want to consider using theStaticArrays.jl package. This package allows you to
represent such arrays in a way that avoids unnecessary heap allocations and allows the compiler to specialize
code for the size of the array, e.g. by completely unrolling vector operations (eliminating the loops) and storing
elements in CPU registers.

For example, if you are doing computations with 2d geometries, you might have many computations with
2-component vectors. By using theSVectortype from StaticArrays.jl, you can use convenient vector notation
and operations likenorm(3v - w)on vectorsvandw, while allowing the compiler to unroll the code to a
minimal computation equivalent to@inbounds hypot(3v[1]-w[1], 3v[2]-w[2]).

### 34.19Avoid string interpolation for I/O.

When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead.
Instead of:

```

println(file," $a $b ")

```
use:

```

println(file, a," " , b)

```
The first version of the code forms a string, then writes it to the file, while the second version writes values
directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:


#### CHAPTER 34. PERFORMANCE TIPS 381

```

println(file," $ (f(a)) $ (f(b))")

```
versus:

```

println(file, f(a), f(b))

```
### 34.20Optimize network I/O during parallel execution

When executing a remote function in parallel:

```

using Distributed

responses= Vector { Any }(undef, nworkers())  
@sync begin  
for (idx, pid) in enumerate(workers())  
@asyncresponses[idx]= remotecall_fetch(foo, pid, args...)  
end  
end

```
is faster than:

```

using Distributed

refs= Vector { Any }(undef, nworkers())  
for (idx, pid) in enumerate(workers())  
refs[idx]= @spawnatpid foo(args...)  
end  
responses= [fetch(r) for r in refs]

```
The former results in a single network round-trip to every worker, while the latter results in two network calls -
first by the@spawnatand the second due to thefetch(or even await). Thefetch/waitis also being executed
serially resulting in an overall poorer performance.

### 34.21Fix deprecation warnings

A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra
lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested
by the warnings.

### 34.22Tweaks.

These are some minor points that might help in tight inner loops.

- Avoid unnecessary arrays. For example, instead ofsum([x,y,z])usex+y+z.
- Useabs2(z)instead ofabs(z)^2for complexz. In general, try to rewrite code to useabs2instead of
    absfor complex arguments.
- Usediv(x,y)fortruncatingdivisionofintegersinsteadoftrunc(x/y),fld(x,y)insteadoffloor(x/y),
    andcld(x,y)instead ofceil(x/y).


#### CHAPTER 34. PERFORMANCE TIPS 382

### 34.23Performance Annotations

Sometimes you can enable better optimization by promising certain program properties.

- Use@inboundsto eliminate array bounds checking within expressions. Be certain before doing this. If
    the subscripts are ever out of bounds, you may suffer crashes or silent corruption.
- Use@fastmathto allow floating point optimizations that are correct for real numbers, but lead to dif-
    ferences for IEEE numbers. Be careful when doing this, as this may change numerical results. This
    corresponds to the-ffast-mathoption of clang.
- Write@simdin front offorloops to promise that the iterations are independent and may be reordered.
    Note that in many cases, Julia can automatically vectorize code without the@simdmacro; it is only
    beneficial in cases where such a transformation would otherwise be illegal, including cases like allowing
    floating-point re-associativity and ignoring dependent memory accesses (@simd ivdep). Again, be very
    careful when asserting@simdas erroneously annotating a loop with dependent iterations may result in
    unexpected results. In particular, note thatsetindex!on someAbstractArraysubtypes is inherently
    dependentuponiterationorder. **This feature is experimental** andcouldchangeordisappearinfuture
    versions of Julia.

The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional
indexing, and may cause a segmentation fault if bounds checking is turned off. UseLinearIndices(x)or
eachindex(x)instead (see alsoArrays with custom indices).

```

Note  
While@simdneeds to be placed directly in front of an innermostforloop, both@inboundsand  
@fastmathcan be applied to either single expressions or all the expressions that appear within  
nested blocks of code, e.g., using@inbounds beginor@inbounds for ....

```
Here is an example with both@inboundsand@simdmarkup (we here use@noinlineto prevent the optimizer
from trying to be too clever and defeat our benchmark):

```

@noinline function inner(x, y)  
s = zero(eltype(x))  
for i=eachindex(x)  
@inboundss += x[i]*y[i]  
end  
return s  
end

@noinline function innersimd(x, y)  
s = zero(eltype(x))  
@simd for i = eachindex(x)  
@inboundss += x[i]* y[i]  
end  
return s  
end

function timeit(n, reps)  
x = rand( Float32 , n)  
y = rand( Float32 , n)  
s = zero( Float64 )

```

#### CHAPTER 34. PERFORMANCE TIPS 383

```

time= @elapsed for j in 1:reps  
s += inner(x, y)  
end  
println("GFlop/sec = ", 2n_reps/ time_1E-9)  
time= @elapsed for j in 1:reps  
s += innersimd(x, y)  
end  
println("GFlop/sec (SIMD) = ", 2n_reps/ time_1E-9)  
end

timeit(1000, 1000)

```
On a computer with a 2.4GHz Intel Core i5 processor, this produces:

```

GFlop/sec = 1.9467069505224963  
GFlop/sec (SIMD) = 17.578554163920018

```
(GFlop/secmeasures the performance, and larger numbers are better.)

Here is an example with all three kinds of markup. This program first calculates the finite difference of a
one-dimensional array, and then evaluates the L2-norm of the result:

```

function init!(u:: Vector )  
n = length(u)  
dx = 1.0 / (n-1)  
@fastmath@inbounds@simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has  
↪→ 1-based indexing  
u[i]= sin(2pi_dx_i)  
end  
end

function deriv!(u:: Vector , du)  
n = length(u)  
dx = 1.0 / (n-1)  
@fastmath@inboundsdu[1] = (u[2] - u[1]) / dx  
@fastmath@inbounds@simd for i in 2:n-1  
du[i]= (u[i+1] - u[i-1]) / (2*dx)  
end  
@fastmath@inboundsdu[n]= (u[n]- u[n-1]) / dx  
end

function mynorm(u:: Vector )  
n = length(u)  
T = eltype(u)  
s = zero(T)  
@fastmath@inbounds@simd for i in 1:n  
s += u[i]^2  
end  
@fastmath@inbounds return sqrt(s)  
end

function main()  
n = 2000  
u = Vector { Float64 }(undef, n)  
init!(u)  
du = similar(u)

```

#### CHAPTER 34. PERFORMANCE TIPS 384

```

deriv!(u, du)  
nu = mynorm(du)

@time for i in 1:10^6  
deriv!(u, du)  
nu = mynorm(du)  
end

println(nu)  
end

main()

```
On a computer with a 2.7 GHz Intel Core i7 processor, this produces:

```

$ julia wave.jl;  
1.207814709 seconds  
4.443986180758249

$ julia --math-mode=ieee wave.jl;  
4.487083643 seconds  
4.443986180758249

```
Here, the option--math-mode=ieeedisables the@fastmathmacro, so that we can compare results.

In this case, the speedup due to@fastmathis a factor of about 3.7. This is unusually large – in general, the
speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit
into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is
dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization
does not change the result – in general, the result will be slightly different. In some cases, especially for
numerically unstable algorithms, the result can be very different.

The annotation@fastmathre-arranges floating point expressions, e.g. changing the order of evaluation, or
assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer),
the main difference is that the expression1 / (2*dx)in the functionderivis hoisted out of the loop (i.e.
calculated outside the loop), as if one had writtenidx = 1 / (2*dx). In the loop, the expression... /
(2*dx)then becomes... * idx, which is much faster to evaluate. Of course, both the actual optimization
that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can
examine the change in generated code by using Julia'scode_nativefunction.

Notethat@fastmathalsoassumesthatNaNswillnotoccurduringthecomputation,whichcanleadtosurprising
behavior:

```

julia> f(x)= isnan(x);

julia> f(NaN)  
true

julia> f_fast(x)= @fastmathisnan(x);

julia> f_fast(NaN)  
false

```

#### CHAPTER 34. PERFORMANCE TIPS 385

### 34.24Treat Subnormal Numbers as Zeros

Subnormal numbers, formerly calleddenormal numbers, are useful in many contexts, but incur a performance
penaltyonsomehardware. Acallset_zero_subnormals(true)grantspermissionforfloating-pointoperations
to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call
set_zero_subnormals(false)enforces strict IEEE behavior for subnormal numbers.

Below is an example where subnormals noticeably impact performance on some hardware:

```

function timestep(b:: Vector {T}, a:: Vector {T}, Δt::T) where T  
@assertlength(a)==length(b)  
n = length(b)  
b[1] = 1 # Boundary condition  
for i=2:n-1  
b[i]= a[i]+ (a[i-1] - T(2)*a[i]+ a[i+1]) * Δt  
end  
b[n]= 0 # Boundary condition  
end

function heatflow(a:: Vector {T}, nstep:: Integer ) where T  
b = similar(a)  
for t=1:div(nstep,2) # Assume nstep is even  
timestep(b,a,T(0.1))  
timestep(a,b,T(0.1))  
end  
end

heatflow(zeros( Float32 ,10),2) # Force compilation  
for trial=1:6  
a = zeros( Float32 ,1000)  
set_zero_subnormals(iseven(trial)) # Odd trials use strict IEEE arithmetic  
@timeheatflow(a,1000)  
end

```
This gives an output similar to

```

0.002202 seconds (1 allocation: 4.063 KiB)  
0.001502 seconds (1 allocation: 4.063 KiB)  
0.002139 seconds (1 allocation: 4.063 KiB)  
0.001454 seconds (1 allocation: 4.063 KiB)  
0.002115 seconds (1 allocation: 4.063 KiB)  
0.001455 seconds (1 allocation: 4.063 KiB)

```
Note how each even iteration is significantly faster.

This example generates many subnormal numbers because the values inabecome an exponentially decreas-
ing curve, which slowly flattens out over time.

Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as
x-y == 0impliesx == y:

```

julia> x = 3f-38; y = 2f-38;

julia> set_zero_subnormals( true ); (x- y, x== y)  
(0.0f0, false)

```

#### CHAPTER 34. PERFORMANCE TIPS 386

```

julia> set_zero_subnormals( false ); (x- y, x== y)  
(1.0000001f-38, false)

```
In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example,
instead of initializingawith zeros, initialize it with:

```

a = rand( Float32 ,1000) * 1.f-9

```
### 34.25@code_warntype.

The macro@code_warntype(or its function variantcode_warntype) can sometimes be helpful in diagnosing
type-related problems. Here's an example:

```

julia> @noinlinepos(x)= x < 0? 0 : x;

julia>function f(x)  
y = pos(x)  
return sin(y*x + 1)  
end ;

julia> @code_warntypef(3.2)  
Variables  
#self#::Core.Const(f)  
x::Float64  
y::UNION{FLOAT64, INT64}

Body::Float64  
1 ─ (y = Main.pos(x))  
│ %2 = (y * x)::Float64  
│ %3 = (%2 + 1)::Float64  
│ %4 = Main.sin(%3)::Float64  
└── return %4

```
Interpreting the output of@code_warntype, like that of its cousins@code_lowered,@code_typed,@code_llvm,
and@code_native, takes a little practice. Your code is being presented in form that has been heavily digested
on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated
by the::T(whereTmight beFloat64, for example). The most important characteristic of@code_warntypeis
that non-concrete types are displayed in red; since this document is written in Markdown, which has no color,
in this document, red text is denoted by uppercase.

At the top, the inferred return type of the function is shown asBody::Float64. The next lines represent the
body offin Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (viagoto)
in your code. Looking at the body, you can see that the first thing that happens is thatposis called and the
return value has been inferred as theUniontypeUNION{FLOAT64, INT64}shown in uppercase since it is a
non-concrete type. This means that we cannot know the exact return type ofposbased on the input types.
However,theresultofy*xisaFloat64nomatterifyisaFloat64orInt64Thenetresultisthatf(x::Float64)
will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.

How you use this information is up to you. Obviously, it would be far and away best to fixposto be type-stable:
if you did so, all of the variables infwould be concrete, and its performance would be optimal. However, there
are circumstances where this kind of ephemeral type instability might not matter too much: for example,
ifposis never used in isolation, the fact thatf's output is type-stable (forFloat64inputs) will shield later
code from the propagating effects of type instability. This is particularly relevant in cases where fixing the


#### CHAPTER 34. PERFORMANCE TIPS 387

type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or
breaking up functions) are your best tools to contain the"damage" from type instability. Also, note that even
Julia Base has functions that are type unstable. For example, the functionfindfirstreturns the index into
an array where a key is found, ornothingif it is not found, a clear type instability. In order to make it easier
to find the type instabilities that are likely to be important,Unions containing eithermissingornothingare
color highlighted in yellow, instead of red.

The following examples may help you interpret expressions marked as containing non-leaf types:

- Function body starting withBody::UNION{T1,T2})
    **-** Interpretation: function with unstable return type
    **-** Suggestion: make the return value type-stable, even if you have to annotate it
- invoke Main.g(%%x::Int64)::UNION{FLOAT64, INT64}
    **-** Interpretation: call to a type-unstable functiong.
    **-** Suggestion: fix the function, or if necessary annotate the return value
- invoke Base.getindex(%%x::Array{Any,1}, 1::Int64)::ANY
    **-** Interpretation: accessing elements of poorly-typed arrays
    **-** Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual
       element accesses
- Base.getfield(%%x, :(:data))::ARRAY{FLOAT64,N} WHERE N
    **-** Interpretation: gettingafieldthatisofnon-leaftype. Inthiscase,thetypeofx,sayArrayContainer,
       had a fielddata::Array{T}. ButArrayneeds the dimensionN, too, to be a concrete type.
    **-** Suggestion: use concrete types likeArray{T,3}orArray{T,N}, whereNis now a parameter of
       ArrayContainer

### 34.26Performance of captured variable.

Consider the following example that defines an inner function:

```

function abmult(r:: Int )  
if r < 0  
r = -r  
end  
f = x -> x * r  
return f  
end

```
Functionabmultreturns a functionfthat multiplies its argument by the absolute value ofr. The inner function
assignedtofiscalleda"closure". Innerfunctionsarealsousedbythelanguagefordo-blocksandforgenerator
expressions.

This style of code presents performance challenges for the language. The parser, when translating it into
lower-levelinstructions, substantiallyreorganizestheabovecodebyextractingtheinnerfunctiontoaseparate
code block."Captured" variables such asrthat are shared by inner functions and their enclosing scope are
also extracted into a heap-allocated"box " accessible to both inner and outer functions because the language


#### CHAPTER 34. PERFORMANCE TIPS 388

specifies thatrin the inner scope must be identical torin the outer scope even after the outer scope (or
another inner function) modifiesr.

The discussion in the preceding paragraph referred to the"parser", that is, the phase of compilation that takes
place when the module containingabmultis first loaded, as opposed to the later phase when it is first invoked.
The parser does not"know" thatIntis a fixed type, or that the statementr = -rtransforms anIntto another
Int. The magic of type inference takes place in the later phase of compilation.

Thus, the parser does not know thatrhas a fixed type (Int). nor thatrdoes not change value once the inner
function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object
with an abstract type such asAny, which requires run-time type dispatch for each occurrence ofr. This can be
verified by applying@code_warntypeto the above function. Both the boxing and the run-time type dispatch
can cause loss of performance.

If captured variables are used in a performance-critical section of the code, then the following tips help ensure
that their use is performant. First, if it is known that a captured variable does not change its type, then this
can be declared explicitly with a type annotation (on the variable, not the right-hand side):

```

function abmult2(r0:: Int )  
r:: Int = r0  
if r < 0  
r = -r  
end  
f = x -> x * r  
return f  
end

```
The type annotation partially recovers lost performance due to capturing because the parser can associate a
concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all
(because it will not be reassigned after the closure is created), this can be indicated withletblocks as follows.

```

function abmult3(r:: Int )  
if r < 0  
r = -r  
end  
f = let r = r  
x -> x * r  
end  
return f  
end

```
Theletblock creates a new variablerwhose scope is only the inner function. The second technique recovers
full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of
the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain
performance. In the mean time, some user-contributed packages likeFastClosuresautomate the insertion of
letstatements as inabmult3.


**Chapter 35**

**Workflow Tips**

Here are some tips for working with Julia efficiently.

### 35.1 REPL-based workflow

As already elaborated inThe Julia REPL, Julia 's REPL provides rich functionality that facilitates an efficient
interactive workflow. Here are some tips that might further enhance your experience at the command line.

### A basic editor/REPL workflow

The most basic Julia workflows involve using a text editor in conjunction with thejuliacommand line. A
common pattern includes the following elements:

- **Put code under development in a temporary module.** Create a file, sayTmp.jl, and include within
    it

```

module Tmp  
export say_hello

say_hello()= println("Hello!")

# your other definitions here

end

```
- **Put your test code in another file.** Create another file, saytst.jl, which looks like

```

include("Tmp.jl")  
import .Tmp

# using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace

Tmp.say_hello()

# say_hello()

# your other test code here

and includes tests for the contents ofTmp. Alternatively, you can wrap the contents of your test file in a  
module, as

```
#### 389


#### CHAPTER 35. WORKFLOW TIPS 390

```

module Tst  
include("Tmp.jl")  
import .Tmp  
#using .Tmp

Tmp.say_hello()

# say_hello()

# your other test code here

end

The advantage is that your testing code is now contained in a module and does not use the global scope  
inMainfor definitions, which is a bit more tidy.

```
- includethetst.jlfile in the Julia REPL withinclude("tst.jl").
- **Lather. Rinse. Repeat.** Explore ideas at thejuliacommand prompt. Save good ideas intst.jl. To
    executetst.jlafter it has been changed, justincludeit again.

### 35.2 Browser-based workflow.

It is also possible to interact with a Julia REPL in the browser viaIJulia. See the package home for details.

### 35.3 Revise-based workflows.

Whether you're at the REPL or in IJulia, you can typically improve your development experience withRevise.
It is common to configure Revise to start whenever julia is started, as per the instructions in theRevise docu-
mentation. Once configured, Revise will track changes to files in any loaded modules, and to any files loaded
in to the REPL withincludet(but not with plaininclude); you can then edit the files and the changes take
effect without restarting your julia session. A standard workflow is similar to the REPL-based workflow above,
with the following modifications:

1. Put your code in a module somewhere on your load path. There are several options for achieving this,
    of which two recommended choices are:
       **-** For long-term projects, usePkgTemplates:
          **using** PkgTemplates
          t = Template()
          t("MyPkg")
This will create a blank package,"MyPkg", in your.julia/devdirectory. Note that PkgTemplates
allows you to control many different options through itsTemplateconstructor.
Instep2below,editMyPkg/src/MyPkg.jltochangethesourcecode,andMyPkg/test/runtests.jl
for the tests.
       **-** For "throw-away" projects, you can avoid any need for cleanup by doing your work in your tempo-
          rary directory (e.g.,/tmp).
          Navigate to your temporary directory and launch Julia, then do the following:
             pkg> generate MyPkg # type ] to enter pkg mode
             julia> push!(LOAD_PATH, pwd()) # hit backspace to exit pkg mode
          If you restart your Julia session you'll have to re-issue that command modifyingLOAD_PATH.
          In step 2 below, editMyPkg/src/MyPkg.jlto change the source code, and create any test file of
          your choosing.


#### CHAPTER 35. WORKFLOW TIPS 391

2. Develop your package
    Before loading any code, make sure you're running Revise: sayusing Reviseor follow its documenta-
    tion on configuring it to run automatically.
    Then navigate to the directory containing your test file (here assumed to be"runtests.jl") and do the
    following:

```

julia> using MyPkg

julia> include("runtests.jl")

YoucaniterativelymodifythecodeinMyPkginyoureditorandre-runthetestswithinclude("runtests.jl").  
You generally should not need to restart your Julia session to see the changes take effect (subject to a  
few limitations).

```

**Chapter 36**

**Style Guide**

The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute;
they are only suggestions to help familiarize you with the language and to help you choose among alternative
designs.

### 36.1 Indentation

Use 4 spaces per indentation level.

### 36.2 Write functions, not just scripts

Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should
trytodivideaprogramintofunctionsassoonaspossible. Functionsaremorereusableandtestable, andclarify
what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to
run much faster than top level code, due to how Julia's compiler works.

It is also worth emphasizing that functions should take arguments, instead of operating directly on global
variables (aside from constants likepi).

### 36.3 Avoid writing overly-specific types

Code should be as generic as possible. Instead of writing:

```

Complex { Float64 }(x)

```
it's better to use available generic functions:

```

complex(float(x))

```
The second version will convertxto an appropriate type, instead of always the same type.

This style point is especially relevant to function arguments. For example, don't declare an argument to be of
typeIntorInt32if it really could be any integer, expressed with the abstract typeInteger. In fact, in many
cases you can omit the argument type altogether, unless it is needed to disambiguate from other method
definitions, since aMethodErrorwill be thrown anyway if a type is passed that does not support any of the
requisite operations. (This is known asduck typing.)

For example, consider the following definitions of a functionaddonethat returns one plus its argument:

#### 392


#### CHAPTER 36. STYLE GUIDE 393

```

addone(x:: Int ) = x + 1 # works only for Int  
addone(x:: Integer ) = x + oneunit(x) # any integer type  
addone(x:: Number ) = x + oneunit(x) # any numeric type  
addone(x)= x + oneunit(x) # any type supporting + and oneunit

```
The last definition ofaddonehandles any type supportingoneunit(which returns 1 in the same type asx,
which avoids unwanted type promotion) and the+function with those arguments. The key thing to realize is
thatthereisnoperformancepenaltytodefiningonlythegeneraladdone(x) = x + oneunit(x), becauseJulia
will automatically compile specialized versions as needed. For example, the first time you calladdone(12),
Julia will automatically compile a specializedaddonefunction forx::Intarguments, with the call tooneunit
replaced by its inlined value 1. Therefore, the first three definitions ofaddoneabove are completely redundant
with the fourth definition.

### 36.4 Handle excess argument diversity in the caller

Instead of:

```

function foo(x, y)  
x = Int (x); y= Int (y)

end  
foo(x, y)

```
use:

```

function foo(x:: Int , y :: Int )

end  
foo( Int (x), Int (y))

```
This is better style becausefoodoes not really accept numbers of all types; it really needsInts.

One issue here is that if a function inherently requires integers, it might be better to force the caller to decide
how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific
types leaves more"space" for future method definitions.

### 36.5 Append!to names of functions that modify their arguments

Instead of:

```

function double(a:: AbstractArray {<: Number })  
for i = firstindex(a):lastindex(a)  
a[i]*= 2  
end  
return a  
end

```
use:


#### CHAPTER 36. STYLE GUIDE 394

```

function double!(a:: AbstractArray {<: Number })  
for i = firstindex(a):lastindex(a)  
a[i]*= 2  
end  
return a  
end

```
JuliaBaseusesthisconventionthroughoutandcontainsexamplesoffunctionswithbothcopyingandmodifying
forms (e.g.,sortandsort!), and others which are just modifying (e.g.,push!,pop!,splice!). It is typical for
such functions to also return the modified array for convenience.

### 36.6 Avoid strange typeUnions

Types such asUnion{Function,AbstractString}are often a sign that some design could be cleaner.

### 36.7 Avoid elaborate container types.

It is usually not much help to construct arrays like the following:

```

a = Vector { Union { Int , AbstractString , Tuple , Array }}(undef, n)

```
In this caseVector{Any}(undef, n)is better. It is also more helpful to the compiler to annotate specific uses
(e.g.a[i]::Int) than to try to pack many alternatives into one type.

### 36.8 Prefer exported methods over direct field access.

Idiomatic Julia code should generally treat a module's exported methods as the interface to its types. An
object's fields are generally considered implementation details and user code should only access them directly
if this is stated to be the API. This has several benefits:

- Package developers are freer to change the implementation without breaking user code.
- Methods can be passed to higher-order constructs likemap(e.g.map(imag, zs))rather than[z.im for
    z in zs]).
- Methods can be defined on abstract types.
- Methods can describe a conceptual operation that can be shared across disparate types (e.g.real(z)
    works on Complex numbers or Quaternions).

Julia's dispatch system encourages this style becauseplay(x::MyType)only defines theplaymethod on that
particular type, leaving other types to have their own implementation.

Similarly, non-exported functions are typically internal and subject to change, unless the documentations
states otherwise. Names sometimes are given a_prefix (or suffix) to further suggest that something is"inter-
nal" or an implementation-detail, but it is not a rule.

Counter-examples to this rule includeNamedTuple,RegexMatch,StatStruct.


#### CHAPTER 36. STYLE GUIDE 395

### 36.9 Use naming conventions consistent with Juliabase/

- modulesandtypenamesusecapitalizationandcamelcase:module SparseArrays,struct UnitRange.
- functions are lowercase (maximum,convert) and, when readable, with multiple words squashed to-
    gether (isequal,haskey). When necessary, use underscores as word separators. Underscores are
    also used to indicate a combination of concepts (remotecall_fetchas a more efficient implementation
    offetch(remotecall(...))) or as modifiers.
- functions mutating at least one of their arguments end in!.
- conciseness is valued, but avoid abbreviation (indexinrather thanindxin) as it becomes difficult to
    remember whether and how particular words are abbreviated.

If a function name requires multiple words, consider whether it might represent more than one concept and
might be better split into pieces.

### 36.10Write functions with argument ordering similar to Julia Base

As a general rule, the Base library uses the following order of arguments to functions, as applicable:

1. **Function argument**. Puttingafunctionargumentfirstpermitstheuseofdoblocksforpassingmultiline
    anonymous functions.
2. **I/O stream**. Specifying theIOobject first permits passing the function to functions such assprint, e.g.
    sprint(show, x).
3. **Input being mutated**. For example, infill!(x, v),xis the object being mutated and it appears
    before the value to be inserted intox.
4. **Type**. Passing a type typically means that the output will have the given type. Inparse(Int, "1"),
    the type comes before the string to parse. There are many such examples where the type appears first,
    but it 's useful to note that inread(io, String), theIOargument appears before the type, which is in
    keeping with the order outlined here.
5. **Input not being mutated**. Infill!(x, v),vis not being mutated and it comes afterx.
6. **Key**. For associative collections, this is the key of the key-value pair(s). For other indexed collections,
    this is the index.
7. **Value**. For associative collections, this is the value of the key-value pair(s). In cases likefill!(x, v),
    this isv.
8. **Everything else**. Any other arguments.
9. **Varargs**. This refers to arguments that can be listed indefinitely at the end of a function call. For
    example,inMatrix{T}(undef, dims),thedimensionscanbegivenasaTuple,e.g.Matrix{T}(undef,
    (1,2)), or asVarargs, e.g.Matrix{T}(undef, 1, 2).
10. **Keyword arguments**. In Julia keyword arguments have to come last anyway in function definitions;
they're listed here for the sake of completeness.


#### CHAPTER 36. STYLE GUIDE 396

The vast majority of functions will not take every kind of argument listed above; the numbers merely denote
the precedence that should be used for any applicable arguments to a function.

There are of course a few exceptions. For example, inconvert, the type should always come first. In
setindex!, the value comes before the indices so that the indices can be provided as varargs.

When designing APIs, adhering to this general order as much as possible is likely to give users of your functions
a more consistent experience.

### 36.11Don't overuse try-catch

It is better to avoid errors than to rely on catching them.

### 36.12Don't parenthesize conditions.

Julia doesn't require parens around conditions inifandwhile. Write:

```

if a == b

```
instead of:

```

if (a == b)

```
### 36.13Don't overuse...

Splicing function arguments can be addictive. Instead of[a..., b...], use simply[a; b], which already
concatenates arrays.collect(a)is better than[a...], but sinceais already iterable it is often even better
to leave it alone, and not convert it to an array.

### 36.14Don't use unnecessary static parameters.

A function signature:

```

foo(x::T) where {T<: Real } = ...

```
should be written as:

```

foo(x:: Real ) = ...

```
instead, especially ifTis not used in the function body. Even ifTis used, it can be replaced withtypeof(x)if
convenient. There is no performance difference. Note that this is not a general caution against static param-
eters, just against uses where they are not needed.

Note also that container types, specifically may need type parameters in function calls. See the FAQAvoid
fields with abstract containersfor more information.


#### CHAPTER 36. STYLE GUIDE 397

### 36.15Avoid confusion about whether something is an instance or a type.

Sets of definitions like the following are confusing:

```

foo(:: Type {MyType})= ...  
foo(::MyType)= foo(MyType)

```
Decide whether the concept in question will be written asMyTypeorMyType(), and stick to it.

The preferred style is to use instances by default, and only add methods involvingType{MyType}later if they
become necessary to solve some problems.

If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive)
type, with the enumeration values being instances of it. Constructors and conversions can check whether
values are valid. This design is preferred over making the enumeration an abstract type, with the"values" as
subtypes.

### 36.16Don't overuse macros.

Be aware of when a macro could really be a function instead.

Callingevalinside a macro is a particularly dangerous warning sign; it means the macro will only work when
called at the top level. If such a macro is written as a function instead, it will naturally have access to the
run-time values it needs.

### 36.17Don't expose unsafe operations at the interface level

If you have a type that uses a native pointer:

```

mutable struct NativeType  
p:: Ptr { UInt8 }

end

```
don't write definitions like the following:

```

getindex(x::NativeType, i)= unsafe_load(x.p, i)

```
The problem is that users of this type can writex[i]without realizing that the operation is unsafe, and then
be susceptible to memory bugs.

Such a function should either check the operation to ensure it is safe, or haveunsafesomewhere in its name
to alert callers.

### 36.18Don't overload methods of base container types

It is possible to write definitions like the following:

```

show(io:: IO , v :: Vector {MyType})= ...

```
This would provide custom showing of vectors with a specific new element type. While tempting, this should
be avoided. The trouble is that users will expect a well-known type likeVector()to behave in a certain way,
and overly customizing its behavior can make it harder to work with.


#### CHAPTER 36. STYLE GUIDE 398

### 36.19Avoid type piracy

"Type piracy" refers to the practice of extending or redefining methods in Base or other packages on types
that you have not defined. In some cases, you can get away with type piracy with little ill effect. In extreme
cases, however, you can even crash Julia (e.g. if your method extension or redefinition causes invalid input to
be passed to accall). Type piracy can complicate reasoning about code, and may introduce incompatibilities
that are hard to predict and diagnose.

As an example, suppose you wanted to define multiplication on symbols in a module:

```

module A  
import Base.*  
*(x:: Symbol , y :: Symbol ) = Symbol (x,y)  
end

```
TheproblemisthatnowanyothermodulethatusesBase.*willalsoseethisdefinition. SinceSymbolisdefined
in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are
several alternatives here, including using a different function name, or wrapping theSymbols in another type
that you define.

Sometimes,coupledpackagesmayengageintypepiracytoseparatefeaturesfromdefinitions,especiallywhen
the packages were designed by collaborating authors, and when the definitions are reusable. For example,
one package might provide some types useful for working with colors; another package could define methods
for those types that enable conversions between color spaces. Another example might be a package that acts
as a thin wrapper for some C code, which another package might then pirate to implement a higher-level,
Julia-friendly API.

### 36.20Be careful with type equality

You generally want to useisaand<:for testing types, not==. Checking types for exact equality typically
only makes sense when comparing to a known concrete type (e.g.T == Float64), or if you really, really know
what you're doing.

### 36.21Do not writex->f(x)

Since higher-order functions are often called with anonymous functions, it is easy to conclude that this is de-
sirable or even necessary. But any function can be passed directly, without being"wrapped" in an anonymous
function. Instead of writingmap(x->f(x), a), writemap(f, a).

### 36.22Avoid using floats for numeric literals in generic code when possible.

If you write generic code which handles numbers, and which can be expected to run with many different
numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible
through promotion.

For example,

```

julia> f(x)= 2.0 * x  
f (generic function with 1 method)

julia> f(1//2)  
1.0

```

#### CHAPTER 36. STYLE GUIDE 399

```

julia> f(1/2)  
1.0

julia> f(1)  
2.0

```
while

```

julia> g(x)= 2 * x  
g (generic function with 1 method)

julia> g(1//2)  
1//1

julia> g(1/2)  
1.0

julia> g(1)  
2

```
As you can see, the second version, where we used anIntliteral, preserved the type of the input argument,
whilethefirstdidn't. Thisisbecausee.g.promote_type(Int, Float64) == Float64,andpromotionhappens
with the multiplication. Similarly,Rationalliterals are less type disruptive thanFloat64literals, but more
disruptive thanInts:

```

julia> h(x)= 2//1 * x  
h (generic function with 1 method)

julia> h(1//2)  
1//1

julia> h(1/2)  
1.0

julia> h(1)  
2//1

```
Thus, useIntliterals when possible, withRational{Int}for literal non-integer numbers, in order to make it
easier to use your code.


**Chapter 37**

**Frequently Asked Questions**

### 37.1 General

### Is Julia named after someone or something?

No.

### Why don't you compile Matlab/Python/R/... code to Julia?

Since many people are familiar with the syntax of other dynamic languages, and lots of code has already been
written in those languages, it is natural to wonder why we didn't just plug a Matlab or Python front-end into a
Julia back-end (or “transpile” code to Julia) in order to get all the performance benefits of Julia without requiring
programmers to learn a new language. Simple, right?

The basic issue is that there is nothing special about Julia's compiler: we use a commonplace compiler (LLVM)
with no “secret sauce” that other language developers don't know about. Indeed, Julia's compiler is in many
waysmuchsimplerthanthoseofotherdynamiclanguages(e.g. PyPyorLuaJIT).Julia'sperformanceadvantage
derives almost entirely from its front-end: its language semantics allow awell-written Julia programto give
more opportunities to the compiler to generate efficient code and memory layouts. If you tried to compile
MatlaborPythoncodetoJulia, ourcompilerwouldbelimitedbythesemanticsofMatlaborPythontoproducing
code no better than that of existing compilers for those languages (and probably worse). The key role of
semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize
a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are
already doing at least as well as we could for the same semantics. The people working on those projects are
incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was
designed to be interpreted is a very difficult problem.

Julia's advantage is that good performance is not limited to a small subset of “built-in” types and operations,
and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast
and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler
for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.

Forsimilarreasons,automatedtranslationtoJuliawouldalsotypicallygenerateunreadable,slow,non-idiomatic
code that would not be a good starting point for a native Julia port from another language.

On the other hand, language interoperability is extremely useful: we want to exploit existing high-quality code
in other languages from Julia (and vice versa)! The best way to enable this is not a transpiler, but rather via
easy inter-language calling facilities. We have worked hard on this, from the built-inccallintrinsic (to call C
and Fortran libraries) toJuliaInteroppackages that connect Julia to Python, Matlab, C++, and more.

#### 400


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 401

### 37.2 Public API

### How does Julia define its public API?

The only interfaces that are stable with respect toSemVerofjuliaversion are the JuliaBaseand standard
libraries interfaces described inthe documentationand not marked as unstable (e.g., experimental and inter-
nal). Functions,types,andconstantsarenotpartofthepublicAPIiftheyarenotincludedinthedocumentation,
even if they have docstrings.

### There is a useful undocumented function/type/constant. Can I use it?

Updating Julia may break your code if you use non-public API. If the code is self-contained, it may be a good
idea to copy it into your project. If you want to rely on a complex non-public API, especially when using it
from a stable package, it is a good idea to open anissue or pull requestto start a discussion for turning it
into a public API. However, we do not discourage the attempt to create packages that expose stable public
interfaces while relying on non-public implementation details ofjuliaand buffering the differences across
differentjuliaversions.

### The documentation is not accurate enough. Can I rely on the existing behavior?

Please open anissue or pull requestto start a discussion for turning the existing behavior into a public API.

### 37.3 Sessions and the REPL.

### How do I delete an object in memory?

JuliadoesnothaveananalogofMATLAB'sclearfunction; onceanameisdefinedinaJuliasession(technically,
in moduleMain), it is always present.

If memory usage is your concern, you can always replace objects with ones that consume less memory. For
example, ifAis a gigabyte-sized array that you no longer need, you can free the memory withA = nothing.
The memory will be released the next time the garbage collector runs; you can force this to happen with
GC.gc(). Moreover, an attempt to useAwill likely result in an error, because most methods are not defined
on typeNothing.

### How can I modify the declaration of a type in my session?

Perhaps you've defined a type and then realize you need to add a new field. If you try this at the REPL, you
get the error:

```

ERROR: invalid redefinition of constant MyType

```
Types in moduleMaincannot be redefined.

While this can be inconvenient when you are developing new code, there's an excellent workaround. Modules
can be replaced by redefining them, and so if you wrap all your new code inside a module you can redefine
types and constants. You can't import the type names intoMainand then expect to be able to redefine them
there, but you can use the module name to resolve the scope. In other words, while developing you might use
a workflow something like this:

```

include("mynewcode.jl") # this defines a module MyModule  
obj1= MyModule.ObjConstructor(a, b)  
obj2= MyModule.somefunction(obj1)

# Got an error. Change something in "mynewcode.jl"

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 402

```

include("mynewcode.jl") # reload the module  
obj1= MyModule.ObjConstructor(a, b)# old objects are no longer valid, must reconstruct  
obj2= MyModule.somefunction(obj1) # this time it worked!  
obj3= MyModule.someotherfunction(obj2, c)

```
### 37.4 Scripting.

### How do I check if the current file is being run as the main script?

When a file is run as the main script usingjulia file.jlone might want to activate extra functionality
like command line argument handling. A way to determine that a file is run in this fashion is to check if
abspath(PROGRAM_FILE) == @__FILE__istrue.

### How do I catch CTRL-C in a script?

Running a Julia script usingjulia file.jldoes not throwInterruptExceptionwhen you try to terminate it
withCTRL-C(SIGINT).TorunacertaincodebeforeterminatingaJuliascript,whichmayormaynotbecausedby
CTRL-C,useatexit. Alternatively, youcanusejulia -e 'include(popfirst!(ARGS))' file.jltoexecute
a script while being able to catchInterruptExceptionin thetryblock.

### How do I pass options tojuliausing#!/usr/bin/env?

Passing options tojuliain so-called shebang by, e.g.,#!/usr/bin/env julia --startup-file=nomay not
work in some platforms such as Linux. This is because argument parsing in shebang is platform-dependent
and not well-specified. In a Unix-like environment, a reliable way to pass options tojuliain an executable
script would be to start the script as abashscript and useexecto replace the process tojulia:

```

#!/bin/bash  
#=  
exec julia --color=yes --startup-file=no "${BASH_SOURCE[0]}" "$@"  
=#

@showARGS # put any Julia code here

```
In the example above, the code between#=and=#is run as abashscript. Julia ignores this part since it is a
multi-line comment for Julia. The Julia code after=#is ignored bybashsince it stops parsing the file once it
reaches to theexecstatement.

```

Note  
In order tocatch CTRL-Cin the script you can use

#!/bin/bash  
#=  
exec julia --color=yes --startup-file=no -e 'include(popfirst!(ARGS))'  
"${BASH_SOURCE[0]}" "$@"  
=#

@showARGS # put any Julia code here

instead. Note that with this strategyPROGRAM_FILEwill not be set.

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 403

### 37.5 Functions

### I passed an argumentxto a function, modified it inside that function, but on the

### outside, the variablexis still unchanged. Why?

Suppose you call a function like this:

```

julia> x = 10  
10

julia>function change_value!(y)  
y = 17  
end  
change_value! (generic function with 1 method)

julia> change_value!(x)  
17

julia> x # x is unchanged!  
10

```
In Julia, the binding of a variablexcannot be changed by passingxas an argument to a function. When calling
change_value!(x)in the above example,yis a newly created variable, bound initially to the value ofx, i.e.
10 ; thenyis rebound to the constant 17 , while the variablexof the outer scope is left untouched.

However, ifxis bound to an object of typeArray(or any other mutable type). From within the function, you
cannot"unbind"xfrom this Array, but you can change its content. For example:

```

julia> x = [1,2,3]  
3-element Vector{Int64}:  
1  
2  
3

julia>function change_array!(A)  
A[1] = 5  
end  
change_array! (generic function with 1 method)

julia> change_array!(x)  
5

julia> x  
3-element Vector{Int64}:  
5  
2  
3

```
Here we created a functionchange_array!, that assigns 5 to the first element of the passed array (bound to
xat the call site, and bound toAwithin the function). Notice that, after the function call,xis still bound to the
same array, but the content of that array changed: the variablesAandxwere distinct bindings referring to
the same mutableArrayobject.


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 404

### Can I useusingorimportinside a function?

No, you are not allowed to have ausingorimportstatement inside a function. If you want to import a module
but only use its symbols inside a specific function or set of functions, you have two options:

1. Useimport:

```

import Foo  
function bar(...)

# ... refer to Foo symbols via Foo.baz ...

end

This loads the moduleFooand defines a variableFoothat refers to the module, but does not import any  
of the other symbols from the module into the current namespace. You refer to theFoosymbols by their  
qualified namesFoo.baretc.

```
2. Wrap your function in a module:

```

module Bar  
export bar  
using Foo  
function bar(...)

# ... refer to Foo.baz as simply baz ....

end  
end  
using Bar

This imports all the symbols fromFoo, but only inside the moduleBar.

```
### What does the...operator do?

**The two uses of the...operator: slurping and splatting**

ManynewcomerstoJuliafindtheuseof...operatorconfusing. Partofwhatmakesthe...operatorconfusing
is that it means two different things depending on context.

**...combines many arguments into one argument in function definitions**

In the context of function definitions, the...operator is used to combine many different arguments into a
single argument. This use of... for combining many different arguments into a single argument is called
slurping:

```

julia>function printargs(args...)  
println(typeof(args))  
for (i, arg) in enumerate(args)  
println("Arg # $i = $arg ")  
end  
end  
printargs (generic function with 1 method)

julia> printargs(1, 2, 3)  
Tuple{Int64, Int64, Int64}  
Arg #1 = 1  
Arg #2 = 2  
Arg #3 = 3

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 405

If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been
written as<-...instead of....

**...splits one argument into many different arguments in function calls**

In contrast to the use of the...operator to denote slurping many different arguments into one argument
when defining a function, the...operator is also used to cause a single function argument to be split apart
into many different arguments when used in the context of a function call. This use of...is called splatting:

```

julia>function threeargs(a, b, c)  
println("a = $a :: $ (typeof(a))")  
println("b = $b :: $ (typeof(b))")  
println("c = $c :: $ (typeof(c))")  
end  
threeargs (generic function with 1 method)

julia> x = [1, 2, 3]  
3-element Vector{Int64}:  
1  
2  
3

julia> threeargs(x...)  
a = 1::Int64  
b = 2::Int64  
c = 3::Int64

```
If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been
written as...->instead of....

### What is the return value of an assignment?

The operator=always returns the right-hand side, therefore:

```

julia>function threeint()  
x:: Int = 3.0  
x # returns variable x  
end  
threeint (generic function with 1 method)

julia>function threefloat()  
x:: Int = 3.0 # returns 3.0  
end  
threefloat (generic function with 1 method)

julia> threeint()  
3

julia> threefloat()  
3.0

```
and similarly:


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 406

```

julia>function twothreetup()  
x, y= [2, 3] # assigns 2 to x and 3 to y  
x, y# returns a tuple  
end  
twothreetup (generic function with 1 method)

julia>function twothreearr()  
x, y= [2, 3] # returns an array  
end  
twothreearr (generic function with 1 method)

julia> twothreetup()  
(2, 3)

julia> twothreearr()  
2-element Vector{Int64}:  
2  
3

```
### 37.6 Types, type declarations, and constructors

### What does"type-stable" mean?

It means that the type of the output is predictable from the types of the inputs. In particular, it means that the
type of the output cannot vary depending on the values of the inputs. The following code is not type-stable:

```

julia>function unstable(flag:: Bool )  
if flag  
return 1  
else  
return 1.0  
end  
end  
unstable (generic function with 1 method)

```
It returns either anIntor aFloat64depending on the value of its argument. Since Julia can't predict the
return type of this function at compile-time, any computation that uses it must be able to cope with values of
both types, which makes it hard to produce fast machine code.

### Why does Julia give aDomainErrorfor certain seemingly-sensible operations?

Certain operations make mathematical sense but result in errors:

```

julia> sqrt(-2.0)  
ERROR: DomainError with -2.0:  
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).  
Stacktrace:  
[...]

```
This behavior is an inconvenient consequence of the requirement for type-stability. In the case ofsqrt, most
users wantsqrt(2.0)to give a real number, and would be unhappy if it produced the complex number
1.4142135623730951 + 0.0im. One could write thesqrtfunction to switch to a complex-valued output only


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 407

when passed a negative number (which is whatsqrtdoes in some other languages), but then the result would
not betype-stableand thesqrtfunction would have poor performance.

In these and other cases, you can get the result you want by choosing an input type that conveys your willing-
ness to accept an output type in which the result can be represented:

```

julia> sqrt(-2.0+0im)  
0.0 + 1.4142135623730951im

```
### How can I constrain or compute type parameters?

The parameters of aparametric typecan hold either types or bits values, and the type itself chooses how
it makes use of these parameters. For example,Array{Float64, 2}is parameterized by the typeFloat64
to express its element type and the integer value 2 to express its number of dimensions. When defining
your own parametric type, you can use subtype constraints to declare that a certain parameter must be a
subtype (<:) of some abstract type or a previous type parameter. There is not, however, a dedicated syntax
to declare that a parameter must be a value of a given type — that is, you cannot directly declare that a
dimensionality-like parameterisa Intwithin thestructdefinition, for example. Similarly, you cannot do
computations (including simple things like addition or subtraction) on type parameters. Instead, these sorts
of constraints and relationships may be expressed through additional type parameters that are computed and
enforced within the type's constructors.

As an example, consider

```

struct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX  
A:: Array {T,N}  
B:: Array {T,N+1}  
end

```
where the user would like to enforce that the third type parameter is always the second plus one. This can be
implemented with an explicit type parameter that is checked by aninner constructor method(where it can be
combined with other checks):

```

struct ConstrainedType{T,N,M}  
A:: Array {T,N}  
B:: Array {T,M}  
function ConstrainedType(A:: Array {T,N}, B:: Array {T,M}) where {T,N,M}  
N + 1 == M || throw( ArgumentError ("second argument should have one more axis"))  
new{T,N,M}(A, B)  
end  
end

```
This check is usually costless, as the compiler can elide the check for valid concrete types. If the second
argument is also computed, it may be advantageous to provide anouter constructor methodthat performs
this calculation:

```

ConstrainedType(A)= ConstrainedType(A, compute_B(A))

```
### Why does Julia use native machine integer arithmetic?

Julia uses machine arithmetic for integer computations. This means that the range ofIntvalues is bounded
and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow,
leading to some results that can be unsettling at first:


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 408

```

julia> x = typemax( Int )  
9223372036854775807

julia> y = x+1  
-9223372036854775808

julia> z = -y  
-9223372036854775808

julia> 2*z  
0

```
Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-
level programming language to expose this to the user. For numerical work where efficiency and transparency
are at a premium, however, the alternatives are worse.

Onealternativetoconsiderwouldbetocheckeachintegeroperationforoverflowandpromoteresultstobigger
integer types such asInt128orBigIntin the case of overflow. Unfortunately, this introduces major overhead
on every integer operation (think incrementing a loop counter) – it requires emitting code to perform run-
time overflow checks after arithmetic instructions and branches to handle potential overflows. Worse still, this
would cause every computation involving integers to be type-unstable. As we mentioned above,type-stability
is crucialfor effective generation of efficient code. If you can't count on the results of integer operations being
integers, it's impossible to generate fast, simple code the way C and Fortran compilers do.

A variation on this approach, which avoids the appearance of type instability is to merge theIntandBigInt
types into a single hybrid integer type, that internally changes representation when a result no longer fits into
the size of a machine integer. While this superficially avoids type-instability at the level of Julia code, it just
sweeps the problem under the rug by foisting all of the same difficulties onto the C code implementing this
hybrid integer type. This approach can be made to work and can even be made quite fast in many cases, but
hasseveraldrawbacks. Oneproblemisthatthein-memoryrepresentationofintegersandarraysofintegersno
longer match the natural representation used by C, Fortran and other languages with native machine integers.
Thus,tointeroperatewiththoselanguages,wewouldultimatelyneedtointroducenativeintegertypesanyway.
Any unbounded representation of integers cannot have a fixed number of bits, and thus cannot be stored inline
in an array with fixed-size slots – large integer values will always require separate heap-allocated storage. And
of course, no matter how clever a hybrid integer implementation one uses, there are always performance traps

- situations where performance degrades unexpectedly. Complex representation, lack of interoperability with
C and Fortran, the inability to represent integer arrays without additional heap storage, and unpredictable
performance characteristics make even the cleverest hybrid integer implementations a poor choice for high-
performance numerical work.

An alternative to using hybrid integers or promoting to BigInts is to use saturating integer arithmetic, where
adding to the largest integer value leaves it unchanged and likewise for subtracting from the smallest integer
value. This is precisely what Matlab™ does:

```

> > int64(9223372036854775807)

ans =

9223372036854775807

> > int64(9223372036854775807) + 1

ans =

9223372036854775807

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 409

```

> > int64(-9223372036854775808)

ans =

-9223372036854775808

> > int64(-9223372036854775808) - 1

ans =

-9223372036854775808

```
Atfirstblush,thisseemsreasonableenoughsince9223372036854775807ismuchcloserto9223372036854775808
than-9223372036854775808isandintegersarestillrepresentedwithafixedsizeinanaturalwaythatiscom-
patible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most
obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated oper-
ations requires emitting instructions after each machine integer operation to check for underflow or overflow
and replace the result withtypemin(Int)ortypemax(Int)as appropriate. This alone expands each integer
operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But
it gets worse – saturating integer arithmetic isn't associative. Consider this Matlab computation:

```

> > n = int64(2)^62  
> > 4611686018427387904

> > n + (n - 1)  
> > 9223372036854775807

> > (n + n) - 1  
> > 9223372036854775806

```
This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the
fact that machine addition with overflow is associative. Consider finding the midpoint between integer values
loandhiin Julia using the expression(lo + hi) >>> 1:

```

julia> n = 2^62  
4611686018427387904

julia> (n + 2n) >>> 1  
6917529027641081856

```
See? No problem. That's the correct midpoint between 2^62 and 2^63, despite the fact thatn + 2nis
-4611686018427387904. Now try it in Matlab:

```

> > (n + 2*n)/2

ans =

4611686018427387904

```
Oops. Adding a>>>operator to Matlab wouldn't help, because saturation that occurs when addingnand2n
has already destroyed the information necessary to compute the correct midpoint.

Not only is lack of associativity unfortunate for programmers who cannot rely it for techniques like this, but it
alsodefeatsalmostanythingcompilersmightwanttodotooptimizeintegerarithmetic. Forexample,sinceJulia


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 410

integers use normal machine integer arithmetic, LLVM is free to aggressively optimize simple little functions
likef(k) = 5k-1. The machine code for this function is just this:

```

julia> code_native(f, Tuple { Int })  
.text  
Filename: none  
pushq %rbp  
movq %rsp, %rbp  
Source line: 1  
leaq -1(%rdi,%rdi,4), %rax  
popq %rbp  
retq  
nopl (%rax,%rax)

```
The actual body of the function is a singleleaqinstruction, which computes the integer multiply and add at
once. This is even more beneficial whenfgets inlined into another function:

```

julia>function g(k, n)  
for i = 1:n  
k = f(k)  
end  
return k  
end  
g (generic function with 1 methods)

julia> code_native(g, Tuple { Int , Int })  
.text  
Filename: none  
pushq %rbp  
movq %rsp, %rbp  
Source line: 2  
testq %rsi, %rsi  
jle L26  
nopl (%rax)  
Source line: 3  
L16:  
leaq -1(%rdi,%rdi,4), %rdi  
Source line: 2  
decq %rsi  
jne L16  
Source line: 5  
L26:  
movq %rdi, %rax  
popq %rbp  
retq  
nop

```
Since the call tofgets inlined, the loop body ends up being just a singleleaqinstruction. Next, consider what
happens if we make the number of loop iterations fixed:

```

julia>function g(k)  
for i = 1:10  
k = f(k)  
end

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 411

```

return k  
end  
g (generic function with 2 methods)

julia> code_native(g,( Int ,))  
.text  
Filename: none  
pushq %rbp  
movq %rsp, %rbp  
Source line: 3  
imulq $9765625, %rdi, %rax # imm = 0x9502F9  
addq $-2441406, %rax # imm = 0xFFDABF42  
Source line: 5  
popq %rbp  
retq  
nopw %cs:(%rax,%rax)

```
Because the compiler knows that integer addition and multiplication are associative and that multiplication
distributes over addition – neither of which is true of saturating arithmetic – it can optimize the entire loop
down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since
associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which
iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple
operations into fewer equivalent operations.

The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic
everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-
correct. In thisblog post, Dan Luu analyzes this and finds that rather than the trivial cost that this approach
should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully
optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to
checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.

Inthemeantime, overflow-safeintegeroperationscanbeachievedthroughtheuseofexternallibrariessuchas
SaferIntegers.jl. Note that, as stated previously, the use of these libraries significantly increases the execution
time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it
were used for all integer operations. You can follow the status of the discussionhere.

### What are the possible causes of anUndefVarErrorduring remote execution?

As the error states, an immediate cause of anUndefVarErroron a remote node is that a binding by that name
does not exist. Let us explore some of the possible causes.

```

julia>module Foo  
foo()= remotecall_fetch(x->x, 2, "Hello")  
end

julia> Foo.foo()  
ERROR: On worker 2:  
UndefVarError: Foo not defined  
Stacktrace:  
[...]

```
The closurex->xcarries a reference toFoo, and sinceFoois unavailable on node 2, anUndefVarErroris
thrown.


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 412

Globals under modules other thanMainare not serialized by value to the remote node. Only a reference is
sent. Functions which create global bindings (except underMain) may cause anUndefVarErrorto be thrown
later.

```

julia> @everywhere module Foo  
function foo()  
global gvar= "Hello"  
remotecall_fetch(()->gvar,2)  
end  
end

julia> Foo.foo()  
ERROR: On worker 2:  
UndefVarError: gvar not defined  
Stacktrace:  
[...]

```
In the above example,@everywhere module FoodefinedFooon all nodes. However the call toFoo.foo()
created a new global bindinggvaron the local node, but this was not found on node 2 resulting in an
UndefVarErrorerror.

Note that this does not apply to globals created under moduleMain. Globals under moduleMainare serialized
and new bindings created underMainon the remote node.

```

julia> gvar_self= "Node1"  
"Node1"

julia> remotecall_fetch(()->gvar_self,2)  
"Node1"

julia> remotecall_fetch(varinfo,2)  
name size summary  
––––––––– –––––––– –––––––  
Base Module  
Core Module  
Main Module  
gvar_self 13 bytes String

```
This does not apply tofunctionorstructdeclarations. However, anonymous functions bound to global
variables are serialized as can be seen below.

```

julia> bar()= 1  
bar (generic function with 1 method)

julia> remotecall_fetch(bar,2)  
ERROR: On worker 2:  
UndefVarError: #bar not defined  
[...]

julia> anon_bar = ()->1  
(::#21) (generic function with 1 method)

julia> remotecall_fetch(anon_bar,2)  
1

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 413

### 37.7 Troubleshooting"method not matched": parametric type invariance andMethodErrors

### Why doesn't it work to declarefoo(bar::Vector{Real}) = 42and then callfoo([1])?

As you'll see if you try this, the result is aMethodError:

```

julia> foo(x:: Vector { Real }) = 42  
foo (generic function with 1 method)

julia> foo([1])  
ERROR: MethodError: no method matching foo(::Vector{Int64})  
Closest candidates are:  
foo(!Matched::Vector{Real}) at none:1

```
This is becauseVector{Real}is not a supertype ofVector{Int}! You can solve this problem with something
likefoo(bar::Vector{T}) where {T<:Real}(or the short formfoo(bar::Vector{<:Real})if the static pa-
rameterTis not needed in the body of the function). TheTis a wild card: you first specify that it must be a
subtype of Real, then specify the function takes a Vector of with elements of that type.

This same issue goes for any composite typeComp, not justVector. IfComphas a parameter declared of type
Y, then another typeComp2with a parameter of typeX<:Yis not a subtype ofComp. This is type-invariance (by
contrast, Tuple is type-covariant in its parameters). SeeParametric Composite Typesfor more explanation of
these.

### Why does Julia use*for string concatenation? Why not+or something else?

The main argumentagainst+is that string concatenation is not commutative, while+is generally used as a
commutative operator. While the Julia community recognizes that other languages use different operators and
*may be unfamiliar for some users, it communicates certain algebraic properties.

Note that you can also usestring(...)to concatenate strings (and other values converted to strings); simi-
larly,repeatcan be used instead of^to repeat strings. Theinterpolation syntaxis also useful for constructing
strings.

### 37.8 Packages and Modules.

### What is the difference between"using" and "import"?

There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference be-
tweenusingandimportis that withusingyou need to sayfunction Foo.bar(..to extend module Foo's
function bar with a new method, but withimport Foo.bar, you only need to sayfunction bar(...and it
automatically extends module Foo's function bar.

The reason this is important enough to have been given separate syntax is that you don't want to accidentally
extend a function that you didn't know existed, because that could easily cause a bug. This is most likely
to happen with a method that takes a common type like a string or integer, because both you and the other
module could define a method to handle such a common type. If you useimport, then you'll replace the other
module's implementation ofbar(s::AbstractString)with your new implementation, which could easily do
something completely different (and break all/many future usages of the other functions in module Foo that
depend on calling bar).


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 414

### 37.9 Nothingness and missing values

### How does"null", "nothingness" or "missingness" work in Julia?

Unlike many languages (for example, C and Java), Julia objects cannot be"null" by default. When a reference
(variable, object field, or array element) is uninitialized, accessing it will immediately throw an error. This
situation can be detected using theisdefinedorisassignedfunctions.

Some functions are used only for their side effects, and do not need to return a value. In these cases, the
convention is to return the valuenothing, which is just a singleton object of typeNothing. This is an ordinary
type with no fields; there is nothing special about it except for this convention, and that the REPL does not
print anything for it. Some language constructs that would not otherwise have a value also yieldnothing, for
exampleif false; end.

For situations where a valuexof typeTexists only sometimes, theUnion{T, Nothing}type can be used for
function arguments, object fields and array element types as the equivalent ofNullable,OptionorMaybein
other languages. If the value itself can benothing(notably, whenTisAny), theUnion{Some{T}, Nothing}
type is more appropriate sincex == nothingthen indicates the absence of a value, andx == Some(nothing)
indicates the presence of a value equal tonothing. Thesomethingfunction allows unwrappingSomeobjects
and using a default value instead ofnothingarguments. Note that the compiler is able to generate efficient
code when working withUnion{T, Nothing}arguments or fields.

To represent missing data in the statistical sense (NAin R orNULLin SQL), use themissingobject. See the
Missing Valuessection for more details.

In some languages, the empty tuple (()) is considered the canonical form of nothingness. However, in julia it
is best thought of as just a regular tuple that happens to contain zero values.

The empty (or"bottom") type, written asUnion{}(an empty union type), is a type with no values and no
subtypes (except itself). You will generally not need to use this type.

### 37.10Memory

### Why doesx += yallocate memory whenxandyare arrays?

In Julia,x += ygets replaced during parsing byx = x + y. For arrays, this has the consequence that, rather
than storing the result in the same location in memory asx, it allocates a new array to store the result.

While this behavior might surprise some, the choice is deliberate. The main reason is the presence of im-
mutable objects within Julia, which cannot change their value once created. Indeed, a number is an immutable
object; the statementsx = 5; x += 1do not modify the meaning of 5 , they modify the value bound tox. For
an immutable, the only way to change the value is to reassign it.

To amplify a bit further, consider the following function:

```

function power_by_squaring(x, n:: Int )  
ispow2(n)|| error("This implementation only works for powers of 2")  
while n >= 2  
x *= x  
n >>= 1  
end  
x  
end

```
After a call likex = 5; y = power_by_squaring(x, 4), you would get the expected result:x == 5 && y ==
625. However, now suppose that*=, when used with matrices, instead mutated the left hand side. There
would be two problems:


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 415

- For general square matrices,A = A*Bcannot be implemented without temporary storage:A[1,1]gets
    computed and stored on the left hand side before you're done using it on the right hand side.
- Suppose you were willing to allocate a temporary for the computation (which would eliminate most of
    the point of making*=work in-place); if you took advantage of the mutability ofx, then this function
    would behave differently for mutable vs. immutable inputs. In particular, for immutablex, after the call
    you'd have (in general)y != x, but for mutablexyou'd havey == x.

Becausesupportinggenericprogrammingisdeemedmoreimportantthanpotentialperformanceoptimizations
that can be achieved by other means (e.g., using explicit loops), operators like+=and*=work by rebinding
new values.

### 37.11Asynchronous IO and concurrent synchronous writes.

### Why do concurrent writes to the same stream result in inter-mixed output?

While the streaming I/O API is synchronous, the underlying implementation is fully asynchronous.

Consider the printed output from the following:

```

julia> @sync for i in 1:3  
@asyncwrite(stdout, string(i)," Foo ", " Bar ")  
end  
123 Foo Foo Foo Bar Bar Bar

```
This is happening because, while thewritecall is synchronous, the writing of each argument yields to other
tasks while waiting for that part of the I/O to complete.

printandprintln"lock" the stream during a call. Consequently changingwritetoprintlnin the above
example results in:

```

julia> @sync for i in 1:3  
@asyncprintln(stdout, string(i)," Foo ", " Bar ")  
end  
1 Foo Bar  
2 Foo Bar  
3 Foo Bar

```
You can lock your writes with aReentrantLocklike this:

```

julia> l = ReentrantLock ();

julia> @sync for i in 1:3  
@async begin  
lock(l)  
try  
write(stdout, string(i)," Foo ", " Bar ")  
finally  
unlock(l)  
end  
end  
end  
1 Foo Bar 2 Foo Bar 3 Foo Bar

```

#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 416

### 37.12Arrays

### What are the differences between zero-dimensional arrays and scalars?

Zero-dimensional arrays are arrays of the formArray{T,0}. They behave similar to scalars, but there are
important differences. They deserve a special mention because they are a special case which makes logical
sense given the generic definition of arrays, but might be a bit unintuitive at first. The following line defines a
zero-dimensional array:

```

julia> A = zeros()  
0-dimensional Array{Float64,0}:  
0.0

```
In this example,Ais a mutable container that contains one element, which can be set byA[] = 1.0and
retrieved withA[]. All zero-dimensional arrays have the same size (size(A) == ()), and length (length(A)
== 1). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas
that might help to understand Julia's definition.

- Zero-dimensional arrays are the"point" to vector's "line" and matrix's "plane". Just as a line has no area
    (but still represents a set of things), a point has no length or any dimensions at all (but still represents
    a thing).
- We defineprod(())to be 1, and the total number of elements in an array is the product of the size. The
    size of a zero-dimensional array is(), and therefore its length is 1.
- Zero-dimensional arrays don't natively have any dimensions into which you index – they’re justA[]. We
    can apply the same"trailing one" rule for them as for all other array dimensionalities, so you can indeed
    index them asA[1],A[1,1], etc; seeOmitted and extra indices.

It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even
though they are iterable and define things likelength,getindex, e.g.1[] == 1). In particular, ifx = 0.0is
defined as a scalar, it is an error to attempt to change its value viax[] = 1.0. A scalarxcan be converted
into a zero-dimensional array containing it viafill(x), and conversely, a zero-dimensional arrayacan be
converted to the contained scalar viaa[]. Another difference is that a scalar can participate in linear algebra
operations such as2 * rand(2,2), but the analogous operation with a zero-dimensional arrayfill(2) *
rand(2,2)is an error.

### Why are my Julia benchmarks for linear algebra operations different from other

### languages?

You may find that simple benchmarks of linear algebra building blocks like

```

using BenchmarkTools  
A = randn(1000, 1000)  
B = randn(1000, 1000)  
@btime$A \ $B  
@btime$A * $B

```
can be different when compared to other languages like Matlab or R.

Since operations like this are very thin wrappers over the relevant BLAS functions, the reason for the discrep-
ancy is very likely to be

1. the BLAS library each language is using,


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 417

2. the number of concurrent threads.

Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at 8 (or the number of your
cores).

Modifying OpenBLAS settings or compiling Julia with a different BLAS library, egIntel MKL, may provide perfor-
mance improvements. You can useMKL.jl, a package that makes Julia's linear algebra use Intel MKL BLAS and
LAPACK instead of OpenBLAS, or search the discussion forum for suggestions on how to set this up manually.
Note that Intel MKL cannot be bundled with Julia, as it is not open source.

### 37.13Computing cluster.

### How do I manage precompilation caches in distributed file systems?

When usingjuliain high-performance computing (HPC) facilities, invoking njuliaprocesses simultaneously
creates at most n temporary copies of precompilation cache files. If this is an issue (slow and/or small dis-
tributed file system), you may:

1. Usejuliawith--compiled-modules=noflag to turn off precompilation.
2. Configureaprivatewritabledepotusingpushfirst!(DEPOT_PATH, private_path)whereprivate_path
    isapathuniquetothisjuliaprocess. ThiscanalsobedonebysettingenvironmentvariableJULIA_DEPOT_PATH
    to$private_path:$HOME/.julia.
3. Create a symlink from~/.julia/compiledto a directory in a scratch space.

### 37.14Julia Releases

### Do I want to use the Stable, LTS, or nightly version of Julia?

The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run.
It has the latest features, including improved performance. The Stable version of Julia is versioned according to
SemVeras v1.x.y. A new minor release of Julia corresponding to a new Stable version is made approximately
every 4-5 months after a few weeks of testing as a release candidate. Unlike the LTS version the a Stable
version will not normally receive bugfixes after another Stable version of Julia has been released. However,
upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run
code written for earlier versions.

You may prefer the LTS (Long Term Support) version of Julia if you are looking for a very stable code base. The
current LTS version of Julia is versioned according to SemVer as v1.0.x; this branch will continue to receive
bugfixes until a new LTS branch is chosen, at which point the v1.0.x series will no longer received regular bug
fixes and all but the most conservative users will be advised to upgrade to the new LTS version series. As a
package developer, you may prefer to develop for the LTS version, to maximize the number of users who can
use your package. As per SemVer, code written for v1.0 will continue to work for all future LTS and Stable
versions. In general, even if targeting the LTS, one can develop and run code in the latest Stable version, to
take advantage of the improved performance; so long as one avoids using new features (such as added library
functions or new methods).

You may prefer the nightly version of Julia if you want to take advantage of the latest updates to the language,
and don't mind if the version available today occasionally doesn't actually work. As the name implies, releases
to the nightly version are made roughly every night (depending on build infrastructure stability). In general
nightly released are fairly safe to use—your code will not catch on fire. However, they may be occasional
regressions and or issues that will not be found until more thorough pre-release testing. You may wish to test


#### CHAPTER 37. FREQUENTLY ASKED QUESTIONS 418

againstthenightlyversiontoensurethatsuchregressionsthataffectyourusecasearecaughtbeforearelease
is made.

Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals
who are comfortable at the command line, or interested in learning. If this describes you, you may also be
interested in reading ourguidelines for contributing.

Links to each of these download types can be found on the download page athttps://julialang.org/downloads/.
Note that not all versions of Julia are available for all platforms.

### How can I transfer the list of installed packages after updating my version of Julia?

Each minor version of julia has its own defaultenvironment. As a result, upon installing a new minor version of
Julia, the packages you added using the previous minor version will not be available by default. The environ-
ment for a given julia version is defined by the filesProject.tomlandManifest.tomlin a folder matching
the version number in.julia/environments/, for instance,.julia/environments/v1.3.

IfyouinstallanewminorversionofJulia,say1.4,andwanttouseinitsdefaultenvironmentthesamepackages
as in a previous version (e.g.1.3), you can copy the contents of the fileProject.tomlfrom the1.3folder to
1.4. Then, in a session of the new Julia version, enter the"package management mode" by typing the key],
and run the commandinstantiate.

This operation will resolve a set of feasible packages from the copied file that are compatible with the target
Julia version, and will install or update them if suitable. If you want to reproduce not only the set of packages,
but also the versions you were using in the previous Julia version, you should also copy theManifest.toml
file before running the Pkg commandinstantiate. However, note that packages may define compatibility
constraints that may be affected by changing the version of Julia, so the exact set of versions you had in1.3
may not work for1.4.


**Chapter 38**

**Noteworthy Differences from other Languages**

### 38.1 Noteworthy differences from MATLAB.

Although MATLAB users may find Julia's syntax familiar, Julia is not a MATLAB clone. There are major syn-
tactic and functional differences. The following are some noteworthy differences that may trip up Julia users
accustomed to MATLAB:

- Julia arrays are indexed with square brackets,A[i,j].
- Julia arrays are not copied when assigned to another variable. AfterA = B, changing elements ofBwill
    modifyAas well.
- Julia values are not copied when passed to a function. If a function modifies an array, the changes will
    be visible in the caller.
- Julia does not automatically grow arrays in an assignment statement. Whereas in MATLABa(4) = 3.2
    can create the arraya = [0 0 0 3.2]anda(5) = 7can grow it intoa = [0 0 0 3.2 7], the corre-
    sponding Julia statementa[5] = 7throws an error if the length ofais less than 5 or if this statement is
    the first use of the identifiera. Julia haspush!andappend!, which growVectors much more efficiently
    than MATLAB'sa(end+1) = val.
- The imaginary unitsqrt(-1)is represented in Julia asim, notiorjas in MATLAB.
- In Julia, literal numbers without a decimal point (such as 42 ) create integers instead of floating point
    numbers. As a result, some operations can throw a domain error if they expect a float; for example,
    julia> a = -1; 2^athrowsadomainerror, astheresultisnotaninteger(seetheFAQentryondomain
    errors for details).
- In Julia, multiple values are returned and assigned as tuples, e.g. (a, b) = (1, 2)ora, b = 1, 2.
    MATLAB'snargout, which is often used in MATLAB to do optional work based on the number of returned
    values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar
    capabilities.
- Julia has true one-dimensional arrays. Column vectors are of sizeN, notNx1. For example,rand(N)
    makes a 1-dimensional array.
- In Julia,[x,y,z]will always construct a 3-element array containingx,yandz.
    **-** To concatenate in the first ("vertical") dimension use eithervcat(x,y,z)or separate with semi-
       colons ([x; y; z]).

#### 419


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 420

**-** To concatenate in the second ("horizontal") dimension use eitherhcat(x,y,z)or separate with
    spaces ([x y z]).
**-** To construct block matrices (concatenating in the first two dimensions), use eitherhvcator com-
    bine spaces and semicolons ([a b; c d]).
- In Julia,a:banda:b:cconstructAbstractRangeobjects. To construct a full vector like in MATLAB, use
collect(a:b). Generally, there is no need to callcollectthough. AnAbstractRangeobject will act
like a normal array in most cases but is more efficient because it lazily computes its values. This pattern
of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such
asrange, or with iterators such asenumerate, andzip. The special objects can mostly be used as if
they were normal arrays.
- Functions in Julia return values from their last expression or thereturnkeyword instead of listing the
names of variables to return in the function definition (seeThe return Keywordfor details).
- A Julia script may contain any number of functions, and all definitions will be externally visible when the
file is loaded. Function definitions can be loaded from files outside the current working directory.
- In Julia, reductions such assum,prod, andmaxare performed over every element of an array when called
with a single argument, as insum(A), even ifAhas more than one dimension.
- In Julia, parentheses must be used to call a function with zero arguments, like inrand().
- Julia discourages the use of semicolons to end statements. The results of statements are not automati-
cally printed (except at the interactive prompt), and lines of code do not need to end with semicolons.
printlnor@printfcan be used to print specific output.
- InJulia,ifAandBarearrays,logicalcomparisonoperationslikeA == Bdonotreturnanarrayofbooleans.
Instead, useA .== B, and similarly for the other boolean operators like<,>.
- In Julia, the operators&,|, and ⊻ (xor) perform the bitwise operations equivalent toand,or, andxor
respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can
operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note
the difference in order of operations: parentheses may be required (e.g., to select elements ofAequal
to 1 or 2 use(A .== 1) .| (A .== 2)).
- In Julia, the elements of a collection can be passed as arguments to a function using the splat operator
..., as inxs=[1,2]; f(xs...).
- Julia'ssvdreturns singular values as a vector instead of as a dense diagonal matrix.
- InJulia,...isnotusedtocontinuelinesofcode. Instead,incompleteexpressionsautomaticallycontinue
onto the next line.
- InbothJuliaandMATLAB,thevariableansissettothevalueofthelastexpressionissuedinaninteractive
session. In Julia, unlike MATLAB,ansis not set when Julia code is run in non-interactive mode.
- Julia'sstructs do not support dynamically adding fields at runtime, unlike MATLAB'sclasses. Instead,
use aDict. Dict in Julia isn't ordered.
- In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global
scope.
- In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression
x(x>3)or in the statementx(x>3) = []to modifyxin-place. In contrast, Julia provides the higher order
functionsfilterandfilter!, allowing users to writefilter(z->z>3, x)andfilter!(z->z>3, x)
as alternatives to the corresponding transliterationsx[x.>3]andx = x[x.>3]. Usingfilter!reduces
the use of temporary arrays.


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 421

- The analogue of extracting (or"dereferencing") all elements of a cell array, e.g. invertcat(A{:})in
    MATLAB, is written using the splat operator in Julia, e.g. asvcat(A...).
- In Julia, theadjointfunction performs conjugate transposition; in MATLAB,adjointprovides the"adju-
    gate" or classical adjoint, which is the transpose of the matrix of cofactors.
- In Julia, a^b^c is evaluated a^(b^c) while in MATLAB it's (a^b)^c.

### 38.2 Noteworthy differences from R

One of Julia's goals is to provide an effective language for data analysis and statistical programming. For users
coming to Julia from R, these are some noteworthy differences:

- Julia's single quotes enclose characters, not strings.
- Juliacancreatesubstringsbyindexingintostrings. InR,stringsmustbeconvertedintocharactervectors
    before creating substrings.
- In Julia, like Python but unlike R, strings can be created with triple quotes""" ... """. This syntax is
    convenient for constructing strings that contain line breaks.
- In Julia, varargs are specified using the splat operator..., which always follows the name of a specific
    variable, unlike R, for which...can occur in isolation.
- In Julia, modulus ismod(a, b), nota %% b.%in Julia is the remainder operator.
- InJulia,notalldatastructuressupportlogicalindexing. Furthermore,logicalindexinginJuliaissupported
    only with vectors of length equal to the object being indexed. For example:
       **-** In R,c(1, 2, 3, 4)[c(TRUE, FALSE)]is equivalent toc(1, 3).
       **-** In R,c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]is equivalent toc(1, 3).
       **-** In Julia,[1, 2, 3, 4][[true, false]]throws aBoundsError.
       **-** In Julia,[1, 2, 3, 4][[true, false, true, false]]produces[1, 3].
- Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R
    where the vectors only need to share a common index range. For example,c(1, 2, 3, 4) + c(1, 2)
    is valid R but the equivalent[1, 2, 3, 4] + [1, 2]will throw an error in Julia.
- Julia allows an optional trailing comma when that comma does not change the meaning of code. This
    can cause confusion among R users when indexing into arrays. For example,x[1,]in R would return
    the first row of a matrix; in Julia, however, the comma is ignored, sox[1,] == x[1], and will return the
    first element. To extract a row, be sure to use:, as inx[1,:].
- Julia'smaptakes the function first, then its arguments, unlikelapply(<structure>, function, ...)
    in R. Similarly Julia's equivalent ofapply(X, MARGIN, FUN, ...)in R ismapsliceswhere the function
    is the first argument.
- Multivariate apply in R, e.g.mapply(choose, 11:13, 1:3), can be written asbroadcast(binomial,
    11:13, 1:3)inJulia. EquivalentlyJuliaoffersashorterdotsyntaxforvectorizingfunctionsbinomial.(11:13,
    1:3).
- Julia usesendto denote the end of conditional blocks, likeif, loop blocks, likewhile/for, and func-
    tions. In lieu of the one-lineif ( cond ) statement, Julia allows statements of the formif cond;
    statement; end,cond && statementand!cond || statement. Assignment statements in the latter
    two syntaxes must be explicitly wrapped in parentheses, e.g.cond && (x = value).


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 422

- In Julia,<-,<<-and->are not assignment operators.
- Julia's->creates an anonymous function.
- Julia constructs vectors using brackets. Julia's[1, 2, 3]is the equivalent of R'sc(1, 2, 3).
- Julia's*operator can perform matrix multiplication, unlike in R. IfAandBare matrices, thenA * B
    denotesamatrixmultiplicationinJulia, equivalenttoR'sA %*% B.InR,thissamenotationwouldperform
    an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to
    writeA .* Bin Julia.
- Julia performs matrix transposition using thetransposefunction and conjugated transposition using the
    'operatorortheadjointfunction. Julia'stranspose(A)isthereforeequivalenttoR'st(A).Additionally
    a non-recursive transpose in Julia is provided by thepermutedimsfunction.
- Julia does not require parentheses when writingifstatements orfor/whileloops: usefor i in [1,
    2, 3]instead offor (i in c(1, 2, 3))andif i == 1instead ofif (i == 1).
- Julia does not treat the numbers 0 and 1 as Booleans. You cannot writeif (1)in Julia, becauseif
    statements accept only booleans. Instead, you can writeif true,if Bool(1), orif 1==1.
- Juliadoesnotprovidenrowandncol. Instead,usesize(M, 1)fornrow(M)andsize(M, 2)forncol(M).
- Julia is careful to distinguish scalars, vectors and matrices. In R, 1 andc(1)are the same. In Julia, they
    cannot be used interchangeably.
- Julia'sdiaganddiagmare not like R's.
- Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you
    cannot writediag(M) = fill(1, n).
- Julia discourages populating the main namespace with functions. Most statistical functionality for Julia
    is found inpackagesunder theJuliaStats organization. For example:
       **-** Functions pertaining to probability distributions are provided by theDistributions package.
       **-** The DataFrames packageprovides data frames.
       **-** Generalized linear models are provided by theGLM package.
- Juliaprovidestuplesandrealhashtables,butnotR-stylelists. Whenreturningmultipleitems,youshould
    typically use a tuple or a named tuple: instead oflist(a = 1, b = 2), use(1, 2)or(a=1, b=2).
- Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's
    multipledispatchsystemmeansthattable(x::TypeA)andtable(x::TypeB)actlikeR'stable.TypeA(x)
    andtable.TypeB(x).
- In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the
    changes will be visible in the caller. This is very different from R and allows new functions to operate on
    large data structures much more efficiently.
- In Julia, vectors and matrices are concatenated usinghcat,vcatandhvcat, notc,rbindandcbindlike
    in R.
- In Julia, a range likea:bis not shorthand for a vector like in R, but is a specializedAbstractRangeobject
    that is used for iteration. To convert a range into a vector, usecollect(a:b).
- Julia'smaxandminare the equivalent ofpmaxandpminrespectively in R, but both arguments need to
    have the same dimensions. Whilemaximumandminimumreplacemaxandminin R, there are important
    differences.


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 423

- Julia'ssum,prod,maximum, andminimumare different from their counterparts in R. They all accept an
    optional keyword argumentdims, which indicates the dimensions, over which the operation is carried
    out. For instance, letA = [1 2; 3 4]in Julia andB <- rbind(c(1,2),c(3,4))be the same matrix in
    R. Thensum(A)gives the same result assum(B), butsum(A, dims=1)is a row vector containing the
    sum over each column andsum(A, dims=2)is a column vector containing the sum over each row. This
    contrasts to the behavior of R, where separatecolSums(B)androwSums(B)functions provide these
    functionalities. If thedimskeyword argument is a vector, then it specifies all the dimensions over which
    the sum is performed, while retaining the dimensions of the summed array, e.g.sum(A, dims=(1,2))
    == hcat(10). It should be noted that there is no error checking regarding the second argument.
- Julia has several functions that can mutate their arguments. For example, it has bothsortandsort!.
- In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code
    is often achieved by using devectorized loops.
- Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that
    there are very few unquoted expressions or column names.
- Julia does not support theNULLtype. The closest equivalent isnothing, but it behaves like a scalar
    value rather than like a list. Usex === nothinginstead ofis.null(x).
- In Julia, missing values are represented by themissingobject rather than byNA. Useismissing(x)(or
    ismissing.(x)for element-wise operation on vectors) instead ofis.na(x). Theskipmissingfunction
    is generally used instead ofna.rm=TRUE(though in some particular cases functions take askipmissing
    argument).
- Julia lacks the equivalent of R'sassignorget.
- In Julia,returndoes not require parentheses.
- In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression
    x[x>3]or in the statementx = x[x>3]to modifyxin-place. In contrast, Julia provides the higher order
    functionsfilterandfilter!, allowing users to writefilter(z->z>3, x)andfilter!(z->z>3, x)
    as alternatives to the corresponding transliterationsx[x.>3]andx = x[x.>3]. Usingfilter!reduces
    the use of temporary arrays.

### 38.3 Noteworthy differences from Python

- Julia'sfor,if,while, etc. blocks are terminated by theendkeyword. Indentation level is not significant
    as it is in Python. Unlike Python, Julia has nopasskeyword.
- Strings are denoted by double quotation marks ("text") in Julia (with three double quotation marks for
    multi-line strings), whereas in Python they can be denoted either by single ('text') or double quotation
    marks ("text"). Single quotation marks are used for characters in Julia ('c').
- String concatenation is done with*in Julia, not+like in Python. Analogously, string repetition is done
    with^, not*. Implicit string concatenation of string literals like in Python (e.g.'ab' 'cd' == 'abcd')
    is not done in Julia.
- Python Lists—flexible but slow—correspond to the JuliaVector{Any}type or more generallyVector{T}
    whereTis some non-concrete element type."Fast " arrays like NumPy arrays that store elements in-
    place (i.e.,dtypeisnp.float64,[('f1', np.uint64), ('f2', np.int32)], etc.) can be represented
    byArray{T}whereTis a concrete, immutable element type. This includes built-in types likeFloat64,
    Int32,Int64but also more complex types likeTuple{UInt64,Float64}and many user-defined types
    as well.


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 424

- In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.
- Julia's slice indexing includes the last element, unlike in Python.a[2:3]in Julia isa[1:3]in Python.
- Julia does not support negative indices. In particular, the last element of a list or array is indexed with
    endin Julia, not-1as in Python.
- Julia requiresendfor indexing until the last element.x[1:]in Python is equivalent tox[2:end]in Julia.
- Julia'srangeindexinghastheformatofx[start:step:stop],whereasPython'sformatisx[start:(stop+1):step].
    Hence,x[0:10:2]in Python is equivalent tox[1:2:10]in Julia. Similarly,x[::-1]in Python, which
    refers to the reversed array, is equivalent tox[end:-1:1]in Julia.
- In Julia, indexing a matrix with arrays likeX[[1,2], [1,3]]refers to a sub-matrix that contains the
    intersections of the first and second rows with the first and third columns. In Python,X[[1,2], [1,3]]
    refers to a vector that contains the values of cell[1,1]and[2,3]in the matrix.X[[1,2], [1,3]]in
    Julia is equivalent withX[np.ix_([0,1],[0,2])]in Python.X[[0,1], [0,2]]in Python is equivalent
    withX[[CartesianIndex(1,1), CartesianIndex(2,3)]]in Julia.
- Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression,
    it is considered done; otherwise the input continues. One way to force an expression to continue is to
    wrap it in parentheses.
- Julia arrays are column-major (Fortran-ordered) whereas NumPy arrays are row-major (C-ordered) by
    default. To get optimal performance when looping over arrays, the order of the loops should be reversed
    in Julia relative to NumPy (seerelevant section of Performance Tips).
- Julia's updating operators (e.g.+=,-=, ...) are not in-place whereas NumPy's are. This meansA = [1,
    1]; B = A; B += [3, 3]doesn't change values inA, it rather rebinds the nameBto the result of the
    right-hand sideB = B + 3, which is a new array. For in-place operation, useB .+= 3(see alsodot
    operators), explicit loops, orInplaceOps.jl.
- Julia evaluates default values of function arguments every time the method is invoked, unlike in Python
    wherethedefaultvaluesareevaluatedonlyoncewhenthefunctionisdefined. Forexample,thefunction
    f(x=rand()) = xreturnsanewrandomnumbereverytimeitisinvokedwithoutargument. Ontheother
    hand, the functiong(x=[1,2]) = push!(x,3)returns[1,2,3]every time it is called asg().
- In Julia, keyword arguments must be passed using keywords, unlike Python in which it is usually pos-
    sible to pass them positionally. Attempting to pass a keyword argument positionally alters the method
    signature leading to aMethodErroror calling of the wrong method.
- In Julia%is the remainder operator, whereas in Python it is the modulus.
- In Julia, the commonly usedInttype corresponds to the machine integer type (Int32orInt64), unlike
    in Python, whereintis an arbitrary length integer. This means in Julia theInttype will overflow, such
    that2^64 == 0. If you need larger values use another appropriate type, such asInt128,BigIntor a
    floating point type likeFloat64.
- The imaginary unitsqrt(-1)is represented in Julia asim, notjas in Python.
- In Julia, the exponentiation operator is^, not**as in Python.
- JuliausesnothingoftypeNothingtorepresentanullvalue,whereasPythonusesNoneoftypeNoneType.
- In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the stan-
    dard operators are element-wise operations. When bothAandBare matrices,A * Bin Julia performs
    matrix multiplication, not element-wise multiplication as in Python.A * Bin Julia is equivalent withA @
    Bin Python, whereasA * Bin Python is equivalent withA .* Bin Julia.


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 425

- Theadjointoperator'inJuliareturnsanadjointofavector(alazyrepresentationofrowvector), whereas
    the transpose operator.Tover a vector in Python returns the original vector (non-op).
- In Julia, a function may contain multiple concrete implementations (called methods), which are selected
    via multiple dispatch based on the types of all arguments to the call, as compared to functions in Python,
    which have a single implementation and no polymorphism (as opposed to Python method calls which
    use a different syntax and allows dispatch on the receiver of the method).
- There are no classes in Julia. Instead there are structures (mutable or immutable), containing data but
    no methods.
- CallingamethodofaclassinstanceinPython(x = MyClass(*args); x.f(y))correspondstoafunction
    call in Julia, e.g.x = MyType(args...); f(x, y). In general, multiple dispatch is more flexible and
    powerful than the Python class system.
- Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one
    or more (abstract or concrete) superclasses.
- The logical Julia program structure (Packages and Modules) is independent of the file structure (include
    for additional files), whereas the Python code structure is defined by directories (Packages) and files
    (Modules).
- The ternary operatorx > 0? 1 : -1in Julia corresponds to a conditional expression in Python1 if x
    > 0 else -1.
- In Julia the@symbol refers to a macro, whereas in Python it refers to a decorator.
- Exception handling in Julia is done usingtry—catch—finally, instead oftry—except—finally.
    In contrast to Python, it is not recommended to use exception handling as part of the normal workflow
    in Julia due to performance reasons.
- In Julia loops are fast, there is no need to write"vectorized" code for performance reasons.
- Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write
    close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (seePerformance Tips).
- In Python, the majority of values can be used in logical contexts (e.g. if "a":means the following
    block is executed, andif "":means it is not). In Julia, you need explicit conversion toBool(e.g.if
    "a"throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write
    if !isempty("").
- InJulia,anewlocalscopeisintroducedbymostcodeblocks,includingloopsandtry—catch—finally.
    Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia,
    whereasifblocks do not introduce a new local scope in both languages.

### 38.4 Noteworthy differences from C/C++

- Julia arrays are indexed with square brackets, and can have more than one dimensionA[i,j]. This
    syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. Seethe manual
    entry about array construction.
- In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.
- Julia arrays are not copied when assigned to another variable. AfterA = B, changing elements ofBwill
    modifyAas well. Updating operators like+=do not operate in-place, they are equivalent toA = A + B
    which rebinds the left-hand side to the result of the right-hand side expression.


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 426

- Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default.
    To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia
    relative to C/C++ (seerelevant section of Performance Tips).
- Julia values are not copied when assigned or passed to a function. If a function modifies an array, the
    changes will be visible in the caller.
- InJulia,whitespaceissignificant,unlikeC/C++,socaremustbetakenwhenadding/removingwhitespace
    from a Julia program.
- In Julia, literal numbers without a decimal point (such as 42 ) create signed integers, of typeInt, but
    literals too large to fit in the machine word size will automatically be promoted to a larger size type,
    such asInt64(ifIntisInt32),Int128, or the arbitrarily largeBigInttype. There are no numeric literal
    suffixes, such asL,LL,U,UL,ULLto indicate unsigned and/or signed vs. unsigned. Decimal literals
    are always signed, and hexadecimal literals (which start with0xlike C/C++), are unsigned, unless when
    they encode more than 128 bits, in which case they are of typeBigInt. Hexadecimal literals also, unlike
    C/C++/Java and unlike decimal literals in Julia, have a type based on the length of the literal, including
    leading 0s. For example,0x0and0x00have typeUInt8,0x000and0x0000have typeUInt16, then
    literals with 5 to 8 hex digits have typeUInt32, 9 to 16 hex digits typeUInt64, 17 to 32 hex digits
    typeUInt128, and more that 32 hex digits typeBigInt. This needs to be taken into account when
    defining hexadecimal masks, for example~0xf == 0xf0is very different from~0x000f == 0xfff0. 64
    bitFloat64and 32 bitFloat32bit literals are expressed as1.0and1.0f0respectively. Floating point
    literals are rounded (and not promoted to theBigFloattype) if they can not be exactly represented.
    Floating point literals are closer in behavior to C/C++. Octal (prefixed with0o) and binary (prefixed with
    0b) literals are also treated as unsigned (orBigIntfor more than 128 bits).
- In Julia, the division operator/returns a floating point number when both operands are of integer type.
    To perform integer division, usedivor÷.
- Indexing anArraywith floating point types is generally an error in Julia. The Julia equivalent of the C
    expressiona[i / 2]isa[i ÷ 2 + 1], whereiis of integer type.
- String literals can be delimited with either"or""","""delimited literals can contain"characters
    without quoting it like"\"". String literals can have values of other variables or expressions interpolated
    into them, indicated by$variablenameor$(expression), which evaluates the variable name or the
    expression in the context of the function.
- //indicates aRationalnumber, and not a single-line comment (which is#in Julia)
- #=indicates the start of a multiline comment, and=#ends it.
- Functions in Julia return values from their last expression(s) or thereturnkeyword. Multiple values can
    bereturnedfromfunctionsandassignedastuples,e.g.(a, b) = myfunction()ora, b = myfunction(),
    insteadofhavingtopasspointerstovaluesasonewouldhavetodoinC/C++(i.e.a = myfunction(&b).
- Julia does not require the use of semicolons to end statements. The results of expressions are not
    automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to
    end with semicolons.printlnor@printfcan be used to print specific output. In the REPL,;can be
    used to suppress output.;also has a different meaning within[ ], something to watch out for.;can
    be used to separate expressions on a single line, but are not strictly necessary in many cases, and are
    more an aid to readability.
- In Julia, the operator⊻ (xor) performs the bitwise XOR operation, i.e. ^in C/C++. Also, the bitwise
    operators do not have the same precedence as C/C++, so parenthesis may be required.
- Julia's^is exponentiation (pow), not bitwise XOR as in C/C++ (use⊻, orxor, in Julia)


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 427

- Julia has two right-shift operators,>>and>>>.>>performs an arithmetic shift,>>>always performs a
    logical shift, unlike C/C++, where the meaning of>>depends on the type of the value being shifted.
- Julia's->creates an anonymous function, it does not access a member via a pointer.
- Julia does not require parentheses when writingifstatements orfor/whileloops: usefor i in [1,
    2, 3]instead offor (int i=1; i <= 3; i++)andif i == 1instead ofif (i == 1).
- Julia does not treat the numbers 0 and 1 as Booleans. You cannot writeif (1)in Julia, becauseif
    statements accept only booleans. Instead, you can writeif true,if Bool(1), orif 1==1.
- Julia usesendto denote the end of conditional blocks, likeif, loop blocks, likewhile/for, and func-
    tions. In lieu of the one-lineif ( cond ) statement, Julia allows statements of the formif cond;
    statement; end,cond && statementand!cond || statement. Assignment statements in the latter
    two syntaxes must be explicitly wrapped in parentheses, e.g.cond && (x = value), because of the
    operator precedence.
- Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression,
    it is considered done; otherwise the input continues. One way to force an expression to continue is to
    wrap it in parentheses.
- Julia macros operate on parsed expressions, rather than the text of the program, which allows them
    to perform sophisticated transformations of Julia code. Macro names start with the@character, and
    havebothafunction-likesyntax,@mymacro(arg1, arg2, arg3), andastatement-likesyntax,@mymacro
    arg1 arg2 arg3. Theformsareinterchangeable; thefunction-likeformisparticularlyusefulifthemacro
    appears within another expression, and is often clearest. The statement-like form is often used to an-
    notate blocks, as in the distributedforconstruct:@distributed for i in 1:n; #= body =#; end.
    Where the end of the macro construct may be unclear, use the function-like form.
- Julia has an enumeration type, expressed using the macro@enum(name, value1, value2, ...) For
    example:@enum(Fruit, banana=1, apple, pear)
- By convention, functions that modify their arguments have a! at the end of the name, for example
    push!.
- In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to
    have dynamic dispatch. On the other hand, in Julia every method is"virtual" (although it's more general
    than that since methods are dispatched on every argument type, not onlythis, using the most-specific-
    declaration rule).

### 38.5 Noteworthy differences from Common Lisp

- Julia uses 1-based indexing for arrays by default, and it can also handle arbitraryindex offsets.
- Functions and variables share the same namespace (“Lisp-1”).
- There is aPairtype, but it is not meant to be used as aCOMMON-LISP:CONS. Various iterable collections
    can be used interchangeably in most parts of the language (eg splatting, tuples, etc).Tuples are the
    closest to Common Lisp lists for short collections of heterogeneous elements. UseNamedTuples in place
    of alists. For larger collections of homogeneous types,Arrays andDicts should be used.
- The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented
    with theRevise.jlpackage.
- For performance, Julia prefers that operations havetype stability. Where Common Lisp abstracts away
    from the underlying machine operations, Julia cleaves closer to them. For example:


#### CHAPTER 38. NOTEWORTHY DIFFERENCES FROM OTHER LANGUAGES 428

**-** Integer division using/always returns a floating-point result, even if the computation is exact.
    ∗//always returns a rational result
    ∗÷always returns a (truncated) integer result
**-** Bignums are supported, but conversion is not automatic; ordinary integersoverflow.
**-** Complex numbers are supported, but to get complex results,you need complex inputs.
**-** There are multiple Complex and Rational types, with different component types.
- Modules (namespaces) can be hierarchical.importandusinghave a dual role: they load the code and
make it available in the namespace.importfor only the module name is possible (roughly equivalent
toASDF:LOAD-OP). Slot names don't need to be exported separately. Global variables can't be assigned
to from outside the module (except witheval(mod, :(var = val))as an escape hatch).
- Macros start with@, and are not as seamlessly integrated into the language as Common Lisp; conse-
quently, macro usage is not as widespread as in the latter. A form of hygiene formacrosis supported by
the language. Because of the different surface syntax, there is no equivalent toCOMMON-LISP:&BODY.
- All functions are generic and use multiple dispatch. Argument lists don't have to follow the same tem-
plate, whichleadstoapowerfulidiom(seedo). Optionalandkeywordargumentsarehandleddifferently.
Method ambiguities are not resolved like in the Common Lisp Object System, necessitating the definition
of a more specific method for the intersection.
- Symbols do not belong to any package, and do not contain any values per se. M.varevaluates the
symbolvarin the moduleM.
- A functional programming style is fully supported by the language, including closures, but isn't always
the idiomatic solution for Julia. Someworkaroundsmay be necessary for performance when modifying
captured variables.


**Chapter 39**

**Unicode Input**

The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations
in the Julia REPL (and in various other editing environments). You can also get information on how to type a
symbol by entering it in the REPL help, i.e. by typing?and then entering the symbol in the REPL (e.g., by
copy-paste from somewhere you saw the symbol).

```

Warning  
This table may appear to contain missing characters in the second column, or even show charac-  
tersthatareinconsistentwiththecharactersastheyarerenderedintheJuliaREPL.Inthesecases,  
users are strongly advised to check their choice of fonts in their browser and REPL environment,  
as there are known issues with glyphs in many fonts.

Code  
point(s)

Char-  
ac-  
ter(s)

Tab completion  
sequence(s)

Unicode name(s)

U+000A1 ¡ \exclamdown Inverted Exclamation Mark  
U+000A3 £ \sterling Pound Sign  
U+000A5 ¥ \yen Yen Sign  
U+000A6 ¦ \brokenbar Broken Bar / Broken Vertical Bar  
U+000A7 § \S Section Sign  
U+000A9 © \copyright, :copyright: Copyright Sign  
U+000AA ª \ordfeminine Feminine Ordinal Indicator  
U+000AC ¬ \neg Not Sign  
U+000AE ® \circledR, :registered: Registered Sign / Registered Trade Mark Sign  
U+000AF ̄ \highminus Macron / Spacing Macron  
U+000B0 ° \degree Degree Sign  
U+000B1 ± \pm Plus-Minus Sign / Plus-Or-Minus Sign  
U+000B2 ² ^2 Superscript Two / Superscript Digit Two  
U+000B3 ³ ^3 Superscript Three / Superscript Digit Three  
U+000B6 ¶ \P Pilcrow Sign / Paragraph Sign  
U+000B7 · \cdotp Middle Dot  
U+000B9 ¹ ^1 Superscript One / Superscript Digit One  
U+000BA º \ordmasculine Masculine Ordinal Indicator  
U+000BC ¼ \1/4 Vulgar Fraction One Quarter / Fraction One Quarter  
U+000BD ½ \1/2 Vulgar Fraction One Half / Fraction One Half  
U+000BE ¾ \3/4 Vulgar Fraction Three Quarters / Fraction Three  
Quarters  
U+000BF ¿ \questiondown Inverted Question Mark  
U+000C5 Å \AA Latin Capital Letter A With Ring Above / Latin Capital  
Letter A Ring  
U+000C6 Æ \AE Latin Capital Letter Ae / Latin Capital Letter A E  
U+000D0 Ð \DH Latin Capital Letter Eth  
U+000D7 × \times Multiplication Sign  
U+000D8 Ø \O Latin Capital Letter O With Stroke / Latin Capital Letter  
O Slash  
U+000DE Þ \TH Latin Capital Letter Thorn  
U+000DF ß \ss Latin Small Letter Sharp S  
U+000E5 å \aa Latin Small Letter A With Ring Above / Latin Small  
Letter A Ring  
U+000E6 æ \ae Latin Small Letter Ae / Latin Small Letter A E  
U+000F0 ð \eth, \dh Latin Small Letter Eth  
U+000F7 ÷ \div Division Sign  
U+000F8 ø \o Latin Small Letter O With Stroke / Latin Small Letter O  
Slash  
U+000FE þ \th Latin Small Letter Thorn  
U+00110 Đ \DJ Latin Capital Letter D With Stroke / Latin Capital Letter  
D Bar  
U+00111 đ \dj Latin Small Letter D With Stroke / Latin Small Letter D  
Bar  
U+00127 ħ \hbar Latin Small Letter H With Stroke / Latin Small Letter H  
Bar  
U+00131 ı \imath Latin Small Letter Dotless I  
U+00141 Ł \L Latin Capital Letter L With Stroke / Latin Capital Letter  
L Slash  
U+00142 ł \l Latin Small Letter L With Stroke / Latin Small Letter L  
Slash  
U+0014A Ŋ \NG Latin Capital Letter Eng  
U+0014B ŋ \ng Latin Small Letter Eng  
U+00152 Œ \OE Latin Capital Ligature Oe / Latin Capital Letter O E  
U+00153 œ \oe Latin Small Ligature Oe / Latin Small Letter O E  
U+00195 ƕ \hvlig Latin Small Letter Hv / Latin Small Letter H V  
U+0019E ƞ \nrleg Latin Small Letter N With Long Right Leg  
U+001B5 Ƶ \Zbar Latin Capital Letter Z With Stroke / Latin Capital Letter  
Z Bar  
U+001C2 ǂ \doublepipe Latin Letter Alveolar Click / Latin Letter Pipe Double  
Bar  
U+00237 ȷ \jmath Latin Small Letter Dotless J  
U+00250 ɐ \trna Latin Small Letter Turned A  
U+00252 ɒ \trnsa Latin Small Letter Turned Alpha / Latin Small Letter  
Turned Script A  
U+00254 ɔ \openo Latin Small Letter Open O  
U+00256 ɖ \rtld Latin Small Letter D With Tail / Latin Small Letter D  
Retroflex Hook  
U+00259 ə \schwa Latin Small Letter Schwa  
U+00263 ɣ \pgamma Latin Small Letter Gamma  
U+00264 ɤ \pbgam Latin Small Letter Rams Horn / Latin Small Letter Baby  
Gamma  
U+00265 ɥ \trnh Latin Small Letter Turned H  
U+0026C ɬ \btdl Latin Small Letter L With Belt / Latin Small Letter L Belt  
U+0026D ɭ \rtll Latin Small Letter L With Retroflex Hook / Latin Small  
Letter L Retroflex Hook  
U+0026F ɯ \trnm Latin Small Letter Turned M  
U+00270 ɰ \trnmlr Latin Small Letter Turned M With Long Leg  
U+00271 ɱ \ltlmr Latin Small Letter M With Hook / Latin Small Letter M  
Hook  
U+00272 ɲ \ltln Latin Small Letter N With Left Hook / Latin Small Letter  
N Hook  
U+00273 ɳ \rtln Latin Small Letter N With Retroflex Hook / Latin Small  
Letter N Retroflex Hook  
U+00277 ɷ \clomeg Latin Small Letter Closed Omega  
U+00278 ɸ \ltphi Latin Small Letter Phi  
U+00279 ɹ \trnr Latin Small Letter Turned R  
U+0027A ɺ \trnrl Latin Small Letter Turned R With Long Leg  
U+0027B ɻ \rttrnr Latin Small Letter Turned R With Hook / Latin Small  
Letter Turned R Hook  
U+0027C ɼ \rl Latin Small Letter R With Long Leg  
U+0027D ɽ \rtlr Latin Small Letter R With Tail / Latin Small Letter R  
Hook  
U+0027E ɾ \fhr Latin Small Letter R With Fishhook / Latin Small Letter  
Fishhook R  
U+00282 ʂ \rtls Latin Small Letter S With Hook / Latin Small Letter S  
Hook  
U+00283 ʃ \esh Latin Small Letter Esh  
U+00287 ʇ \trnt Latin Small Letter Turned T  
U+00288 ʈ \rtlt Latin Small Letter T With Retroflex Hook / Latin Small  
Letter T Retroflex Hook  
U+0028A ʊ \pupsil Latin Small Letter Upsilon  
U+0028B ʋ \pscrv Latin Small Letter V With Hook / Latin Small Letter  
Script V  
U+0028C ʌ \invv Latin Small Letter Turned V  
U+0028D ʍ \invw Latin Small Letter Turned W  
U+0028E ʎ \trny Latin Small Letter Turned Y  
U+00290 ʐ \rtlz Latin Small Letter Z With Retroflex Hook / Latin Small  
Letter Z Retroflex Hook  
U+00292 ʒ \yogh Latin Small Letter Ezh / Latin Small Letter Yogh  
U+00294 ʔ \glst Latin Letter Glottal Stop  
U+00295 ʕ \reglst Latin Letter Pharyngeal Voiced Fricative / Latin Letter  
Reversed Glottal Stop  
U+00296 ʖ \inglst Latin Letter Inverted Glottal Stop  
U+0029E ʞ \turnk Latin Small Letter Turned K  
U+002A4 ʤ \dyogh Latin Small Letter Dezh Digraph / Latin Small Letter D  
Yogh  
U+002A7 ʧ \tesh Latin Small Letter Tesh Digraph / Latin Small Letter T  
Esh  
U+002B0 ʰ ^h Modifier Letter Small H  
U+002B2 ʲ ^j Modifier Letter Small J  
U+002B3 ʳ ^r Modifier Letter Small R  
U+002B7 ʷ ^w Modifier Letter Small W  
U+002B8 ʸ ^y Modifier Letter Small Y  
U+002BC ʼ \rasp Modifier Letter Apostrophe  
U+002C8 ˈ \verts Modifier Letter Vertical Line  
U+002CC ˌ \verti Modifier Letter Low Vertical Line  
U+002D0 ː \lmrk Modifier Letter Triangular Colon  
U+002D1 ˑ \hlmrk Modifier Letter Half Triangular Colon  
U+002D2 ˒ \sbrhr Modifier Letter Centred Right Half Ring / Modifier  
Letter Centered Right Half Ring  
U+002D3 ˓ \sblhr Modifier Letter Centred Left Half Ring / Modifier Letter  
Centered Left Half Ring  
U+002D4 ˔ \rais Modifier Letter Up Tack  
U+002D5 ˕ \low Modifier Letter Down Tack  
U+002D8 ̆ \u Breve / Spacing Breve  
U+002DC ̃ \tildelow Small Tilde / Spacing Tilde  
U+002E1 ˡ ^l Modifier Letter Small L  
U+002E2 ˢ ^s Modifier Letter Small S  
U+002E3 ˣ ^x Modifier Letter Small X  
U+00300 ̀ \grave Combining Grave Accent / Non-Spacing Grave  
U+00301 ́ \acute Combining Acute Accent / Non-Spacing Acute  
U+00302 ̂ \hat Combining Circumflex Accent / Non-Spacing  
Circumflex  
U+00303 ̃ \tilde Combining Tilde / Non-Spacing Tilde  
U+00304 ̄ \bar Combining Macron / Non-Spacing Macron  
U+00305 ̅ \overbar Combining Overline / Non-Spacing Overscore  
U+00306 ̆ \breve Combining Breve / Non-Spacing Breve  
U+00307 ̇ \dot Combining Dot Above / Non-Spacing Dot Above  
U+00308 ̈ \ddot Combining Diaeresis / Non-Spacing Diaeresis  
U+00309 ̉ \ovhook Combining Hook Above / Non-Spacing Hook Above  
U+0030A ̊ \ocirc Combining Ring Above / Non-Spacing Ring Above  
U+0030B ̋ \H Combining Double Acute Accent / Non-Spacing Double  
Acute  
U+0030C ̌ \check Combining Caron / Non-Spacing Hacek  
U+00310 ̐ \candra Combining Candrabindu / Non-Spacing Candrabindu  
U+00312 ̒ \oturnedcomma Combining Turned Comma Above / Non-Spacing  
Turned Comma Above  
U+00315 ̕ \ocommatopright Combining Comma Above Right / Non-Spacing Comma  
Above Right  
U+0031A ̚ \droang Combining Left Angle Above / Non-Spacing Left Angle  
Above  
U+00321 ̡ \palh Combining Palatalized Hook Below / Non-Spacing  
Palatalized Hook Below  
U+00322 ̢ \rh Combining Retroflex Hook Below / Non-Spacing  
Retroflex Hook Below  
U+00327 ̧ \c Combining Cedilla / Non-Spacing Cedilla  
U+00328 ̨ \k Combining Ogonek / Non-Spacing Ogonek  
U+0032A ̪ \sbbrg Combining Bridge Below / Non-Spacing Bridge Below  
U+00330 ̰ \wideutilde Combining Tilde Below / Non-Spacing Tilde Below  
U+00332 ̲ \underbar Combining Low Line / Non-Spacing Underscore  
U+00336 ̶ \strike, \sout Combining Long Stroke Overlay / Non-Spacing Long  
Bar Overlay  
U+00338 ̸ \not Combining Long Solidus Overlay / Non-Spacing Long  
Slash Overlay  
U+0034D ͍ \underleftrightarrow Combining Left Right Arrow Below  
U+00391 Α \Alpha Greek Capital Letter Alpha  
U+00392 Β \Beta Greek Capital Letter Beta  
U+00393 Γ \Gamma Greek Capital Letter Gamma  
U+00394 Δ \Delta Greek Capital Letter Delta  
U+00395 Ε \Epsilon Greek Capital Letter Epsilon  
U+00396 Ζ \Zeta Greek Capital Letter Zeta  
U+00397 Η \Eta Greek Capital Letter Eta  
U+00398 Θ \Theta Greek Capital Letter Theta  
U+00399 Ι \Iota Greek Capital Letter Iota  
U+0039A Κ \Kappa Greek Capital Letter Kappa  
U+0039B Λ \Lambda Greek Capital Letter Lamda / Greek Capital Letter  
Lambda  
U+0039C Μ \upMu Greek Capital Letter Mu  
U+0039D Ν \upNu Greek Capital Letter Nu  
U+0039E Ξ \Xi Greek Capital Letter Xi  
U+0039F Ο \upOmicron Greek Capital Letter Omicron  
U+003A0 Π \Pi Greek Capital Letter Pi  
U+003A1 Ρ \Rho Greek Capital Letter Rho  
U+003A3 Σ \Sigma Greek Capital Letter Sigma  
U+003A4 Τ \Tau Greek Capital Letter Tau  
U+003A5 Υ \Upsilon Greek Capital Letter Upsilon  
U+003A6 Φ \Phi Greek Capital Letter Phi  
U+003A7 Χ \Chi Greek Capital Letter Chi  
U+003A8 Ψ \Psi Greek Capital Letter Psi  
U+003A9 Ω \Omega Greek Capital Letter Omega  
U+003B1 α \alpha Greek Small Letter Alpha  
U+003B2 β \beta Greek Small Letter Beta  
U+003B3 γ \gamma Greek Small Letter Gamma  
U+003B4 δ \delta Greek Small Letter Delta  
U+003B5 ε \upepsilon, \varepsilon Greek Small Letter Epsilon  
U+003B6 ζ \zeta Greek Small Letter Zeta  
U+003B7 η \eta Greek Small Letter Eta  
U+003B8 θ \theta Greek Small Letter Theta  
U+003B9 ι \iota Greek Small Letter Iota  
U+003BA κ \kappa Greek Small Letter Kappa  
U+003BB λ \lambda Greek Small Letter Lamda / Greek Small Letter Lambda  
U+003BC μ \mu Greek Small Letter Mu  
U+003BD ν \nu Greek Small Letter Nu  
U+003BE ξ \xi Greek Small Letter Xi  
U+003BF ο \upomicron Greek Small Letter Omicron  
U+003C0 π \pi Greek Small Letter Pi  
U+003C1 ρ \rho Greek Small Letter Rho  
U+003C2 ς \varsigma Greek Small Letter Final Sigma  
U+003C3 σ \sigma Greek Small Letter Sigma  
U+003C4 τ \tau Greek Small Letter Tau  
U+003C5 υ \upsilon Greek Small Letter Upsilon  
U+003C6 φ \varphi Greek Small Letter Phi  
U+003C7 χ \chi Greek Small Letter Chi  
U+003C8 ψ \psi Greek Small Letter Psi  
U+003C9 ω \omega Greek Small Letter Omega  
U+003D0 β \upvarbeta Greek Beta Symbol / Greek Small Letter Curled Beta  
U+003D1 θ \vartheta Greek Theta Symbol / Greek Small Letter Script Theta  
U+003D5 φ \phi Greek Phi Symbol / Greek Small Letter Script Phi  
U+003D6 π \varpi Greek Pi Symbol / Greek Small Letter Omega Pi  
U+003D8 Ϙ \upoldKoppa Greek Letter Archaic Koppa  
U+003D9 ϙ \upoldkoppa Greek Small Letter Archaic Koppa  
U+003DA Ϛ \Stigma Greek Letter Stigma / Greek Capital Letter Stigma  
U+003DB ϛ \upstigma Greek Small Letter Stigma  
U+003DC Ϝ \Digamma Greek Letter Digamma / Greek Capital Letter Digamma  
U+003DD ϝ \digamma Greek Small Letter Digamma  
U+003DE Ϟ \Koppa Greek Letter Koppa / Greek Capital Letter Koppa  
U+003DF ϟ \upkoppa Greek Small Letter Koppa  
U+003E0 Ϡ \Sampi Greek Letter Sampi / Greek Capital Letter Sampi  
U+003E1 ϡ \upsampi Greek Small Letter Sampi  
U+003F0 κ \varkappa Greek Kappa Symbol / Greek Small Letter Script Kappa  
U+003F1 ρ \varrho Greek Rho Symbol / Greek Small Letter Tailed Rho  
U+003F4 Θ \varTheta Greek Capital Theta Symbol  
U+003F5 ε \epsilon Greek Lunate Epsilon Symbol  
U+003F6 ϶ \backepsilon Greek Reversed Lunate Epsilon Symbol  
U+01D2C ᴬ ^A Modifier Letter Capital A  
U+01D2E ᴮ ^B Modifier Letter Capital B  
U+01D30 ᴰ ^D Modifier Letter Capital D  
U+01D31 ᴱ ^E Modifier Letter Capital E  
U+01D33 ᴳ ^G Modifier Letter Capital G  
U+01D34 ᴴ ^H Modifier Letter Capital H  
U+01D35 ᴵ ^I Modifier Letter Capital I  
U+01D36 ᴶ ^J Modifier Letter Capital J  
U+01D37 ᴷ ^K Modifier Letter Capital K  
U+01D38 ᴸ ^L Modifier Letter Capital L  
U+01D39 ᴹ ^M Modifier Letter Capital M  
U+01D3A ᴺ ^N Modifier Letter Capital N  
U+01D3C ᴼ ^O Modifier Letter Capital O  
U+01D3E ᴾ ^P Modifier Letter Capital P  
U+01D3F ᴿ ^R Modifier Letter Capital R  
U+01D40 ᵀ ^T Modifier Letter Capital T  
U+01D41 ᵁ ^U Modifier Letter Capital U  
U+01D42 ᵂ ^W Modifier Letter Capital W  
U+01D43 ᵃ ^a Modifier Letter Small A  
U+01D45 ᵅ ^alpha Modifier Letter Small Alpha  
U+01D47 ᵇ ^b Modifier Letter Small B  
U+01D48 ᵈ ^d Modifier Letter Small D  
U+01D49 ᵉ ^e Modifier Letter Small E  
U+01D4B ᵋ ^epsilon Modifier Letter Small Open E  
U+01D4D ᵍ ^g Modifier Letter Small G  
U+01D4F ᵏ ^k Modifier Letter Small K  
U+01D50 ᵐ ^m Modifier Letter Small M  
U+01D52 ᵒ ^o Modifier Letter Small O  
U+01D56 ᵖ ^p Modifier Letter Small P  
U+01D57 ᵗ ^t Modifier Letter Small T  
U+01D58 ᵘ ^u Modifier Letter Small U  
U+01D5B ᵛ ^v Modifier Letter Small V  
U+01D5D ᵝ ^beta Modifier Letter Small Beta  
U+01D5E ᵞ ^gamma Modifier Letter Small Greek Gamma  
U+01D5F ᵟ ^delta Modifier Letter Small Delta  
U+01D60 ᵠ ^phi Modifier Letter Small Greek Phi  
U+01D61 ᵡ ^chi Modifier Letter Small Chi  
U+01D62 ᵢ _i Latin Subscript Small Letter I  
U+01D63 ᵣ _r Latin Subscript Small Letter R  
U+01D64 ᵤ _u Latin Subscript Small Letter U  
U+01D65 ᵥ _v Latin Subscript Small Letter V  
U+01D66 ᵦ _beta Greek Subscript Small Letter Beta  
U+01D67 ᵧ _gamma Greek Subscript Small Letter Gamma  
U+01D68 ᵨ _rho Greek Subscript Small Letter Rho  
U+01D69 ᵩ _phi Greek Subscript Small Letter Phi  
U+01D6A ᵪ _chi Greek Subscript Small Letter Chi  
U+01D9C ᶜ ^c Modifier Letter Small C  
U+01DA0 ᶠ ^f Modifier Letter Small F  
U+01DA5 ᶥ ^iota Modifier Letter Small Iota  
U+01DB2 ᶲ ^ltphi Modifier Letter Small Phi  
U+01DBB ᶻ ^z Modifier Letter Small Z  
U+01DBF ᶿ ^theta Modifier Letter Small Theta  
U+02002 \enspace En Space  
U+02003 \quad Em Space  
U+02005 \thickspace Four-Per-Em Space  
U+02009 \thinspace Thin Space  
U+0200A \hspace Hair Space  
U+02013 – \endash En Dash  
U+02014 — \emdash Em Dash  
U+02016 ‖ \Vert Double Vertical Line / Double Vertical Bar  
U+02018 ‘ \lq Left Single Quotation Mark / Single Turned Comma  
Quotation Mark  
U+02019 ’ \rq Right Single Quotation Mark / Single Comma Quotation  
Mark  
U+0201B ‛ \reapos Single High-Reversed-9 Quotation Mark / Single  
Reversed Comma Quotation Mark  
U+0201C “ \ldq Left Double Quotation Mark / Double Turned Comma  
Quotation Mark  
U+0201D ” \rdq Right Double Quotation Mark / Double Comma  
Quotation Mark  
U+02020 † \dagger Dagger  
U+02021 ‡ \ddagger Double Dagger  
U+02022 • \bullet Bullet  
U+02026 ... \dots, \ldots Horizontal Ellipsis  
U+02030 ‰ \perthousand Per Mille Sign  
U+02031 ‱ \pertenthousand Per Ten Thousand Sign  
U+02032 ′ \prime Prime  
U+02033 ′′ \pprime Double Prime  
U+02034 ′′′ \ppprime Triple Prime  
U+02035 ‵ \backprime Reversed Prime  
U+02036 ‵‵ \backpprime Reversed Double Prime  
U+02037 ‵‵‵ \backppprime Reversed Triple Prime  
U+02039 ‹ \guilsinglleft Single Left-Pointing Angle Quotation Mark / Left  
Pointing Single Guillemet  
U+0203A › \guilsinglright Single Right-Pointing Angle Quotation Mark / Right  
Pointing Single Guillemet  
U+0203C !! :bangbang: Double Exclamation Mark  
U+02040 ⁀ \tieconcat Character Tie  
U+02049 !? :interrobang: Exclamation Question Mark  
U+02057 ′′′′ \pppprime Quadruple Prime  
U+0205D ⁝ \tricolon Tricolon  
U+02060 ⁠ \nolinebreak Word Joiner  
U+02070 ⁰ ^0 Superscript Zero / Superscript Digit Zero  
U+02071 ⁱ ^i Superscript Latin Small Letter I  
U+02074 ⁴ ^4 Superscript Four / Superscript Digit Four  
U+02075 ⁵ ^5 Superscript Five / Superscript Digit Five  
U+02076 ⁶ ^6 Superscript Six / Superscript Digit Six  
U+02077 ⁷ ^7 Superscript Seven / Superscript Digit Seven  
U+02078 ⁸ ^8 Superscript Eight / Superscript Digit Eight  
U+02079 ⁹ ^9 Superscript Nine / Superscript Digit Nine  
U+0207A ⁺ ^+ Superscript Plus Sign  
U+0207B ⁻ ^- Superscript Minus / Superscript Hyphen-Minus  
U+0207C ⁼ ^= Superscript Equals Sign  
U+0207D ⁽ ^( Superscript Left Parenthesis / Superscript Opening  
Parenthesis  
U+0207E ⁾ ^) Superscript Right Parenthesis / Superscript Closing  
Parenthesis  
U+0207F ⁿ ^n Superscript Latin Small Letter N  
U+02080 ₀ _0 Subscript Zero / Subscript Digit Zero  
U+02081 ₁ _1 Subscript One / Subscript Digit One  
U+02082 ₂ _2 Subscript Two / Subscript Digit Two  
U+02083 ₃ _3 Subscript Three / Subscript Digit Three  
U+02084 ₄ _4 Subscript Four / Subscript Digit Four  
U+02085 ₅ _5 Subscript Five / Subscript Digit Five  
U+02086 ₆ _6 Subscript Six / Subscript Digit Six  
U+02087 ₇ _7 Subscript Seven / Subscript Digit Seven  
U+02088 ₈ _8 Subscript Eight / Subscript Digit Eight  
U+02089 ₉ _9 Subscript Nine / Subscript Digit Nine  
U+0208A ₊ _+ Subscript Plus Sign  
U+0208B ₋ _- Subscript Minus / Subscript Hyphen-Minus  
U+0208C ₌ _= Subscript Equals Sign  
U+0208D ₍ _( Subscript Left Parenthesis / Subscript Opening  
Parenthesis  
U+0208E ₎ _) Subscript Right Parenthesis / Subscript Closing  
Parenthesis  
U+02090 ₐ _a Latin Subscript Small Letter A  
U+02091 ₑ _e Latin Subscript Small Letter E  
U+02092 ₒ _o Latin Subscript Small Letter O  
U+02093 ₓ _x Latin Subscript Small Letter X  
U+02094 ₔ _schwa Latin Subscript Small Letter Schwa  
U+02095 ₕ _h Latin Subscript Small Letter H  
U+02096 ₖ _k Latin Subscript Small Letter K  
U+02097 ₗ _l Latin Subscript Small Letter L  
U+02098 ₘ _m Latin Subscript Small Letter M  
U+02099 ₙ _n Latin Subscript Small Letter N  
U+0209A ₚ _p Latin Subscript Small Letter P  
U+0209B ₛ _s Latin Subscript Small Letter S  
U+0209C ₜ _t Latin Subscript Small Letter T  
U+020A7 ₧ \pes Peseta Sign  
U+020AC € \euro Euro Sign  
U+020D0 ⃐ \leftharpoonaccent Combining Left Harpoon Above / Non-Spacing Left  
Harpoon Above  
U+020D1 ⃑ \rightharpoonaccent Combining Right Harpoon Above / Non-Spacing Right  
Harpoon Above  
U+020D2 \vertoverlay Combining Long Vertical Line Overlay / Non-Spacing  
Long Vertical Bar Overlay  
U+020D6 ⃖ \overleftarrow Combining Left Arrow Above / Non-Spacing Left Arrow  
Above  
U+020D7 ⃗ \vec Combining Right Arrow Above / Non-Spacing Right  
Arrow Above  
U+020DB ⃛ \dddot Combining Three Dots Above / Non-Spacing Three  
Dots Above  
U+020DC ⃜ \ddddot Combining Four Dots Above / Non-Spacing Four Dots  
Above  
U+020DD \enclosecircle Combining Enclosing Circle / Enclosing Circle  
U+020DE \enclosesquare Combining Enclosing Square / Enclosing Square  
U+020DF \enclosediamond Combining Enclosing Diamond / Enclosing Diamond  
U+020E1 ⃡ \overleftrightarrow Combining Left Right Arrow Above / Non-Spacing Left  
Right Arrow Above  
U+020E4 \enclosetriangle Combining Enclosing Upward Pointing Triangle  
U+020E7 \annuity Combining Annuity Symbol  
U+020E8 \threeunderdot Combining Triple Underdot  
U+020E9 \widebridgeabove Combining Wide Bridge Above  
U+020EC \underrightharpoon-  
down

Combining Rightwards Harpoon With Barb Downwards

U+020ED \underleftharpoondown Combining Leftwards Harpoon With Barb Downwards  
U+020EE \underleftarrow Combining Left Arrow Below  
U+020EF \underrightarrow Combining Right Arrow Below  
U+020F0 \asteraccent Combining Asterisk Above  
U+02102 ℂ \bbC Double-Struck Capital C / Double-Struck C  
U+02107 Ɛ \eulermascheroni Euler Constant / Eulers  
U+0210A \scrg Script Small G  
U+0210B ℋ \scrH Script Capital H / Script H  
U+0210C ℌ \frakH Black-Letter Capital H / Black-Letter H  
U+0210D ℍ \bbH Double-Struck Capital H / Double-Struck H  
U+0210E ℎ \ith, \planck Planck Constant  
U+0210F ℏ \hslash Planck Constant Over Two Pi / Planck Constant Over 2  
Pi  
U+02110 ℐ \scrI Script Capital I / Script I  
U+02111 ℑ \Im, \frakI Black-Letter Capital I / Black-Letter I  
U+02112 ℒ \scrL Script Capital L / Script L  
U+02113 ℓ \ell Script Small L  
U+02115 ℕ \bbN Double-Struck Capital N / Double-Struck N  
U+02116 No \numero Numero Sign / Numero  
U+02118 ℘ \wp Script Capital P / Script P  
U+02119 ℙ \bbP Double-Struck Capital P / Double-Struck P  
U+0211A ℚ \bbQ Double-Struck Capital Q / Double-Struck Q  
U+0211B ℛ \scrR Script Capital R / Script R  
U+0211C ℜ \Re, \frakR Black-Letter Capital R / Black-Letter R  
U+0211D ℝ \bbR Double-Struck Capital R / Double-Struck R  
U+0211E ℞ \xrat Prescription Take  
U+02122 ™ \trademark, :tm: Trade Mark Sign / Trademark  
U+02124 ℤ \bbZ Double-Struck Capital Z / Double-Struck Z  
U+02126 Ω \ohm Ohm Sign / Ohm  
U+02127 ℧ \mho Inverted Ohm Sign / Mho  
U+02128 ℨ \frakZ Black-Letter Capital Z / Black-Letter Z  
U+02129 ℩ \turnediota Turned Greek Small Letter Iota  
U+0212B Å \Angstrom Angstrom Sign / Angstrom Unit  
U+0212C ℬ \scrB Script Capital B / Script B  
U+0212D ℭ \frakC Black-Letter Capital C / Black-Letter C  
U+0212F ℯ \scre, \euler Script Small E  
U+02130 ℰ \scrE Script Capital E / Script E  
U+02131 ℱ \scrF Script Capital F / Script F  
U+02132 Ⅎ \Finv Turned Capital F / Turned F  
U+02133 ℳ \scrM Script Capital M / Script M  
U+02134 ℴ \scro Script Small O  
U+02135 א \aleph Alef Symbol / First Transfinite Cardinal  
U+02136 ב \beth Bet Symbol / Second Transfinite Cardinal  
U+02137 ג \gimel Gimel Symbol / Third Transfinite Cardinal  
U+02138 ד \daleth Dalet Symbol / Fourth Transfinite Cardinal  
U+02139 ℹ :information_source: Information Source  
U+0213C ℼ \bbpi Double-Struck Small Pi  
U+0213D ℽ \bbgamma Double-Struck Small Gamma  
U+0213E ℾ \bbGamma Double-Struck Capital Gamma  
U+0213F ℿ \bbPi Double-Struck Capital Pi  
U+02140 ⅀ \bbsum Double-Struck N-Ary Summation  
U+02141 ⅁ \Game Turned Sans-Serif Capital G  
U+02142 ⅂ \sansLturned Turned Sans-Serif Capital L  
U+02143 ⅃ \sansLmirrored Reversed Sans-Serif Capital L  
U+02144 ⅄ \Yup Turned Sans-Serif Capital Y  
U+02145 ⅅ \bbiD Double-Struck Italic Capital D  
U+02146 ⅆ \bbid Double-Struck Italic Small D  
U+02147 ⅇ \bbie Double-Struck Italic Small E  
U+02148 ⅈ \bbii Double-Struck Italic Small I  
U+02149 ⅉ \bbij Double-Struck Italic Small J  
U+0214A \PropertyLine Property Line  
U+0214B ⅋ \upand Turned Ampersand  
U+02150 ⅐ \1/7 Vulgar Fraction One Seventh  
U+02151 ⅑ \1/9 Vulgar Fraction One Ninth  
U+02152 ⅒ \1/10 Vulgar Fraction One Tenth  
U+02153 ⅓ \1/3 Vulgar Fraction One Third / Fraction One Third  
U+02154 ⅔ \2/3 Vulgar Fraction Two Thirds / Fraction Two Thirds  
U+02155 ⅕ \1/5 Vulgar Fraction One Fifth / Fraction One Fifth  
U+02156 ⅖ \2/5 Vulgar Fraction Two Fifths / Fraction Two Fifths  
U+02157 ⅗ \3/5 Vulgar Fraction Three Fifths / Fraction Three Fifths  
U+02158 ⅘ \4/5 Vulgar Fraction Four Fifths / Fraction Four Fifths  
U+02159 ⅙ \1/6 Vulgar Fraction One Sixth / Fraction One Sixth  
U+0215A ⅚ \5/6 Vulgar Fraction Five Sixths / Fraction Five Sixths  
U+0215B ⅛ \1/8 Vulgar Fraction One Eighth / Fraction One Eighth  
U+0215C ⅜ \3/8 Vulgar Fraction Three Eighths / Fraction Three Eighths  
U+0215D ⅝ \5/8 Vulgar Fraction Five Eighths / Fraction Five Eighths  
U+0215E ⅞ \7/8 Vulgar Fraction Seven Eighths / Fraction Seven Eighths  
U+0215F ⅟ \1/ Fraction Numerator One  
U+02189 ↉ \0/3 Vulgar Fraction Zero Thirds  
U+02190 ← \leftarrow Leftwards Arrow / Left Arrow  
U+02191 ↑ \uparrow Upwards Arrow / Up Arrow  
U+02192 → \to, \rightarrow Rightwards Arrow / Right Arrow  
U+02193 ↓ \downarrow Downwards Arrow / Down Arrow  
U+02194 ↔ \leftrightarrow,  
:left_right_arrow:

Left Right Arrow

U+02195 ↕ \updownarrow,  
:arrow_up_down:

Up Down Arrow

U+02196 ↖ \nwarrow,  
:arrow_upper_left:

North West Arrow / Upper Left Arrow

U+02197 ↗ \nearrow,  
:arrow_upper_right:

North East Arrow / Upper Right Arrow

U+02198 ↘ \searrow,  
:arrow_lower_right:

South East Arrow / Lower Right Arrow

U+02199 ↙ \swarrow,  
:arrow_lower_left:

South West Arrow / Lower Left Arrow

U+0219A ↚ \nleftarrow Leftwards Arrow With Stroke / Left Arrow With Stroke  
U+0219B ↛ \nrightarrow Rightwards Arrow With Stroke / Right Arrow With  
Stroke  
U+0219C ↜ \leftwavearrow Leftwards Wave Arrow / Left Wave Arrow  
U+0219D ↝ \rightwavearrow Rightwards Wave Arrow / Right Wave Arrow  
U+0219E ↞ \twoheadleftarrow Leftwards Two Headed Arrow / Left Two Headed Arrow  
U+0219F ↟ \twoheaduparrow Upwards Two Headed Arrow / Up Two Headed Arrow  
U+021A0 ↠ \twoheadrightarrow Rightwards Two Headed Arrow / Right Two Headed  
Arrow  
U+021A1 ↡ \twoheaddownarrow Downwards Two Headed Arrow / Down Two Headed  
Arrow  
U+021A2 ↢ \leftarrowtail Leftwards Arrow With Tail / Left Arrow With Tail  
U+021A3 ↣ \rightarrowtail Rightwards Arrow With Tail / Right Arrow With Tail  
U+021A4 ↤ \mapsfrom Leftwards Arrow From Bar / Left Arrow From Bar  
U+021A5 ↥ \mapsup Upwards Arrow From Bar / Up Arrow From Bar  
U+021A6 ↦ \mapsto Rightwards Arrow From Bar / Right Arrow From Bar  
U+021A7 ↧ \mapsdown Downwards Arrow From Bar / Down Arrow From Bar  
U+021A8 ↨ \updownarrowbar Up Down Arrow With Base  
U+021A9 ↩ \hookleftarrow, :left-  
wards_arrow_with_hook:

Leftwards Arrow With Hook / Left Arrow With Hook

U+021AA ↪ \hookrightarrow,  
:arrow_right_hook:

Rightwards Arrow With Hook / Right Arrow With Hook

U+021AB ↫ \looparrowleft Leftwards Arrow With Loop / Left Arrow With Loop  
U+021AC ↬ \looparrowright Rightwards Arrow With Loop / Right Arrow With Loop  
U+021AD ↭ \leftrightsquigarrow Left Right Wave Arrow  
U+021AE ↮ \nleftrightarrow Left Right Arrow With Stroke  
U+021AF ↯ \downzigzagarrow Downwards Zigzag Arrow / Down Zigzag Arrow  
U+021B0 ↰ \Lsh Upwards Arrow With Tip Leftwards / Up Arrow With Tip  
Left  
U+021B1 ↱ \Rsh Upwards Arrow With Tip Rightwards / Up Arrow With  
Tip Right  
U+021B2 ↲ \Ldsh Downwards Arrow With Tip Leftwards / Down Arrow  
With Tip Left  
U+021B3 ↳ \Rdsh Downwards Arrow With Tip Rightwards / Down Arrow  
With Tip Right  
U+021B4 ↴ \linefeed Rightwards Arrow With Corner Downwards / Right  
Arrow With Corner Down  
U+021B5 ↵ \carriagereturn Downwards Arrow With Corner Leftwards / Down Arrow  
With Corner Left  
U+021B6 ↶ \curvearrowleft Anticlockwise Top Semicircle Arrow  
U+021B7 ↷ \curvearrowright Clockwise Top Semicircle Arrow  
U+021B8 ↸ \barovernorthwestarrow North West Arrow To Long Bar / Upper Left Arrow To  
Long Bar  
U+021B9 ↹ \barleftarrowrightarrow-  
bar

Leftwards Arrow To Bar Over Rightwards Arrow To Bar /  
Left Arrow To Bar Over Right Arrow To Bar  
U+021BA ↺ \circlearrowleft Anticlockwise Open Circle Arrow  
U+021BB ↻ \circlearrowright Clockwise Open Circle Arrow  
U+021BC ↼ \leftharpoonup Leftwards Harpoon With Barb Upwards / Left Harpoon  
With Barb Up  
U+021BD ↽ \leftharpoondown Leftwards Harpoon With Barb Downwards / Left  
Harpoon With Barb Down  
U+021BE ↾ \upharpoonright Upwards Harpoon With Barb Rightwards / Up Harpoon  
With Barb Right  
U+021BF ↿ \upharpoonleft Upwards Harpoon With Barb Leftwards / Up Harpoon  
With Barb Left  
U+021C0 ⇀ \rightharpoonup Rightwards Harpoon With Barb Upwards / Right  
Harpoon With Barb Up  
U+021C1 ⇁ \rightharpoondown Rightwards Harpoon With Barb Downwards / Right  
Harpoon With Barb Down  
U+021C2 ⇂ \downharpoonright Downwards Harpoon With Barb Rightwards / Down  
Harpoon With Barb Right  
U+021C3 ⇃ \downharpoonleft Downwards Harpoon With Barb Leftwards / Down  
Harpoon With Barb Left  
U+021C4 ⇄ \rightleftarrows Rightwards Arrow Over Leftwards Arrow / Right Arrow  
Over Left Arrow  
U+021C5 ⇅ \dblarrowupdown Upwards Arrow Leftwards Of Downwards Arrow / Up  
Arrow Left Of Down Arrow  
U+021C6 ⇆ \leftrightarrows Leftwards Arrow Over Rightwards Arrow / Left Arrow  
Over Right Arrow  
U+021C7 ⇇ \leftleftarrows Leftwards Paired Arrows / Left Paired Arrows  
U+021C8 ⇈ \upuparrows Upwards Paired Arrows / Up Paired Arrows  
U+021C9 ⇉ \rightrightarrows Rightwards Paired Arrows / Right Paired Arrows  
U+021CA ⇊ \downdownarrows Downwards Paired Arrows / Down Paired Arrows  
U+021CB ⇋ \leftrightharpoons Leftwards Harpoon Over Rightwards Harpoon / Left  
Harpoon Over Right Harpoon  
U+021CC ⇌ \rightleftharpoons Rightwards Harpoon Over Leftwards Harpoon / Right  
Harpoon Over Left Harpoon  
U+021CD ⇍ \nLeftarrow Leftwards Double Arrow With Stroke / Left Double  
Arrow With Stroke  
U+021CE ⇎ \nLeftrightarrow Left Right Double Arrow With Stroke  
U+021CF ⇏ \nRightarrow Rightwards Double Arrow With Stroke / Right Double  
Arrow With Stroke  
U+021D0 ⇐ \Leftarrow Leftwards Double Arrow / Left Double Arrow  
U+021D1 ⇑ \Uparrow Upwards Double Arrow / Up Double Arrow  
U+021D2 ⇒ \Rightarrow Rightwards Double Arrow / Right Double Arrow  
U+021D3 ⇓ \Downarrow Downwards Double Arrow / Down Double Arrow  
U+021D4 ⇔ \Leftrightarrow Left Right Double Arrow  
U+021D5 ⇕ \Updownarrow Up Down Double Arrow  
U+021D6 ⇖ \Nwarrow North West Double Arrow / Upper Left Double Arrow  
U+021D7 ⇗ \Nearrow North East Double Arrow / Upper Right Double Arrow  
U+021D8 ⇘ \Searrow South East Double Arrow / Lower Right Double Arrow  
U+021D9 ⇙ \Swarrow South West Double Arrow / Lower Left Double Arrow  
U+021DA ⇚ \Lleftarrow Leftwards Triple Arrow / Left Triple Arrow  
U+021DB ⇛ \Rrightarrow Rightwards Triple Arrow / Right Triple Arrow  
U+021DC ⇜ \leftsquigarrow Leftwards Squiggle Arrow / Left Squiggle Arrow  
U+021DD ⇝ \rightsquigarrow Rightwards Squiggle Arrow / Right Squiggle Arrow  
U+021DE ⇞ \nHuparrow Upwards Arrow With Double Stroke / Up Arrow With  
Double Stroke  
U+021DF ⇟ \nHdownarrow Downwards Arrow With Double Stroke / Down Arrow  
With Double Stroke  
U+021E0 ⇠ \leftdasharrow Leftwards Dashed Arrow / Left Dashed Arrow  
U+021E1 ⇡ \updasharrow Upwards Dashed Arrow / Up Dashed Arrow  
U+021E2 ⇢ \rightdasharrow Rightwards Dashed Arrow / Right Dashed Arrow  
U+021E3 ⇣ \downdasharrow Downwards Dashed Arrow / Down Dashed Arrow  
U+021E4 ⇤ \barleftarrow Leftwards Arrow To Bar / Left Arrow To Bar  
U+021E5 ⇥ \rightarrowbar Rightwards Arrow To Bar / Right Arrow To Bar  
U+021E6 ⇦ \leftwhitearrow Leftwards White Arrow / White Left Arrow  
U+021E7 ⇧ \upwhitearrow Upwards White Arrow / White Up Arrow  
U+021E8 ⇨ \rightwhitearrow Rightwards White Arrow / White Right Arrow  
U+021E9 ⇩ \downwhitearrow Downwards White Arrow / White Down Arrow  
U+021EA ⇪ \whitearrowupfrombar Upwards White Arrow From Bar / White Up Arrow From  
Bar  
U+021F4 ⇴ \circleonrightarrow Right Arrow With Small Circle  
U+021F5 ⇵ \DownArrowUpArrow Downwards Arrow Leftwards Of Upwards Arrow  
U+021F6 ⇶ \rightthreearrows Three Rightwards Arrows  
U+021F7 ⇷ \nvleftarrow Leftwards Arrow With Vertical Stroke  
U+021F8 ⇸ \nvrightarrow Rightwards Arrow With Vertical Stroke  
U+021F9 ⇹ \nvleftrightarrow Left Right Arrow With Vertical Stroke  
U+021FA ⇺ \nVleftarrow Leftwards Arrow With Double Vertical Stroke  
U+021FB ⇻ \nVrightarrow Rightwards Arrow With Double Vertical Stroke  
U+021FC ⇼ \nVleftrightarrow Left Right Arrow With Double Vertical Stroke  
U+021FD ⇽ \leftarrowtriangle Leftwards Open-Headed Arrow  
U+021FE ⇾ \rightarrowtriangle Rightwards Open-Headed Arrow  
U+021FF ⇿ \leftrightarrowtriangle Left Right Open-Headed Arrow  
U+02200 ∀ \forall For All  
U+02201 ∁ \complement Complement  
U+02202 ∂ \partial Partial Differential  
U+02203 ∃ \exists There Exists  
U+02204 ∄ \nexists There Does Not Exist  
U+02205 ∅ \varnothing, \emptyset Empty Set  
U+02206 ∆ \increment Increment  
U+02207 ∇ \del, \nabla Nabla  
U+02208 ∈ \in Element Of  
U+02209 ∉ \notin Not An Element Of  
U+0220A ∊ \smallin Small Element Of  
U+0220B ∋ \ni Contains As Member  
U+0220C ∌ \nni Does Not Contain As Member  
U+0220D ∍ \smallni Small Contains As Member  
U+0220E ∎ \QED End Of Proof  
U+0220F ∏ \prod N-Ary Product  
U+02210 ∐ \coprod N-Ary Coproduct  
U+02211 ∑ \sum N-Ary Summation  
U+02212 − \minus Minus Sign  
U+02213 ∓ \mp Minus-Or-Plus Sign  
U+02214 ∔ \dotplus Dot Plus  
U+02216 ∖ \setminus Set Minus  
U+02217 ∗ \ast Asterisk Operator  
U+02218 ∘ \circ Ring Operator  
U+02219 ∙ \vysmblkcircle Bullet Operator  
U+0221A √ \surd, \sqrt Square Root  
U+0221B ∛ \cbrt Cube Root  
U+0221C ∜ \fourthroot Fourth Root  
U+0221D ∝ \propto Proportional To  
U+0221E ∞ \infty Infinity  
U+0221F ∟ \rightangle Right Angle  
U+02220 ∠ \angle Angle  
U+02221 ∡ \measuredangle Measured Angle  
U+02222 ∢ \sphericalangle Spherical Angle  
U+02223 ∣ \mid Divides  
U+02224 ∤ \nmid Does Not Divide  
U+02225 ∥ \parallel Parallel To  
U+02226 ∦ \nparallel Not Parallel To  
U+02227 ∧ \wedge Logical And  
U+02228 ∨ \vee Logical Or  
U+02229 ∩ \cap Intersection  
U+0222A ∪ \cup Union  
U+0222B ∫ \int Integral  
U+0222C ∫∫ \iint Double Integral  
U+0222D ∫∫∫ \iiint Triple Integral  
U+0222E ∮ \oint Contour Integral  
U+0222F ∮∮ \oiint Surface Integral  
U+02230 ∮∮∮ \oiiint Volume Integral  
U+02231 ∱ \clwintegral Clockwise Integral  
U+02232 ∲ \varointclockwise Clockwise Contour Integral  
U+02233 ∳ \ointctrclockwise Anticlockwise Contour Integral  
U+02234 ∴ \therefore Therefore  
U+02235 ∵ \because Because  
U+02237 ∷ \Colon Proportion  
U+02238 ∸ \dotminus Dot Minus  
U+0223A ∺ \dotsminusdots Geometric Proportion  
U+0223B ∻ \kernelcontraction Homothetic  
U+0223C ∼ \sim Tilde Operator  
U+0223D ∽ \backsim Reversed Tilde  
U+0223E ∾ \lazysinv Inverted Lazy S  
U+0223F ∿ \sinewave Sine Wave  
U+02240 ≀ \wr Wreath Product  
U+02241 ≁ \nsim Not Tilde  
U+02242 ≂ \eqsim Minus Tilde  
U+02242

U+00338

≂̸ \neqsim Minus Tilde + Combining Long Solidus Overlay /  
Non-Spacing Long Slash Overlay

U+02243 ≃ \simeq Asymptotically Equal To  
U+02244 ≄ \nsime Not Asymptotically Equal To  
U+02245 ≅ \cong Approximately Equal To  
U+02246 ≆ \approxnotequal Approximately But Not Actually Equal To  
U+02247 ≇ \ncong Neither Approximately Nor Actually Equal To  
U+02248 ≈ \approx Almost Equal To  
U+02249 ≉ \napprox Not Almost Equal To  
U+0224A ≊ \approxeq Almost Equal Or Equal To  
U+0224B ≋ \tildetrpl Triple Tilde  
U+0224C ≌ \allequal All Equal To  
U+0224D ≍ \asymp Equivalent To  
U+0224E ≎ \Bumpeq Geometrically Equivalent To  
U+0224E

U+00338

≎̸ \nBumpeq Geometrically Equivalent To + Combining Long Solidus  
Overlay / Non-Spacing Long Slash Overlay

U+0224F ≏ \bumpeq Difference Between  
U+0224F

U+00338

≏̸ \nbumpeq Difference Between + Combining Long Solidus Overlay  
/ Non-Spacing Long Slash Overlay

U+02250 ≐ \doteq Approaches The Limit  
U+02251 ≑ \Doteq Geometrically Equal To  
U+02252 ≒ \fallingdotseq Approximately Equal To Or The Image Of  
U+02253 ≓ \risingdotseq Image Of Or Approximately Equal To  
U+02254 ≔ \coloneq Colon Equals / Colon Equal  
U+02255 ≕ \eqcolon Equals Colon / Equal Colon  
U+02256 ≖ \eqcirc Ring In Equal To  
U+02257 ≗ \circeq Ring Equal To  
U+02258 ≘ \arceq Corresponds To  
U+02259 ≙ \wedgeq Estimates  
U+0225A ≚ \veeeq Equiangular To  
U+0225B ≛ \starequal Star Equals  
U+0225C ≜ \triangleq Delta Equal To  
U+0225D ≝ \eqdef Equal To By Definition  
U+0225E ≞ \measeq Measured By  
U+0225F ≟ \questeq Questioned Equal To  
U+02260 ≠ \ne Not Equal To  
U+02261 ≡ \equiv Identical To  
U+02262 ≢ \nequiv Not Identical To  
U+02263 ≣ \Equiv Strictly Equivalent To  
U+02264 ≤ \le, \leq Less-Than Or Equal To / Less Than Or Equal To  
U+02265 ≥ \ge, \geq Greater-Than Or Equal To / Greater Than Or Equal To  
U+02266 ≦ \leqq Less-Than Over Equal To / Less Than Over Equal To  
U+02267 ≧ \geqq Greater-Than Over Equal To / Greater Than Over Equal  
To  
U+02268 ≨ \lneqq Less-Than But Not Equal To / Less Than But Not Equal  
To  
U+02268

U+0FE00

≨︀ \lvertneqq Less-Than But Not Equal To / Less Than But Not Equal  
To + Variation Selector-1

U+02269 ≩ \gneqq Greater-Than But Not Equal To / Greater Than But Not  
Equal To  
U+02269

U+0FE00

≩︀ \gvertneqq Greater-Than But Not Equal To / Greater Than But Not  
Equal To + Variation Selector-1

U+0226A ≪ \ll Much Less-Than / Much Less Than  
U+0226A

U+00338

≪̸ \NotLessLess Much Less-Than / Much Less Than + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+0226B ≫ \gg Much Greater-Than / Much Greater Than  
U+0226B

U+00338

≫̸ \NotGreaterGreater Much Greater-Than / Much Greater Than + Combining  
Long Solidus Overlay / Non-Spacing Long Slash Overlay

U+0226C ≬ \between Between  
U+0226D ≭ \nasymp Not Equivalent To  
U+0226E ≮ \nless Not Less-Than / Not Less Than  
U+0226F ≯ \ngtr Not Greater-Than / Not Greater Than  
U+02270 ≰ \nleq Neither Less-Than Nor Equal To / Neither Less Than Nor  
Equal To  
U+02271 ≱ \ngeq Neither Greater-Than Nor Equal To / Neither Greater  
Than Nor Equal To  
U+02272 ≲ \lesssim Less-Than Or Equivalent To / Less Than Or Equivalent  
To  
U+02273 ≳ \gtrsim Greater-Than Or Equivalent To / Greater Than Or  
Equivalent To  
U+02274 ≴ \nlesssim Neither Less-Than Nor Equivalent To / Neither Less  
Than Nor Equivalent To  
U+02275 ≵ \ngtrsim Neither Greater-Than Nor Equivalent To / Neither  
Greater Than Nor Equivalent To  
U+02276 ≶ \lessgtr Less-Than Or Greater-Than / Less Than Or Greater Than  
U+02277 ≷ \gtrless Greater-Than Or Less-Than / Greater Than Or Less Than  
U+02278 ≸ \notlessgreater Neither Less-Than Nor Greater-Than / Neither Less  
Than Nor Greater Than  
U+02279 ≹ \notgreaterless Neither Greater-Than Nor Less-Than / Neither Greater  
Than Nor Less Than  
U+0227A ≺ \prec Precedes  
U+0227B ≻ \succ Succeeds  
U+0227C ≼ \preccurlyeq Precedes Or Equal To  
U+0227D ≽ \succcurlyeq Succeeds Or Equal To  
U+0227E ≾ \precsim Precedes Or Equivalent To  
U+0227E

U+00338

≾̸ \nprecsim Precedes Or Equivalent To + Combining Long Solidus  
Overlay / Non-Spacing Long Slash Overlay

U+0227F ≿ \succsim Succeeds Or Equivalent To  
U+0227F

U+00338

≿̸ \nsuccsim Succeeds Or Equivalent To + Combining Long Solidus  
Overlay / Non-Spacing Long Slash Overlay

U+02280 ⊀ \nprec Does Not Precede  
U+02281 ⊁ \nsucc Does Not Succeed  
U+02282 ⊂ \subset Subset Of  
U+02283 ⊃ \supset Superset Of  
U+02284 ⊄ \nsubset Not A Subset Of  
U+02285 ⊅ \nsupset Not A Superset Of  
U+02286 ⊆ \subseteq Subset Of Or Equal To  
U+02287 ⊇ \supseteq Superset Of Or Equal To  
U+02288 ⊈ \nsubseteq Neither A Subset Of Nor Equal To  
U+02289 ⊉ \nsupseteq Neither A Superset Of Nor Equal To  
U+0228A ⊊ \subsetneq Subset Of With Not Equal To / Subset Of Or Not Equal To  
U+0228A

U+0FE00

⊊︀ \varsubsetneqq Subset Of With Not Equal To / Subset Of Or Not Equal  
To + Variation Selector-1

U+0228B ⊋ \supsetneq Superset Of With Not Equal To / Superset Of Or Not  
Equal To  
U+0228B

U+0FE00

⊋︀ \varsupsetneq Superset Of With Not Equal To / Superset Of Or Not  
Equal To + Variation Selector-1

U+0228D ⊍ \cupdot Multiset Multiplication  
U+0228E ⊎ \uplus Multiset Union  
U+0228F ⊏ \sqsubset Square Image Of  
U+0228F

U+00338

⊏̸ \NotSquareSubset Square Image Of + Combining Long Solidus Overlay /  
Non-Spacing Long Slash Overlay

U+02290 ⊐ \sqsupset Square Original Of  
U+02290

U+00338

⊐̸ \NotSquareSuperset Square Original Of + Combining Long Solidus Overlay /  
Non-Spacing Long Slash Overlay

U+02291 ⊑ \sqsubseteq Square Image Of Or Equal To  
U+02292 ⊒ \sqsupseteq Square Original Of Or Equal To  
U+02293 ⊓ \sqcap Square Cap  
U+02294 ⊔ \sqcup Square Cup  
U+02295 ⊕ \oplus Circled Plus  
U+02296 ⊖ \ominus Circled Minus  
U+02297 ⊗ \otimes Circled Times  
U+02298 ⊘ \oslash Circled Division Slash  
U+02299 ⊙ \odot Circled Dot Operator  
U+0229A ⊚ \circledcirc Circled Ring Operator  
U+0229B ⊛ \circledast Circled Asterisk Operator  
U+0229C ⊜ \circledequal Circled Equals  
U+0229D ⊝ \circleddash Circled Dash  
U+0229E ⊞ \boxplus Squared Plus  
U+0229F ⊟ \boxminus Squared Minus  
U+022A0 ⊠ \boxtimes Squared Times  
U+022A1 ⊡ \boxdot Squared Dot Operator  
U+022A2 ⊢ \vdash Right Tack  
U+022A3 ⊣ \dashv Left Tack  
U+022A4 ⊤ \top Down Tack  
U+022A5 ⊥ \bot Up Tack  
U+022A7 ⊧ \models Models  
U+022A8 ⊨ \vDash True  
U+022A9 ⊩ \Vdash Forces  
U+022AA ⊪ \Vvdash Triple Vertical Bar Right Turnstile  
U+022AB ⊫ \VDash Double Vertical Bar Double Right Turnstile  
U+022AC ⊬ \nvdash Does Not Prove  
U+022AD ⊭ \nvDash Not True  
U+022AE ⊮ \nVdash Does Not Force  
U+022AF ⊯ \nVDash Negated Double Vertical Bar Double Right Turnstile  
U+022B0 ⊰ \prurel Precedes Under Relation  
U+022B1 ⊱ \scurel Succeeds Under Relation  
U+022B2 ⊲ \vartriangleleft Normal Subgroup Of  
U+022B3 ⊳ \vartriangleright Contains As Normal Subgroup  
U+022B4 ⊴ \trianglelefteq Normal Subgroup Of Or Equal To  
U+022B5 ⊵ \trianglerighteq Contains As Normal Subgroup Or Equal To  
U+022B6 ⊶ \original Original Of  
U+022B7 ⊷ \image Image Of  
U+022B8 ⊸ \multimap Multimap  
U+022B9 ⊹ \hermitconjmatrix Hermitian Conjugate Matrix  
U+022BA ⊺ \intercal Intercalate  
U+022BB ⊻ \veebar, \xor Xor  
U+022BC ⊼ \barwedge, \nand Nand  
U+022BD ⊽ \barvee, \nor Nor  
U+022BE ⊾ \rightanglearc Right Angle With Arc  
U+022BF ⊿ \varlrtriangle Right Triangle  
U+022C0 ⋀ \bigwedge N-Ary Logical And  
U+022C1 ⋁ \bigvee N-Ary Logical Or  
U+022C2 ⋂ \bigcap N-Ary Intersection  
U+022C3 ⋃ \bigcup N-Ary Union  
U+022C4 ⋄ \diamond Diamond Operator  
U+022C5 ⋅ \cdot Dot Operator  
U+022C6 ⋆ \star Star Operator  
U+022C7 ⋇ \divideontimes Division Times  
U+022C8 ⋈ \bowtie Bowtie  
U+022C9 ⋉ \ltimes Left Normal Factor Semidirect Product  
U+022CA ⋊ \rtimes Right Normal Factor Semidirect Product  
U+022CB ⋋ \leftthreetimes Left Semidirect Product  
U+022CC ⋌ \rightthreetimes Right Semidirect Product  
U+022CD ⋍ \backsimeq Reversed Tilde Equals  
U+022CE ⋎ \curlyvee Curly Logical Or  
U+022CF ⋏ \curlywedge Curly Logical And  
U+022D0 ⋐ \Subset Double Subset  
U+022D1 ⋑ \Supset Double Superset  
U+022D2 ⋒ \Cap Double Intersection  
U+022D3 ⋓ \Cup Double Union  
U+022D4 ⋔ \pitchfork Pitchfork  
U+022D5 ⋕ \equalparallel Equal And Parallel To  
U+022D6 ⋖ \lessdot Less-Than With Dot / Less Than With Dot  
U+022D7 ⋗ \gtrdot Greater-Than With Dot / Greater Than With Dot  
U+022D8 ⋘ \verymuchless Very Much Less-Than / Very Much Less Than  
U+022D9 ⋙ \ggg Very Much Greater-Than / Very Much Greater Than  
U+022DA ⋚ \lesseqgtr Less-Than Equal To Or Greater-Than / Less Than Equal  
To Or Greater Than  
U+022DB ⋛ \gtreqless Greater-Than Equal To Or Less-Than / Greater Than  
Equal To Or Less Than  
U+022DC ⋜ \eqless Equal To Or Less-Than / Equal To Or Less Than  
U+022DD ⋝ \eqgtr Equal To Or Greater-Than / Equal To Or Greater Than  
U+022DE ⋞ \curlyeqprec Equal To Or Precedes  
U+022DF ⋟ \curlyeqsucc Equal To Or Succeeds  
U+022E0 ⋠ \npreccurlyeq Does Not Precede Or Equal  
U+022E1 ⋡ \nsucccurlyeq Does Not Succeed Or Equal  
U+022E2 ⋢ \nsqsubseteq Not Square Image Of Or Equal To  
U+022E3 ⋣ \nsqsupseteq Not Square Original Of Or Equal To  
U+022E4 ⋤ \sqsubsetneq Square Image Of Or Not Equal To  
U+022E5 ⋥ \sqspne Square Original Of Or Not Equal To  
U+022E6 ⋦ \lnsim Less-Than But Not Equivalent To / Less Than But Not  
Equivalent To  
U+022E7 ⋧ \gnsim Greater-Than But Not Equivalent To / Greater Than But  
Not Equivalent To  
U+022E8 ⋨ \precnsim Precedes But Not Equivalent To  
U+022E9 ⋩ \succnsim Succeeds But Not Equivalent To  
U+022EA ⋪ \ntriangleleft Not Normal Subgroup Of  
U+022EB ⋫ \ntriangleright Does Not Contain As Normal Subgroup  
U+022EC ⋬ \ntrianglelefteq Not Normal Subgroup Of Or Equal To  
U+022ED ⋭ \ntrianglerighteq Does Not Contain As Normal Subgroup Or Equal  
U+022EE ⋮ \vdots Vertical Ellipsis  
U+022EF ⋯ \cdots Midline Horizontal Ellipsis  
U+022F0 ⋰ \adots Up Right Diagonal Ellipsis  
U+022F1 ⋱ \ddots Down Right Diagonal Ellipsis  
U+022F2 ⋲ \disin Element Of With Long Horizontal Stroke  
U+022F3 ⋳ \varisins Element Of With Vertical Bar At End Of Horizontal  
Stroke  
U+022F4 ⋴ \isins Small Element Of With Vertical Bar At End Of  
Horizontal Stroke  
U+022F5 ⋵ \isindot Element Of With Dot Above  
U+022F6 ⋶ \varisinobar Element Of With Overbar  
U+022F7 ⋷ \isinobar Small Element Of With Overbar  
U+022F8 ⋸ \isinvb Element Of With Underbar  
U+022F9 ⋹ \isinE Element Of With Two Horizontal Strokes  
U+022FA ⋺ \nisd Contains With Long Horizontal Stroke  
U+022FB ⋻ \varnis Contains With Vertical Bar At End Of Horizontal Stroke  
U+022FC ⋼ \nis Small Contains With Vertical Bar At End Of Horizontal  
Stroke  
U+022FD ⋽ \varniobar Contains With Overbar  
U+022FE ⋾ \niobar Small Contains With Overbar  
U+022FF ⋿ \bagmember Z Notation Bag Membership  
U+02300 ⌀ \diameter Diameter Sign  
U+02302 ⌂ \house House  
U+02305 ⌅ \varbarwedge Projective  
U+02306 ⌆ \vardoublebarwedge Perspective  
U+02308 ⌈ \lceil Left Ceiling  
U+02309 ⌉ \rceil Right Ceiling  
U+0230A ⌊ \lfloor Left Floor  
U+0230B ⌋ \rfloor Right Floor  
U+02310 ⌐ \invnot Reversed Not Sign  
U+02311 ⌑ \sqlozenge Square Lozenge  
U+02312 \profline Arc  
U+02313 \profsurf Segment  
U+02315 \recorder Telephone Recorder  
U+02317 \viewdata Viewdata Square  
U+02319 ⌙ \turnednot Turned Not Sign  
U+0231A :watch: Watch  
U+0231B :hourglass: Hourglass  
U+0231C ⌜ \ulcorner Top Left Corner  
U+0231D ⌝ \urcorner Top Right Corner  
U+0231E ⌞ \llcorner Bottom Left Corner  
U+0231F ⌟ \lrcorner Bottom Right Corner  
U+02322 \frown Frown  
U+02323 \smile Smile  
U+0232C ⌬ \varhexagonlrbonds Benzene Ring  
U+02332 \conictaper Conical Taper  
U+02336 \topbot Apl Functional Symbol I-Beam  
U+0233D \obar Apl Functional Symbol Circle Stile  
U+0233F \notslash Apl Functional Symbol Slash Bar  
U+02340 \notbackslash Apl Functional Symbol Backslash Bar  
U+02353 \boxupcaret Apl Functional Symbol Quad Up Caret  
U+02370 \boxquestion Apl Functional Symbol Quad Question  
U+02394 ⎔ \hexagon Software-Function Symbol  
U+023A3 ⎣ \dlcorn Left Square Bracket Lower Corner  
U+023B0 \lmoustache Upper Left Or Lower Right Curly Bracket Section  
U+023B1 \rmoustache Upper Right Or Lower Left Curly Bracket Section  
U+023B4 \overbracket Top Square Bracket  
U+023B5 \underbracket Bottom Square Bracket  
U+023B6 \bbrktbrk Bottom Square Bracket Over Top Square Bracket  
U+023B7 \sqrtbottom Radical Symbol Bottom  
U+023B8 \lvboxline Left Vertical Box Line  
U+023B9 \rvboxline Right Vertical Box Line  
U+023CE ⏎ \varcarriagereturn Return Symbol  
U+023DE \overbrace Top Curly Bracket  
U+023DF \underbrace Bottom Curly Bracket  
U+023E2 \trapezium White Trapezium  
U+023E3 ⏣ \benzenr Benzene Ring With Circle  
U+023E4 \strns Straightness  
U+023E5 ⏥ \fltns Flatness  
U+023E6 \accurrent Ac Current  
U+023E7 \elinters Electrical Intersection  
U+023E9 :fast_forward: Black Right-Pointing Double Triangle  
U+023EA :rewind: Black Left-Pointing Double Triangle  
U+023EB :arrow_double_up: Black Up-Pointing Double Triangle  
U+023EC :arrow_double_down: Black Down-Pointing Double Triangle  
U+023F0 :alarm_clock: Alarm Clock  
U+023F3 :hourglass_flow-  
ing_sand:

Hourglass With Flowing Sand

U+02422 ␢ \blanksymbol Blank Symbol / Blank  
U+02423 ␣ \visiblespace Open Box  
U+024C2 :m: Circled Latin Capital Letter M  
U+024C8 \circledS Circled Latin Capital Letter S  
U+02506 ┆ \dshfnc Box Drawings Light Triple Dash Vertical / Forms Light  
Triple Dash Vertical  
U+02519 ┙ \sqfnw Box Drawings Up Light And Left Heavy / Forms Up  
Light And Left Heavy  
U+02571 ╱ \diagup Box Drawings Light Diagonal Upper Right To Lower Left  
/ Forms Light Diagonal Upper Right To Lower Left  
U+02572 ╲ \diagdown Box Drawings Light Diagonal Upper Left To Lower Right  
/ Forms Light Diagonal Upper Left To Lower Right  
U+02580 ▀ \blockuphalf Upper Half Block  
U+02584 ▄ \blocklowhalf Lower Half Block  
U+02588 █ \blockfull Full Block  
U+0258C ▌ \blocklefthalf Left Half Block  
U+02590 ▐ \blockrighthalf Right Half Block  
U+02591 ░ \blockqtrshaded Light Shade  
U+02592 ▒ \blockhalfshaded Medium Shade  
U+02593 ▓ \blockthreeqtrshaded Dark Shade  
U+025A0 ■ \blacksquare Black Square  
U+025A1 □ \square White Square  
U+025A2 ▢ \squoval White Square With Rounded Corners  
U+025A3 ▣ \blackinwhitesquare White Square Containing Black Small Square  
U+025A4 ▤ \squarehfill Square With Horizontal Fill  
U+025A5 ▥ \squarevfill Square With Vertical Fill  
U+025A6 ▦ \squarehvfill Square With Orthogonal Crosshatch Fill  
U+025A7 ▧ \squarenwsefill Square With Upper Left To Lower Right Fill  
U+025A8 ▨ \squareneswfill Square With Upper Right To Lower Left Fill  
U+025A9 ▩ \squarecrossfill Square With Diagonal Crosshatch Fill  
U+025AA ▪ \smblksquare,  
:black_small_square:

Black Small Square

U+025AB ▫ \smwhtsquare,  
:white_small_square:

White Small Square

U+025AC ▬ \hrectangleblack Black Rectangle  
U+025AD ▭ \hrectangle White Rectangle  
U+025AE ▮ \vrectangleblack Black Vertical Rectangle  
U+025AF ▯ \vrecto White Vertical Rectangle  
U+025B0 ▰ \parallelogramblack Black Parallelogram  
U+025B1 ▱ \parallelogram White Parallelogram  
U+025B2 ▲ \bigblacktriangleup Black Up-Pointing Triangle / Black Up Pointing Triangle  
U+025B3 △ \bigtriangleup White Up-Pointing Triangle / White Up Pointing Triangle  
U+025B4 ▴ \blacktriangle Black Up-Pointing Small Triangle / Black Up Pointing  
Small Triangle  
U+025B5 ▵ \vartriangle White Up-Pointing Small Triangle / White Up Pointing  
Small Triangle  
U+025B6 ▶ \blacktriangleright,  
:arrow_forward:

Black Right-Pointing Triangle / Black Right Pointing  
Triangle  
U+025B7 ▷ \triangleright White Right-Pointing Triangle / White Right Pointing  
Triangle  
U+025B8 ▸ \smallblacktriangleright Black Right-Pointing Small Triangle / Black Right  
Pointing Small Triangle  
U+025B9 ▹ \smalltriangleright White Right-Pointing Small Triangle / White Right  
Pointing Small Triangle  
U+025BA ► \blackpointerright Black Right-Pointing Pointer / Black Right Pointing  
Pointer  
U+025BB ▻ \whitepointerright White Right-Pointing Pointer / White Right Pointing  
Pointer  
U+025BC ▼ \bigblacktriangledown Black Down-Pointing Triangle / Black Down Pointing  
Triangle  
U+025BD ▽ \bigtriangledown White Down-Pointing Triangle / White Down Pointing  
Triangle  
U+025BE ▾ \blacktriangledown Black Down-Pointing Small Triangle / Black Down  
Pointing Small Triangle  
U+025BF ▿ \triangledown White Down-Pointing Small Triangle / White Down  
Pointing Small Triangle  
U+025C0 ◀ \blacktriangleleft,  
:arrow_backward:

Black Left-Pointing Triangle / Black Left Pointing  
Triangle  
U+025C1 ◁ \triangleleft White Left-Pointing Triangle / White Left Pointing  
Triangle  
U+025C2 ◂ \smallblacktriangleleft Black Left-Pointing Small Triangle / Black Left Pointing  
Small Triangle  
U+025C3 ◃ \smalltriangleleft White Left-Pointing Small Triangle / White Left Pointing  
Small Triangle  
U+025C4 ◄ \blackpointerleft Black Left-Pointing Pointer / Black Left Pointing Pointer  
U+025C5 ◅ \whitepointerleft White Left-Pointing Pointer / White Left Pointing Pointer  
U+025C6 ◆ \mdlgblkdiamond Black Diamond  
U+025C7 ◇ \mdlgwhtdiamond White Diamond  
U+025C8 ◈ \blackinwhitediamond White Diamond Containing Black Small Diamond  
U+025C9 ◉ \fisheye Fisheye  
U+025CA ◊ \lozenge Lozenge  
U+025CB ○ \bigcirc White Circle  
U+025CC ◌ \dottedcircle Dotted Circle  
U+025CD ◍ \circlevertfill Circle With Vertical Fill  
U+025CE ◎ \bullseye Bullseye  
U+025CF ● \mdlgblkcircle Black Circle  
U+025D0 ◐ \cirfl Circle With Left Half Black  
U+025D1 ◑ \cirfr Circle With Right Half Black  
U+025D2 ◒ \cirfb Circle With Lower Half Black  
U+025D3 ◓ \circletophalfblack Circle With Upper Half Black  
U+025D4 ◔ \circleurquadblack Circle With Upper Right Quadrant Black  
U+025D5 ◕ \blackcircleulquadwhite Circle With All But Upper Left Quadrant Black  
U+025D6 ◖ \blacklefthalfcircle Left Half Black Circle  
U+025D7 ◗ \blackrighthalfcircle Right Half Black Circle  
U+025D8 ◘ \rvbull Inverse Bullet  
U+025D9 ◙ \inversewhitecircle Inverse White Circle  
U+025DA ◚ \invwhiteupperhalfcircle Upper Half Inverse White Circle  
U+025DB ◛ \invwhitelowerhalfcircle Lower Half Inverse White Circle  
U+025DC ◜ \ularc Upper Left Quadrant Circular Arc  
U+025DD ◝ \urarc Upper Right Quadrant Circular Arc  
U+025DE ◞ \lrarc Lower Right Quadrant Circular Arc  
U+025DF ◟ \llarc Lower Left Quadrant Circular Arc  
U+025E0 ◠ \topsemicircle Upper Half Circle  
U+025E1 ◡ \botsemicircle Lower Half Circle  
U+025E2 ◢ \lrblacktriangle Black Lower Right Triangle  
U+025E3 ◣ \llblacktriangle Black Lower Left Triangle  
U+025E4 ◤ \ulblacktriangle Black Upper Left Triangle  
U+025E5 ◥ \urblacktriangle Black Upper Right Triangle  
U+025E6 ◦ \smwhtcircle White Bullet  
U+025E7 ◧ \sqfl Square With Left Half Black  
U+025E8 ◨ \sqfr Square With Right Half Black  
U+025E9 ◩ \squareulblack Square With Upper Left Diagonal Half Black  
U+025EA ◪ \sqfse Square With Lower Right Diagonal Half Black  
U+025EB ◫ \boxbar White Square With Vertical Bisecting Line  
U+025EC ◬ \trianglecdot White Up-Pointing Triangle With Dot / White Up  
Pointing Triangle With Dot  
U+025ED ◭ \triangleleftblack Up-Pointing Triangle With Left Half Black / Up Pointing  
Triangle With Left Half Black  
U+025EE ◮ \trianglerightblack Up-Pointing Triangle With Right Half Black / Up Pointing  
Triangle With Right Half Black  
U+025EF ◯ \lgwhtcircle Large Circle  
U+025F0 ◰ \squareulquad White Square With Upper Left Quadrant  
U+025F1 ◱ \squarellquad White Square With Lower Left Quadrant  
U+025F2 ◲ \squarelrquad White Square With Lower Right Quadrant  
U+025F3 ◳ \squareurquad White Square With Upper Right Quadrant  
U+025F4 ◴ \circleulquad White Circle With Upper Left Quadrant  
U+025F5 ◵ \circlellquad White Circle With Lower Left Quadrant  
U+025F6 ◶ \circlelrquad White Circle With Lower Right Quadrant  
U+025F7 ◷ \circleurquad White Circle With Upper Right Quadrant  
U+025F8 ◸ \ultriangle Upper Left Triangle  
U+025F9 ◹ \urtriangle Upper Right Triangle  
U+025FA ◺ \lltriangle Lower Left Triangle  
U+025FB ◻ \mdwhtsquare,  
:white_medium_square:

White Medium Square

U+025FC ◼ \mdblksquare,  
:black_medium_square:

Black Medium Square

U+025FD ◽ \mdsmwhtsquare,  
:white_medium_small_square:

White Medium Small Square

U+025FE ◾ \mdsmblksquare,  
:black_medium_small_square:

Black Medium Small Square

U+025FF ◿ \lrtriangle Lower Right Triangle  
U+02600 ☀ :sunny: Black Sun With Rays  
U+02601 ☁ :cloud: Cloud  
U+02605 ★ \bigstar Black Star  
U+02606 ☆ \bigwhitestar White Star  
U+02609 ☉ \astrosun Sun  
U+0260E ☎ :phone: Black Telephone  
U+02611 ☑ :ballot_box_with_check: Ballot Box With Check  
U+02614 ☔ :um-  
brella_with_rain_drops:,  
:umbrella:

Umbrella With Rain Drops

U+02615 ☕ :coffee: Hot Beverage  
U+0261D ☝ :point_up: White Up Pointing Index  
U+02621 ☡ \danger Caution Sign  
U+0263A ☺ :relaxed: White Smiling Face  
U+0263B ☻ \blacksmiley Black Smiling Face  
U+0263C ☼ \sun White Sun With Rays  
U+0263D ☽ \rightmoon First Quarter Moon  
U+0263E ☾ \leftmoon Last Quarter Moon  
U+0263F ☿ \mercury Mercury  
U+02640 ♀ \venus, \female Female Sign  
U+02642 ♂ \male, \mars Male Sign  
U+02643 ♃ \jupiter Jupiter  
U+02644 ♄ \saturn Saturn  
U+02645 ♅ \uranus Uranus  
U+02646 ♆ \neptune Neptune  
U+02647 ♇ \pluto Pluto  
U+02648 ♈ \aries, :aries: Aries  
U+02649 ♉ \taurus, :taurus: Taurus  
U+0264A ♊ \gemini, :gemini: Gemini  
U+0264B ♋ \cancer, :cancer: Cancer  
U+0264C ♌ \leo, :leo: Leo  
U+0264D ♍ \virgo, :virgo: Virgo  
U+0264E ♎ \libra, :libra: Libra  
U+0264F ♏ \scorpio, :scorpius: Scorpius  
U+02650 ♐ \sagittarius,  
:sagittarius:

Sagittarius

U+02651 ♑ \capricornus,  
:capricorn:

Capricorn

U+02652 ♒ \aquarius, :aquarius: Aquarius  
U+02653 ♓ \pisces, :pisces: Pisces  
U+02660 ♠ \spadesuit, :spades: Black Spade Suit  
U+02661 ♡ \heartsuit White Heart Suit  
U+02662 ♢ \diamondsuit White Diamond Suit  
U+02663 ♣ \clubsuit, :clubs: Black Club Suit  
U+02664 ♤ \varspadesuit White Spade Suit  
U+02665 ♥ \varheartsuit, :hearts: Black Heart Suit  
U+02666 ♦ \vardiamondsuit,  
:diamonds:

Black Diamond Suit

U+02667 ♧ \varclubsuit White Club Suit  
U+02668 ♨ :hotsprings: Hot Springs  
U+02669 ♩ \quarternote Quarter Note  
U+0266A ♪ \eighthnote Eighth Note  
U+0266B ♫ \twonotes Beamed Eighth Notes / Barred Eighth Notes  
U+0266D ♭ \flat Music Flat Sign / Flat  
U+0266E ♮ \natural Music Natural Sign / Natural  
U+0266F ♯ \sharp Music Sharp Sign / Sharp  
U+0267B ♻ :recycle: Black Universal Recycling Symbol  
U+0267E ♾ \acidfree Permanent Paper Sign  
U+0267F ♿ :wheelchair: Wheelchair Symbol  
U+02680 ⚀ \dicei Die Face-1  
U+02681 ⚁ \diceii Die Face-2  
U+02682 ⚂ \diceiii Die Face-3  
U+02683 ⚃ \diceiv Die Face-4  
U+02684 ⚄ \dicev Die Face-5  
U+02685 ⚅ \dicevi Die Face-6  
U+02686 ⚆ \circledrightdot White Circle With Dot Right  
U+02687 ⚇ \circledtwodots White Circle With Two Dots  
U+02688 ⚈ \blackcircledrightdot Black Circle With White Dot Right  
U+02689 ⚉ \blackcircledtwodots Black Circle With Two White Dots  
U+02693 ⚓ :anchor: Anchor  
U+026A0 ⚠ :warning: Warning Sign  
U+026A1 ⚡ :zap: High Voltage Sign  
U+026A5 ⚥ \hermaphrodite Male And Female Sign  
U+026AA ⚪ \mdwhtcircle,  
:white_circle:

Medium White Circle

U+026AB ⚫ \mdblkcircle,  
:black_circle:

Medium Black Circle

U+026AC ⚬ \mdsmwhtcircle Medium Small White Circle  
U+026B2 ⚲ \neuter Neuter  
U+026BD :soccer: Soccer Ball  
U+026BE :baseball: Baseball  
U+026C4 :snowman:, :snow-  
man_without_snow:

Snowman Without Snow

U+026C5 :partly_sunny: Sun Behind Cloud  
U+026CE :ophiuchus: Ophiuchus  
U+026D4 :no_entry: No Entry  
U+026EA :church: Church  
U+026F2 :fountain: Fountain  
U+026F3 :golf: Flag In Hole  
U+026F5 :boat: Sailboat  
U+026FA :tent: Tent  
U+026FD :fuelpump: Fuel Pump  
U+02702 ✂ :scissors: Black Scissors  
U+02705 :white_check_mark: White Heavy Check Mark  
U+02708 ✈ :airplane: Airplane  
U+02709 ✉ :email: Envelope  
U+0270A :fist: Raised Fist  
U+0270B :hand: Raised Hand  
U+0270C ✌ :v: Victory Hand  
U+0270F ✏ :pencil2: Pencil  
U+02712 ✒ :black_nib: Black Nib  
U+02713 ✓ \checkmark Check Mark  
U+02714 ✔ :heavy_check_mark: Heavy Check Mark  
U+02716 ✖ :heavy_multiplica-  
tion_x:

Heavy Multiplication X

U+02720 ✠ \maltese Maltese Cross  
U+02728 :sparkles: Sparkles  
U+0272A ✪ \circledstar Circled White Star  
U+02733 ✳ :eight_spoked_asterisk: Eight Spoked Asterisk  
U+02734 ✴ :eight_pointed_black_star:Eight Pointed Black Star  
U+02736 ✶ \varstar Six Pointed Black Star  
U+0273D ✽ \dingasterisk Heavy Teardrop-Spoked Asterisk  
U+02744 ❄ :snowflake: Snowflake  
U+02747 ❇ :sparkle: Sparkle  
U+0274C :x: Cross Mark  
U+0274E :nega-  
tive_squared_cross_mark:

Negative Squared Cross Mark

U+02753 :question: Black Question Mark Ornament  
U+02754 :grey_question: White Question Mark Ornament  
U+02755 :grey_exclamation: White Exclamation Mark Ornament  
U+02757 :exclamation: Heavy Exclamation Mark Symbol  
U+02764 ❤ :heart: Heavy Black Heart  
U+02795 :heavy_plus_sign: Heavy Plus Sign  
U+02796 :heavy_minus_sign: Heavy Minus Sign  
U+02797 :heavy_division_sign: Heavy Division Sign  
U+0279B ➛ \draftingarrow Drafting Point Rightwards Arrow / Drafting Point Right  
Arrow  
U+027A1 ➡ :arrow_right: Black Rightwards Arrow / Black Right Arrow  
U+027B0 :curly_loop: Curly Loop  
U+027BF :loop: Double Curly Loop  
U+027C0 \threedangle Three Dimensional Angle  
U+027C1 \whiteinwhitetriangle White Triangle Containing Small White Triangle  
U+027C2 \perp Perpendicular  
U+027C8 \bsolhsub Reverse Solidus Preceding Subset  
U+027C9 \suphsol Superset Preceding Solidus  
U+027D1 \wedgedot And With Dot  
U+027D2 \upin Element Of Opening Upwards  
U+027D5 \leftouterjoin Left Outer Join  
U+027D6 \rightouterjoin Right Outer Join  
U+027D7 \fullouterjoin Full Outer Join  
U+027D8 \bigbot Large Up Tack  
U+027D9 \bigtop Large Down Tack  
U+027E6 ⟦ \llbracket,  
\openbracketleft

Mathematical Left White Square Bracket

U+027E7 ⟧ \openbracketright,  
\rrbracket

Mathematical Right White Square Bracket

U+027E8 ⟨ \langle Mathematical Left Angle Bracket  
U+027E9 ⟩ \rangle Mathematical Right Angle Bracket  
U+027F0 ⟰ \UUparrow Upwards Quadruple Arrow  
U+027F1 ⟱ \DDownarrow Downwards Quadruple Arrow  
U+027F5 ⟵ \longleftarrow Long Leftwards Arrow  
U+027F6 ⟶ \longrightarrow Long Rightwards Arrow  
U+027F7 ⟷ \longleftrightarrow Long Left Right Arrow  
U+027F8 ⟸ \impliedby,  
\Longleftarrow

Long Leftwards Double Arrow

U+027F9 ⟹ \implies,  
\Longrightarrow

Long Rightwards Double Arrow

U+027FA ⟺ \Longleftrightarrow, \iff Long Left Right Double Arrow  
U+027FB ⟻ \longmapsfrom Long Leftwards Arrow From Bar  
U+027FC ⟼ \longmapsto Long Rightwards Arrow From Bar  
U+027FD ⟽ \Longmapsfrom Long Leftwards Double Arrow From Bar  
U+027FE ⟾ \Longmapsto Long Rightwards Double Arrow From Bar  
U+027FF ⟿ \longrightsquigarrow Long Rightwards Squiggle Arrow  
U+02900 \nvtwoheadrightarrow Rightwards Two-Headed Arrow With Vertical Stroke  
U+02901 \nVtwoheadrightarrow Rightwards Two-Headed Arrow With Double Vertical  
Stroke  
U+02902 \nvLeftarrow Leftwards Double Arrow With Vertical Stroke  
U+02903 \nvRightarrow Rightwards Double Arrow With Vertical Stroke  
U+02904 \nvLeftrightarrow Left Right Double Arrow With Vertical Stroke  
U+02905 \twoheadmapsto Rightwards Two-Headed Arrow From Bar  
U+02906 ⤆ \Mapsfrom Leftwards Double Arrow From Bar  
U+02907 ⤇ \Mapsto Rightwards Double Arrow From Bar  
U+02908 \downarrowbarred Downwards Arrow With Horizontal Stroke  
U+02909 \uparrowbarred Upwards Arrow With Horizontal Stroke  
U+0290A ⤊ \Uuparrow Upwards Triple Arrow  
U+0290B ⤋ \Ddownarrow Downwards Triple Arrow  
U+0290C \leftbkarrow Leftwards Double Dash Arrow  
U+0290D \bkarow Rightwards Double Dash Arrow  
U+0290E \leftdbkarrow Leftwards Triple Dash Arrow  
U+0290F \dbkarow Rightwards Triple Dash Arrow  
U+02910 \drbkarrow Rightwards Two-Headed Triple Dash Arrow  
U+02911 \rightdotarrow Rightwards Arrow With Dotted Stem  
U+02912 \UpArrowBar Upwards Arrow To Bar  
U+02913 \DownArrowBar Downwards Arrow To Bar  
U+02914 \nvrightarrowtail Rightwards Arrow With Tail With Vertical Stroke  
U+02915 \nVrightarrowtail Rightwards Arrow With Tail With Double Vertical Stroke  
U+02916 \twoheadrightarrowtail Rightwards Two-Headed Arrow With Tail  
U+02917 \nvtwoheadrightarrow-  
tail

Rightwards Two-Headed Arrow With Tail With Vertical  
Stroke  
U+02918 \nVtwoheadrightarrow-  
tail

Rightwards Two-Headed Arrow With Tail With Double  
Vertical Stroke  
U+0291D \diamondleftarrow Leftwards Arrow To Black Diamond  
U+0291E \rightarrowdiamond Rightwards Arrow To Black Diamond  
U+0291F \diamondleftarrowbar Leftwards Arrow From Bar To Black Diamond  
U+02920 \barrightarrowdiamond Rightwards Arrow From Bar To Black Diamond  
U+02925 \hksearow South East Arrow With Hook  
U+02926 \hkswarow South West Arrow With Hook  
U+02927 \tona North West Arrow And North East Arrow  
U+02928 \toea North East Arrow And South East Arrow  
U+02929 \tosa South East Arrow And South West Arrow  
U+0292A \towa South West Arrow And North West Arrow  
U+0292B \rdiagovfdiag Rising Diagonal Crossing Falling Diagonal  
U+0292C \fdiagovrdiag Falling Diagonal Crossing Rising Diagonal  
U+0292D \seovnearrow South East Arrow Crossing North East Arrow  
U+0292E \neovsearrow North East Arrow Crossing South East Arrow  
U+0292F \fdiagovnearrow Falling Diagonal Crossing North East Arrow  
U+02930 \rdiagovsearrow Rising Diagonal Crossing South East Arrow  
U+02931 \neovnwarrow North East Arrow Crossing North West Arrow  
U+02932 \nwovnearrow North West Arrow Crossing North East Arrow  
U+02934 :arrow_heading_up: Arrow Pointing Rightwards Then Curving Upwards  
U+02935 :arrow_heading_down: Arrow Pointing Rightwards Then Curving Downwards  
U+02942 \Rlarr Rightwards Arrow Above Short Leftwards Arrow  
U+02944 \rLarr Short Rightwards Arrow Above Leftwards Arrow  
U+02945 \rightarrowplus Rightwards Arrow With Plus Below  
U+02946 \leftarrowplus Leftwards Arrow With Plus Below  
U+02947 \rarrx Rightwards Arrow Through X  
U+02948 \leftrightarrowcircle Left Right Arrow Through Small Circle  
U+02949 \twoheaduparrowcircle Upwards Two-Headed Arrow From Small Circle  
U+0294A \leftrightharpoonup-  
down

Left Barb Up Right Barb Down Harpoon

U+0294B \leftrightharpoon-  
downup

Left Barb Down Right Barb Up Harpoon

U+0294C \updownharpoon-  
rightleft

Up Barb Right Down Barb Left Harpoon

U+0294D \updownharpoonleft-  
right

Up Barb Left Down Barb Right Harpoon

U+0294E \LeftRightVector Left Barb Up Right Barb Up Harpoon  
U+0294F \RightUpDownVector Up Barb Right Down Barb Right Harpoon  
U+02950 \DownLeftRightVector Left Barb Down Right Barb Down Harpoon  
U+02951 \LeftUpDownVector Up Barb Left Down Barb Left Harpoon  
U+02952 \LeftVectorBar Leftwards Harpoon With Barb Up To Bar  
U+02953 \RightVectorBar Rightwards Harpoon With Barb Up To Bar  
U+02954 \RightUpVectorBar Upwards Harpoon With Barb Right To Bar  
U+02955 \RightDownVectorBar Downwards Harpoon With Barb Right To Bar  
U+02956 \DownLeftVectorBar Leftwards Harpoon With Barb Down To Bar  
U+02957 \DownRightVectorBar Rightwards Harpoon With Barb Down To Bar  
U+02958 \LeftUpVectorBar Upwards Harpoon With Barb Left To Bar  
U+02959 \LeftDownVectorBar Downwards Harpoon With Barb Left To Bar  
U+0295A \LeftTeeVector Leftwards Harpoon With Barb Up From Bar  
U+0295B \RightTeeVector Rightwards Harpoon With Barb Up From Bar  
U+0295C \RightUpTeeVector Upwards Harpoon With Barb Right From Bar  
U+0295D \RightDownTeeVector Downwards Harpoon With Barb Right From Bar  
U+0295E \DownLeftTeeVector Leftwards Harpoon With Barb Down From Bar  
U+0295F \DownRightTeeVector Rightwards Harpoon With Barb Down From Bar  
U+02960 \LeftUpTeeVector Upwards Harpoon With Barb Left From Bar  
U+02961 \LeftDownTeeVector Downwards Harpoon With Barb Left From Bar  
U+02962 \leftharpoonsupdown Leftwards Harpoon With Barb Up Above Leftwards  
Harpoon With Barb Down  
U+02963 \upharpoonsleftright Upwards Harpoon With Barb Left Beside Upwards  
Harpoon With Barb Right  
U+02964 \rightharpoonsupdown Rightwards Harpoon With Barb Up Above Rightwards  
Harpoon With Barb Down  
U+02965 \downharpoonsleftright Downwards Harpoon With Barb Left Beside  
Downwards Harpoon With Barb Right  
U+02966 \leftrightharpoonsup Leftwards Harpoon With Barb Up Above Rightwards  
Harpoon With Barb Up  
U+02967 \leftrightharpoonsdown Leftwards Harpoon With Barb Down Above Rightwards  
Harpoon With Barb Down  
U+02968 \rightleftharpoonsup Rightwards Harpoon With Barb Up Above Leftwards  
Harpoon With Barb Up  
U+02969 \rightleftharpoonsdown Rightwards Harpoon With Barb Down Above Leftwards  
Harpoon With Barb Down  
U+0296A \leftharpoonupdash Leftwards Harpoon With Barb Up Above Long Dash  
U+0296B \dashleftharpoondown Leftwards Harpoon With Barb Down Below Long Dash  
U+0296C \rightharpoonupdash Rightwards Harpoon With Barb Up Above Long Dash  
U+0296D \dashrightharpoondown Rightwards Harpoon With Barb Down Below Long Dash  
U+0296E \UpEquilibrium Upwards Harpoon With Barb Left Beside Downwards  
Harpoon With Barb Right  
U+0296F \ReverseUpEquilibrium Downwards Harpoon With Barb Left Beside Upwards  
Harpoon With Barb Right  
U+02970 \RoundImplies Right Double Arrow With Rounded Head  
U+02980 \Vvert Triple Vertical Bar Delimiter  
U+02986 \Elroang Right White Parenthesis  
U+02999 \ddfnc Dotted Fence  
U+0299B \measuredangleleft Measured Angle Opening Left  
U+0299C \Angle Right Angle Variant With Square  
U+0299D \rightanglemdot Measured Right Angle With Dot  
U+0299E \angles Angle With S Inside  
U+0299F \angdnr Acute Angle  
U+029A0 \lpargt Spherical Angle Opening Left  
U+029A1 \sphericalangleup Spherical Angle Opening Up  
U+029A2 \turnangle Turned Angle  
U+029A3 \revangle Reversed Angle  
U+029A4 \angleubar Angle With Underbar  
U+029A5 \revangleubar Reversed Angle With Underbar  
U+029A6 \wideangledown Oblique Angle Opening Up  
U+029A7 \wideangleup Oblique Angle Opening Down  
U+029A8 \measanglerutone Measured Angle With Open Arm Ending In Arrow  
Pointing Up And Right  
U+029A9 \measanglelutonw Measured Angle With Open Arm Ending In Arrow  
Pointing Up And Left  
U+029AA \measanglerdtose Measured Angle With Open Arm Ending In Arrow  
Pointing Down And Right  
U+029AB \measangleldtosw Measured Angle With Open Arm Ending In Arrow  
Pointing Down And Left  
U+029AC \measangleurtone Measured Angle With Open Arm Ending In Arrow  
Pointing Right And Up  
U+029AD \measangleultonw Measured Angle With Open Arm Ending In Arrow  
Pointing Left And Up  
U+029AE \measangledrtose Measured Angle With Open Arm Ending In Arrow  
Pointing Right And Down  
U+029AF \measangledltosw Measured Angle With Open Arm Ending In Arrow  
Pointing Left And Down  
U+029B0 \revemptyset Reversed Empty Set  
U+029B1 \emptysetobar Empty Set With Overbar  
U+029B2 \emptysetocirc Empty Set With Small Circle Above  
U+029B3 \emptysetoarr Empty Set With Right Arrow Above  
U+029B4 \emptysetoarrl Empty Set With Left Arrow Above  
U+029B7 \circledparallel Circled Parallel  
U+029B8 \obslash Circled Reverse Solidus  
U+029BC \odotslashdot Circled Anticlockwise-Rotated Division Sign  
U+029BE \circledwhitebullet Circled White Bullet  
U+029BF \circledbullet Circled Bullet  
U+029C0 \olessthan Circled Less-Than  
U+029C1 \ogreaterthan Circled Greater-Than  
U+029C4 \boxdiag Squared Rising Diagonal Slash  
U+029C5 \boxbslash Squared Falling Diagonal Slash  
U+029C6 \boxast Squared Asterisk  
U+029C7 \boxcircle Squared Small Circle  
U+029CA \Lap Triangle With Dot Above  
U+029CB \defas Triangle With Underbar  
U+029CF ⧏ \LeftTriangleBar Left Triangle Beside Vertical Bar  
U+029CF

U+00338

⧏̸ \NotLeftTriangleBar Left Triangle Beside Vertical Bar + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+029D0 ⧐ \RightTriangleBar Vertical Bar Beside Right Triangle  
U+029D0

U+00338

⧐̸ \NotRightTriangleBar Vertical Bar Beside Right Triangle + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+029DF \dualmap Double-Ended Multimap  
U+029E1 \lrtriangleeq Increases As  
U+029E2 \shuffle Shuffle Product  
U+029E3 \eparsl Equals Sign And Slanted Parallel  
U+029E4 \smeparsl Equals Sign And Slanted Parallel With Tilde Above  
U+029E5 \eqvparsl Identical To And Slanted Parallel  
U+029EB ⧫ \blacklozenge Black Lozenge  
U+029F4 \RuleDelayed Rule-Delayed  
U+029F6 \dsol Solidus With Overbar  
U+029F7 \rsolbar Reverse Solidus With Horizontal Stroke  
U+029FA ⧺ \doubleplus Double Plus  
U+029FB ⧻ \tripleplus Triple Plus  
U+02A00 ⨀ \bigodot N-Ary Circled Dot Operator  
U+02A01 ⨁ \bigoplus N-Ary Circled Plus Operator  
U+02A02 ⨂ \bigotimes N-Ary Circled Times Operator  
U+02A03 \bigcupdot N-Ary Union Operator With Dot  
U+02A04 \biguplus N-Ary Union Operator With Plus  
U+02A05 \bigsqcap N-Ary Square Intersection Operator  
U+02A06 \bigsqcup N-Ary Square Union Operator  
U+02A07 \conjquant Two Logical And Operator  
U+02A08 \disjquant Two Logical Or Operator  
U+02A09 \bigtimes N-Ary Times Operator  
U+02A0A \modtwosum Modulo Two Sum  
U+02A0B \sumint Summation With Integral  
U+02A0C ∫∫∫∫ \iiiint Quadruple Integral Operator  
U+02A0D ⨍ \intbar Finite Part Integral  
U+02A0E ⨎ \intBar Integral With Double Stroke  
U+02A0F ⨏ \clockoint Integral Average With Slash  
U+02A10 ⨐ \cirfnint Circulation Function  
U+02A11 ⨑ \awint Anticlockwise Integration  
U+02A12 ⨒ \rppolint Line Integration With Rectangular Path Around Pole  
U+02A13 ⨓ \scpolint Line Integration With Semicircular Path Around Pole  
U+02A14 ⨔ \npolint Line Integration Not Including The Pole  
U+02A15 ⨕ \pointint Integral Around A Point Operator  
U+02A16 ⨖ \sqrint Quaternion Integral Operator  
U+02A18 ⨘ \intx Integral With Times Sign  
U+02A19 ⨙ \intcap Integral With Intersection  
U+02A1A ⨚ \intcup Integral With Union  
U+02A1B ⨛ \upint Integral With Overbar  
U+02A1C ⨜ \lowint Integral With Underbar  
U+02A1D \join Join  
U+02A1F \bbsemi Z Notation Schema Composition  
U+02A22 \ringplus Plus Sign With Small Circle Above  
U+02A23 \plushat Plus Sign With Circumflex Accent Above  
U+02A24 \simplus Plus Sign With Tilde Above  
U+02A25 \plusdot Plus Sign With Dot Below  
U+02A26 \plussim Plus Sign With Tilde Below  
U+02A27 \plussubtwo Plus Sign With Subscript Two  
U+02A28 \plustrif Plus Sign With Black Triangle  
U+02A29 \commaminus Minus Sign With Comma Above  
U+02A2A \minusdot Minus Sign With Dot Below  
U+02A2B \minusfdots Minus Sign With Falling Dots  
U+02A2C \minusrdots Minus Sign With Rising Dots  
U+02A2D \opluslhrim Plus Sign In Left Half Circle  
U+02A2E \oplusrhrim Plus Sign In Right Half Circle  
U+02A2F ⨯ \Times Vector Or Cross Product  
U+02A30 \dottimes Multiplication Sign With Dot Above  
U+02A31 \timesbar Multiplication Sign With Underbar  
U+02A32 \btimes Semidirect Product With Bottom Closed  
U+02A33 \smashtimes Smash Product  
U+02A34 \otimeslhrim Multiplication Sign In Left Half Circle  
U+02A35 \otimesrhrim Multiplication Sign In Right Half Circle  
U+02A36 \otimeshat Circled Multiplication Sign With Circumflex Accent  
U+02A37 \Otimes Multiplication Sign In Double Circle  
U+02A38 \odiv Circled Division Sign  
U+02A39 \triangleplus Plus Sign In Triangle  
U+02A3A \triangleminus Minus Sign In Triangle  
U+02A3B \triangletimes Multiplication Sign In Triangle  
U+02A3C \intprod Interior Product  
U+02A3D \intprodr Righthand Interior Product  
U+02A3F \amalg Amalgamation Or Coproduct  
U+02A40 \capdot Intersection With Dot  
U+02A41 \uminus Union With Minus Sign  
U+02A42 \barcup Union With Overbar  
U+02A43 \barcap Intersection With Overbar  
U+02A44 \capwedge Intersection With Logical And  
U+02A45 \cupvee Union With Logical Or  
U+02A4A \twocups Union Beside And Joined With Union  
U+02A4B \twocaps Intersection Beside And Joined With Intersection  
U+02A4C \closedvarcup Closed Union With Serifs  
U+02A4D \closedvarcap Closed Intersection With Serifs  
U+02A4E \Sqcap Double Square Intersection  
U+02A4F \Sqcup Double Square Union  
U+02A50 \closedvarcupsmash-  
prod

Closed Union With Serifs And Smash Product

U+02A51 \wedgeodot Logical And With Dot Above  
U+02A52 \veeodot Logical Or With Dot Above  
U+02A53 \And Double Logical And  
U+02A54 \Or Double Logical Or  
U+02A55 \wedgeonwedge Two Intersecting Logical And  
U+02A56 \ElOr Two Intersecting Logical Or  
U+02A57 \bigslopedvee Sloping Large Or  
U+02A58 \bigslopedwedge Sloping Large And  
U+02A5A \wedgemidvert Logical And With Middle Stem  
U+02A5B \veemidvert Logical Or With Middle Stem  
U+02A5C \midbarwedge Logical And With Horizontal Dash  
U+02A5D \midbarvee Logical Or With Horizontal Dash  
U+02A5E \perspcorrespond Logical And With Double Overbar  
U+02A5F \minhat Logical And With Underbar  
U+02A60 \wedgedoublebar Logical And With Double Underbar  
U+02A61 \varveebar Small Vee With Underbar  
U+02A62 \doublebarvee Logical Or With Double Overbar  
U+02A63 \veedoublebar Logical Or With Double Underbar  
U+02A66 \eqdot Equals Sign With Dot Below  
U+02A67 \dotequiv Identical With Dot Above  
U+02A6A ⩪ \dotsim Tilde Operator With Dot Above  
U+02A6B ⩫ \simrdots Tilde Operator With Rising Dots  
U+02A6C \simminussim Similar Minus Similar  
U+02A6D \congdot Congruent With Dot Above  
U+02A6E \asteq Equals With Asterisk  
U+02A6F \hatapprox Almost Equal To With Circumflex Accent  
U+02A70 \approxeqq Approximately Equal Or Equal To  
U+02A71 \eqqplus Equals Sign Above Plus Sign  
U+02A72 \pluseqq Plus Sign Above Equals Sign  
U+02A73 \eqqsim Equals Sign Above Tilde Operator  
U+02A74 \Coloneq Double Colon Equal  
U+02A75 \Equal Two Consecutive Equals Signs  
U+02A76 \eqeqeq Three Consecutive Equals Signs  
U+02A77 \ddotseq Equals Sign With Two Dots Above And Two Dots Below  
U+02A78 \equivDD Equivalent With Four Dots Above  
U+02A79 \ltcir Less-Than With Circle Inside  
U+02A7A \gtcir Greater-Than With Circle Inside  
U+02A7B \ltquest Less-Than With Question Mark Above  
U+02A7C \gtquest Greater-Than With Question Mark Above  
U+02A7D ⩽ \leqslant Less-Than Or Slanted Equal To  
U+02A7D

U+00338

⩽̸ \nleqslant Less-Than Or Slanted Equal To + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+02A7E ⩾ \geqslant Greater-Than Or Slanted Equal To  
U+02A7E

U+00338

⩾̸ \ngeqslant Greater-Than Or Slanted Equal To + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+02A7F ⩿ \lesdot Less-Than Or Slanted Equal To With Dot Inside  
U+02A80 ⪀ \gesdot Greater-Than Or Slanted Equal To With Dot Inside  
U+02A81 ⪁ \lesdoto Less-Than Or Slanted Equal To With Dot Above  
U+02A82 ⪂ \gesdoto Greater-Than Or Slanted Equal To With Dot Above  
U+02A83 ⪃ \lesdotor Less-Than Or Slanted Equal To With Dot Above Right  
U+02A84 ⪄ \gesdotol Greater-Than Or Slanted Equal To With Dot Above Left  
U+02A85 ⪅ \lessapprox Less-Than Or Approximate  
U+02A86 ⪆ \gtrapprox Greater-Than Or Approximate  
U+02A87 ⪇ \lneq Less-Than And Single-Line Not Equal To  
U+02A88 ⪈ \gneq Greater-Than And Single-Line Not Equal To  
U+02A89 ⪉ \lnapprox Less-Than And Not Approximate  
U+02A8A ⪊ \gnapprox Greater-Than And Not Approximate  
U+02A8B ⪋ \lesseqqgtr Less-Than Above Double-Line Equal Above  
Greater-Than  
U+02A8C ⪌ \gtreqqless Greater-Than Above Double-Line Equal Above  
Less-Than  
U+02A8D ⪍ \lsime Less-Than Above Similar Or Equal  
U+02A8E ⪎ \gsime Greater-Than Above Similar Or Equal  
U+02A8F ⪏ \lsimg Less-Than Above Similar Above Greater-Than  
U+02A90 ⪐ \gsiml Greater-Than Above Similar Above Less-Than  
U+02A91 ⪑ \lgE Less-Than Above Greater-Than Above Double-Line  
Equal  
U+02A92 ⪒ \glE Greater-Than Above Less-Than Above Double-Line  
Equal  
U+02A93 ⪓ \lesges Less-Than Above Slanted Equal Above Greater-Than  
Above Slanted Equal  
U+02A94 ⪔ \gesles Greater-Than Above Slanted Equal Above Less-Than  
Above Slanted Equal  
U+02A95 ⪕ \eqslantless Slanted Equal To Or Less-Than  
U+02A96 ⪖ \eqslantgtr Slanted Equal To Or Greater-Than  
U+02A97 ⪗ \elsdot Slanted Equal To Or Less-Than With Dot Inside  
U+02A98 ⪘ \egsdot Slanted Equal To Or Greater-Than With Dot Inside  
U+02A99 ⪙ \eqqless Double-Line Equal To Or Less-Than  
U+02A9A ⪚ \eqqgtr Double-Line Equal To Or Greater-Than  
U+02A9B ⪛ \eqqslantless Double-Line Slanted Equal To Or Less-Than  
U+02A9C ⪜ \eqqslantgtr Double-Line Slanted Equal To Or Greater-Than  
U+02A9D ⪝ \simless Similar Or Less-Than  
U+02A9E ⪞ \simgtr Similar Or Greater-Than  
U+02A9F ⪟ \simlE Similar Above Less-Than Above Equals Sign  
U+02AA0 ⪠ \simgE Similar Above Greater-Than Above Equals Sign  
U+02AA1 \NestedLessLess Double Nested Less-Than  
U+02AA1

U+00338

̸ \NotNestedLessLess Double Nested Less-Than + Combining Long Solidus  
Overlay / Non-Spacing Long Slash Overlay

U+02AA2 \NestedGreaterGreater Double Nested Greater-Than  
U+02AA2

U+00338

̸ \NotNestedGreater-  
Greater

Double Nested Greater-Than + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+02AA3 \partialmeetcontraction Double Nested Less-Than With Underbar  
U+02AA4 \glj Greater-Than Overlapping Less-Than  
U+02AA5 \gla Greater-Than Beside Less-Than  
U+02AA6 \ltcc Less-Than Closed By Curve  
U+02AA7 \gtcc Greater-Than Closed By Curve  
U+02AA8 \lescc Less-Than Closed By Curve Above Slanted Equal  
U+02AA9 \gescc Greater-Than Closed By Curve Above Slanted Equal  
U+02AAA \smt Smaller Than  
U+02AAB \lat Larger Than  
U+02AAC \smte Smaller Than Or Equal To  
U+02AAD \late Larger Than Or Equal To  
U+02AAE ⪮ \bumpeqq Equals Sign With Bumpy Above  
U+02AAF ⪯ \preceq Precedes Above Single-Line Equals Sign  
U+02AAF

U+00338

⪯̸ \npreceq Precedes Above Single-Line Equals Sign + Combining  
Long Solidus Overlay / Non-Spacing Long Slash Overlay

U+02AB0 ⪰ \succeq Succeeds Above Single-Line Equals Sign  
U+02AB0

U+00338

⪰̸ \nsucceq Succeeds Above Single-Line Equals Sign + Combining  
Long Solidus Overlay / Non-Spacing Long Slash Overlay

U+02AB1 ⪱ \precneq Precedes Above Single-Line Not Equal To  
U+02AB2 ⪲ \succneq Succeeds Above Single-Line Not Equal To  
U+02AB3 ⪳ \preceqq Precedes Above Equals Sign  
U+02AB4 ⪴ \succeqq Succeeds Above Equals Sign  
U+02AB5 ⪵ \precneqq Precedes Above Not Equal To  
U+02AB6 ⪶ \succneqq Succeeds Above Not Equal To  
U+02AB7 ⪷ \precapprox Precedes Above Almost Equal To  
U+02AB8 ⪸ \succapprox Succeeds Above Almost Equal To  
U+02AB9 ⪹ \precnapprox Precedes Above Not Almost Equal To  
U+02ABA ⪺ \succnapprox Succeeds Above Not Almost Equal To  
U+02ABB \Prec Double Precedes  
U+02ABC \Succ Double Succeeds  
U+02ABD \subsetdot Subset With Dot  
U+02ABE \supsetdot Superset With Dot  
U+02ABF \subsetplus Subset With Plus Sign Below  
U+02AC0 \supsetplus Superset With Plus Sign Below  
U+02AC1 \submult Subset With Multiplication Sign Below  
U+02AC2 \supmult Superset With Multiplication Sign Below  
U+02AC3 \subedot Subset Of Or Equal To With Dot Above  
U+02AC4 \supedot Superset Of Or Equal To With Dot Above  
U+02AC5 \subseteqq Subset Of Above Equals Sign  
U+02AC5

U+00338

̸ \nsubseteqq Subset Of Above Equals Sign + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+02AC6 \supseteqq Superset Of Above Equals Sign  
U+02AC6

U+00338

̸ \nsupseteqq Superset Of Above Equals Sign + Combining Long  
Solidus Overlay / Non-Spacing Long Slash Overlay

U+02AC7 \subsim Subset Of Above Tilde Operator  
U+02AC8 \supsim Superset Of Above Tilde Operator  
U+02AC9 \subsetapprox Subset Of Above Almost Equal To  
U+02ACA \supsetapprox Superset Of Above Almost Equal To  
U+02ACB \subsetneqq Subset Of Above Not Equal To  
U+02ACC \supsetneqq Superset Of Above Not Equal To  
U+02ACD \lsqhook Square Left Open Box Operator  
U+02ACE \rsqhook Square Right Open Box Operator  
U+02ACF \csub Closed Subset  
U+02AD0 \csup Closed Superset  
U+02AD1 \csube Closed Subset Or Equal To  
U+02AD2 \csupe Closed Superset Or Equal To  
U+02AD3 \subsup Subset Above Superset  
U+02AD4 \supsub Superset Above Subset  
U+02AD5 \subsub Subset Above Subset  
U+02AD6 \supsup Superset Above Superset  
U+02AD7 \suphsub Superset Beside Subset  
U+02AD8 \supdsub Superset Beside And Joined By Dash With Subset  
U+02AD9 \forkv Element Of Opening Downwards  
U+02ADB \mlcp Transversal Intersection  
U+02ADC \forks Forking  
U+02ADD \forksnot Nonforking  
U+02AE3 \dashV Double Vertical Bar Left Turnstile  
U+02AE4 \Dashv Vertical Bar Double Left Turnstile  
U+02AEA \Top, \downvDash Double Down Tack  
U+02AEB \upvDash, \Bot, \indep Double Up Tack  
U+02AF4 \interleave Triple Vertical Bar Binary Relation  
U+02AF6 \tdcol Triple Colon Operator  
U+02AF7 \lllnest Triple Nested Less-Than  
U+02AF8 \gggnest Triple Nested Greater-Than  
U+02AF9 ⫹ \leqqslant Double-Line Slanted Less-Than Or Equal To  
U+02AFA ⫺ \geqqslant Double-Line Slanted Greater-Than Or Equal To  
U+02B05 ⬅ :arrow_left: Leftwards Black Arrow  
U+02B06 ⬆ :arrow_up: Upwards Black Arrow  
U+02B07 ⬇ :arrow_down: Downwards Black Arrow  
U+02B12 ⬒ \squaretopblack Square With Top Half Black  
U+02B13 ⬓ \squarebotblack Square With Bottom Half Black  
U+02B14 ⬔ \squareurblack Square With Upper Right Diagonal Half Black  
U+02B15 ⬕ \squarellblack Square With Lower Left Diagonal Half Black  
U+02B16 ⬖ \diamondleftblack Diamond With Left Half Black  
U+02B17 ⬗ \diamondrightblack Diamond With Right Half Black  
U+02B18 ⬘ \diamondtopblack Diamond With Top Half Black  
U+02B19 ⬙ \diamondbotblack Diamond With Bottom Half Black  
U+02B1A ⬚ \dottedsquare Dotted Square  
U+02B1B \lgblksquare,  
:black_large_square:

Black Large Square

U+02B1C \lgwhtsquare,  
:white_large_square:

White Large Square

U+02B1D \vysmblksquare Black Very Small Square  
U+02B1E \vysmwhtsquare White Very Small Square  
U+02B1F ⬟ \pentagonblack Black Pentagon  
U+02B20 ⬠ \pentagon White Pentagon  
U+02B21 ⬡ \varhexagon White Hexagon  
U+02B22 ⬢ \varhexagonblack Black Hexagon  
U+02B23 ⬣ \hexagonblack Horizontal Black Hexagon  
U+02B24 ⬤ \lgblkcircle Black Large Circle  
U+02B25 \mdblkdiamond Black Medium Diamond  
U+02B26 \mdwhtdiamond White Medium Diamond  
U+02B27 \mdblklozenge Black Medium Lozenge  
U+02B28 \mdwhtlozenge White Medium Lozenge  
U+02B29 \smblkdiamond Black Small Diamond  
U+02B2A \smblklozenge Black Small Lozenge  
U+02B2B \smwhtlozenge White Small Lozenge  
U+02B2C \blkhorzoval Black Horizontal Ellipse  
U+02B2D \whthorzoval White Horizontal Ellipse  
U+02B2E \blkvertoval Black Vertical Ellipse  
U+02B2F \whtvertoval White Vertical Ellipse  
U+02B30 \circleonleftarrow Left Arrow With Small Circle  
U+02B31 \leftthreearrows Three Leftwards Arrows  
U+02B32 \leftarrowonoplus Left Arrow With Circled Plus  
U+02B33 \longleftsquigarrow Long Leftwards Squiggle Arrow  
U+02B34 \nvtwoheadleftarrow Leftwards Two-Headed Arrow With Vertical Stroke  
U+02B35 \nVtwoheadleftarrow Leftwards Two-Headed Arrow With Double Vertical  
Stroke  
U+02B36 \twoheadmapsfrom Leftwards Two-Headed Arrow From Bar  
U+02B37 \twoheadleftdbkarrow Leftwards Two-Headed Triple Dash Arrow  
U+02B38 \leftdotarrow Leftwards Arrow With Dotted Stem  
U+02B39 \nvleftarrowtail Leftwards Arrow With Tail With Vertical Stroke  
U+02B3A \nVleftarrowtail Leftwards Arrow With Tail With Double Vertical Stroke  
U+02B3B \twoheadleftarrowtail Leftwards Two-Headed Arrow With Tail  
U+02B3C \nvtwoheadleftarrowtail Leftwards Two-Headed Arrow With Tail With Vertical  
Stroke  
U+02B3D \nVtwoheadleftarrowtail Leftwards Two-Headed Arrow With Tail With Double  
Vertical Stroke  
U+02B3E \leftarrowx Leftwards Arrow Through X  
U+02B3F \leftcurvedarrow Wave Arrow Pointing Directly Left  
U+02B40 \equalleftarrow Equals Sign Above Leftwards Arrow  
U+02B41 \bsimilarleftarrow Reverse Tilde Operator Above Leftwards Arrow  
U+02B42 \leftarrowbackapprox Leftwards Arrow Above Reverse Almost Equal To  
U+02B43 \rightarrowgtr Rightwards Arrow Through Greater-Than  
U+02B44 \rightarrowsupset Rightwards Arrow Through Superset  
U+02B45 \LLeftarrow Leftwards Quadruple Arrow  
U+02B46 \RRightarrow Rightwards Quadruple Arrow  
U+02B47 \bsimilarrightarrow Reverse Tilde Operator Above Rightwards Arrow  
U+02B48 \rightarrowbackapprox Rightwards Arrow Above Reverse Almost Equal To  
U+02B49 \similarleftarrow Tilde Operator Above Leftwards Arrow  
U+02B4A \leftarrowapprox Leftwards Arrow Above Almost Equal To  
U+02B4B \leftarrowbsimilar Leftwards Arrow Above Reverse Tilde Operator  
U+02B4C \rightarrowbsimilar Rightwards Arrow Above Reverse Tilde Operator  
U+02B50 \medwhitestar, :star: White Medium Star  
U+02B51 \medblackstar Black Small Star  
U+02B52 \smwhitestar White Small Star  
U+02B53 ⭓ \rightpentagonblack Black Right-Pointing Pentagon  
U+02B54 ⭔ \rightpentagon White Right-Pointing Pentagon  
U+02B55 :o: Heavy Large Circle  
U+02C7C ⱼ _j Latin Subscript Small Letter J  
U+02C7D ⱽ ^V Modifier Letter Capital V  
U+03012 \postalmark Postal Mark  
U+03030 :wavy_dash: Wavy Dash  
U+0303D :part_alternation_mark: Part Alternation Mark  
U+03297 :congratulations: Circled Ideograph Congratulation  
U+03299 :secret: Circled Ideograph Secret  
U+0A71B ꜛ ^uparrow Modifier Letter Raised Up Arrow  
U+0A71C ꜜ ^downarrow Modifier Letter Raised Down Arrow  
U+0A71D ꜝ ^! Modifier Letter Raised Exclamation Mark  
U+1D400 \bfA Mathematical Bold Capital A  
U+1D401 \bfB Mathematical Bold Capital B  
U+1D402 \bfC Mathematical Bold Capital C  
U+1D403 \bfD Mathematical Bold Capital D  
U+1D404 \bfE Mathematical Bold Capital E  
U+1D405 \bfF Mathematical Bold Capital F  
U+1D406 \bfG Mathematical Bold Capital G  
U+1D407 \bfH Mathematical Bold Capital H  
U+1D408 \bfI Mathematical Bold Capital I  
U+1D409 \bfJ Mathematical Bold Capital J  
U+1D40A \bfK Mathematical Bold Capital K  
U+1D40B \bfL Mathematical Bold Capital L  
U+1D40C \bfM Mathematical Bold Capital M  
U+1D40D \bfN Mathematical Bold Capital N  
U+1D40E \bfO Mathematical Bold Capital O  
U+1D40F \bfP Mathematical Bold Capital P  
U+1D410 \bfQ Mathematical Bold Capital Q  
U+1D411 \bfR Mathematical Bold Capital R  
U+1D412 \bfS Mathematical Bold Capital S  
U+1D413 \bfT Mathematical Bold Capital T  
U+1D414 \bfU Mathematical Bold Capital U  
U+1D415 \bfV Mathematical Bold Capital V  
U+1D416 \bfW Mathematical Bold Capital W  
U+1D417 \bfX Mathematical Bold Capital X  
U+1D418 \bfY Mathematical Bold Capital Y  
U+1D419 \bfZ Mathematical Bold Capital Z  
U+1D41A \bfa Mathematical Bold Small A  
U+1D41B \bfb Mathematical Bold Small B  
U+1D41C \bfc Mathematical Bold Small C  
U+1D41D \bfd Mathematical Bold Small D  
U+1D41E \bfe Mathematical Bold Small E  
U+1D41F \bff Mathematical Bold Small F  
U+1D420 \bfg Mathematical Bold Small G  
U+1D421 \bfh Mathematical Bold Small H  
U+1D422 \bfi Mathematical Bold Small I  
U+1D423 \bfj Mathematical Bold Small J  
U+1D424 \bfk Mathematical Bold Small K  
U+1D425 \bfl Mathematical Bold Small L  
U+1D426 \bfm Mathematical Bold Small M  
U+1D427 \bfn Mathematical Bold Small N  
U+1D428 \bfo Mathematical Bold Small O  
U+1D429 \bfp Mathematical Bold Small P  
U+1D42A \bfq Mathematical Bold Small Q  
U+1D42B \bfr Mathematical Bold Small R  
U+1D42C \bfs Mathematical Bold Small S  
U+1D42D \bft Mathematical Bold Small T  
U+1D42E \bfu Mathematical Bold Small U  
U+1D42F \bfv Mathematical Bold Small V  
U+1D430 \bfw Mathematical Bold Small W  
U+1D431 \bfx Mathematical Bold Small X  
U+1D432 \bfy Mathematical Bold Small Y  
U+1D433 \bfz Mathematical Bold Small Z  
U+1D434 \itA Mathematical Italic Capital A  
U+1D435 \itB Mathematical Italic Capital B  
U+1D436 \itC Mathematical Italic Capital C  
U+1D437 \itD Mathematical Italic Capital D  
U+1D438 \itE Mathematical Italic Capital E  
U+1D439 \itF Mathematical Italic Capital F  
U+1D43A \itG Mathematical Italic Capital G  
U+1D43B \itH Mathematical Italic Capital H  
U+1D43C \itI Mathematical Italic Capital I  
U+1D43D \itJ Mathematical Italic Capital J  
U+1D43E \itK Mathematical Italic Capital K  
U+1D43F \itL Mathematical Italic Capital L  
U+1D440 \itM Mathematical Italic Capital M  
U+1D441 \itN Mathematical Italic Capital N  
U+1D442 \itO Mathematical Italic Capital O  
U+1D443 \itP Mathematical Italic Capital P  
U+1D444 \itQ Mathematical Italic Capital Q  
U+1D445 \itR Mathematical Italic Capital R  
U+1D446 \itS Mathematical Italic Capital S  
U+1D447 \itT Mathematical Italic Capital T  
U+1D448 \itU Mathematical Italic Capital U  
U+1D449 \itV Mathematical Italic Capital V  
U+1D44A \itW Mathematical Italic Capital W  
U+1D44B \itX Mathematical Italic Capital X  
U+1D44C \itY Mathematical Italic Capital Y  
U+1D44D \itZ Mathematical Italic Capital Z  
U+1D44E \ita Mathematical Italic Small A  
U+1D44F \itb Mathematical Italic Small B  
U+1D450 \itc Mathematical Italic Small C  
U+1D451 \itd Mathematical Italic Small D  
U+1D452 \ite Mathematical Italic Small E  
U+1D453 \itf Mathematical Italic Small F  
U+1D454 \itg Mathematical Italic Small G  
U+1D456 \iti Mathematical Italic Small I  
U+1D457 \itj Mathematical Italic Small J  
U+1D458 \itk Mathematical Italic Small K  
U+1D459 \itl Mathematical Italic Small L  
U+1D45A \itm Mathematical Italic Small M  
U+1D45B \itn Mathematical Italic Small N  
U+1D45C \ito Mathematical Italic Small O  
U+1D45D \itp Mathematical Italic Small P  
U+1D45E \itq Mathematical Italic Small Q  
U+1D45F \itr Mathematical Italic Small R  
U+1D460 \its Mathematical Italic Small S  
U+1D461 \itt Mathematical Italic Small T  
U+1D462 \itu Mathematical Italic Small U  
U+1D463 \itv Mathematical Italic Small V  
U+1D464 \itw Mathematical Italic Small W  
U+1D465 \itx Mathematical Italic Small X  
U+1D466 \ity Mathematical Italic Small Y  
U+1D467 \itz Mathematical Italic Small Z  
U+1D468 \biA Mathematical Bold Italic Capital A  
U+1D469 \biB Mathematical Bold Italic Capital B  
U+1D46A \biC Mathematical Bold Italic Capital C  
U+1D46B \biD Mathematical Bold Italic Capital D  
U+1D46C \biE Mathematical Bold Italic Capital E  
U+1D46D \biF Mathematical Bold Italic Capital F  
U+1D46E \biG Mathematical Bold Italic Capital G  
U+1D46F \biH Mathematical Bold Italic Capital H  
U+1D470 \biI Mathematical Bold Italic Capital I  
U+1D471 \biJ Mathematical Bold Italic Capital J  
U+1D472 \biK Mathematical Bold Italic Capital K  
U+1D473 \biL Mathematical Bold Italic Capital L  
U+1D474 \biM Mathematical Bold Italic Capital M  
U+1D475 \biN Mathematical Bold Italic Capital N  
U+1D476 \biO Mathematical Bold Italic Capital O  
U+1D477 \biP Mathematical Bold Italic Capital P  
U+1D478 \biQ Mathematical Bold Italic Capital Q  
U+1D479 \biR Mathematical Bold Italic Capital R  
U+1D47A \biS Mathematical Bold Italic Capital S  
U+1D47B \biT Mathematical Bold Italic Capital T  
U+1D47C \biU Mathematical Bold Italic Capital U  
U+1D47D \biV Mathematical Bold Italic Capital V  
U+1D47E \biW Mathematical Bold Italic Capital W  
U+1D47F \biX Mathematical Bold Italic Capital X  
U+1D480 \biY Mathematical Bold Italic Capital Y  
U+1D481 \biZ Mathematical Bold Italic Capital Z  
U+1D482 \bia Mathematical Bold Italic Small A  
U+1D483 \bib Mathematical Bold Italic Small B  
U+1D484 \bic Mathematical Bold Italic Small C  
U+1D485 \bid Mathematical Bold Italic Small D  
U+1D486 \bie Mathematical Bold Italic Small E  
U+1D487 \bif Mathematical Bold Italic Small F  
U+1D488 \big Mathematical Bold Italic Small G  
U+1D489 \bih Mathematical Bold Italic Small H  
U+1D48A \bii Mathematical Bold Italic Small I  
U+1D48B \bij Mathematical Bold Italic Small J  
U+1D48C \bik Mathematical Bold Italic Small K  
U+1D48D \bil Mathematical Bold Italic Small L  
U+1D48E \bim Mathematical Bold Italic Small M  
U+1D48F \bin Mathematical Bold Italic Small N  
U+1D490 \bio Mathematical Bold Italic Small O  
U+1D491 \bip Mathematical Bold Italic Small P  
U+1D492 \biq Mathematical Bold Italic Small Q  
U+1D493 \bir Mathematical Bold Italic Small R  
U+1D494 \bis Mathematical Bold Italic Small S  
U+1D495 \bit Mathematical Bold Italic Small T  
U+1D496 \biu Mathematical Bold Italic Small U  
U+1D497 \biv Mathematical Bold Italic Small V  
U+1D498 \biw Mathematical Bold Italic Small W  
U+1D499 \bix Mathematical Bold Italic Small X  
U+1D49A \biy Mathematical Bold Italic Small Y  
U+1D49B \biz Mathematical Bold Italic Small Z  
U+1D49C \scrA Mathematical Script Capital A  
U+1D49E \scrC Mathematical Script Capital C  
U+1D49F \scrD Mathematical Script Capital D  
U+1D4A2 \scrG Mathematical Script Capital G  
U+1D4A5 \scrJ Mathematical Script Capital J  
U+1D4A6 \scrK Mathematical Script Capital K  
U+1D4A9 \scrN Mathematical Script Capital N  
U+1D4AA \scrO Mathematical Script Capital O  
U+1D4AB \scrP Mathematical Script Capital P  
U+1D4AC \scrQ Mathematical Script Capital Q  
U+1D4AE \scrS Mathematical Script Capital S  
U+1D4AF \scrT Mathematical Script Capital T  
U+1D4B0 \scrU Mathematical Script Capital U  
U+1D4B1 \scrV Mathematical Script Capital V  
U+1D4B2 \scrW Mathematical Script Capital W  
U+1D4B3 \scrX Mathematical Script Capital X  
U+1D4B4 \scrY Mathematical Script Capital Y  
U+1D4B5 \scrZ Mathematical Script Capital Z  
U+1D4B6 \scra Mathematical Script Small A  
U+1D4B7 \scrb Mathematical Script Small B  
U+1D4B8 \scrc Mathematical Script Small C  
U+1D4B9 \scrd Mathematical Script Small D  
U+1D4BB \scrf Mathematical Script Small F  
U+1D4BD \scrh Mathematical Script Small H  
U+1D4BE \scri Mathematical Script Small I  
U+1D4BF \scrj Mathematical Script Small J  
U+1D4C0 \scrk Mathematical Script Small K  
U+1D4C1 \scrl Mathematical Script Small L  
U+1D4C2 \scrm Mathematical Script Small M  
U+1D4C3 \scrn Mathematical Script Small N  
U+1D4C5 \scrp Mathematical Script Small P  
U+1D4C6 \scrq Mathematical Script Small Q  
U+1D4C7 \scrr Mathematical Script Small R  
U+1D4C8 \scrs Mathematical Script Small S  
U+1D4C9 \scrt Mathematical Script Small T  
U+1D4CA \scru Mathematical Script Small U  
U+1D4CB \scrv Mathematical Script Small V  
U+1D4CC \scrw Mathematical Script Small W  
U+1D4CD \scrx Mathematical Script Small X  
U+1D4CE \scry Mathematical Script Small Y  
U+1D4CF \scrz Mathematical Script Small Z  
U+1D4D0 \bscrA Mathematical Bold Script Capital A  
U+1D4D1 \bscrB Mathematical Bold Script Capital B  
U+1D4D2 \bscrC Mathematical Bold Script Capital C  
U+1D4D3 \bscrD Mathematical Bold Script Capital D  
U+1D4D4 \bscrE Mathematical Bold Script Capital E  
U+1D4D5 \bscrF Mathematical Bold Script Capital F  
U+1D4D6 \bscrG Mathematical Bold Script Capital G  
U+1D4D7 \bscrH Mathematical Bold Script Capital H  
U+1D4D8 \bscrI Mathematical Bold Script Capital I  
U+1D4D9 \bscrJ Mathematical Bold Script Capital J  
U+1D4DA \bscrK Mathematical Bold Script Capital K  
U+1D4DB \bscrL Mathematical Bold Script Capital L  
U+1D4DC \bscrM Mathematical Bold Script Capital M  
U+1D4DD \bscrN Mathematical Bold Script Capital N  
U+1D4DE \bscrO Mathematical Bold Script Capital O  
U+1D4DF \bscrP Mathematical Bold Script Capital P  
U+1D4E0 \bscrQ Mathematical Bold Script Capital Q  
U+1D4E1 \bscrR Mathematical Bold Script Capital R  
U+1D4E2 \bscrS Mathematical Bold Script Capital S  
U+1D4E3 \bscrT Mathematical Bold Script Capital T  
U+1D4E4 \bscrU Mathematical Bold Script Capital U  
U+1D4E5 \bscrV Mathematical Bold Script Capital V  
U+1D4E6 \bscrW Mathematical Bold Script Capital W  
U+1D4E7 \bscrX Mathematical Bold Script Capital X  
U+1D4E8 \bscrY Mathematical Bold Script Capital Y  
U+1D4E9 \bscrZ Mathematical Bold Script Capital Z  
U+1D4EA \bscra Mathematical Bold Script Small A  
U+1D4EB \bscrb Mathematical Bold Script Small B  
U+1D4EC \bscrc Mathematical Bold Script Small C  
U+1D4ED \bscrd Mathematical Bold Script Small D  
U+1D4EE \bscre Mathematical Bold Script Small E  
U+1D4EF \bscrf Mathematical Bold Script Small F  
U+1D4F0 \bscrg Mathematical Bold Script Small G  
U+1D4F1 \bscrh Mathematical Bold Script Small H  
U+1D4F2 \bscri Mathematical Bold Script Small I  
U+1D4F3 \bscrj Mathematical Bold Script Small J  
U+1D4F4 \bscrk Mathematical Bold Script Small K  
U+1D4F5 \bscrl Mathematical Bold Script Small L  
U+1D4F6 \bscrm Mathematical Bold Script Small M  
U+1D4F7 \bscrn Mathematical Bold Script Small N  
U+1D4F8 \bscro Mathematical Bold Script Small O  
U+1D4F9 \bscrp Mathematical Bold Script Small P  
U+1D4FA \bscrq Mathematical Bold Script Small Q  
U+1D4FB \bscrr Mathematical Bold Script Small R  
U+1D4FC \bscrs Mathematical Bold Script Small S  
U+1D4FD \bscrt Mathematical Bold Script Small T  
U+1D4FE \bscru Mathematical Bold Script Small U  
U+1D4FF \bscrv Mathematical Bold Script Small V  
U+1D500 \bscrw Mathematical Bold Script Small W  
U+1D501 \bscrx Mathematical Bold Script Small X  
U+1D502 \bscry Mathematical Bold Script Small Y  
U+1D503 \bscrz Mathematical Bold Script Small Z  
U+1D504 \frakA Mathematical Fraktur Capital A  
U+1D505 \frakB Mathematical Fraktur Capital B  
U+1D507 \frakD Mathematical Fraktur Capital D  
U+1D508 \frakE Mathematical Fraktur Capital E  
U+1D509 \frakF Mathematical Fraktur Capital F  
U+1D50A \frakG Mathematical Fraktur Capital G  
U+1D50D \frakJ Mathematical Fraktur Capital J  
U+1D50E \frakK Mathematical Fraktur Capital K  
U+1D50F \frakL Mathematical Fraktur Capital L  
U+1D510 \frakM Mathematical Fraktur Capital M  
U+1D511 \frakN Mathematical Fraktur Capital N  
U+1D512 \frakO Mathematical Fraktur Capital O  
U+1D513 \frakP Mathematical Fraktur Capital P  
U+1D514 \frakQ Mathematical Fraktur Capital Q  
U+1D516 \frakS Mathematical Fraktur Capital S  
U+1D517 \frakT Mathematical Fraktur Capital T  
U+1D518 \frakU Mathematical Fraktur Capital U  
U+1D519 \frakV Mathematical Fraktur Capital V  
U+1D51A \frakW Mathematical Fraktur Capital W  
U+1D51B \frakX Mathematical Fraktur Capital X  
U+1D51C \frakY Mathematical Fraktur Capital Y  
U+1D51E \fraka Mathematical Fraktur Small A  
U+1D51F \frakb Mathematical Fraktur Small B  
U+1D520 \frakc Mathematical Fraktur Small C  
U+1D521 \frakd Mathematical Fraktur Small D  
U+1D522 \frake Mathematical Fraktur Small E  
U+1D523 \frakf Mathematical Fraktur Small F  
U+1D524 \frakg Mathematical Fraktur Small G  
U+1D525 \frakh Mathematical Fraktur Small H  
U+1D526 \fraki Mathematical Fraktur Small I  
U+1D527 \frakj Mathematical Fraktur Small J  
U+1D528 \frakk Mathematical Fraktur Small K  
U+1D529 \frakl Mathematical Fraktur Small L  
U+1D52A \frakm Mathematical Fraktur Small M  
U+1D52B \frakn Mathematical Fraktur Small N  
U+1D52C \frako Mathematical Fraktur Small O  
U+1D52D \frakp Mathematical Fraktur Small P  
U+1D52E \frakq Mathematical Fraktur Small Q  
U+1D52F \frakr Mathematical Fraktur Small R  
U+1D530 \fraks Mathematical Fraktur Small S  
U+1D531 \frakt Mathematical Fraktur Small T  
U+1D532 \fraku Mathematical Fraktur Small U  
U+1D533 \frakv Mathematical Fraktur Small V  
U+1D534 \frakw Mathematical Fraktur Small W  
U+1D535 \frakx Mathematical Fraktur Small X  
U+1D536 \fraky Mathematical Fraktur Small Y  
U+1D537 \frakz Mathematical Fraktur Small Z  
U+1D538 𝔸 \bbA Mathematical Double-Struck Capital A  
U+1D539 𝔹 \bbB Mathematical Double-Struck Capital B  
U+1D53B 𝔻 \bbD Mathematical Double-Struck Capital D  
U+1D53C 𝔼 \bbE Mathematical Double-Struck Capital E  
U+1D53D 𝔽 \bbF Mathematical Double-Struck Capital F  
U+1D53E 𝔾 \bbG Mathematical Double-Struck Capital G  
U+1D540 𝕀 \bbI Mathematical Double-Struck Capital I  
U+1D541 𝕁 \bbJ Mathematical Double-Struck Capital J  
U+1D542 𝕂 \bbK Mathematical Double-Struck Capital K  
U+1D543 𝕃 \bbL Mathematical Double-Struck Capital L  
U+1D544 𝕄 \bbM Mathematical Double-Struck Capital M  
U+1D546 𝕆 \bbO Mathematical Double-Struck Capital O  
U+1D54A 𝕊 \bbS Mathematical Double-Struck Capital S  
U+1D54B 𝕋 \bbT Mathematical Double-Struck Capital T  
U+1D54C 𝕌 \bbU Mathematical Double-Struck Capital U  
U+1D54D 𝕍 \bbV Mathematical Double-Struck Capital V  
U+1D54E 𝕎 \bbW Mathematical Double-Struck Capital W  
U+1D54F 𝕏 \bbX Mathematical Double-Struck Capital X  
U+1D550 𝕐 \bbY Mathematical Double-Struck Capital Y  
U+1D552 𝕒 \bba Mathematical Double-Struck Small A  
U+1D553 𝕓 \bbb Mathematical Double-Struck Small B  
U+1D554 𝕔 \bbc Mathematical Double-Struck Small C  
U+1D555 𝕕 \bbd Mathematical Double-Struck Small D  
U+1D556 𝕖 \bbe Mathematical Double-Struck Small E  
U+1D557 𝕗 \bbf Mathematical Double-Struck Small F  
U+1D558 𝕘 \bbg Mathematical Double-Struck Small G  
U+1D559 𝕙 \bbh Mathematical Double-Struck Small H  
U+1D55A 𝕚 \bbi Mathematical Double-Struck Small I  
U+1D55B 𝕛 \bbj Mathematical Double-Struck Small J  
U+1D55C 𝕜 \bbk Mathematical Double-Struck Small K  
U+1D55D 𝕝 \bbl Mathematical Double-Struck Small L  
U+1D55E 𝕞 \bbm Mathematical Double-Struck Small M  
U+1D55F 𝕟 \bbn Mathematical Double-Struck Small N  
U+1D560 𝕠 \bbo Mathematical Double-Struck Small O  
U+1D561 𝕡 \bbp Mathematical Double-Struck Small P  
U+1D562 𝕢 \bbq Mathematical Double-Struck Small Q  
U+1D563 𝕣 \bbr Mathematical Double-Struck Small R  
U+1D564 𝕤 \bbs Mathematical Double-Struck Small S  
U+1D565 𝕥 \bbt Mathematical Double-Struck Small T  
U+1D566 𝕦 \bbu Mathematical Double-Struck Small U  
U+1D567 𝕧 \bbv Mathematical Double-Struck Small V  
U+1D568 𝕨 \bbw Mathematical Double-Struck Small W  
U+1D569 𝕩 \bbx Mathematical Double-Struck Small X  
U+1D56A 𝕪 \bby Mathematical Double-Struck Small Y  
U+1D56B 𝕫 \bbz Mathematical Double-Struck Small Z  
U+1D56C \bfrakA Mathematical Bold Fraktur Capital A  
U+1D56D \bfrakB Mathematical Bold Fraktur Capital B  
U+1D56E \bfrakC Mathematical Bold Fraktur Capital C  
U+1D56F \bfrakD Mathematical Bold Fraktur Capital D  
U+1D570 \bfrakE Mathematical Bold Fraktur Capital E  
U+1D571 \bfrakF Mathematical Bold Fraktur Capital F  
U+1D572 \bfrakG Mathematical Bold Fraktur Capital G  
U+1D573 \bfrakH Mathematical Bold Fraktur Capital H  
U+1D574 \bfrakI Mathematical Bold Fraktur Capital I  
U+1D575 \bfrakJ Mathematical Bold Fraktur Capital J  
U+1D576 \bfrakK Mathematical Bold Fraktur Capital K  
U+1D577 \bfrakL Mathematical Bold Fraktur Capital L  
U+1D578 \bfrakM Mathematical Bold Fraktur Capital M  
U+1D579 \bfrakN Mathematical Bold Fraktur Capital N  
U+1D57A \bfrakO Mathematical Bold Fraktur Capital O  
U+1D57B \bfrakP Mathematical Bold Fraktur Capital P  
U+1D57C \bfrakQ Mathematical Bold Fraktur Capital Q  
U+1D57D \bfrakR Mathematical Bold Fraktur Capital R  
U+1D57E \bfrakS Mathematical Bold Fraktur Capital S  
U+1D57F \bfrakT Mathematical Bold Fraktur Capital T  
U+1D580 \bfrakU Mathematical Bold Fraktur Capital U  
U+1D581 \bfrakV Mathematical Bold Fraktur Capital V  
U+1D582 \bfrakW Mathematical Bold Fraktur Capital W  
U+1D583 \bfrakX Mathematical Bold Fraktur Capital X  
U+1D584 \bfrakY Mathematical Bold Fraktur Capital Y  
U+1D585 \bfrakZ Mathematical Bold Fraktur Capital Z  
U+1D586 \bfraka Mathematical Bold Fraktur Small A  
U+1D587 \bfrakb Mathematical Bold Fraktur Small B  
U+1D588 \bfrakc Mathematical Bold Fraktur Small C  
U+1D589 \bfrakd Mathematical Bold Fraktur Small D  
U+1D58A \bfrake Mathematical Bold Fraktur Small E  
U+1D58B \bfrakf Mathematical Bold Fraktur Small F  
U+1D58C \bfrakg Mathematical Bold Fraktur Small G  
U+1D58D \bfrakh Mathematical Bold Fraktur Small H  
U+1D58E \bfraki Mathematical Bold Fraktur Small I  
U+1D58F \bfrakj Mathematical Bold Fraktur Small J  
U+1D590 \bfrakk Mathematical Bold Fraktur Small K  
U+1D591 \bfrakl Mathematical Bold Fraktur Small L  
U+1D592 \bfrakm Mathematical Bold Fraktur Small M  
U+1D593 \bfrakn Mathematical Bold Fraktur Small N  
U+1D594 \bfrako Mathematical Bold Fraktur Small O  
U+1D595 \bfrakp Mathematical Bold Fraktur Small P  
U+1D596 \bfrakq Mathematical Bold Fraktur Small Q  
U+1D597 \bfrakr Mathematical Bold Fraktur Small R  
U+1D598 \bfraks Mathematical Bold Fraktur Small S  
U+1D599 \bfrakt Mathematical Bold Fraktur Small T  
U+1D59A \bfraku Mathematical Bold Fraktur Small U  
U+1D59B \bfrakv Mathematical Bold Fraktur Small V  
U+1D59C \bfrakw Mathematical Bold Fraktur Small W  
U+1D59D \bfrakx Mathematical Bold Fraktur Small X  
U+1D59E \bfraky Mathematical Bold Fraktur Small Y  
U+1D59F \bfrakz Mathematical Bold Fraktur Small Z  
U+1D5A0 𝖠 \sansA Mathematical Sans-Serif Capital A  
U+1D5A1 𝖡 \sansB Mathematical Sans-Serif Capital B  
U+1D5A2 𝖢 \sansC Mathematical Sans-Serif Capital C  
U+1D5A3 𝖣 \sansD Mathematical Sans-Serif Capital D  
U+1D5A4 𝖤 \sansE Mathematical Sans-Serif Capital E  
U+1D5A5 𝖥 \sansF Mathematical Sans-Serif Capital F  
U+1D5A6 𝖦 \sansG Mathematical Sans-Serif Capital G  
U+1D5A7 𝖧 \sansH Mathematical Sans-Serif Capital H  
U+1D5A8 𝖨 \sansI Mathematical Sans-Serif Capital I  
U+1D5A9 𝖩 \sansJ Mathematical Sans-Serif Capital J  
U+1D5AA 𝖪 \sansK Mathematical Sans-Serif Capital K  
U+1D5AB 𝖫 \sansL Mathematical Sans-Serif Capital L  
U+1D5AC 𝖬 \sansM Mathematical Sans-Serif Capital M  
U+1D5AD 𝖭 \sansN Mathematical Sans-Serif Capital N  
U+1D5AE 𝖮 \sansO Mathematical Sans-Serif Capital O  
U+1D5AF 𝖯 \sansP Mathematical Sans-Serif Capital P  
U+1D5B0 𝖰 \sansQ Mathematical Sans-Serif Capital Q  
U+1D5B1 𝖱 \sansR Mathematical Sans-Serif Capital R  
U+1D5B2 𝖲 \sansS Mathematical Sans-Serif Capital S  
U+1D5B3 𝖳 \sansT Mathematical Sans-Serif Capital T  
U+1D5B4 𝖴 \sansU Mathematical Sans-Serif Capital U  
U+1D5B5 𝖵 \sansV Mathematical Sans-Serif Capital V  
U+1D5B6 𝖶 \sansW Mathematical Sans-Serif Capital W  
U+1D5B7 𝖷 \sansX Mathematical Sans-Serif Capital X  
U+1D5B8 𝖸 \sansY Mathematical Sans-Serif Capital Y  
U+1D5B9 𝖹 \sansZ Mathematical Sans-Serif Capital Z  
U+1D5BA 𝖺 \sansa Mathematical Sans-Serif Small A  
U+1D5BB 𝖻 \sansb Mathematical Sans-Serif Small B  
U+1D5BC 𝖼 \sansc Mathematical Sans-Serif Small C  
U+1D5BD 𝖽 \sansd Mathematical Sans-Serif Small D  
U+1D5BE 𝖾 \sanse Mathematical Sans-Serif Small E  
U+1D5BF 𝖿 \sansf Mathematical Sans-Serif Small F  
U+1D5C0 𝗀 \sansg Mathematical Sans-Serif Small G  
U+1D5C1 𝗁 \sansh Mathematical Sans-Serif Small H  
U+1D5C2 𝗂 \sansi Mathematical Sans-Serif Small I  
U+1D5C3 𝗃 \sansj Mathematical Sans-Serif Small J  
U+1D5C4 𝗄 \sansk Mathematical Sans-Serif Small K  
U+1D5C5 𝗅 \sansl Mathematical Sans-Serif Small L  
U+1D5C6 𝗆 \sansm Mathematical Sans-Serif Small M  
U+1D5C7 𝗇 \sansn Mathematical Sans-Serif Small N  
U+1D5C8 𝗈 \sanso Mathematical Sans-Serif Small O  
U+1D5C9 𝗉 \sansp Mathematical Sans-Serif Small P  
U+1D5CA 𝗊 \sansq Mathematical Sans-Serif Small Q  
U+1D5CB 𝗋 \sansr Mathematical Sans-Serif Small R  
U+1D5CC 𝗌 \sanss Mathematical Sans-Serif Small S  
U+1D5CD 𝗍 \sanst Mathematical Sans-Serif Small T  
U+1D5CE 𝗎 \sansu Mathematical Sans-Serif Small U  
U+1D5CF 𝗏 \sansv Mathematical Sans-Serif Small V  
U+1D5D0 𝗐 \sansw Mathematical Sans-Serif Small W  
U+1D5D1 𝗑 \sansx Mathematical Sans-Serif Small X  
U+1D5D2 𝗒 \sansy Mathematical Sans-Serif Small Y  
U+1D5D3 𝗓 \sansz Mathematical Sans-Serif Small Z  
U+1D5D4 \bsansA Mathematical Sans-Serif Bold Capital A  
U+1D5D5 \bsansB Mathematical Sans-Serif Bold Capital B  
U+1D5D6 \bsansC Mathematical Sans-Serif Bold Capital C  
U+1D5D7 \bsansD Mathematical Sans-Serif Bold Capital D  
U+1D5D8 \bsansE Mathematical Sans-Serif Bold Capital E  
U+1D5D9 \bsansF Mathematical Sans-Serif Bold Capital F  
U+1D5DA \bsansG Mathematical Sans-Serif Bold Capital G  
U+1D5DB \bsansH Mathematical Sans-Serif Bold Capital H  
U+1D5DC \bsansI Mathematical Sans-Serif Bold Capital I  
U+1D5DD \bsansJ Mathematical Sans-Serif Bold Capital J  
U+1D5DE \bsansK Mathematical Sans-Serif Bold Capital K  
U+1D5DF \bsansL Mathematical Sans-Serif Bold Capital L  
U+1D5E0 \bsansM Mathematical Sans-Serif Bold Capital M  
U+1D5E1 \bsansN Mathematical Sans-Serif Bold Capital N  
U+1D5E2 \bsansO Mathematical Sans-Serif Bold Capital O  
U+1D5E3 \bsansP Mathematical Sans-Serif Bold Capital P  
U+1D5E4 \bsansQ Mathematical Sans-Serif Bold Capital Q  
U+1D5E5 \bsansR Mathematical Sans-Serif Bold Capital R  
U+1D5E6 \bsansS Mathematical Sans-Serif Bold Capital S  
U+1D5E7 \bsansT Mathematical Sans-Serif Bold Capital T  
U+1D5E8 \bsansU Mathematical Sans-Serif Bold Capital U  
U+1D5E9 \bsansV Mathematical Sans-Serif Bold Capital V  
U+1D5EA \bsansW Mathematical Sans-Serif Bold Capital W  
U+1D5EB \bsansX Mathematical Sans-Serif Bold Capital X  
U+1D5EC \bsansY Mathematical Sans-Serif Bold Capital Y  
U+1D5ED \bsansZ Mathematical Sans-Serif Bold Capital Z  
U+1D5EE \bsansa Mathematical Sans-Serif Bold Small A  
U+1D5EF \bsansb Mathematical Sans-Serif Bold Small B  
U+1D5F0 \bsansc Mathematical Sans-Serif Bold Small C  
U+1D5F1 \bsansd Mathematical Sans-Serif Bold Small D  
U+1D5F2 \bsanse Mathematical Sans-Serif Bold Small E  
U+1D5F3 \bsansf Mathematical Sans-Serif Bold Small F  
U+1D5F4 \bsansg Mathematical Sans-Serif Bold Small G  
U+1D5F5 \bsansh Mathematical Sans-Serif Bold Small H  
U+1D5F6 \bsansi Mathematical Sans-Serif Bold Small I  
U+1D5F7 \bsansj Mathematical Sans-Serif Bold Small J  
U+1D5F8 \bsansk Mathematical Sans-Serif Bold Small K  
U+1D5F9 \bsansl Mathematical Sans-Serif Bold Small L  
U+1D5FA \bsansm Mathematical Sans-Serif Bold Small M  
U+1D5FB \bsansn Mathematical Sans-Serif Bold Small N  
U+1D5FC \bsanso Mathematical Sans-Serif Bold Small O  
U+1D5FD \bsansp Mathematical Sans-Serif Bold Small P  
U+1D5FE \bsansq Mathematical Sans-Serif Bold Small Q  
U+1D5FF \bsansr Mathematical Sans-Serif Bold Small R  
U+1D600 \bsanss Mathematical Sans-Serif Bold Small S  
U+1D601 \bsanst Mathematical Sans-Serif Bold Small T  
U+1D602 \bsansu Mathematical Sans-Serif Bold Small U  
U+1D603 \bsansv Mathematical Sans-Serif Bold Small V  
U+1D604 \bsansw Mathematical Sans-Serif Bold Small W  
U+1D605 \bsansx Mathematical Sans-Serif Bold Small X  
U+1D606 \bsansy Mathematical Sans-Serif Bold Small Y  
U+1D607 \bsansz Mathematical Sans-Serif Bold Small Z  
U+1D608 \isansA Mathematical Sans-Serif Italic Capital A  
U+1D609 \isansB Mathematical Sans-Serif Italic Capital B  
U+1D60A \isansC Mathematical Sans-Serif Italic Capital C  
U+1D60B \isansD Mathematical Sans-Serif Italic Capital D  
U+1D60C \isansE Mathematical Sans-Serif Italic Capital E  
U+1D60D \isansF Mathematical Sans-Serif Italic Capital F  
U+1D60E \isansG Mathematical Sans-Serif Italic Capital G  
U+1D60F \isansH Mathematical Sans-Serif Italic Capital H  
U+1D610 \isansI Mathematical Sans-Serif Italic Capital I  
U+1D611 \isansJ Mathematical Sans-Serif Italic Capital J  
U+1D612 \isansK Mathematical Sans-Serif Italic Capital K  
U+1D613 \isansL Mathematical Sans-Serif Italic Capital L  
U+1D614 \isansM Mathematical Sans-Serif Italic Capital M  
U+1D615 \isansN Mathematical Sans-Serif Italic Capital N  
U+1D616 \isansO Mathematical Sans-Serif Italic Capital O  
U+1D617 \isansP Mathematical Sans-Serif Italic Capital P  
U+1D618 \isansQ Mathematical Sans-Serif Italic Capital Q  
U+1D619 \isansR Mathematical Sans-Serif Italic Capital R  
U+1D61A \isansS Mathematical Sans-Serif Italic Capital S  
U+1D61B \isansT Mathematical Sans-Serif Italic Capital T  
U+1D61C \isansU Mathematical Sans-Serif Italic Capital U  
U+1D61D \isansV Mathematical Sans-Serif Italic Capital V  
U+1D61E \isansW Mathematical Sans-Serif Italic Capital W  
U+1D61F \isansX Mathematical Sans-Serif Italic Capital X  
U+1D620 \isansY Mathematical Sans-Serif Italic Capital Y  
U+1D621 \isansZ Mathematical Sans-Serif Italic Capital Z  
U+1D622 \isansa Mathematical Sans-Serif Italic Small A  
U+1D623 \isansb Mathematical Sans-Serif Italic Small B  
U+1D624 \isansc Mathematical Sans-Serif Italic Small C  
U+1D625 \isansd Mathematical Sans-Serif Italic Small D  
U+1D626 \isanse Mathematical Sans-Serif Italic Small E  
U+1D627 \isansf Mathematical Sans-Serif Italic Small F  
U+1D628 \isansg Mathematical Sans-Serif Italic Small G  
U+1D629 \isansh Mathematical Sans-Serif Italic Small H  
U+1D62A \isansi Mathematical Sans-Serif Italic Small I  
U+1D62B \isansj Mathematical Sans-Serif Italic Small J  
U+1D62C \isansk Mathematical Sans-Serif Italic Small K  
U+1D62D \isansl Mathematical Sans-Serif Italic Small L  
U+1D62E \isansm Mathematical Sans-Serif Italic Small M  
U+1D62F \isansn Mathematical Sans-Serif Italic Small N  
U+1D630 \isanso Mathematical Sans-Serif Italic Small O  
U+1D631 \isansp Mathematical Sans-Serif Italic Small P  
U+1D632 \isansq Mathematical Sans-Serif Italic Small Q  
U+1D633 \isansr Mathematical Sans-Serif Italic Small R  
U+1D634 \isanss Mathematical Sans-Serif Italic Small S  
U+1D635 \isanst Mathematical Sans-Serif Italic Small T  
U+1D636 \isansu Mathematical Sans-Serif Italic Small U  
U+1D637 \isansv Mathematical Sans-Serif Italic Small V  
U+1D638 \isansw Mathematical Sans-Serif Italic Small W  
U+1D639 \isansx Mathematical Sans-Serif Italic Small X  
U+1D63A \isansy Mathematical Sans-Serif Italic Small Y  
U+1D63B \isansz Mathematical Sans-Serif Italic Small Z  
U+1D63C \bisansA Mathematical Sans-Serif Bold Italic Capital A  
U+1D63D \bisansB Mathematical Sans-Serif Bold Italic Capital B  
U+1D63E \bisansC Mathematical Sans-Serif Bold Italic Capital C  
U+1D63F \bisansD Mathematical Sans-Serif Bold Italic Capital D  
U+1D640 \bisansE Mathematical Sans-Serif Bold Italic Capital E  
U+1D641 \bisansF Mathematical Sans-Serif Bold Italic Capital F  
U+1D642 \bisansG Mathematical Sans-Serif Bold Italic Capital G  
U+1D643 \bisansH Mathematical Sans-Serif Bold Italic Capital H  
U+1D644 \bisansI Mathematical Sans-Serif Bold Italic Capital I  
U+1D645 \bisansJ Mathematical Sans-Serif Bold Italic Capital J  
U+1D646 \bisansK Mathematical Sans-Serif Bold Italic Capital K  
U+1D647 \bisansL Mathematical Sans-Serif Bold Italic Capital L  
U+1D648 \bisansM Mathematical Sans-Serif Bold Italic Capital M  
U+1D649 \bisansN Mathematical Sans-Serif Bold Italic Capital N  
U+1D64A \bisansO Mathematical Sans-Serif Bold Italic Capital O  
U+1D64B \bisansP Mathematical Sans-Serif Bold Italic Capital P  
U+1D64C \bisansQ Mathematical Sans-Serif Bold Italic Capital Q  
U+1D64D \bisansR Mathematical Sans-Serif Bold Italic Capital R  
U+1D64E \bisansS Mathematical Sans-Serif Bold Italic Capital S  
U+1D64F \bisansT Mathematical Sans-Serif Bold Italic Capital T  
U+1D650 \bisansU Mathematical Sans-Serif Bold Italic Capital U  
U+1D651 \bisansV Mathematical Sans-Serif Bold Italic Capital V  
U+1D652 \bisansW Mathematical Sans-Serif Bold Italic Capital W  
U+1D653 \bisansX Mathematical Sans-Serif Bold Italic Capital X  
U+1D654 \bisansY Mathematical Sans-Serif Bold Italic Capital Y  
U+1D655 \bisansZ Mathematical Sans-Serif Bold Italic Capital Z  
U+1D656 \bisansa Mathematical Sans-Serif Bold Italic Small A  
U+1D657 \bisansb Mathematical Sans-Serif Bold Italic Small B  
U+1D658 \bisansc Mathematical Sans-Serif Bold Italic Small C  
U+1D659 \bisansd Mathematical Sans-Serif Bold Italic Small D  
U+1D65A \bisanse Mathematical Sans-Serif Bold Italic Small E  
U+1D65B \bisansf Mathematical Sans-Serif Bold Italic Small F  
U+1D65C \bisansg Mathematical Sans-Serif Bold Italic Small G  
U+1D65D \bisansh Mathematical Sans-Serif Bold Italic Small H  
U+1D65E \bisansi Mathematical Sans-Serif Bold Italic Small I  
U+1D65F \bisansj Mathematical Sans-Serif Bold Italic Small J  
U+1D660 \bisansk Mathematical Sans-Serif Bold Italic Small K  
U+1D661 \bisansl Mathematical Sans-Serif Bold Italic Small L  
U+1D662 \bisansm Mathematical Sans-Serif Bold Italic Small M  
U+1D663 \bisansn Mathematical Sans-Serif Bold Italic Small N  
U+1D664 \bisanso Mathematical Sans-Serif Bold Italic Small O  
U+1D665 \bisansp Mathematical Sans-Serif Bold Italic Small P  
U+1D666 \bisansq Mathematical Sans-Serif Bold Italic Small Q  
U+1D667 \bisansr Mathematical Sans-Serif Bold Italic Small R  
U+1D668 \bisanss Mathematical Sans-Serif Bold Italic Small S  
U+1D669 \bisanst Mathematical Sans-Serif Bold Italic Small T  
U+1D66A \bisansu Mathematical Sans-Serif Bold Italic Small U  
U+1D66B \bisansv Mathematical Sans-Serif Bold Italic Small V  
U+1D66C \bisansw Mathematical Sans-Serif Bold Italic Small W  
U+1D66D \bisansx Mathematical Sans-Serif Bold Italic Small X  
U+1D66E \bisansy Mathematical Sans-Serif Bold Italic Small Y  
U+1D66F \bisansz Mathematical Sans-Serif Bold Italic Small Z  
U+1D670 \ttA Mathematical Monospace Capital A  
U+1D671 \ttB Mathematical Monospace Capital B  
U+1D672 \ttC Mathematical Monospace Capital C  
U+1D673 \ttD Mathematical Monospace Capital D  
U+1D674 \ttE Mathematical Monospace Capital E  
U+1D675 \ttF Mathematical Monospace Capital F  
U+1D676 \ttG Mathematical Monospace Capital G  
U+1D677 \ttH Mathematical Monospace Capital H  
U+1D678 \ttI Mathematical Monospace Capital I  
U+1D679 \ttJ Mathematical Monospace Capital J  
U+1D67A \ttK Mathematical Monospace Capital K  
U+1D67B \ttL Mathematical Monospace Capital L  
U+1D67C \ttM Mathematical Monospace Capital M  
U+1D67D \ttN Mathematical Monospace Capital N  
U+1D67E \ttO Mathematical Monospace Capital O  
U+1D67F \ttP Mathematical Monospace Capital P  
U+1D680 \ttQ Mathematical Monospace Capital Q  
U+1D681 \ttR Mathematical Monospace Capital R  
U+1D682 \ttS Mathematical Monospace Capital S  
U+1D683 \ttT Mathematical Monospace Capital T  
U+1D684 \ttU Mathematical Monospace Capital U  
U+1D685 \ttV Mathematical Monospace Capital V  
U+1D686 \ttW Mathematical Monospace Capital W  
U+1D687 \ttX Mathematical Monospace Capital X  
U+1D688 \ttY Mathematical Monospace Capital Y  
U+1D689 \ttZ Mathematical Monospace Capital Z  
U+1D68A \tta Mathematical Monospace Small A  
U+1D68B \ttb Mathematical Monospace Small B  
U+1D68C \ttc Mathematical Monospace Small C  
U+1D68D \ttd Mathematical Monospace Small D  
U+1D68E \tte Mathematical Monospace Small E  
U+1D68F \ttf Mathematical Monospace Small F  
U+1D690 \ttg Mathematical Monospace Small G  
U+1D691 \tth Mathematical Monospace Small H  
U+1D692 \tti Mathematical Monospace Small I  
U+1D693 \ttj Mathematical Monospace Small J  
U+1D694 \ttk Mathematical Monospace Small K  
U+1D695 \ttl Mathematical Monospace Small L  
U+1D696 \ttm Mathematical Monospace Small M  
U+1D697 \ttn Mathematical Monospace Small N  
U+1D698 \tto Mathematical Monospace Small O  
U+1D699 \ttp Mathematical Monospace Small P  
U+1D69A \ttq Mathematical Monospace Small Q  
U+1D69B \ttr Mathematical Monospace Small R  
U+1D69C \tts Mathematical Monospace Small S  
U+1D69D \ttt Mathematical Monospace Small T  
U+1D69E \ttu Mathematical Monospace Small U  
U+1D69F \ttv Mathematical Monospace Small V  
U+1D6A0 \ttw Mathematical Monospace Small W  
U+1D6A1 \ttx Mathematical Monospace Small X  
U+1D6A2 \tty Mathematical Monospace Small Y  
U+1D6A3 \ttz Mathematical Monospace Small Z  
U+1D6A4 \itimath Mathematical Italic Small Dotless I  
U+1D6A5 \itjmath Mathematical Italic Small Dotless J  
U+1D6A8 \bfAlpha Mathematical Bold Capital Alpha  
U+1D6A9 \bfBeta Mathematical Bold Capital Beta  
U+1D6AA \bfGamma Mathematical Bold Capital Gamma  
U+1D6AB \bfDelta Mathematical Bold Capital Delta  
U+1D6AC \bfEpsilon Mathematical Bold Capital Epsilon  
U+1D6AD \bfZeta Mathematical Bold Capital Zeta  
U+1D6AE \bfEta Mathematical Bold Capital Eta  
U+1D6AF \bfTheta Mathematical Bold Capital Theta  
U+1D6B0 \bfIota Mathematical Bold Capital Iota  
U+1D6B1 \bfKappa Mathematical Bold Capital Kappa  
U+1D6B2 \bfLambda Mathematical Bold Capital Lamda  
U+1D6B3 \bfMu Mathematical Bold Capital Mu  
U+1D6B4 \bfNu Mathematical Bold Capital Nu  
U+1D6B5 \bfXi Mathematical Bold Capital Xi  
U+1D6B6 \bfOmicron Mathematical Bold Capital Omicron  
U+1D6B7 \bfPi Mathematical Bold Capital Pi  
U+1D6B8 \bfRho Mathematical Bold Capital Rho  
U+1D6B9 \bfvarTheta Mathematical Bold Capital Theta Symbol  
U+1D6BA \bfSigma Mathematical Bold Capital Sigma  
U+1D6BB \bfTau Mathematical Bold Capital Tau  
U+1D6BC \bfUpsilon Mathematical Bold Capital Upsilon  
U+1D6BD \bfPhi Mathematical Bold Capital Phi  
U+1D6BE \bfChi Mathematical Bold Capital Chi  
U+1D6BF \bfPsi Mathematical Bold Capital Psi  
U+1D6C0 \bfOmega Mathematical Bold Capital Omega  
U+1D6C1 \bfnabla Mathematical Bold Nabla  
U+1D6C2 \bfalpha Mathematical Bold Small Alpha  
U+1D6C3 \bfbeta Mathematical Bold Small Beta  
U+1D6C4 \bfgamma Mathematical Bold Small Gamma  
U+1D6C5 \bfdelta Mathematical Bold Small Delta  
U+1D6C6 \bfvarepsilon Mathematical Bold Small Epsilon  
U+1D6C7 \bfzeta Mathematical Bold Small Zeta  
U+1D6C8 \bfeta Mathematical Bold Small Eta  
U+1D6C9 \bftheta Mathematical Bold Small Theta  
U+1D6CA \bfiota Mathematical Bold Small Iota  
U+1D6CB \bfkappa Mathematical Bold Small Kappa  
U+1D6CC \bflambda Mathematical Bold Small Lamda  
U+1D6CD \bfmu Mathematical Bold Small Mu  
U+1D6CE \bfnu Mathematical Bold Small Nu  
U+1D6CF \bfxi Mathematical Bold Small Xi  
U+1D6D0 \bfomicron Mathematical Bold Small Omicron  
U+1D6D1 \bfpi Mathematical Bold Small Pi  
U+1D6D2 \bfrho Mathematical Bold Small Rho  
U+1D6D3 \bfvarsigma Mathematical Bold Small Final Sigma  
U+1D6D4 \bfsigma Mathematical Bold Small Sigma  
U+1D6D5 \bftau Mathematical Bold Small Tau  
U+1D6D6 \bfupsilon Mathematical Bold Small Upsilon  
U+1D6D7 \bfvarphi Mathematical Bold Small Phi  
U+1D6D8 \bfchi Mathematical Bold Small Chi  
U+1D6D9 \bfpsi Mathematical Bold Small Psi  
U+1D6DA \bfomega Mathematical Bold Small Omega  
U+1D6DB \bfpartial Mathematical Bold Partial Differential  
U+1D6DC \bfepsilon Mathematical Bold Epsilon Symbol  
U+1D6DD \bfvartheta Mathematical Bold Theta Symbol  
U+1D6DE \bfvarkappa Mathematical Bold Kappa Symbol  
U+1D6DF \bfphi Mathematical Bold Phi Symbol  
U+1D6E0 \bfvarrho Mathematical Bold Rho Symbol  
U+1D6E1 \bfvarpi Mathematical Bold Pi Symbol  
U+1D6E2 \itAlpha Mathematical Italic Capital Alpha  
U+1D6E3 \itBeta Mathematical Italic Capital Beta  
U+1D6E4 \itGamma Mathematical Italic Capital Gamma  
U+1D6E5 \itDelta Mathematical Italic Capital Delta  
U+1D6E6 \itEpsilon Mathematical Italic Capital Epsilon  
U+1D6E7 \itZeta Mathematical Italic Capital Zeta  
U+1D6E8 \itEta Mathematical Italic Capital Eta  
U+1D6E9 \itTheta Mathematical Italic Capital Theta  
U+1D6EA \itIota Mathematical Italic Capital Iota  
U+1D6EB \itKappa Mathematical Italic Capital Kappa  
U+1D6EC \itLambda Mathematical Italic Capital Lamda  
U+1D6ED \itMu Mathematical Italic Capital Mu  
U+1D6EE \itNu Mathematical Italic Capital Nu  
U+1D6EF \itXi Mathematical Italic Capital Xi  
U+1D6F0 \itOmicron Mathematical Italic Capital Omicron  
U+1D6F1 \itPi Mathematical Italic Capital Pi  
U+1D6F2 \itRho Mathematical Italic Capital Rho  
U+1D6F3 \itvarTheta Mathematical Italic Capital Theta Symbol  
U+1D6F4 \itSigma Mathematical Italic Capital Sigma  
U+1D6F5 \itTau Mathematical Italic Capital Tau  
U+1D6F6 \itUpsilon Mathematical Italic Capital Upsilon  
U+1D6F7 \itPhi Mathematical Italic Capital Phi  
U+1D6F8 \itChi Mathematical Italic Capital Chi  
U+1D6F9 \itPsi Mathematical Italic Capital Psi  
U+1D6FA \itOmega Mathematical Italic Capital Omega  
U+1D6FB \itnabla Mathematical Italic Nabla  
U+1D6FC \italpha Mathematical Italic Small Alpha  
U+1D6FD \itbeta Mathematical Italic Small Beta  
U+1D6FE \itgamma Mathematical Italic Small Gamma  
U+1D6FF \itdelta Mathematical Italic Small Delta  
U+1D700 \itvarepsilon Mathematical Italic Small Epsilon  
U+1D701 \itzeta Mathematical Italic Small Zeta  
U+1D702 \iteta Mathematical Italic Small Eta  
U+1D703 \ittheta Mathematical Italic Small Theta  
U+1D704 \itiota Mathematical Italic Small Iota  
U+1D705 \itkappa Mathematical Italic Small Kappa  
U+1D706 \itlambda Mathematical Italic Small Lamda  
U+1D707 \itmu Mathematical Italic Small Mu  
U+1D708 \itnu Mathematical Italic Small Nu  
U+1D709 \itxi Mathematical Italic Small Xi  
U+1D70A \itomicron Mathematical Italic Small Omicron  
U+1D70B \itpi Mathematical Italic Small Pi  
U+1D70C \itrho Mathematical Italic Small Rho  
U+1D70D \itvarsigma Mathematical Italic Small Final Sigma  
U+1D70E \itsigma Mathematical Italic Small Sigma  
U+1D70F \ittau Mathematical Italic Small Tau  
U+1D710 \itupsilon Mathematical Italic Small Upsilon  
U+1D711 \itvarphi Mathematical Italic Small Phi  
U+1D712 \itchi Mathematical Italic Small Chi  
U+1D713 \itpsi Mathematical Italic Small Psi  
U+1D714 \itomega Mathematical Italic Small Omega  
U+1D715 \itpartial Mathematical Italic Partial Differential  
U+1D716 \itepsilon Mathematical Italic Epsilon Symbol  
U+1D717 \itvartheta Mathematical Italic Theta Symbol  
U+1D718 \itvarkappa Mathematical Italic Kappa Symbol  
U+1D719 \itphi Mathematical Italic Phi Symbol  
U+1D71A \itvarrho Mathematical Italic Rho Symbol  
U+1D71B \itvarpi Mathematical Italic Pi Symbol  
U+1D71C \biAlpha Mathematical Bold Italic Capital Alpha  
U+1D71D \biBeta Mathematical Bold Italic Capital Beta  
U+1D71E \biGamma Mathematical Bold Italic Capital Gamma  
U+1D71F \biDelta Mathematical Bold Italic Capital Delta  
U+1D720 \biEpsilon Mathematical Bold Italic Capital Epsilon  
U+1D721 \biZeta Mathematical Bold Italic Capital Zeta  
U+1D722 \biEta Mathematical Bold Italic Capital Eta  
U+1D723 \biTheta Mathematical Bold Italic Capital Theta  
U+1D724 \biIota Mathematical Bold Italic Capital Iota  
U+1D725 \biKappa Mathematical Bold Italic Capital Kappa  
U+1D726 \biLambda Mathematical Bold Italic Capital Lamda  
U+1D727 \biMu Mathematical Bold Italic Capital Mu  
U+1D728 \biNu Mathematical Bold Italic Capital Nu  
U+1D729 \biXi Mathematical Bold Italic Capital Xi  
U+1D72A \biOmicron Mathematical Bold Italic Capital Omicron  
U+1D72B \biPi Mathematical Bold Italic Capital Pi  
U+1D72C \biRho Mathematical Bold Italic Capital Rho  
U+1D72D \bivarTheta Mathematical Bold Italic Capital Theta Symbol  
U+1D72E \biSigma Mathematical Bold Italic Capital Sigma  
U+1D72F \biTau Mathematical Bold Italic Capital Tau  
U+1D730 \biUpsilon Mathematical Bold Italic Capital Upsilon  
U+1D731 \biPhi Mathematical Bold Italic Capital Phi  
U+1D732 \biChi Mathematical Bold Italic Capital Chi  
U+1D733 \biPsi Mathematical Bold Italic Capital Psi  
U+1D734 \biOmega Mathematical Bold Italic Capital Omega  
U+1D735 \binabla Mathematical Bold Italic Nabla  
U+1D736 \bialpha Mathematical Bold Italic Small Alpha  
U+1D737 \bibeta Mathematical Bold Italic Small Beta  
U+1D738 \bigamma Mathematical Bold Italic Small Gamma  
U+1D739 \bidelta Mathematical Bold Italic Small Delta  
U+1D73A \bivarepsilon Mathematical Bold Italic Small Epsilon  
U+1D73B \bizeta Mathematical Bold Italic Small Zeta  
U+1D73C \bieta Mathematical Bold Italic Small Eta  
U+1D73D \bitheta Mathematical Bold Italic Small Theta  
U+1D73E \biiota Mathematical Bold Italic Small Iota  
U+1D73F \bikappa Mathematical Bold Italic Small Kappa  
U+1D740 \bilambda Mathematical Bold Italic Small Lamda  
U+1D741 \bimu Mathematical Bold Italic Small Mu  
U+1D742 \binu Mathematical Bold Italic Small Nu  
U+1D743 \bixi Mathematical Bold Italic Small Xi  
U+1D744 \biomicron Mathematical Bold Italic Small Omicron  
U+1D745 \bipi Mathematical Bold Italic Small Pi  
U+1D746 \birho Mathematical Bold Italic Small Rho  
U+1D747 \bivarsigma Mathematical Bold Italic Small Final Sigma  
U+1D748 \bisigma Mathematical Bold Italic Small Sigma  
U+1D749 \bitau Mathematical Bold Italic Small Tau  
U+1D74A \biupsilon Mathematical Bold Italic Small Upsilon  
U+1D74B \bivarphi Mathematical Bold Italic Small Phi  
U+1D74C \bichi Mathematical Bold Italic Small Chi  
U+1D74D \bipsi Mathematical Bold Italic Small Psi  
U+1D74E \biomega Mathematical Bold Italic Small Omega  
U+1D74F \bipartial Mathematical Bold Italic Partial Differential  
U+1D750 \biepsilon Mathematical Bold Italic Epsilon Symbol  
U+1D751 \bivartheta Mathematical Bold Italic Theta Symbol  
U+1D752 \bivarkappa Mathematical Bold Italic Kappa Symbol  
U+1D753 \biphi Mathematical Bold Italic Phi Symbol  
U+1D754 \bivarrho Mathematical Bold Italic Rho Symbol  
U+1D755 \bivarpi Mathematical Bold Italic Pi Symbol  
U+1D756 \bsansAlpha Mathematical Sans-Serif Bold Capital Alpha  
U+1D757 \bsansBeta Mathematical Sans-Serif Bold Capital Beta  
U+1D758 \bsansGamma Mathematical Sans-Serif Bold Capital Gamma  
U+1D759 \bsansDelta Mathematical Sans-Serif Bold Capital Delta  
U+1D75A \bsansEpsilon Mathematical Sans-Serif Bold Capital Epsilon  
U+1D75B \bsansZeta Mathematical Sans-Serif Bold Capital Zeta  
U+1D75C \bsansEta Mathematical Sans-Serif Bold Capital Eta  
U+1D75D \bsansTheta Mathematical Sans-Serif Bold Capital Theta  
U+1D75E \bsansIota Mathematical Sans-Serif Bold Capital Iota  
U+1D75F \bsansKappa Mathematical Sans-Serif Bold Capital Kappa  
U+1D760 \bsansLambda Mathematical Sans-Serif Bold Capital Lamda  
U+1D761 \bsansMu Mathematical Sans-Serif Bold Capital Mu  
U+1D762 \bsansNu Mathematical Sans-Serif Bold Capital Nu  
U+1D763 \bsansXi Mathematical Sans-Serif Bold Capital Xi  
U+1D764 \bsansOmicron Mathematical Sans-Serif Bold Capital Omicron  
U+1D765 \bsansPi Mathematical Sans-Serif Bold Capital Pi  
U+1D766 \bsansRho Mathematical Sans-Serif Bold Capital Rho  
U+1D767 \bsansvarTheta Mathematical Sans-Serif Bold Capital Theta Symbol  
U+1D768 \bsansSigma Mathematical Sans-Serif Bold Capital Sigma  
U+1D769 \bsansTau Mathematical Sans-Serif Bold Capital Tau  
U+1D76A \bsansUpsilon Mathematical Sans-Serif Bold Capital Upsilon  
U+1D76B \bsansPhi Mathematical Sans-Serif Bold Capital Phi  
U+1D76C \bsansChi Mathematical Sans-Serif Bold Capital Chi  
U+1D76D \bsansPsi Mathematical Sans-Serif Bold Capital Psi  
U+1D76E \bsansOmega Mathematical Sans-Serif Bold Capital Omega  
U+1D76F \bsansnabla Mathematical Sans-Serif Bold Nabla  
U+1D770 \bsansalpha Mathematical Sans-Serif Bold Small Alpha  
U+1D771 \bsansbeta Mathematical Sans-Serif Bold Small Beta  
U+1D772 \bsansgamma Mathematical Sans-Serif Bold Small Gamma  
U+1D773 \bsansdelta Mathematical Sans-Serif Bold Small Delta  
U+1D774 \bsansvarepsilon Mathematical Sans-Serif Bold Small Epsilon  
U+1D775 \bsanszeta Mathematical Sans-Serif Bold Small Zeta  
U+1D776 \bsanseta Mathematical Sans-Serif Bold Small Eta  
U+1D777 \bsanstheta Mathematical Sans-Serif Bold Small Theta  
U+1D778 \bsansiota Mathematical Sans-Serif Bold Small Iota  
U+1D779 \bsanskappa Mathematical Sans-Serif Bold Small Kappa  
U+1D77A \bsanslambda Mathematical Sans-Serif Bold Small Lamda  
U+1D77B \bsansmu Mathematical Sans-Serif Bold Small Mu  
U+1D77C \bsansnu Mathematical Sans-Serif Bold Small Nu  
U+1D77D \bsansxi Mathematical Sans-Serif Bold Small Xi  
U+1D77E \bsansomicron Mathematical Sans-Serif Bold Small Omicron  
U+1D77F \bsanspi Mathematical Sans-Serif Bold Small Pi  
U+1D780 \bsansrho Mathematical Sans-Serif Bold Small Rho  
U+1D781 \bsansvarsigma Mathematical Sans-Serif Bold Small Final Sigma  
U+1D782 \bsanssigma Mathematical Sans-Serif Bold Small Sigma  
U+1D783 \bsanstau Mathematical Sans-Serif Bold Small Tau  
U+1D784 \bsansupsilon Mathematical Sans-Serif Bold Small Upsilon  
U+1D785 \bsansvarphi Mathematical Sans-Serif Bold Small Phi  
U+1D786 \bsanschi Mathematical Sans-Serif Bold Small Chi  
U+1D787 \bsanspsi Mathematical Sans-Serif Bold Small Psi  
U+1D788 \bsansomega Mathematical Sans-Serif Bold Small Omega  
U+1D789 \bsanspartial Mathematical Sans-Serif Bold Partial Differential  
U+1D78A \bsansepsilon Mathematical Sans-Serif Bold Epsilon Symbol  
U+1D78B \bsansvartheta Mathematical Sans-Serif Bold Theta Symbol  
U+1D78C \bsansvarkappa Mathematical Sans-Serif Bold Kappa Symbol  
U+1D78D \bsansphi Mathematical Sans-Serif Bold Phi Symbol  
U+1D78E \bsansvarrho Mathematical Sans-Serif Bold Rho Symbol  
U+1D78F \bsansvarpi Mathematical Sans-Serif Bold Pi Symbol  
U+1D790 \bisansAlpha Mathematical Sans-Serif Bold Italic Capital Alpha  
U+1D791 \bisansBeta Mathematical Sans-Serif Bold Italic Capital Beta  
U+1D792 \bisansGamma Mathematical Sans-Serif Bold Italic Capital Gamma  
U+1D793 \bisansDelta Mathematical Sans-Serif Bold Italic Capital Delta  
U+1D794 \bisansEpsilon Mathematical Sans-Serif Bold Italic Capital Epsilon  
U+1D795 \bisansZeta Mathematical Sans-Serif Bold Italic Capital Zeta  
U+1D796 \bisansEta Mathematical Sans-Serif Bold Italic Capital Eta  
U+1D797 \bisansTheta Mathematical Sans-Serif Bold Italic Capital Theta  
U+1D798 \bisansIota Mathematical Sans-Serif Bold Italic Capital Iota  
U+1D799 \bisansKappa Mathematical Sans-Serif Bold Italic Capital Kappa  
U+1D79A \bisansLambda Mathematical Sans-Serif Bold Italic Capital Lamda  
U+1D79B \bisansMu Mathematical Sans-Serif Bold Italic Capital Mu  
U+1D79C \bisansNu Mathematical Sans-Serif Bold Italic Capital Nu  
U+1D79D \bisansXi Mathematical Sans-Serif Bold Italic Capital Xi  
U+1D79E \bisansOmicron Mathematical Sans-Serif Bold Italic Capital Omicron  
U+1D79F \bisansPi Mathematical Sans-Serif Bold Italic Capital Pi  
U+1D7A0 \bisansRho Mathematical Sans-Serif Bold Italic Capital Rho  
U+1D7A1 \bisansvarTheta Mathematical Sans-Serif Bold Italic Capital Theta  
Symbol  
U+1D7A2 \bisansSigma Mathematical Sans-Serif Bold Italic Capital Sigma  
U+1D7A3 \bisansTau Mathematical Sans-Serif Bold Italic Capital Tau  
U+1D7A4 \bisansUpsilon Mathematical Sans-Serif Bold Italic Capital Upsilon  
U+1D7A5 \bisansPhi Mathematical Sans-Serif Bold Italic Capital Phi  
U+1D7A6 \bisansChi Mathematical Sans-Serif Bold Italic Capital Chi  
U+1D7A7 \bisansPsi Mathematical Sans-Serif Bold Italic Capital Psi  
U+1D7A8 \bisansOmega Mathematical Sans-Serif Bold Italic Capital Omega  
U+1D7A9 \bisansnabla Mathematical Sans-Serif Bold Italic Nabla  
U+1D7AA \bisansalpha Mathematical Sans-Serif Bold Italic Small Alpha  
U+1D7AB \bisansbeta Mathematical Sans-Serif Bold Italic Small Beta  
U+1D7AC \bisansgamma Mathematical Sans-Serif Bold Italic Small Gamma  
U+1D7AD \bisansdelta Mathematical Sans-Serif Bold Italic Small Delta  
U+1D7AE \bisansvarepsilon Mathematical Sans-Serif Bold Italic Small Epsilon  
U+1D7AF \bisanszeta Mathematical Sans-Serif Bold Italic Small Zeta  
U+1D7B0 \bisanseta Mathematical Sans-Serif Bold Italic Small Eta  
U+1D7B1 \bisanstheta Mathematical Sans-Serif Bold Italic Small Theta  
U+1D7B2 \bisansiota Mathematical Sans-Serif Bold Italic Small Iota  
U+1D7B3 \bisanskappa Mathematical Sans-Serif Bold Italic Small Kappa  
U+1D7B4 \bisanslambda Mathematical Sans-Serif Bold Italic Small Lamda  
U+1D7B5 \bisansmu Mathematical Sans-Serif Bold Italic Small Mu  
U+1D7B6 \bisansnu Mathematical Sans-Serif Bold Italic Small Nu  
U+1D7B7 \bisansxi Mathematical Sans-Serif Bold Italic Small Xi  
U+1D7B8 \bisansomicron Mathematical Sans-Serif Bold Italic Small Omicron  
U+1D7B9 \bisanspi Mathematical Sans-Serif Bold Italic Small Pi  
U+1D7BA \bisansrho Mathematical Sans-Serif Bold Italic Small Rho  
U+1D7BB \bisansvarsigma Mathematical Sans-Serif Bold Italic Small Final Sigma  
U+1D7BC \bisanssigma Mathematical Sans-Serif Bold Italic Small Sigma  
U+1D7BD \bisanstau Mathematical Sans-Serif Bold Italic Small Tau  
U+1D7BE \bisansupsilon Mathematical Sans-Serif Bold Italic Small Upsilon  
U+1D7BF \bisansvarphi Mathematical Sans-Serif Bold Italic Small Phi  
U+1D7C0 \bisanschi Mathematical Sans-Serif Bold Italic Small Chi  
U+1D7C1 \bisanspsi Mathematical Sans-Serif Bold Italic Small Psi  
U+1D7C2 \bisansomega Mathematical Sans-Serif Bold Italic Small Omega  
U+1D7C3 \bisanspartial Mathematical Sans-Serif Bold Italic Partial Differential  
U+1D7C4 \bisansepsilon Mathematical Sans-Serif Bold Italic Epsilon Symbol  
U+1D7C5 \bisansvartheta Mathematical Sans-Serif Bold Italic Theta Symbol  
U+1D7C6 \bisansvarkappa Mathematical Sans-Serif Bold Italic Kappa Symbol  
U+1D7C7 \bisansphi Mathematical Sans-Serif Bold Italic Phi Symbol  
U+1D7C8 \bisansvarrho Mathematical Sans-Serif Bold Italic Rho Symbol  
U+1D7C9 \bisansvarpi Mathematical Sans-Serif Bold Italic Pi Symbol  
U+1D7CA \bfDigamma Mathematical Bold Capital Digamma  
U+1D7CB \bfdigamma Mathematical Bold Small Digamma  
U+1D7CE \bfzero Mathematical Bold Digit Zero  
U+1D7CF \bfone Mathematical Bold Digit One  
U+1D7D0 \bftwo Mathematical Bold Digit Two  
U+1D7D1 \bfthree Mathematical Bold Digit Three  
U+1D7D2 \bffour Mathematical Bold Digit Four  
U+1D7D3 \bffive Mathematical Bold Digit Five  
U+1D7D4 \bfsix Mathematical Bold Digit Six  
U+1D7D5 \bfseven Mathematical Bold Digit Seven  
U+1D7D6 \bfeight Mathematical Bold Digit Eight  
U+1D7D7 \bfnine Mathematical Bold Digit Nine  
U+1D7D8 𝟘 \bbzero Mathematical Double-Struck Digit Zero  
U+1D7D9 𝟙 \bbone Mathematical Double-Struck Digit One  
U+1D7DA 𝟚 \bbtwo Mathematical Double-Struck Digit Two  
U+1D7DB 𝟛 \bbthree Mathematical Double-Struck Digit Three  
U+1D7DC 𝟜 \bbfour Mathematical Double-Struck Digit Four  
U+1D7DD 𝟝 \bbfive Mathematical Double-Struck Digit Five  
U+1D7DE 𝟞 \bbsix Mathematical Double-Struck Digit Six  
U+1D7DF 𝟟 \bbseven Mathematical Double-Struck Digit Seven  
U+1D7E0 𝟠 \bbeight Mathematical Double-Struck Digit Eight  
U+1D7E1 𝟡 \bbnine Mathematical Double-Struck Digit Nine  
U+1D7E2 𝟢 \sanszero Mathematical Sans-Serif Digit Zero  
U+1D7E3 𝟣 \sansone Mathematical Sans-Serif Digit One  
U+1D7E4 𝟤 \sanstwo Mathematical Sans-Serif Digit Two  
U+1D7E5 𝟥 \sansthree Mathematical Sans-Serif Digit Three  
U+1D7E6 𝟦 \sansfour Mathematical Sans-Serif Digit Four  
U+1D7E7 𝟧 \sansfive Mathematical Sans-Serif Digit Five  
U+1D7E8 𝟨 \sanssix Mathematical Sans-Serif Digit Six  
U+1D7E9 𝟩 \sansseven Mathematical Sans-Serif Digit Seven  
U+1D7EA 𝟪 \sanseight Mathematical Sans-Serif Digit Eight  
U+1D7EB 𝟫 \sansnine Mathematical Sans-Serif Digit Nine  
U+1D7EC \bsanszero Mathematical Sans-Serif Bold Digit Zero  
U+1D7ED \bsansone Mathematical Sans-Serif Bold Digit One  
U+1D7EE \bsanstwo Mathematical Sans-Serif Bold Digit Two  
U+1D7EF \bsansthree Mathematical Sans-Serif Bold Digit Three  
U+1D7F0 \bsansfour Mathematical Sans-Serif Bold Digit Four  
U+1D7F1 \bsansfive Mathematical Sans-Serif Bold Digit Five  
U+1D7F2 \bsanssix Mathematical Sans-Serif Bold Digit Six  
U+1D7F3 \bsansseven Mathematical Sans-Serif Bold Digit Seven  
U+1D7F4 \bsanseight Mathematical Sans-Serif Bold Digit Eight  
U+1D7F5 \bsansnine Mathematical Sans-Serif Bold Digit Nine  
U+1D7F6 \ttzero Mathematical Monospace Digit Zero  
U+1D7F7 \ttone Mathematical Monospace Digit One  
U+1D7F8 \tttwo Mathematical Monospace Digit Two  
U+1D7F9 \ttthree Mathematical Monospace Digit Three  
U+1D7FA \ttfour Mathematical Monospace Digit Four  
U+1D7FB \ttfive Mathematical Monospace Digit Five  
U+1D7FC \ttsix Mathematical Monospace Digit Six  
U+1D7FD \ttseven Mathematical Monospace Digit Seven  
U+1D7FE \tteight Mathematical Monospace Digit Eight  
U+1D7FF \ttnine Mathematical Monospace Digit Nine  
U+1F004 :mahjong: Mahjong Tile Red Dragon  
U+1F0CF 🃏 :black_joker: Playing Card Black Joker  
U+1F170 :a: Negative Squared Latin Capital Letter A  
U+1F171 :b: Negative Squared Latin Capital Letter B  
U+1F17E :o2: Negative Squared Latin Capital Letter O  
U+1F17F :parking: Negative Squared Latin Capital Letter P  
U+1F18E :ab: Negative Squared Ab  
U+1F191 :cl: Squared Cl  
U+1F192 :cool: Squared Cool  
U+1F193 :free: Squared Free  
U+1F194 :id: Squared Id  
U+1F195 :new: Squared New  
U+1F196 :ng: Squared Ng  
U+1F197 :ok: Squared Ok  
U+1F198 :sos: Squared Sos  
U+1F199 :up: Squared Up With Exclamation Mark  
U+1F19A :vs: Squared Vs  
U+1F201 :koko: Squared Katakana Koko  
U+1F202 :sa: Squared Katakana Sa  
U+1F21A :u7121: Squared Cjk Unified Ideograph-7121  
U+1F22F :u6307: Squared Cjk Unified Ideograph-6307  
U+1F232 :u7981: Squared Cjk Unified Ideograph-7981  
U+1F233 :u7a7a: Squared Cjk Unified Ideograph-7A7A  
U+1F234 :u5408: Squared Cjk Unified Ideograph-5408  
U+1F235 :u6e80: Squared Cjk Unified Ideograph-6E80  
U+1F236 :u6709: Squared Cjk Unified Ideograph-6709  
U+1F237 :u6708: Squared Cjk Unified Ideograph-6708  
U+1F238 :u7533: Squared Cjk Unified Ideograph-7533  
U+1F239 :u5272: Squared Cjk Unified Ideograph-5272  
U+1F23A :u55b6: Squared Cjk Unified Ideograph-55B6  
U+1F250 :ideograph_advantage: Circled Ideograph Advantage  
U+1F251 :accept: Circled Ideograph Accept  
U+1F300 :cyclone: Cyclone  
U+1F301 :foggy: Foggy  
U+1F302 :closed_umbrella: Closed Umbrella  
U+1F303 :night_with_stars: Night With Stars  
U+1F304 :sunrise_over_moun-  
tains:

Sunrise Over Mountains

U+1F305 :sunrise: Sunrise  
U+1F306 :city_sunset: Cityscape At Dusk  
U+1F307 :city_sunrise: Sunset Over Buildings  
U+1F308 :rainbow: Rainbow  
U+1F309 :bridge_at_night: Bridge At Night  
U+1F30A :ocean: Water Wave  
U+1F30B :volcano: Volcano  
U+1F30C :milky_way: Milky Way  
U+1F30D :earth_africa: Earth Globe Europe-Africa  
U+1F30E :earth_americas: Earth Globe Americas  
U+1F30F :earth_asia: Earth Globe Asia-Australia  
U+1F310 :globe_with_meridians: Globe With Meridians  
U+1F311 🌑 :new_moon: New Moon Symbol  
U+1F312 🌒 :waxing_cres-  
cent_moon:

Waxing Crescent Moon Symbol

U+1F313 🌓 :first_quarter_moon: First Quarter Moon Symbol  
U+1F314 🌔 :moon: Waxing Gibbous Moon Symbol  
U+1F315 🌕 :full_moon: Full Moon Symbol  
U+1F316 🌖 :waning_gib-  
bous_moon:

Waning Gibbous Moon Symbol

U+1F317 🌗 :last_quarter_moon: Last Quarter Moon Symbol  
U+1F318 🌘 :waning_cres-  
cent_moon:

Waning Crescent Moon Symbol

U+1F319 :crescent_moon: Crescent Moon  
U+1F31A :new_moon_with_face: New Moon With Face  
U+1F31B :first_quar-  
ter_moon_with_face:

First Quarter Moon With Face

U+1F31C :last_quar-  
ter_moon_with_face:

Last Quarter Moon With Face

U+1F31D :full_moon_with_face: Full Moon With Face  
U+1F31E :sun_with_face: Sun With Face  
U+1F31F :star2: Glowing Star  
U+1F320 :stars: Shooting Star  
U+1F32D :hotdog: Hot Dog  
U+1F32E :taco: Taco  
U+1F32F :burrito: Burrito  
U+1F330 :chestnut: Chestnut  
U+1F331 :seedling: Seedling  
U+1F332 :evergreen_tree: Evergreen Tree  
U+1F333 :deciduous_tree: Deciduous Tree  
U+1F334 :palm_tree: Palm Tree  
U+1F335 :cactus: Cactus  
U+1F337 :tulip: Tulip  
U+1F338 :cherry_blossom: Cherry Blossom  
U+1F339 :rose: Rose  
U+1F33A :hibiscus: Hibiscus  
U+1F33B :sunflower: Sunflower  
U+1F33C :blossom: Blossom  
U+1F33D :corn: Ear Of Maize  
U+1F33E :ear_of_rice: Ear Of Rice  
U+1F33F :herb: Herb  
U+1F340 :four_leaf_clover: Four Leaf Clover  
U+1F341 :maple_leaf: Maple Leaf  
U+1F342 :fallen_leaf: Fallen Leaf  
U+1F343 :leaves: Leaf Fluttering In Wind  
U+1F344 :mushroom: Mushroom  
U+1F345 :tomato: Tomato  
U+1F346 :eggplant: Aubergine  
U+1F347 :grapes: Grapes  
U+1F348 :melon: Melon  
U+1F349 :watermelon: Watermelon  
U+1F34A :tangerine: Tangerine  
U+1F34B :lemon: Lemon  
U+1F34C :banana: Banana  
U+1F34D :pineapple: Pineapple  
U+1F34E :apple: Red Apple  
U+1F34F :green_apple: Green Apple  
U+1F350 :pear: Pear  
U+1F351 :peach: Peach  
U+1F352 :cherries: Cherries  
U+1F353 :strawberry: Strawberry  
U+1F354 :hamburger: Hamburger  
U+1F355 :pizza: Slice Of Pizza  
U+1F356 :meat_on_bone: Meat On Bone  
U+1F357 :poultry_leg: Poultry Leg  
U+1F358 :rice_cracker: Rice Cracker  
U+1F359 :rice_ball: Rice Ball  
U+1F35A :rice: Cooked Rice  
U+1F35B :curry: Curry And Rice  
U+1F35C :ramen: Steaming Bowl  
U+1F35D :spaghetti: Spaghetti  
U+1F35E :bread: Bread  
U+1F35F :fries: French Fries  
U+1F360 :sweet_potato: Roasted Sweet Potato  
U+1F361 :dango: Dango  
U+1F362 :oden: Oden  
U+1F363 :sushi: Sushi  
U+1F364 :fried_shrimp: Fried Shrimp  
U+1F365 :fish_cake: Fish Cake With Swirl Design  
U+1F366 :icecream: Soft Ice Cream  
U+1F367 :shaved_ice: Shaved Ice  
U+1F368 :ice_cream: Ice Cream  
U+1F369 :doughnut: Doughnut  
U+1F36A :cookie: Cookie  
U+1F36B :chocolate_bar: Chocolate Bar  
U+1F36C :candy: Candy  
U+1F36D :lollipop: Lollipop  
U+1F36E :custard: Custard  
U+1F36F :honey_pot: Honey Pot  
U+1F370 :cake: Shortcake  
U+1F371 :bento: Bento Box  
U+1F372 :stew: Pot Of Food  
U+1F373 :fried_egg: Cooking  
U+1F374 :fork_and_knife: Fork And Knife  
U+1F375 :tea: Teacup Without Handle  
U+1F376 :sake: Sake Bottle And Cup  
U+1F377 :wine_glass: Wine Glass  
U+1F378 :cocktail: Cocktail Glass  
U+1F379 :tropical_drink: Tropical Drink  
U+1F37A :beer: Beer Mug  
U+1F37B :beers: Clinking Beer Mugs  
U+1F37C :baby_bottle: Baby Bottle  
U+1F37E :champagne: Bottle With Popping Cork  
U+1F37F :popcorn: Popcorn  
U+1F380 :ribbon: Ribbon  
U+1F381 :gift: Wrapped Present  
U+1F382 :birthday: Birthday Cake  
U+1F383 :jack_o_lantern: Jack-O-Lantern  
U+1F384 :christmas_tree: Christmas Tree  
U+1F385 :santa: Father Christmas  
U+1F386 :fireworks: Fireworks  
U+1F387 :sparkler: Firework Sparkler  
U+1F388 :balloon: Balloon  
U+1F389 :tada: Party Popper  
U+1F38A :confetti_ball: Confetti Ball  
U+1F38B :tanabata_tree: Tanabata Tree  
U+1F38C :crossed_flags: Crossed Flags  
U+1F38D :bamboo: Pine Decoration  
U+1F38E :dolls: Japanese Dolls  
U+1F38F :flags: Carp Streamer  
U+1F390 :wind_chime: Wind Chime  
U+1F391 :rice_scene: Moon Viewing Ceremony  
U+1F392 :school_satchel: School Satchel  
U+1F393 :mortar_board: Graduation Cap  
U+1F3A0 :carousel_horse: Carousel Horse  
U+1F3A1 :ferris_wheel: Ferris Wheel  
U+1F3A2 :roller_coaster: Roller Coaster  
U+1F3A3 :fishing_pole_and_fish: Fishing Pole And Fish  
U+1F3A4 :microphone: Microphone  
U+1F3A5 :movie_camera: Movie Camera  
U+1F3A6 :cinema: Cinema  
U+1F3A7 :headphones: Headphone  
U+1F3A8 :art: Artist Palette  
U+1F3A9 :tophat: Top Hat  
U+1F3AA :circus_tent: Circus Tent  
U+1F3AB :ticket: Ticket  
U+1F3AC :clapper: Clapper Board  
U+1F3AD :performing_arts: Performing Arts  
U+1F3AE :video_game: Video Game  
U+1F3AF :dart: Direct Hit  
U+1F3B0 :slot_machine: Slot Machine  
U+1F3B1 :8ball: Billiards  
U+1F3B2 :game_die: Game Die  
U+1F3B3 :bowling: Bowling  
U+1F3B4 :flower_playing_cards: Flower Playing Cards  
U+1F3B5 :musical_note: Musical Note  
U+1F3B6 :notes: Multiple Musical Notes  
U+1F3B7 :saxophone: Saxophone  
U+1F3B8 :guitar: Guitar  
U+1F3B9 :musical_keyboard: Musical Keyboard  
U+1F3BA :trumpet: Trumpet  
U+1F3BB :violin: Violin  
U+1F3BC :musical_score: Musical Score  
U+1F3BD :run-  
ning_shirt_with_sash:

Running Shirt With Sash

U+1F3BE :tennis: Tennis Racquet And Ball  
U+1F3BF :ski: Ski And Ski Boot  
U+1F3C0 :basketball: Basketball And Hoop  
U+1F3C1 :checkered_flag: Chequered Flag  
U+1F3C2 :snowboarder: Snowboarder  
U+1F3C3 :runner: Runner  
U+1F3C4 :surfer: Surfer  
U+1F3C5 :sports_medal: Sports Medal  
U+1F3C6 :trophy: Trophy  
U+1F3C7 :horse_racing: Horse Racing  
U+1F3C8 :football: American Football  
U+1F3C9 :rugby_football: Rugby Football  
U+1F3CA :swimmer: Swimmer  
U+1F3CF :cricket_bat_and_ball: Cricket Bat And Ball  
U+1F3D0 :volleyball: Volleyball  
U+1F3D1 :field_hockey_stick_and_ball:Field Hockey Stick And Ball  
U+1F3D2 :ice_hockey_stick_and_puck:Ice Hockey Stick And Puck  
U+1F3D3 :table_tennis_pad-  
dle_and_ball:

Table Tennis Paddle And Ball

U+1F3E0 :house: House Building  
U+1F3E1 :house_with_garden: House With Garden  
U+1F3E2 :office: Office Building  
U+1F3E3 :post_office: Japanese Post Office  
U+1F3E4 :european_post_office: European Post Office  
U+1F3E5 :hospital: Hospital  
U+1F3E6 :bank: Bank  
U+1F3E7 :atm: Automated Teller Machine  
U+1F3E8 :hotel: Hotel  
U+1F3E9 :love_hotel: Love Hotel  
U+1F3EA :convenience_store: Convenience Store  
U+1F3EB :school: School  
U+1F3EC :department_store: Department Store  
U+1F3ED :factory: Factory  
U+1F3EE :izakaya_lantern: Izakaya Lantern  
U+1F3EF :japanese_castle: Japanese Castle  
U+1F3F0 :european_castle: European Castle  
U+1F3F4 :waving_black_flag: Waving Black Flag  
U+1F3F8 :badminton_rac-  
quet_and_shuttlecock:

Badminton Racquet And Shuttlecock

U+1F3F9 :bow_and_arrow: Bow And Arrow  
U+1F3FA :amphora: Amphora  
U+1F3FB :skin-tone-2: Emoji Modifier Fitzpatrick Type-1-2  
U+1F3FC :skin-tone-3: Emoji Modifier Fitzpatrick Type-3  
U+1F3FD :skin-tone-4: Emoji Modifier Fitzpatrick Type-4  
U+1F3FE :skin-tone-5: Emoji Modifier Fitzpatrick Type-5  
U+1F3FF :skin-tone-6: Emoji Modifier Fitzpatrick Type-6  
U+1F400 :rat: Rat  
U+1F401 :mouse2: Mouse  
U+1F402 :ox: Ox  
U+1F403 :water_buffalo: Water Buffalo  
U+1F404 :cow2: Cow  
U+1F405 :tiger2: Tiger  
U+1F406 :leopard: Leopard  
U+1F407 :rabbit2: Rabbit  
U+1F408 :cat2: Cat  
U+1F409 :dragon: Dragon  
U+1F40A :crocodile: Crocodile  
U+1F40B :whale2: Whale  
U+1F40C :snail: Snail  
U+1F40D :snake: Snake  
U+1F40E :racehorse: Horse  
U+1F40F :ram: Ram  
U+1F410 :goat: Goat  
U+1F411 :sheep: Sheep  
U+1F412 :monkey: Monkey  
U+1F413 :rooster: Rooster  
U+1F414 :chicken: Chicken  
U+1F415 :dog2: Dog  
U+1F416 :pig2: Pig  
U+1F417 :boar: Boar  
U+1F418 :elephant: Elephant  
U+1F419 :octopus: Octopus  
U+1F41A :shell: Spiral Shell  
U+1F41B :bug: Bug  
U+1F41C :ant: Ant  
U+1F41D :bee: Honeybee  
U+1F41E :ladybug: Lady Beetle  
U+1F41F :fish: Fish  
U+1F420 :tropical_fish: Tropical Fish  
U+1F421 :blowfish: Blowfish  
U+1F422 :turtle: Turtle  
U+1F423 :hatching_chick: Hatching Chick  
U+1F424 :baby_chick: Baby Chick  
U+1F425 :hatched_chick: Front-Facing Baby Chick  
U+1F426 :bird: Bird  
U+1F427 :penguin: Penguin  
U+1F428 :koala: Koala  
U+1F429 :poodle: Poodle  
U+1F42A :dromedary_camel: Dromedary Camel  
U+1F42B :camel: Bactrian Camel  
U+1F42C :dolphin: Dolphin  
U+1F42D 🐭 :mouse: Mouse Face  
U+1F42E 🐮 :cow: Cow Face  
U+1F42F :tiger: Tiger Face  
U+1F430 :rabbit: Rabbit Face  
U+1F431 🐱 :cat: Cat Face  
U+1F432 :dragon_face: Dragon Face  
U+1F433 :whale: Spouting Whale  
U+1F434 :horse: Horse Face  
U+1F435 🐵 :monkey_face: Monkey Face  
U+1F436 :dog: Dog Face  
U+1F437 :pig: Pig Face  
U+1F438 :frog: Frog Face  
U+1F439 :hamster: Hamster Face  
U+1F43A :wolf: Wolf Face  
U+1F43B :bear: Bear Face  
U+1F43C :panda_face: Panda Face  
U+1F43D :pig_nose: Pig Nose  
U+1F43E :feet: Paw Prints  
U+1F440 :eyes: Eyes  
U+1F442 :ear: Ear  
U+1F443 :nose: Nose  
U+1F444 :lips: Mouth  
U+1F445 :tongue: Tongue  
U+1F446 :point_up_2: White Up Pointing Backhand Index  
U+1F447 :point_down: White Down Pointing Backhand Index  
U+1F448 :point_left: White Left Pointing Backhand Index  
U+1F449 :point_right: White Right Pointing Backhand Index  
U+1F44A :facepunch: Fisted Hand Sign  
U+1F44B :wave: Waving Hand Sign  
U+1F44C :ok_hand: Ok Hand Sign  
U+1F44D :+1: Thumbs Up Sign  
U+1F44E :-1: Thumbs Down Sign  
U+1F44F :clap: Clapping Hands Sign  
U+1F450 :open_hands: Open Hands Sign  
U+1F451 :crown: Crown  
U+1F452 :womans_hat: Womans Hat  
U+1F453 :eyeglasses: Eyeglasses  
U+1F454 :necktie: Necktie  
U+1F455 :shirt: T-Shirt  
U+1F456 :jeans: Jeans  
U+1F457 :dress: Dress  
U+1F458 :kimono: Kimono  
U+1F459 :bikini: Bikini  
U+1F45A :womans_clothes: Womans Clothes  
U+1F45B :purse: Purse  
U+1F45C :handbag: Handbag  
U+1F45D :pouch: Pouch  
U+1F45E :mans_shoe: Mans Shoe  
U+1F45F :athletic_shoe: Athletic Shoe  
U+1F460 :high_heel: High-Heeled Shoe  
U+1F461 :sandal: Womans Sandal  
U+1F462 :boot: Womans Boots  
U+1F463 :footprints: Footprints  
U+1F464 :bust_in_silhouette: Bust In Silhouette  
U+1F465 :busts_in_silhouette: Busts In Silhouette  
U+1F466 :boy: Boy  
U+1F467 :girl: Girl  
U+1F468 :man: Man  
U+1F469 :woman: Woman  
U+1F46A :family: Family  
U+1F46B :couple:,  
:man_and_woman_hold-  
ing_hands:

Man And Woman Holding Hands

U+1F46C :two_men_hold-  
ing_hands:

Two Men Holding Hands

U+1F46D :two_women_hold-  
ing_hands:

Two Women Holding Hands

U+1F46E :cop: Police Officer  
U+1F46F :dancers: Woman With Bunny Ears  
U+1F470 :bride_with_veil: Bride With Veil  
U+1F471 :per-  
son_with_blond_hair:

Person With Blond Hair

U+1F472 :man_with_gua_pi_mao: Man With Gua Pi Mao  
U+1F473 :man_with_turban: Man With Turban  
U+1F474 :older_man: Older Man  
U+1F475 :older_woman: Older Woman  
U+1F476 :baby: Baby  
U+1F477 :construction_worker: Construction Worker  
U+1F478 :princess: Princess  
U+1F479 :japanese_ogre: Japanese Ogre  
U+1F47A :japanese_goblin: Japanese Goblin  
U+1F47B :ghost: Ghost  
U+1F47C :angel: Baby Angel  
U+1F47D :alien: Extraterrestrial Alien  
U+1F47E :space_invader: Alien Monster  
U+1F47F :imp: Imp  
U+1F480 :skull: Skull  
U+1F481 :information_desk_per-  
son:

Information Desk Person

U+1F482 :guardsman: Guardsman  
U+1F483 :dancer: Dancer  
U+1F484 :lipstick: Lipstick  
U+1F485 :nail_care: Nail Polish  
U+1F486 :massage: Face Massage  
U+1F487 :haircut: Haircut  
U+1F488 :barber: Barber Pole  
U+1F489 :syringe: Syringe  
U+1F48A :pill: Pill  
U+1F48B :kiss: Kiss Mark  
U+1F48C :love_letter: Love Letter  
U+1F48D :ring: Ring  
U+1F48E :gem: Gem Stone  
U+1F48F :couplekiss: Kiss  
U+1F490 :bouquet: Bouquet  
U+1F491 :couple_with_heart: Couple With Heart  
U+1F492 :wedding: Wedding  
U+1F493 :heartbeat: Beating Heart  
U+1F494 :broken_heart: Broken Heart  
U+1F495 :two_hearts: Two Hearts  
U+1F496 :sparkling_heart: Sparkling Heart  
U+1F497 :heartpulse: Growing Heart  
U+1F498 :cupid: Heart With Arrow  
U+1F499 :blue_heart: Blue Heart  
U+1F49A :green_heart: Green Heart  
U+1F49B :yellow_heart: Yellow Heart  
U+1F49C :purple_heart: Purple Heart  
U+1F49D :gift_heart: Heart With Ribbon  
U+1F49E :revolving_hearts: Revolving Hearts  
U+1F49F :heart_decoration: Heart Decoration  
U+1F4A0 :dia-  
mond_shape_with_a_dot_in-  
side:

Diamond Shape With A Dot Inside

U+1F4A1 :bulb: Electric Light Bulb  
U+1F4A2 :anger: Anger Symbol  
U+1F4A3 :bomb: Bomb  
U+1F4A4 :zzz: Sleeping Symbol  
U+1F4A5 :boom: Collision Symbol  
U+1F4A6 :sweat_drops: Splashing Sweat Symbol  
U+1F4A7 :droplet: Droplet  
U+1F4A8 :dash: Dash Symbol  
U+1F4A9 :hankey: Pile Of Poo  
U+1F4AA :muscle: Flexed Biceps  
U+1F4AB :dizzy: Dizzy Symbol  
U+1F4AC :speech_balloon: Speech Balloon  
U+1F4AD :thought_balloon: Thought Balloon  
U+1F4AE :white_flower: White Flower  
U+1F4AF :100: Hundred Points Symbol  
U+1F4B0 :moneybag: Money Bag  
U+1F4B1 :currency_exchange: Currency Exchange  
U+1F4B2 :heavy_dollar_sign: Heavy Dollar Sign  
U+1F4B3 :credit_card: Credit Card  
U+1F4B4 :yen: Banknote With Yen Sign  
U+1F4B5 :dollar: Banknote With Dollar Sign  
U+1F4B6 :euro: Banknote With Euro Sign  
U+1F4B7 :pound: Banknote With Pound Sign  
U+1F4B8 :money_with_wings: Money With Wings  
U+1F4B9 :chart: Chart With Upwards Trend And Yen Sign  
U+1F4BA :seat: Seat  
U+1F4BB :computer: Personal Computer  
U+1F4BC :briefcase: Briefcase  
U+1F4BD :minidisc: Minidisc  
U+1F4BE :floppy_disk: Floppy Disk  
U+1F4BF :cd: Optical Disc  
U+1F4C0 :dvd: Dvd  
U+1F4C1 :file_folder: File Folder  
U+1F4C2 :open_file_folder: Open File Folder  
U+1F4C3 :page_with_curl: Page With Curl  
U+1F4C4 :page_facing_up: Page Facing Up  
U+1F4C5 :date: Calendar  
U+1F4C6 :calendar: Tear-Off Calendar  
U+1F4C7 :card_index: Card Index  
U+1F4C8 :chart_with_up-  
wards_trend:

Chart With Upwards Trend

U+1F4C9 :chart_with_down-  
wards_trend:

Chart With Downwards Trend

U+1F4CA :bar_chart: Bar Chart  
U+1F4CB :clipboard: Clipboard  
U+1F4CC :pushpin: Pushpin  
U+1F4CD :round_pushpin: Round Pushpin  
U+1F4CE :paperclip: Paperclip  
U+1F4CF :straight_ruler: Straight Ruler  
U+1F4D0 :triangular_ruler: Triangular Ruler  
U+1F4D1 :bookmark_tabs: Bookmark Tabs  
U+1F4D2 :ledger: Ledger  
U+1F4D3 :notebook: Notebook  
U+1F4D4 :notebook_with_decora-  
tive_cover:

Notebook With Decorative Cover

U+1F4D5 :closed_book: Closed Book  
U+1F4D6 :book: Open Book  
U+1F4D7 :green_book: Green Book  
U+1F4D8 :blue_book: Blue Book  
U+1F4D9 :orange_book: Orange Book  
U+1F4DA :books: Books  
U+1F4DB :name_badge: Name Badge  
U+1F4DC :scroll: Scroll  
U+1F4DD :memo: Memo  
U+1F4DE :telephone_receiver: Telephone Receiver  
U+1F4DF :pager: Pager  
U+1F4E0 :fax: Fax Machine  
U+1F4E1 :satellite:,  
:satellite_antenna:

Satellite Antenna

U+1F4E2 :loudspeaker: Public Address Loudspeaker  
U+1F4E3 :mega: Cheering Megaphone  
U+1F4E4 :outbox_tray: Outbox Tray  
U+1F4E5 :inbox_tray: Inbox Tray  
U+1F4E6 :package: Package  
U+1F4E7 :e-mail: E-Mail Symbol  
U+1F4E8 :incoming_envelope: Incoming Envelope  
U+1F4E9 :envelope_with_arrow: Envelope With Downwards Arrow Above  
U+1F4EA :mailbox_closed: Closed Mailbox With Lowered Flag  
U+1F4EB :mailbox: Closed Mailbox With Raised Flag  
U+1F4EC :mailbox_with_mail: Open Mailbox With Raised Flag  
U+1F4ED :mailbox_with_no_mail: Open Mailbox With Lowered Flag  
U+1F4EE :postbox: Postbox  
U+1F4EF :postal_horn: Postal Horn  
U+1F4F0 :newspaper: Newspaper  
U+1F4F1 :iphone: Mobile Phone  
U+1F4F2 :calling: Mobile Phone With Rightwards Arrow At Left  
U+1F4F3 :vibration_mode: Vibration Mode  
U+1F4F4 :mobile_phone_off: Mobile Phone Off  
U+1F4F5 :no_mobile_phones: No Mobile Phones  
U+1F4F6 :signal_strength: Antenna With Bars  
U+1F4F7 :camera: Camera  
U+1F4F8 :camera_with_flash: Camera With Flash  
U+1F4F9 :video_camera: Video Camera  
U+1F4FA :tv: Television  
U+1F4FB :radio: Radio  
U+1F4FC :vhs: Videocassette  
U+1F4FF :prayer_beads: Prayer Beads  
U+1F500 :twisted_rightwards_ar-  
rows:

Twisted Rightwards Arrows

U+1F501 :repeat: Clockwise Rightwards And Leftwards Open Circle  
Arrows  
U+1F502 :repeat_one: Clockwise Rightwards And Leftwards Open Circle  
Arrows With Circled One Overlay  
U+1F503 :arrows_clockwise: Clockwise Downwards And Upwards Open Circle  
Arrows  
U+1F504 :arrows_counterclock-  
wise:

Anticlockwise Downwards And Upwards Open Circle  
Arrows  
U+1F505 :low_brightness: Low Brightness Symbol  
U+1F506 :high_brightness: High Brightness Symbol  
U+1F507 :mute: Speaker With Cancellation Stroke  
U+1F508 :speaker: Speaker  
U+1F509 :sound: Speaker With One Sound Wave  
U+1F50A :loud_sound: Speaker With Three Sound Waves  
U+1F50B :battery: Battery  
U+1F50C :electric_plug: Electric Plug  
U+1F50D :mag: Left-Pointing Magnifying Glass  
U+1F50E :mag_right: Right-Pointing Magnifying Glass  
U+1F50F :lock_with_ink_pen: Lock With Ink Pen  
U+1F510 :closed_lock_with_key: Closed Lock With Key  
U+1F511 :key: Key  
U+1F512 :lock: Lock  
U+1F513 :unlock: Open Lock  
U+1F514 :bell: Bell  
U+1F515 :no_bell: Bell With Cancellation Stroke  
U+1F516 :bookmark: Bookmark  
U+1F517 :link: Link Symbol  
U+1F518 :radio_button: Radio Button  
U+1F519 :back: Back With Leftwards Arrow Above  
U+1F51A :end: End With Leftwards Arrow Above  
U+1F51B :on: On With Exclamation Mark With Left Right Arrow Above  
U+1F51C :soon: Soon With Rightwards Arrow Above  
U+1F51D :top: Top With Upwards Arrow Above  
U+1F51E :underage: No One Under Eighteen Symbol  
U+1F51F :keycap_ten: Keycap Ten  
U+1F520 :capital_abcd: Input Symbol For Latin Capital Letters  
U+1F521 :abcd: Input Symbol For Latin Small Letters  
U+1F522 :1234: Input Symbol For Numbers  
U+1F523 :symbols: Input Symbol For Symbols  
U+1F524 :abc: Input Symbol For Latin Letters  
U+1F525 :fire: Fire  
U+1F526 :flashlight: Electric Torch  
U+1F527 :wrench: Wrench  
U+1F528 :hammer: Hammer  
U+1F529 :nut_and_bolt: Nut And Bolt  
U+1F52A :hocho: Hocho  
U+1F52B :gun: Pistol  
U+1F52C :microscope: Microscope  
U+1F52D :telescope: Telescope  
U+1F52E :crystal_ball: Crystal Ball  
U+1F52F :six_pointed_star: Six Pointed Star With Middle Dot  
U+1F530 :beginner: Japanese Symbol For Beginner  
U+1F531 :trident: Trident Emblem  
U+1F532 :black_square_button: Black Square Button  
U+1F533 :white_square_button: White Square Button  
U+1F534 :red_circle: Large Red Circle  
U+1F535 :large_blue_circle: Large Blue Circle  
U+1F536 :large_orange_dia-  
mond:

Large Orange Diamond

U+1F537 :large_blue_diamond: Large Blue Diamond  
U+1F538 :small_orange_dia-  
mond:

Small Orange Diamond

U+1F539 :small_blue_diamond: Small Blue Diamond  
U+1F53A :small_red_triangle: Up-Pointing Red Triangle  
U+1F53B :small_red_trian-  
gle_down:

Down-Pointing Red Triangle

U+1F53C :arrow_up_small: Up-Pointing Small Red Triangle  
U+1F53D :arrow_down_small: Down-Pointing Small Red Triangle  
U+1F54B :kaaba: Kaaba  
U+1F54C :mosque: Mosque  
U+1F54D :synagogue: Synagogue  
U+1F54E :meno-  
rah_with_nine_branches:

Menorah With Nine Branches

U+1F550 :clock1: Clock Face One Oclock  
U+1F551 :clock2: Clock Face Two Oclock  
U+1F552 :clock3: Clock Face Three Oclock  
U+1F553 :clock4: Clock Face Four Oclock  
U+1F554 :clock5: Clock Face Five Oclock  
U+1F555 :clock6: Clock Face Six Oclock  
U+1F556 :clock7: Clock Face Seven Oclock  
U+1F557 :clock8: Clock Face Eight Oclock  
U+1F558 :clock9: Clock Face Nine Oclock  
U+1F559 :clock10: Clock Face Ten Oclock  
U+1F55A :clock11: Clock Face Eleven Oclock  
U+1F55B :clock12: Clock Face Twelve Oclock  
U+1F55C :clock130: Clock Face One-Thirty  
U+1F55D :clock230: Clock Face Two-Thirty  
U+1F55E :clock330: Clock Face Three-Thirty  
U+1F55F :clock430: Clock Face Four-Thirty  
U+1F560 :clock530: Clock Face Five-Thirty  
U+1F561 :clock630: Clock Face Six-Thirty  
U+1F562 :clock730: Clock Face Seven-Thirty  
U+1F563 :clock830: Clock Face Eight-Thirty  
U+1F564 :clock930: Clock Face Nine-Thirty  
U+1F565 :clock1030: Clock Face Ten-Thirty  
U+1F566 :clock1130: Clock Face Eleven-Thirty  
U+1F567 :clock1230: Clock Face Twelve-Thirty  
U+1F57A :man_dancing: Man Dancing  
U+1F595 :middle_finger: Reversed Hand With Middle Finger Extended  
U+1F596 :spock-hand: Raised Hand With Part Between Middle And Ring  
Fingers  
U+1F5A4 :black_heart: Black Heart  
U+1F5FB :mount_fuji: Mount Fuji  
U+1F5FC :tokyo_tower: Tokyo Tower  
U+1F5FD :statue_of_liberty: Statue Of Liberty  
U+1F5FE :japan: Silhouette Of Japan  
U+1F5FF :moyai: Moyai  
U+1F600 😀 :grinning: Grinning Face  
U+1F601 😁 :grin: Grinning Face With Smiling Eyes  
U+1F602 😂 :joy: Face With Tears Of Joy  
U+1F603 😃 :smiley: Smiling Face With Open Mouth  
U+1F604 😄 :smile: Smiling Face With Open Mouth And Smiling Eyes  
U+1F605 😅 :sweat_smile: Smiling Face With Open Mouth And Cold Sweat  
U+1F606 😆 :laughing: Smiling Face With Open Mouth And Tightly-Closed Eyes  
U+1F607 😇 :innocent: Smiling Face With Halo  
U+1F608 😈 :smiling_imp: Smiling Face With Horns  
U+1F609 😉 :wink: Winking Face  
U+1F60A 😊 :blush: Smiling Face With Smiling Eyes  
U+1F60B 😋 :yum: Face Savouring Delicious Food  
U+1F60C 😌 :relieved: Relieved Face  
U+1F60D 😍 :heart_eyes: Smiling Face With Heart-Shaped Eyes  
U+1F60E 😎 :sunglasses: Smiling Face With Sunglasses  
U+1F60F 😏 :smirk: Smirking Face  
U+1F610 😐 :neutral_face: Neutral Face  
U+1F611 😑 :expressionless: Expressionless Face  
U+1F612 😒 :unamused: Unamused Face  
U+1F613 😓 :sweat: Face With Cold Sweat  
U+1F614 😔 :pensive: Pensive Face  
U+1F615 😕 :confused: Confused Face  
U+1F616 😖 :confounded: Confounded Face  
U+1F617 😗 :kissing: Kissing Face  
U+1F618 😘 :kissing_heart: Face Throwing A Kiss  
U+1F619 😙 :kissing_smiling_eyes: Kissing Face With Smiling Eyes  
U+1F61A 😚 :kissing_closed_eyes: Kissing Face With Closed Eyes  
U+1F61B 😛 :stuck_out_tongue: Face With Stuck-Out Tongue  
U+1F61C 😜 :stuck_out_tongue_wink-  
ing_eye:

Face With Stuck-Out Tongue And Winking Eye

U+1F61D 😝 :stuck_out_tongue_closed_eyes:Face With Stuck-Out Tongue And Tightly-Closed Eyes  
U+1F61E 😞 :disappointed: Disappointed Face  
U+1F61F 😟 :worried: Worried Face  
U+1F620 😠 :angry: Angry Face  
U+1F621 😡 :rage: Pouting Face  
U+1F622 😢 :cry: Crying Face  
U+1F623 😣 :persevere: Persevering Face  
U+1F624 :triumph: Face With Look Of Triumph  
U+1F625 😥 :disappointed_relieved: Disappointed But Relieved Face  
U+1F626 😦 :frowning: Frowning Face With Open Mouth  
U+1F627 😧 :anguished: Anguished Face  
U+1F628 😨 :fearful: Fearful Face  
U+1F629 😩 :weary: Weary Face  
U+1F62A 😪 :sleepy: Sleepy Face  
U+1F62B 😫 :tired_face: Tired Face  
U+1F62C :grimacing: Grimacing Face  
U+1F62D 😭 :sob: Loudly Crying Face  
U+1F62E 😮 :open_mouth: Face With Open Mouth  
U+1F62F 😯 :hushed: Hushed Face  
U+1F630 😰 :cold_sweat: Face With Open Mouth And Cold Sweat  
U+1F631 😱 :scream: Face Screaming In Fear  
U+1F632 😲 :astonished: Astonished Face  
U+1F633 😳 :flushed: Flushed Face  
U+1F634 😴 :sleeping: Sleeping Face  
U+1F635 😵 :dizzy_face: Dizzy Face  
U+1F636 😶 :no_mouth: Face Without Mouth  
U+1F637 😷 :mask: Face With Medical Mask  
U+1F638 😸 :smile_cat: Grinning Cat Face With Smiling Eyes  
U+1F639 😹 :joy_cat: Cat Face With Tears Of Joy  
U+1F63A 😺 :smiley_cat: Smiling Cat Face With Open Mouth  
U+1F63B 😻 :heart_eyes_cat: Smiling Cat Face With Heart-Shaped Eyes  
U+1F63C 😼 :smirk_cat: Cat Face With Wry Smile  
U+1F63D 😽 :kissing_cat: Kissing Cat Face With Closed Eyes  
U+1F63E 😾 :pouting_cat: Pouting Cat Face  
U+1F63F 😿 :crying_cat_face: Crying Cat Face  
U+1F640 🙀 :scream_cat: Weary Cat Face  
U+1F641 :slightly_frowning_face: Slightly Frowning Face  
U+1F642 :slightly_smiling_face: Slightly Smiling Face  
U+1F643 🙃 :upside_down_face: Upside-Down Face  
U+1F644 :face_with_rolling_eyes: Face With Rolling Eyes  
U+1F645 :no_good: Face With No Good Gesture  
U+1F646 :ok_woman: Face With Ok Gesture  
U+1F647 :bow: Person Bowing Deeply  
U+1F648 :see_no_evil: See-No-Evil Monkey  
U+1F649 :hear_no_evil: Hear-No-Evil Monkey  
U+1F64A :speak_no_evil: Speak-No-Evil Monkey  
U+1F64B :raising_hand: Happy Person Raising One Hand  
U+1F64C :raised_hands: Person Raising Both Hands In Celebration  
U+1F64D :person_frowning: Person Frowning  
U+1F64E :person_with_pout-  
ing_face:

Person With Pouting Face

U+1F64F :pray: Person With Folded Hands  
U+1F680 :rocket: Rocket  
U+1F681 :helicopter: Helicopter  
U+1F682 :steam_locomotive: Steam Locomotive  
U+1F683 :railway_car: Railway Car  
U+1F684 :bullettrain_side: High-Speed Train  
U+1F685 :bullettrain_front: High-Speed Train With Bullet Nose  
U+1F686 :train2: Train  
U+1F687 :metro: Metro  
U+1F688 :light_rail: Light Rail  
U+1F689 :station: Station  
U+1F68A :tram: Tram  
U+1F68B :train: Tram Car  
U+1F68C :bus: Bus  
U+1F68D :oncoming_bus: Oncoming Bus  
U+1F68E :trolleybus: Trolleybus  
U+1F68F :busstop: Bus Stop  
U+1F690 :minibus: Minibus  
U+1F691 :ambulance: Ambulance  
U+1F692 :fire_engine: Fire Engine  
U+1F693 :police_car: Police Car  
U+1F694 :oncoming_police_car: Oncoming Police Car  
U+1F695 :taxi: Taxi  
U+1F696 :oncoming_taxi: Oncoming Taxi  
U+1F697 :car: Automobile  
U+1F698 :oncoming_automobile: Oncoming Automobile  
U+1F699 :blue_car: Recreational Vehicle  
U+1F69A :truck: Delivery Truck  
U+1F69B :articulated_lorry: Articulated Lorry  
U+1F69C :tractor: Tractor  
U+1F69D :monorail: Monorail  
U+1F69E :mountain_railway: Mountain Railway  
U+1F69F :suspension_railway: Suspension Railway  
U+1F6A0 :mountain_cableway: Mountain Cableway  
U+1F6A1 :aerial_tramway: Aerial Tramway  
U+1F6A2 :ship: Ship  
U+1F6A3 :rowboat: Rowboat  
U+1F6A4 :speedboat: Speedboat  
U+1F6A5 :traffic_light: Horizontal Traffic Light  
U+1F6A6 :vertical_traffic_light: Vertical Traffic Light  
U+1F6A7 :construction: Construction Sign  
U+1F6A8 :rotating_light: Police Cars Revolving Light  
U+1F6A9 :triangu-  
lar_flag_on_post:

Triangular Flag On Post

U+1F6AA :door: Door  
U+1F6AB :no_entry_sign: No Entry Sign  
U+1F6AC :smoking: Smoking Symbol  
U+1F6AD :no_smoking: No Smoking Symbol  
U+1F6AE :put_litter_in_its_place: Put Litter In Its Place Symbol  
U+1F6AF :do_not_litter: Do Not Litter Symbol  
U+1F6B0 :potable_water: Potable Water Symbol  
U+1F6B1 :non-potable_water: Non-Potable Water Symbol  
U+1F6B2 :bike: Bicycle  
U+1F6B3 :no_bicycles: No Bicycles  
U+1F6B4 :bicyclist: Bicyclist  
U+1F6B5 :mountain_bicyclist: Mountain Bicyclist  
U+1F6B6 :walking: Pedestrian  
U+1F6B7 :no_pedestrians: No Pedestrians  
U+1F6B8 :children_crossing: Children Crossing  
U+1F6B9 :mens: Mens Symbol  
U+1F6BA :womens: Womens Symbol  
U+1F6BB :restroom: Restroom  
U+1F6BC :baby_symbol: Baby Symbol  
U+1F6BD :toilet: Toilet  
U+1F6BE :wc: Water Closet  
U+1F6BF :shower: Shower  
U+1F6C0 :bath: Bath  
U+1F6C1 :bathtub: Bathtub  
U+1F6C2 :passport_control: Passport Control  
U+1F6C3 :customs: Customs  
U+1F6C4 :baggage_claim: Baggage Claim  
U+1F6C5 :left_luggage: Left Luggage  
U+1F6CC :sleeping_accommoda-  
tion:

Sleeping Accommodation

U+1F6D0 :place_of_worship: Place Of Worship  
U+1F6D1 :octagonal_sign: Octagonal Sign  
U+1F6D2 :shopping_trolley: Shopping Trolley  
U+1F6D5 :hindu_temple: Hindu Temple  
U+1F6D6 :hut: Hut  
U+1F6D7 :elevator: Elevator  
U+1F6EB :airplane_departure: Airplane Departure  
U+1F6EC :airplane_arriving: Airplane Arriving  
U+1F6F4 :scooter: Scooter  
U+1F6F5 :motor_scooter: Motor Scooter  
U+1F6F6 :canoe: Canoe  
U+1F6F7 :sled: Sled  
U+1F6F8 :flying_saucer: Flying Saucer  
U+1F6F9 :skateboard: Skateboard  
U+1F6FA :auto_rickshaw: Auto Rickshaw  
U+1F6FB :pickup_truck: Pickup Truck  
U+1F6FC :roller_skate: Roller Skate  
U+1F7E0 :large_orange_circle: Large Orange Circle  
U+1F7E1 :large_yellow_circle: Large Yellow Circle  
U+1F7E2 :large_green_circle: Large Green Circle  
U+1F7E3 :large_purple_circle: Large Purple Circle  
U+1F7E4 :large_brown_circle: Large Brown Circle  
U+1F7E5 :large_red_square: Large Red Square  
U+1F7E6 :large_blue_square: Large Blue Square  
U+1F7E7 :large_orange_square: Large Orange Square  
U+1F7E8 :large_yellow_square: Large Yellow Square  
U+1F7E9 :large_green_square: Large Green Square  
U+1F7EA :large_purple_square: Large Purple Square  
U+1F7EB :large_brown_square: Large Brown Square  
U+1F90C :pinched_fingers: Pinched Fingers  
U+1F90D :white_heart: White Heart  
U+1F90E :brown_heart: Brown Heart  
U+1F90F :pinching_hand: Pinching Hand  
U+1F910 :zipper_mouth_face: Zipper-Mouth Face  
U+1F911 :money_mouth_face: Money-Mouth Face  
U+1F912 :face_with_thermome-  
ter:

Face With Thermometer

U+1F913 :nerd_face: Nerd Face  
U+1F914 :thinking_face: Thinking Face  
U+1F915 :face_with_head_ban-  
dage:

Face With Head-Bandage

U+1F916 :robot_face: Robot Face  
U+1F917 :hugging_face: Hugging Face  
U+1F918 :the_horns: Sign Of The Horns  
U+1F919 :call_me_hand: Call Me Hand  
U+1F91A :raised_back_of_hand: Raised Back Of Hand  
U+1F91B :left-facing_fist: Left-Facing Fist  
U+1F91C :right-facing_fist: Right-Facing Fist  
U+1F91D :handshake: Handshake  
U+1F91E :crossed_fingers: Hand With Index And Middle Fingers Crossed  
U+1F91F :i_love_you_hand_sign: I Love You Hand Sign  
U+1F920 :face_with_cowboy_hat: Face With Cowboy Hat  
U+1F921 :clown_face: Clown Face  
U+1F922 :nauseated_face: Nauseated Face  
U+1F923 :rolling_on_the_floor_laugh-  
ing:

Rolling On The Floor Laughing

U+1F924 :drooling_face: Drooling Face  
U+1F925 :lying_face: Lying Face  
U+1F926 :face_palm: Face Palm  
U+1F927 :sneezing_face: Sneezing Face  
U+1F928 :face_with_raised_eye-  
brow:

Face With One Eyebrow Raised

U+1F929 :star-struck: Grinning Face With Star Eyes  
U+1F92A :zany_face: Grinning Face With One Large And One Small Eye  
U+1F92B :shushing_face: Face With Finger Covering Closed Lips  
U+1F92C :face_with_sym-  
bols_on_mouth:

Serious Face With Symbols Covering Mouth

U+1F92D :face_with_hand_over_mouth:Smiling Face With Smiling Eyes And Hand Covering  
Mouth  
U+1F92E :face_vomiting: Face With Open Mouth Vomiting  
U+1F92F :exploding_head: Shocked Face With Exploding Head  
U+1F930 :pregnant_woman: Pregnant Woman  
U+1F931 :breast-feeding: Breast-Feeding  
U+1F932 :palms_up_together: Palms Up Together  
U+1F933 :selfie: Selfie  
U+1F934 :prince: Prince  
U+1F935 :person_in_tuxedo: Man In Tuxedo  
U+1F936 :mrs_claus: Mother Christmas  
U+1F937 :shrug: Shrug  
U+1F938 :person_do-  
ing_cartwheel:

Person Doing Cartwheel

U+1F939 :juggling: Juggling  
U+1F93A :fencer: Fencer  
U+1F93C :wrestlers: Wrestlers  
U+1F93D :water_polo: Water Polo  
U+1F93E :handball: Handball  
U+1F93F :diving_mask: Diving Mask  
U+1F940 :wilted_flower: Wilted Flower  
U+1F941 :drum_with_drumsticks: Drum With Drumsticks  
U+1F942 :clinking_glasses: Clinking Glasses  
U+1F943 :tumbler_glass: Tumbler Glass  
U+1F944 :spoon: Spoon  
U+1F945 :goal_net: Goal Net  
U+1F947 :first_place_medal: First Place Medal  
U+1F948 :second_place_medal: Second Place Medal  
U+1F949 :third_place_medal: Third Place Medal  
U+1F94A :boxing_glove: Boxing Glove  
U+1F94B :martial_arts_uniform: Martial Arts Uniform  
U+1F94C :curling_stone: Curling Stone  
U+1F94D :lacrosse: Lacrosse Stick And Ball  
U+1F94E :softball: Softball  
U+1F94F :flying_disc: Flying Disc  
U+1F950 :croissant: Croissant  
U+1F951 :avocado: Avocado  
U+1F952 :cucumber: Cucumber  
U+1F953 :bacon: Bacon  
U+1F954 :potato: Potato  
U+1F955 :carrot: Carrot  
U+1F956 :baguette_bread: Baguette Bread  
U+1F957 :green_salad: Green Salad  
U+1F958 :shallow_pan_of_food: Shallow Pan Of Food  
U+1F959 :stuffed_flatbread: Stuffed Flatbread  
U+1F95A :egg: Egg  
U+1F95B :glass_of_milk: Glass Of Milk  
U+1F95C :peanuts: Peanuts  
U+1F95D :kiwifruit: Kiwifruit  
U+1F95E :pancakes: Pancakes  
U+1F95F :dumpling: Dumpling  
U+1F960 :fortune_cookie: Fortune Cookie  
U+1F961 :takeout_box: Takeout Box  
U+1F962 :chopsticks: Chopsticks  
U+1F963 :bowl_with_spoon: Bowl With Spoon  
U+1F964 :cup_with_straw: Cup With Straw  
U+1F965 :coconut: Coconut  
U+1F966 :broccoli: Broccoli  
U+1F967 :pie: Pie  
U+1F968 :pretzel: Pretzel  
U+1F969 :cut_of_meat: Cut Of Meat  
U+1F96A :sandwich: Sandwich  
U+1F96B :canned_food: Canned Food  
U+1F96C :leafy_green: Leafy Green  
U+1F96D :mango: Mango  
U+1F96E :moon_cake: Moon Cake  
U+1F96F :bagel: Bagel  
U+1F970 :smil-  
ing_face_with_3_hearts:

Smiling Face With Smiling Eyes And Three Hearts

U+1F971 :yawning_face: Yawning Face  
U+1F972 :smil-  
ing_face_with_tear:

Smiling Face With Tear

U+1F973 :partying_face: Face With Party Horn And Party Hat  
U+1F974 :woozy_face: Face With Uneven Eyes And Wavy Mouth  
U+1F975 :hot_face: Overheated Face  
U+1F976 :cold_face: Freezing Face  
U+1F977 :ninja: Ninja  
U+1F978 :disguised_face: Disguised Face  
U+1F97A :pleading_face: Face With Pleading Eyes  
U+1F97B :sari: Sari  
U+1F97C :lab_coat: Lab Coat  
U+1F97D :goggles: Goggles  
U+1F97E :hiking_boot: Hiking Boot  
U+1F97F :womans_flat_shoe: Flat Shoe  
U+1F980 :crab: Crab  
U+1F981 :lion_face: Lion Face  
U+1F982 :scorpion: Scorpion  
U+1F983 :turkey: Turkey  
U+1F984 :unicorn_face: Unicorn Face  
U+1F985 :eagle: Eagle  
U+1F986 :duck: Duck  
U+1F987 :bat: Bat  
U+1F988 :shark: Shark  
U+1F989 :owl: Owl  
U+1F98A :fox_face: Fox Face  
U+1F98B :butterfly: Butterfly  
U+1F98C :deer: Deer  
U+1F98D :gorilla: Gorilla  
U+1F98E :lizard: Lizard  
U+1F98F :rhinoceros: Rhinoceros  
U+1F990 :shrimp: Shrimp  
U+1F991 :squid: Squid  
U+1F992 :giraffe_face: Giraffe Face  
U+1F993 :zebra_face: Zebra Face  
U+1F994 :hedgehog: Hedgehog  
U+1F995 :sauropod: Sauropod  
U+1F996 :t-rex: T-Rex  
U+1F997 :cricket: Cricket  
U+1F998 :kangaroo: Kangaroo  
U+1F999 :llama: Llama  
U+1F99A :peacock: Peacock  
U+1F99B :hippopotamus: Hippopotamus  
U+1F99C :parrot: Parrot  
U+1F99D :raccoon: Raccoon  
U+1F99E :lobster: Lobster  
U+1F99F :mosquito: Mosquito  
U+1F9A0 :microbe: Microbe  
U+1F9A1 :badger: Badger  
U+1F9A2 :swan: Swan  
U+1F9A3 :mammoth: Mammoth  
U+1F9A4 :dodo: Dodo  
U+1F9A5 :sloth: Sloth  
U+1F9A6 :otter: Otter  
U+1F9A7 :orangutan: Orangutan  
U+1F9A8 :skunk: Skunk  
U+1F9A9 :flamingo: Flamingo  
U+1F9AA :oyster: Oyster  
U+1F9AB :beaver: Beaver  
U+1F9AC :bison: Bison  
U+1F9AD :seal: Seal  
U+1F9AE :guide_dog: Guide Dog  
U+1F9AF :probing_cane: Probing Cane  
U+1F9B4 :bone: Bone  
U+1F9B5 :leg: Leg  
U+1F9B6 :foot: Foot  
U+1F9B7 :tooth: Tooth  
U+1F9B8 :superhero: Superhero  
U+1F9B9 :supervillain: Supervillain  
U+1F9BA :safety_vest: Safety Vest  
U+1F9BB :ear_with_hearing_aid: Ear With Hearing Aid  
U+1F9BC :motorized_wheelchair: Motorized Wheelchair  
U+1F9BD :manual_wheelchair: Manual Wheelchair  
U+1F9BE :mechanical_arm: Mechanical Arm  
U+1F9BF :mechanical_leg: Mechanical Leg  
U+1F9C0 :cheese_wedge: Cheese Wedge  
U+1F9C1 :cupcake: Cupcake  
U+1F9C2 :salt: Salt Shaker  
U+1F9C3 :beverage_box: Beverage Box  
U+1F9C4 :garlic: Garlic  
U+1F9C5 :onion: Onion  
U+1F9C6 :falafel: Falafel  
U+1F9C7 :waffle: Waffle  
U+1F9C8 :butter: Butter  
U+1F9C9 :mate_drink: Mate Drink  
U+1F9CA :ice_cube: Ice Cube  
U+1F9CB :bubble_tea: Bubble Tea  
U+1F9CD :standing_person: Standing Person  
U+1F9CE :kneeling_person: Kneeling Person  
U+1F9CF :deaf_person: Deaf Person  
U+1F9D0 :face_with_monocle: Face With Monocle  
U+1F9D1 :adult: Adult  
U+1F9D2 :child: Child  
U+1F9D3 :older_adult: Older Adult  
U+1F9D4 :bearded_person: Bearded Person  
U+1F9D5 :person_with_head-  
scarf:

Person With Headscarf

U+1F9D6 :per-  
son_in_steamy_room:

Person In Steamy Room

U+1F9D7 :person_climbing: Person Climbing  
U+1F9D8 :person_in_lotus_posi-  
tion:

Person In Lotus Position

U+1F9D9 :mage: Mage  
U+1F9DA :fairy: Fairy  
U+1F9DB :vampire: Vampire  
U+1F9DC :merperson: Merperson  
U+1F9DD :elf: Elf  
U+1F9DE :genie: Genie  
U+1F9DF :zombie: Zombie  
U+1F9E0 :brain: Brain  
U+1F9E1 :orange_heart: Orange Heart  
U+1F9E2 :billed_cap: Billed Cap  
U+1F9E3 :scarf: Scarf  
U+1F9E4 :gloves: Gloves  
U+1F9E5 :coat: Coat  
U+1F9E6 :socks: Socks  
U+1F9E7 :red_envelope: Red Gift Envelope  
U+1F9E8 :firecracker: Firecracker  
U+1F9E9 :jigsaw: Jigsaw Puzzle Piece  
U+1F9EA :test_tube: Test Tube  
U+1F9EB :petri_dish: Petri Dish  
U+1F9EC :dna: Dna Double Helix  
U+1F9ED :compass: Compass  
U+1F9EE :abacus: Abacus  
U+1F9EF :fire_extinguisher: Fire Extinguisher  
U+1F9F0 :toolbox: Toolbox  
U+1F9F1 :bricks: Brick  
U+1F9F2 :magnet: Magnet  
U+1F9F3 :luggage: Luggage  
U+1F9F4 :lotion_bottle: Lotion Bottle  
U+1F9F5 :thread: Spool Of Thread  
U+1F9F6 :yarn: Ball Of Yarn  
U+1F9F7 :safety_pin: Safety Pin  
U+1F9F8 :teddy_bear: Teddy Bear  
U+1F9F9 :broom: Broom  
U+1F9FA :basket: Basket  
U+1F9FB :roll_of_paper: Roll Of Paper  
U+1F9FC :soap: Bar Of Soap  
U+1F9FD :sponge: Sponge  
U+1F9FE :receipt: Receipt  
U+1F9FF :nazar_amulet: Nazar Amulet  
U+1FA70 :ballet_shoes: Ballet Shoes  
U+1FA71 :one-piece_swimsuit: One-Piece Swimsuit  
U+1FA72 :briefs: Briefs  
U+1FA73 :shorts: Shorts  
U+1FA74 :thong_sandal: Thong Sandal  
U+1FA78 :drop_of_blood: Drop Of Blood  
U+1FA79 :adhesive_bandage: Adhesive Bandage  
U+1FA7A :stethoscope: Stethoscope  
U+1FA80 :yo-yo: Yo-Yo  
U+1FA81 :kite: Kite  
U+1FA82 :parachute: Parachute  
U+1FA83 :boomerang: Boomerang  
U+1FA84 :magic_wand: Magic Wand  
U+1FA85 :pinata: Pinata  
U+1FA86 :nesting_dolls: Nesting Dolls  
U+1FA90 :ringed_planet: Ringed Planet  
U+1FA91 :chair: Chair  
U+1FA92 :razor: Razor  
U+1FA93 :axe: Axe  
U+1FA94 :diya_lamp: Diya Lamp  
U+1FA95 :banjo: Banjo  
U+1FA96 :military_helmet: Military Helmet  
U+1FA97 :accordion: Accordion  
U+1FA98 :long_drum: Long Drum  
U+1FA99 :coin: Coin  
U+1FA9A :carpentry_saw: Carpentry Saw  
U+1FA9B :screwdriver: Screwdriver  
U+1FA9C :ladder: Ladder  
U+1FA9D :hook: Hook  
U+1FA9E :mirror: Mirror  
U+1FA9F :window: Window  
U+1FAA0 :plunger: Plunger  
U+1FAA1 :sewing_needle: Sewing Needle  
U+1FAA2 :knot: Knot  
U+1FAA3 :bucket: Bucket  
U+1FAA4 :mouse_trap: Mouse Trap  
U+1FAA5 :toothbrush: Toothbrush  
U+1FAA6 :headstone: Headstone  
U+1FAA7 :placard: Placard  
U+1FAA8 :rock: Rock  
U+1FAB0 :fly: Fly  
U+1FAB1 :worm: Worm  
U+1FAB2 :beetle: Beetle  
U+1FAB3 :cockroach: Cockroach  
U+1FAB4 :potted_plant: Potted Plant  
U+1FAB5 :wood: Wood  
U+1FAB6 :feather: Feather  
U+1FAC0 :anatomical_heart: Anatomical Heart  
U+1FAC1 :lungs: Lungs  
U+1FAC2 :people_hugging: People Hugging  
U+1FAD0 :blueberries: Blueberries  
U+1FAD1 :bell_pepper: Bell Pepper  
U+1FAD2 :olive: Olive  
U+1FAD3 :flatbread: Flatbread  
U+1FAD4 :tamale: Tamale  
U+1FAD5 :fondue: Fondue  
U+1FAD6 :teapot: Teapot

```
#### 429


**Chapter 40**

**Command-line Options**

The following is a complete list of command-line switches available when launching julia:

```

Julia 1.1  
In Julia 1.0, the default--project=@.option did not search up from the root directory of a Git  
repository for theProject.tomlfile. From Julia 1.1 forward, it does.

```
#### 430


#### CHAPTER 40. COMMAND-LINE OPTIONS 431

```

Switch Description  
-v,--version Display version information  
-h,--help Print command-line options (this message).  
--  
project[={

|@.}]

Set

as the home project/environment. The default @. option will search  
through parent directories until a Project.toml or JuliaProject.toml file is found.  
-J,--sysimage  

Start up with the given system image file

-H,--home

Set location ofjuliaexecutable  
--startup-  
file={yes|no}

Load~/.julia/config/startup.jl

--handle-  
signals={yes|no}

Enable or disable Julia's default signal handlers

--sysimage-  
native-  
code={yes|no}

Use native code from system image if available

--compiled-  
modules={yes|no}

Enable or disable incremental precompilation of modules

-e,--eval Evaluate  
-E,--print Evaluateand display the result  
-L,--load Loadimmediately on all processors  
-t,--threads  
{N|auto}

Enable N threads;autocurrently sets N to the number of local CPU threads but  
this might change in the future  
-p,--procs  
{N|auto}

Integer value N launches N additional local worker processes;autolaunches as  
many workers as the number of local CPU threads (logical cores)  
--machine-file  

Run processes on hosts listed in

-i Interactive mode; REPL runs andisinteractive()is true  
-q,--quiet Quiet startup: no banner, suppress REPL warnings  
--  
banner={yes|no|auto}

Enable or disable startup banner

--  
color={yes|no|auto}

Enable or disable color text

--history-  
file={yes|no}

Load or save history

```
#### --

```

depwarn={yes|no|error}

Enable or disable syntax and method deprecation warnings (errorturns  
warnings into errors)  
--warn-  
overwrite={yes|no}

Enable or disable method overwrite warnings

-C,--cpu-target  

Limit usage of CPU features up to; set tohelpto see the available  
options  
-O,--  
optimize={0,1,2,3}

Set the optimization level (default level is 2 if unspecified or 3 if used without a  
level)  
--min-  
optlevel={0,1,2,3}

Set the lower bound on per-module optimization (default is 0)

-g,-g Enable / Set the level of debug info generation (default level is 1 if unspecified or  
2 if used without a level)  
--inline={yes|no} Control whether inlining is permitted, including overriding@inlinedeclarations  
--check-  
bounds={yes|no|auto}

Emit bounds checks always, never, or respect @inbounds declarations

--math-  
mode={ieee,fast}

Disallow or enable unsafe floating point optimizations (overrides @fastmath  
declaration)  
--code-  
coverage={none|user|all}

Count executions of source lines

--code-coverage equivalent to--code-coverage=user  
--track-  
allocation={none|user|all}

Count bytes allocated by each source line

--track-  
allocation

equivalent to--track-allocation=user

```

**Part II**

**Base**

#### 432


**Chapter 41**

**Essentials**

### 41.1 Introduction

Julia Base contains a range of functions and macros appropriate for performing scientific and numerical com-
puting, butisalsoasbroadasthoseofmanygeneralpurposeprogramminglanguages. Additionalfunctionality
is available from a growing collection of available packages. Functions are grouped by topic below.

Some general notes:

- To use module functions, useimport Moduleto import the module, andModule.fn(x)to use the func-
    tions.
- Alternatively,using Modulewill import all exportedModulefunctions into the current namespace.
- By convention, function names ending with an exclamation point (!) modify their arguments. Some
    functions have both modifying (e.g.,sort!) and non-modifying (sort) versions.

The behaviors ofBaseand standard libraries are stable as defined inSemVeronly if they are documented; i.e.,
included in theJulia documentationand not marked as unstable. SeeAPI FAQfor more information.

### 41.2 Getting Around

Base.exit– Function.

```

exit(code=0)

Stop the program with an exit code. The default exit code is zero, indicating that the program completed  
successfully. In an interactive session,exit()can be called with the keyboard shortcut^D.  
source

```
Base.atexit– Function.

```

atexit(f)

Register a zero-argument functionf()to be called at process exit.atexit()hooks are called in last in  
first out (LIFO) order and run before object finalizers.  
Exit hooks are allowed to callexit(n), in which case Julia will exit with exit coden(instead of the original  
exit code). If more than one exit hook callsexit(n), then Julia will exit with the exit code corresponding

```
#### 433


#### CHAPTER 41. ESSENTIALS 434

```

to the last called exit hook that callsexit(n). (Because exit hooks are called in LIFO order,"last called" is  
equivalent to"first registered".)  
source

```
Base.isinteractive– Function.

```

isinteractive()-> Bool

Determine whether Julia is running an interactive session.  
source

```
Base.summarysize– Function.

```

Base.summarysize(obj; exclude= Union {...}, chargeall= Union {...}) -> Int

Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.  
Keyword Arguments

```
- exclude: specifies the types of objects to exclude from the traversal.
- chargeall: specifies the types of objects to always charge the size of all of their fields, even if those
    fields would normally be excluded.

```

source

```
Base.require– Function.

```

require(into:: Module , module :: Symbol )

This function is part of the implementation ofusing/import, if a module is not already defined inMain.  
It can also be called directly to force reloading a module, regardless of whether it has been loaded before  
(for example, when interactively developing libraries).  
Loads a source file, in the context of theMainmodule, on every active node, searching standard locations  
for files.requireis considered a top-level operation, so it sets the currentincludepath but does not  
use it to search for files (see help forinclude). This function is typically used to load library code, and is  
implicitly called byusingto load packages.  
When searching for files,requirefirst looks for package code in the global arrayLOAD_PATH.requireis  
case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.  
For more details regarding code loading, see the manual sections onmodulesand parallel computing.  
source

```
Base.compilecache– Function.

```

Base.compilecache( module ::PkgId)

Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce  
package load times. Cache files are stored inDEPOT_PATH[1]/compiled. See Module initialization and  
precompilationfor important notes.  
source

```
Base.__precompile__– Function.


#### CHAPTER 41. ESSENTIALS 435

```

**precompile**(isprecompilable:: Bool )

Specify whether the file calling this function is precompilable, defaulting totrue. If a module or file is not  
safely precompilable, it should call__precompile__(false)in order to throw an error if Julia attempts to  
precompile it.  
source

```
Base.include– Function.

```

Base.include([mapexpr:: Function ,] [m:: Module ,] path:: AbstractString )

Evaluate the contents of the input source file in the global scope of modulem. Every module (except those  
defined withbaremodule) has its own definition ofincludeomitting themargument, which evaluates the  
file in that module. Returns the result of the last evaluated expression of the input file. During including, a  
task-localincludepathissettothedirectorycontainingthefile. Nestedcallstoincludewillsearchrelative  
to that path. This function is typically used to load source interactively, or to combine files in packages  
that are broken into multiple source files.  
The optional first argumentmapexprcan be used to transform the included code before it is evaluated:  
for each parsed expressionexprinpath, theincludefunction actually evaluatesmapexpr(expr). If it is  
omitted,mapexprdefaults toidentity.

Julia 1.5  
Julia 1.5 is required for passing themapexprargument.

source

```
Base.MainInclude.include– Function.

```

include([mapexpr:: Function ,] path:: AbstractString )

Evaluate the contents of the input source file in the global scope of the containing module. Every module  
(except those defined withbaremodule) has its own definition ofinclude, which evaluates the file in that  
module. Returns the result of the last evaluated expression of the input file. During including, a task-local  
include path is set to the directory containing the file. Nested calls toincludewill search relative to that  
path. This function is typically used to load source interactively, or to combine files in packages that are  
broken into multiple source files.  
The optional first argumentmapexprcan be used to transform the included code before it is evaluated:  
for each parsed expressionexprinpath, theincludefunction actually evaluatesmapexpr(expr). If it is  
omitted,mapexprdefaults toidentity.  
UseBase.includeto evaluate a file into another module.

Julia 1.5  
Julia 1.5 is required for passing themapexprargument.

source

```
Base.include_string– Function.

```

include_string([mapexpr:: Function ,] m :: Module , code:: AbstractString ,  
↪→ filename:: AbstractString ="string")

```

#### CHAPTER 41. ESSENTIALS 436

```

Likeinclude, except reads code from the given string rather than from a file.  
The optional first argumentmapexprcan be used to transform the included code before it is evaluated: for  
each parsed expressionexprincode, theinclude_stringfunction actually evaluatesmapexpr(expr). If  
it is omitted,mapexprdefaults toidentity.

Julia 1.5  
Julia 1.5 is required for passing themapexprargument.

source

```
Base.include_dependency– Function.

```

include_dependency(path:: AbstractString )

Inamodule,declarethatthefilespecifiedbypath(relativeorabsolute)isadependencyforprecompilation;  
that is, the module will need to be recompiled if this file changes.  
This is only needed if your module depends on a file that is not used viainclude. It has no effect outside  
of compilation.  
source

```
Base.which– Method.

```

which(f, types)

Returns the method off(aMethodobject) that would be called for arguments of the giventypes.  
Iftypesis an abstract type, then the method that would be called byinvokeis returned.  
See also:parentmodule, and@whichand@editinInteractiveUtils.  
source

```
Base.methods– Function.

```

methods(f, [types], [ module ])

Return the method table forf.  
Iftypesis specified, return an array of methods whose types match. Ifmoduleis specified, return an array  
of methods defined in that module. A list of modules can also be specified as an array.

Julia 1.4  
At least Julia 1.4 is required for specifying a module.

See also:whichand@which.  
source

```
Base.@show– Macro.

```

@showexs...

Prints one or more expressions, and their results, tostdout, and returns the last result.  
See also:show,@info,println.  
Examples

```

#### CHAPTER 41. ESSENTIALS 437

```

julia> x = @show1+2  
1 + 2 = 3  
3

julia> @showx^2 x/2;  
x ^ 2 = 9  
x / 2 = 1.5

source

```
ans– Keyword.

```

ans

A variable referring to the last computed value, automatically set at the interactive prompt.  
source

```
Base.active_project– Function.

```

active_project()

Return the path of the activeProject.tomlfile.  
source

```
### 41.3 Keywords

This is the list of reserved keywords in Julia:baremodule,begin,break,catch,const,continue,do,else,
elseif,end,export,false,finally,for,function,global,if,import,let,local,macro,module,quote,
return,struct,true,try,using,while. Those keywords are not allowed to be used as variable names.

The following two-word sequences are reserved:abstract type,mutable struct,primitive type. How-
ever, you can create variables with names:abstract,mutable,primitiveandtype.

Finally:whereis parsed as an infix operator for writing parametric method and type definitions;inandisaare
parsed as infix operators; andouteris parsed as a keyword when used to modify the scope of a variable in an
iteration specification of aforloop orgeneratorexpression. Creation of variables namedwhere,in,isaor
outeris allowed though.

module– Keyword.

```

module

moduledeclaresaModule, whichisaseparateglobalvariableworkspace. Withinamodule, youcancontrol  
which names from other modules are visible (via importing), and specify which of your names are intended  
to be public (via exporting). Modules allow you to create top-level definitions without worrying about name  
conflicts when your code is used together with somebody else’s. See themanual section about modules  
for more details.  
Examples

module Foo  
import Base.show  
export MyType, foo

struct MyType

```

#### CHAPTER 41. ESSENTIALS 438

```

x  
end

bar(x)= 2x  
foo(a::MyType)= bar(a.x) + 1  
show(io:: IO , a ::MyType)= print(io,"MyType $ (a.x)")  
end

source

```
export– Keyword.

```

export

exportis used within modules to tell Julia which functions should be made available to the user. For  
example:export foomakes the namefooavailable whenusingthe module. See themanual section  
about modulesfor details.  
source

```
import– Keyword.

```

import

import Foowill load the module or packageFoo. Names from the importedFoomodule can be accessed  
with dot syntax (e.g.Foo.footo access the namefoo). See themanual section about modulesfor details.  
source

```
using– Keyword.

```

using

using Foowill load the module or packageFooand make itsexported names available for direct use.  
Names can also be used via dot syntax (e.g.Foo.footo access the namefoo), whether they areexported  
or not. See themanual section about modulesfor details.  
source

```
baremodule– Keyword.

```

baremodule

baremoduledeclares a module that does not containusing Baseor local definitions ofevalandinclude.  
It does still importCore. In other words,

module Mod

...

end

is equivalent to

baremodule Mod

using Base

```

#### CHAPTER 41. ESSENTIALS 439

```

eval(x)= Core.eval(Mod, x)  
include(p)= Base.include(Mod, p)

...

end

source

```
function– Keyword.

```

function

Functions are defined with thefunctionkeyword:

function add(a, b)  
return a + b  
end

Or the short form notation:

add(a, b)= a + b

The use of thereturnkeyword is exactly the same as in other languages, but is often optional. A function  
without an explicitreturnstatement will return the last expression in the function body.  
source

```
macro– Keyword.

```

macro

macrodefines a method for inserting generated code into a program. A macro maps a sequence of ar-  
gument expressions to a returned expression, and the resulting expression is substituted directly into the  
program at the point where the macro is invoked. Macros are a way to run generated code without calling  
eval, since the generated code instead simply becomes part of the surrounding program. Macro argu-  
ments may include expressions, literal values, and symbols. Macros can be defined for variable number  
of arguments (varargs), but do not accept keyword arguments. Every macro also implicitly gets passed  
the arguments__source__, which contains the line number and file name the macro is called from, and  
**module**, which is the module the macro is expanded in.  
Examples

julia>macro sayhello(name)  
return :( println("Hello, ", $name,"!") )  
end  
@sayhello (macro with 1 method)

julia> @sayhello"Charlie"  
Hello, Charlie!

julia>macro saylots(x...)  
return :( println("Say: ", $(x...)) )  
end  
@saylots (macro with 1 method)

```

#### CHAPTER 41. ESSENTIALS 440

```

julia> @saylots"hey ""there ""friend"  
Say: hey there friend

source

```
return– Keyword.

```

return

return xcauses the enclosing function to exit early, passing the given valuexback to its caller.return  
by itself with no value is equivalent toreturn nothing(seenothing).

function compare(a, b)  
a == b && return "equal to"  
a < b? "less than": "greater than"  
end

In general you can place areturnstatement anywhere within a function body, including within deeply  
nested loops or conditionals, but be careful withdoblocks. For example:

function test1(xs)  
for x in xs  
iseven(x)&& return 2x  
end  
end

function test2(xs)  
map(xs) do x  
iseven(x)&& return 2x  
x  
end  
end

In the first example, the return breaks out oftest1as soon as it hits an even number, sotest1([5,6,7])  
returns 12.  
You might expect the second example to behave the same way, but in fact thereturnthere only breaks  
out of the inner function (inside thedoblock) and gives a value back tomap.test2([5,6,7])then returns  
[5,12,7].  
When used in a top-level expression (i.e. outside any function),returncauses the entire current top-level  
expression to terminate early.  
source

```
do– Keyword.

```

do

Create an anonymous function and pass it as the first argument to a function call. For example:

map(1:10) do x  
2x  
end

```

#### CHAPTER 41. ESSENTIALS 441

```

is equivalent tomap(x->2x, 1:10).  
Use multiple arguments like so:

map(1:10, 11:20) do x, y  
x + y  
end

source

```
begin– Keyword.

```

begin

begin...enddenotes a block of code.

begin  
println("Hello, ")  
println("World!")  
end

Usuallybeginwill not be necessary, since keywords such asfunctionandletimplicitly begin blocks of  
code. See also;.  
beginmay also be used when indexing to represent the first index of a collection or the first index of a  
dimension of an array.  
Examples

julia> A = [1 2; 3 4]  
2×2 Array{Int64,2}:  
1 2  
3 4

julia> A[ begin , :]  
2-element Array{Int64,1}:  
1  
2

source

```
end– Keyword.

```

end

endmarks the conclusion of a block of expressions, for examplemodule,struct,mutable struct,begin,  
let,foretc.  
endmay also be used when indexing to represent the last index of a collection or the last index of a  
dimension of an array.  
Examples

julia> A = [1 2; 3 4]  
2×2 Array{Int64, 2}:  
1 2  
3 4

```

#### CHAPTER 41. ESSENTIALS 442

```

julia> A[ end , :]  
2-element Array{Int64, 1}:  
3  
4

source

```
let– Keyword.

```

let

letstatements create a new hard scope block and introduce new variable bindings each time they run.  
Whereas assignments might reassign a new value to an existing value location,letalways creates a new  
location. This difference is only detectable in the case of variables that outlive their scope via closures.  
Theletsyntax accepts a comma-separated series of assignments and variable names:

let var1= value1, var2, var3= value3  
code  
end

The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new  
variable on the left-hand side has been introduced. Therefore it makes sense to write something likelet  
x = x, since the twoxvariables are distinct and have separate storage.  
source

```
if– Keyword.

```

if / elseif / else

if/elseif/elseperforms conditional evaluation, which allows portions of code to be evaluated or not  
evaluated depending on the value of a boolean expression. Here is the anatomy of theif/elseif/else  
conditional syntax:

if x < y  
println("x is less than y")  
elseif x > y  
println("x is greater than y")  
else  
println("x is equal to y")  
end

Iftheconditionexpressionx < yistrue,thenthecorrespondingblockisevaluated; otherwisethecondition  
expressionx > yis evaluated, and if it is true, the corresponding block is evaluated; if neither expression  
is true, theelseblock is evaluated. Theelseifandelseblocks are optional, and as manyelseifblocks  
as desired can be used.  
In contrast to some other languages conditions must be of typeBool. It does not suffice for conditions to  
be convertible toBool.

julia>if 1 end  
ERROR: TypeError: non-boolean (Int64) used in boolean context

source

```

#### CHAPTER 41. ESSENTIALS 443

for– Keyword.

```

for

forloops repeatedly evaluate a block of statements while iterating over a sequence of values.  
Examples

julia>for i in [1, 4, 0]  
println(i)  
end  
1  
4  
0

source

```
while– Keyword.

```

while

whileloops repeatedly evaluate a conditional expression, and continue evaluating the body of the while  
loop as long as the expression remains true. If the condition expression is false when the while loop is first  
reached, the body is never evaluated.  
Examples

julia> i = 1  
1

julia>while i < 5  
println(i)  
global i += 1  
end  
1  
2  
3  
4

source

```
break– Keyword.

```

break

Break out of a loop immediately.  
Examples

julia> i = 0  
0

julia>whiletrue  
global i += 1  
i > 5 && break  
println(i)  
end

```

#### CHAPTER 41. ESSENTIALS 444

```

1  
2  
3  
4  
5

source

```
continue– Keyword.

```

continue

Skip the rest of the current loop iteration.  
Examples

julia>for i = 1:6  
iseven(i)&& continue  
println(i)  
end  
1  
3  
5

source

```
try– Keyword.

```

try / catch

Atry/catchstatement allows intercepting errors (exceptions) thrown bythrowso that program execution  
can continue. For example, the following code attempts to write a file, but warns the user and proceeds  
instead of terminating execution if the file cannot be written:

try  
open("/danger", "w") do f  
println(f,"Hello")  
end  
catch  
@warn"Could not write file."  
end

or, when the file cannot be read into a variable:

lines= try  
open("/danger", "r") do f  
readlines(f)  
end  
catch  
@warn"File not found."  
end

The syntaxcatch e(whereeis any variable) assigns the thrown exception object to the given variable  
within thecatchblock.  
Thepowerofthetry/catchconstructliesintheabilitytounwindadeeplynestedcomputationimmediately  
to a much higher level in the stack of calling functions.  
source

```

#### CHAPTER 41. ESSENTIALS 445

finally– Keyword.

```

finally

Run some code when a given block of code exits, regardless of how it exits. For example, here is how we  
can guarantee that an opened file is closed:

f = open("file")  
try  
operate_on_file(f)  
finally  
close(f)  
end

When control leaves thetryblock (for example, due to areturn, or just finishing normally),close(f)will  
be executed. If thetryblock exits due to an exception, the exception will continue propagating. Acatch  
block may be combined withtryandfinallyas well. In this case thefinallyblock will run aftercatch  
has handled the error.  
source

```
quote– Keyword.

```

quote

quotecreates multiple expression objects in a block without using the explicitExprconstructor. For ex-  
ample:

ex = quote  
x = 1  
y = 2  
x + y  
end

Unlike the other means of quoting,:( ... ), this form introducesQuoteNodeelements to the expression  
tree, which must be considered when directly manipulating the tree. For other purposes,:( ... )and  
quote .. endblocks are treated identically.  
source

```
local– Keyword.

```

local

localintroduces a new local variable. See themanual section on variable scopingfor more information.  
Examples

julia>function foo(n)  
x = 0  
for i = 1:n  
local x # introduce a loop-local x  
x = i  
end  
x  
end  
foo (generic function with 1 method)

```

#### CHAPTER 41. ESSENTIALS 446

```

julia> foo(10)  
0

source

```
global– Keyword.

```

global

global xmakesxin the current scope and its inner scopes refer to the global variable of that name. See  
the manual section on variable scopingfor more information.  
Examples

julia> z = 3  
3

julia>function foo()  
global z = 6 # use the z variable defined outside foo  
end  
foo (generic function with 1 method)

julia> foo()  
6

julia> z  
6

source

```
const– Keyword.

```

const

constis used to declare global variables whose values will not change. In almost all code (and particularly  
performance sensitive code) global variables should be declared constant in this way.

const x = 5

Multiple variables can be declared within a singleconst:

const y, z= 7, 11

Note thatconstonly applies to one=operation, thereforeconst x = y = 1declaresxto be constant but  
noty. On the other hand,const x = const y = 1declares bothxandyconstant.  
Notethat"constant-ness"doesnotextendintomutablecontainers; onlytheassociationbetweenavariable  
and its value is constant. Ifxis an array or dictionary (for example) you can still modify, add, or remove  
elements.  
In some cases changing the value of aconstvariable gives a warning instead of an error. However, this  
can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This  
feature is intended only for convenience during interactive use.  
source

```

#### CHAPTER 41. ESSENTIALS 447

struct– Keyword.

```

struct

The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.

struct Point  
x  
y  
end

Fields can have type restrictions, which may be parameterized:

struct Point{X}  
x::X  
y:: Float64  
end

A struct can also declare an abstract super type via<:syntax:

struct Point<: AbstractPoint  
x  
y  
end

structsareimmutablebydefault; aninstanceofoneofthesetypescannotbemodifiedafterconstruction.  
Usemutable structinstead to declare a type whose instances can be modified.  
See the manual section onComposite Typesfor more details, such as how to define constructors.  
source

```
mutable struct– Keyword.

```

mutable struct

mutable structis similar tostruct, but additionally allows the fields of the type to be set after construc-  
tion. See the manual section onComposite Typesfor more information.  
source

```
abstract type– Keyword.

```

abstracttype

abstract typedeclares a type that cannot be instantiated, and serves only as a node in the type graph,  
thereby describing sets of related concrete types: those concrete types which are their descendants.  
Abstract types form the conceptual hierarchy which makes Julia’s type system more than just a collection  
of object implementations. For example:

abstracttypeNumberend  
abstracttypeReal <: Numberend

Numberhas no supertype, whereasRealis an abstract subtype ofNumber.  
source

```

#### CHAPTER 41. ESSENTIALS 448

primitive type– Keyword.

```

primitive type

primitive typedeclares a concrete type whose data consists only of a series of bits. Classic examples of  
primitive types are integers and floating-point values. Some example built-in primitive type declarations:

primitive typeChar 32 end  
primitive typeBool <: Integer 8 end

The number after the name indicates how many bits of storage the type requires. Currently, only sizes that  
are multiples of 8 bits are supported. TheBooldeclaration shows how a primitive type can be optionally  
declared to be a subtype of some supertype.  
source

```
where– Keyword.

```

where

Thewherekeyword creates a type that is an iterated union of other types, over all values of some variable.  
For exampleVector{T} where T<:Realincludes allVectors where the element type is some kind ofReal  
number.  
The variable bound defaults toAnyif it is omitted:

Vector {T} where T # short for `where T<:Any`

Variables can also have lower bounds:

Vector {T} where T>: Int  
Vector {T} where Int <:T<: Real

There is also a concise syntax for nestedwhereexpressions. For example, this:

Pair {T, S} where S<: Array {T} where T<: Number

can be shortened to:

Pair {T, S} where {T<: Number , S <: Array {T}}

This form is often found on method signatures.  
Note that in this form, the variables are listed outermost-first. This matches the order in which variables  
are substituted when a type is"applied" to parameter values using the syntaxT{p1, p2, ...}.  
source

```
...– Keyword.

```

...

The "splat" operator,..., represents a sequence of arguments....can be used in function definitions,  
to indicate that the function accepts an arbitrary number of arguments....can also be used to apply a  
function to a sequence of arguments.  
Examples

```

#### CHAPTER 41. ESSENTIALS 449

```

julia> add(xs...) = reduce(+, xs)  
add (generic function with 1 method)

julia> add(1, 2, 3, 4, 5)  
15

julia> add([1, 2, 3]...)  
6

julia> add(7, 1:100..., 1000:1100...)  
111107

source

```
;– Keyword.

```

;

;has a similar role in Julia as in many C-like languages, and is used to delimit the end of the previous  
statement.;is not necessary after new lines, but can be used to separate statements on a single line  
or to join statements into a single expression.;is also used to suppress output printing in the REPL and  
similar interfaces.  
Examples

julia> function foo()  
x = "Hello, "; x *= "World!"  
return x  
end  
foo (generic function with1 method)

julia> bar()= (x = "Hello, Mars!"; return x)  
bar (generic function with1 method)

julia> foo();

julia> bar()  
"Hello, Mars!"

source

```
=– Keyword.

```

=

=is the assignment operator.

```
- For variableaand expressionb,a = bmakesarefer to the value ofb.
- For functionsf(x),f(x) = xdefines a new function constantf, or adds a new method tofiffis
    already defined; this usage is equivalent tofunction f(x); x; end.
- a[i] = vcallssetindex!(a,v,i).
- a.b = ccallssetproperty!(a,:b,c).
- Inside a function call,f(a=b)passesbas the value of keyword argumenta.
- Inside parentheses with commas,(a=1,)constructs aNamedTuple.


#### CHAPTER 41. ESSENTIALS 450

```

Examples  
Assigningatobdoes not create a copy ofb; instead usecopyordeepcopy.

julia> b = [1]; a= b; b[1] = 2; a  
1-element Array{Int64, 1}:  
2

julia> b = [1]; a= copy(b); b[1] = 2; a  
1-element Array{Int64, 1}:  
1

Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the  
objects their arguments refer to. (The names of functions which do this are conventionally suffixed with  
'!'.)

julia>function f!(x); x[:] .+= 1; end  
f! (generic function with 1 method)

julia> a = [1]; f!(a); a  
1-element Array{Int64, 1}:  
2

Assignment can operate on multiple variables in parallel, taking values from an iterable:

julia> a, b= 4, 5  
(4, 5)

julia> a, b= 1:3  
1:3

julia> a, b  
(1, 2)

Assignment can operate on multiple variables in series, and will return the value of the right-hand-most  
expression:

julia> a = [1]; b= [2]; c= [3]; a= b = c  
1-element Array{Int64, 1}:  
3

julia> b[1] = 2; a, b, c  
([2], [2], [2])

Assignment at out-of-bounds indices does not grow a collection. If the collection is aVectorit can instead  
be grown withpush!orappend!.

julia> a = [1, 1]; a[3] = 2  
ERROR: BoundsError: attempt to access 2-element Array{Int64, 1} at index [3]  
[...]

julia> push!(a,2, 3)  
4-element Array{Int64, 1}:  
1  
1  
2  
3

```

#### CHAPTER 41. ESSENTIALS 451

```

Assigning[]does not eliminate elements from a collection; instead usefilter!.

julia> a = collect(1:3); a[a.<= 1] = []  
ERROR: DimensionMismatch("tried to assign 0 elements to 1 destinations")  
[...]

julia> filter!(x-> x > 1, a)# in-place & thus more efficient than a = a[a .> 1]  
2-element Array{Int64, 1}:  
2  
3

source

```
?:– Keyword.

```

a? b : c

Shortformforconditionals;read"ifa,evaluatebotherwiseevaluatec". Alsoknownastheternaryoperator.  
This syntax is equivalent toif a; b else c end, but is often used to emphasize the valueb-or-cwhich  
is being used as part of a larger expression, rather than the side effects that evaluatingborcmay have.  
See the manual section oncontrol flowfor more details.  
Examples  
julia> x = 1; y = 2;

julia> x > y? println("x is larger") : println("y is larger")  
y is larger

source

```
### 41.4 Standard Modules

Main– Module.

```

Main

Mainis the top-level module, and Julia starts withMainset as the current module. Variables defined at the  
prompt go inMain, andvarinfolists variables inMain.

julia> @**MODULE**  
Main

source

```
Core– Module.

```

Core

Coreis the module that contains all identifiers considered"built in" to the language, i.e. part of the core  
language and not libraries. Every module implicitly specifiesusing Core, since you can't do anything  
without those definitions.  
source

```
Base– Module.


#### CHAPTER 41. ESSENTIALS 452

```

Base

The base library of Julia.Baseis a module that contains basic functionality (the contents ofbase/). All  
modules implicitly containusing Base, since this is needed in the vast majority of cases.  
source

```
### 41.5 Base Submodules

Base.Broadcast– Module.

```

Base.Broadcast

Module containing the broadcasting implementation.  
source

```
Base.Docs– Module.

```

Docs

TheDocsmodule provides the@docmacro which can be used to set and retrieve documentation metadata  
for Julia objects.  
Please see the manual section ondocumentationfor more information.  
source

```
Base.Iterators– Module.

```

Methods for working with Iterators.  
source

```
Base.Libc– Module.

```

Interface to libc, the C standard library.  
source

```
Base.Meta– Module.

```

Convenience functions for metaprogramming.  
source

```
Base.StackTraces– Module.

```

Tools for collecting and manipulating stack traces. Mainly used for building errors.  
source

```
Base.Sys– Module.

```

Provide methods for retrieving information about hardware and the operating system.  
source

```
Base.Threads– Module.


#### CHAPTER 41. ESSENTIALS 453

```

Multithreading support.  
source

```
Base.GC– Module.

```

Base.GC

Module with garbage collection utilities.  
source

```
### 41.6 All Objects.

Core.:===– Function.

```

===(x,y)-> Bool  
≡(x,y)-> Bool

Determine whetherxandyare identical, in the sense that no program could distinguish them. First the  
types ofxandyare compared. If those are identical, mutable objects are compared by address in memory  
and immutable objects (such as numbers) are compared by contents at the bit level. This function is  
sometimes called"egal". It always returns aBoolvalue.  
Examples

julia> a = [1, 2]; b= [1, 2];

julia> a == b  
true

julia> a === b  
false

julia> a === a  
true

source

```
Core.isa– Function.

```

isa(x, type ) -> Bool

Determine whetherxis of the giventype. Can also be used as an infix operator, e.g.x isa type.  
Examples

julia> isa(1, Int )  
true

julia> isa(1, Matrix )  
false

julia> isa(1, Char )  
false

julia> isa(1, Number )

```

#### CHAPTER 41. ESSENTIALS 454

```

true

julia> 1 isa Number  
true

source

```
Base.isequal– Function.

```

isequal(x, y)

Similar to==, except for the treatment of floating point numbers and of missing values.isequaltreats all  
floating-pointNaNvalues as equal to each other, treats-0.0as unequal to0.0, andmissingas equal to  
missing. Always returns aBoolvalue.  
isequalis an equivalence relation - it is reflexive (===impliesisequal), symmetric (isequal(a, b)im-  
pliesisequal(b, a)) and transitive (isequal(a, b)andisequal(b, c)impliesisequal(a, c)).  
Implementation  
The default implementation ofisequalcalls==, so a type that does not involve floating-point values  
generally only needs to define==.  
isequalis the comparison function used by hash tables (Dict).isequal(x,y)must imply thathash(x)  
== hash(y).  
This typically means that types for which a custom==orisequalmethod exists must implement a cor-  
respondinghashmethod (and vice versa). Collections typically implementisequalby callingisequal  
recursively on all contents.  
Furthermore,isequalis linked withisless, and they work together to define a fixed total ordering, where  
exactly one ofisequal(x, y),isless(x, y), orisless(y, x)must betrue(and the other twofalse).  
Scalartypesgenerallydonotneedtoimplementisequalseparatefrom==, unlesstheyrepresentfloating-  
pointnumbersamenabletoamoreefficientimplementationthanthatprovidedasagenericfallback(based  
onisnan,signbit, and==).  
Examples

julia> isequal([1., NaN], [ 1., NaN])  
true

julia> [1., NaN] == [1., NaN]  
false

julia> 0.0 == -0.0  
true

julia> isequal(0.0, -0.0)  
false

julia> missing== missing  
missing

julia> isequal(missing, missing)  
true

source

```

#### CHAPTER 41. ESSENTIALS 455

```

isequal(x)

Create a function that compares its argument toxusingisequal, i.e. a function equivalent toy ->  
isequal(y, x).  
The returned function is of typeBase.Fix2{typeof(isequal)}, which can be used to implement special-  
ized methods.  
source

```
Base.isless– Function.

```

isless(x, y)

Test whetherxis less thany, according to a fixed total order (defined together withisequal).islessis  
not defined on all pairs of values(x, y). However, if it is defined, it is expected to satisfy the following:

```
- Ifisless(x, y)is defined, then so isisless(y, x)andisequal(x, y), and exactly one of those
    three yieldstrue.
- Therelationdefinedbyislessistransitive,i.e.,isless(x, y) && isless(y, z)impliesisless(x,
    z).

```

Values that are normally unordered, such asNaN, are ordered after regular values.missingvalues are  
ordered last.  
This is the default comparison used bysort.  
Implementation  
Non-numeric types with a total order should implement this function. Numeric types only need to imple-  
ment it if they have special values such asNaN. Types with a partial order should implement<. See the  
documentation onAlternate orderingsfor how to define alternate ordering methods that can be used in  
sorting and related functions.  
Examples

julia> isless(1, 3)  
true

julia> isless("Red", "Blue")  
false

source

```
Core.ifelse– Function.

```

ifelse(condition:: Bool , x, y)

Returnxifconditionistrue, otherwise returny. This differs from?orifin that it is an ordinary function,  
so all the arguments are evaluated first. In some cases, usingifelseinstead of anifstatement can  
eliminate the branch in generated code and provide higher performance in tight loops.  
Examples

julia> ifelse(1 > 2, 1, 2)  
2

```

#### CHAPTER 41. ESSENTIALS 456

```

source

```
Core.typeassert– Function.

```

typeassert(x, type )

Throw aTypeErrorunlessx isa type. The syntaxx::typecalls this function.  
Examples

julia> typeassert(2.5, Int )  
ERROR: TypeError: in typeassert, expected Int64, got a value of type Float64  
Stacktrace:  
[...]

source

```
Core.typeof– Function.

```

typeof(x)

Get the concrete type ofx.  
See alsoeltype.  
Examples

julia> a = 1//2;

julia> typeof(a)  
Rational{Int64}

julia> M = [1 2; 3.5 4];

julia> typeof(M)  
Matrix{Float64} (alias for Array{Float64, 2})

source

```
Core.tuple– Function.

```

tuple(xs...)

Construct a tuple of the given objects.  
See alsoTuple,NamedTuple.  
Examples

julia> tuple(1, 'b', pi)  
(1, 'b', π)

julia> ans === (1, 'b', π)  
true

julia>Tuple ( Real [1, 2, pi]) # takes a collection  
(1, 2, π)

source

```

#### CHAPTER 41. ESSENTIALS 457

Base.ntuple– Function.

```

ntuple(f:: Function , n :: Integer )

Create a tuple of lengthn, computing each element asf(i), whereiis the index of the element.  
Examples

julia> ntuple(i-> 2*i, 4)  
(2, 4, 6, 8)

source  
ntuple(f, ::Val{N})

Create a tuple of lengthN, computing each element asf(i), whereiis the index of the element. By taking  
aVal(N)argument, it is possible that this version of ntuple may generate more efficient code than the  
version taking the length as an integer. Butntuple(f, N)is preferable tontuple(f, Val(N))in cases  
whereNcannot be determined at compile time.  
Examples

julia> ntuple(i-> 2*i, Val (4))  
(2, 4, 6, 8)

source

```
Base.objectid– Function.

```

objectid(x)-> UInt

Get a hash value forxbased on object identity.objectid(x)==objectid(y)ifx === y.  
See alsohash,IdDict.  
source

```
Base.hash– Function.

```

hash(x[, h:: UInt ]) -> UInt

Compute an integer hash code such thatisequal(x,y)implieshash(x)==hash(y). The optional second  
argumenthis a hash code to be mixed with the result.  
New types should implement the 2-argument form, typically by calling the 2-argumenthashmethod re-  
cursively in order to mix hashes of the contents with each other (and withh). Typically, any type that  
implementshashshould also implement its own==(henceisequal) to guarantee the property mentioned  
above. Types supporting subtraction (operator-) should also implementwiden, which is required to hash  
values inside heterogeneous arrays.  
See also:objectid,Dict,Set.  
source

```
Base.finalizer– Function.

```

finalizer(f, x)

```

#### CHAPTER 41. ESSENTIALS 458

```

Register a functionf(x)to be called when there are no program-accessible references tox, and returnx.  
The type ofxmust be amutable struct, otherwise the behavior of this function is unpredictable.  
fmust not cause a task switch, which excludes most I/O operations such asprintln. Using the@async  
macro (to defer context switching to outside of the finalizer) orccallto directly invoke IO functions in C  
may be helpful for debugging purposes.  
Examples

finalizer(my_mutable_struct) do x  
@asyncprintln("Finalizing $x .")  
end

finalizer(my_mutable_struct) do x  
ccall (:jl_safe_printf, Cvoid, ( Cstring , Cstring ), "Finalizing %s .", repr(x))  
end

A finalizer may be registered at object construction. In the following example note that we implicitly rely  
on the finalizer returning the newly created mutable structx.  
Example

mutable struct MyMutableStruct  
bar  
function MyMutableStruct(bar)  
x = new(bar)  
f(t)= @asyncprintln("Finalizing $t .")  
finalizer(f, x)  
end  
end

source

```
Base.finalize– Function.

```

finalize(x)

Immediately run finalizers registered for objectx.  
source

```
Base.copy– Function.

```

copy(x)

Create a shallow copy ofx: the outer structure is copied, but not all internal values. For example, copying  
an array produces a new array with identically-same elements as the original.  
See alsocopy!,copyto!.  
source

```
Base.deepcopy– Function.

```

deepcopy(x)

```

#### CHAPTER 41. ESSENTIALS 459

```

Create a deep copy ofx: everything is copied recursively, resulting in a fully independent object. For  
example, deep-copying an array produces a new array whose elements are deep copies of the original  
elements. Callingdeepcopyon an object should generally have the same effect as serializing and then  
deserializing it.  
Whileitisn'tnormallynecessary,user-definedtypescanoverridethedefaultdeepcopybehaviorbydefining  
a specialized version of the functiondeepcopy_internal(x::T, dict::IdDict)(which shouldn't other-  
wise be used), whereTis the type to be specialized for, anddictkeeps track of objects copied so far  
within the recursion. Within the definition,deepcopy_internalshould be used in place ofdeepcopy, and  
thedictvariable should be updated as appropriate before returning.  
source

```
Base.getproperty– Function.

```

getproperty(value, name:: Symbol )  
getproperty(value, name:: Symbol , order:: Symbol )

The syntaxa.bcallsgetproperty(a, :b). The syntax@atomic order a.bcallsgetproperty(a, :b,  
:order)and the syntax@atomic a.bcallsgetproperty(a, :b, :sequentially_consistent).  
Examples

julia> struct MyType  
x  
end

julia>function Base.getproperty(obj::MyType, sym:: Symbol )  
if sym === :special  
return obj.x + 1  
else # fallback to getfield  
return getfield(obj, sym)  
end  
end

julia> obj = MyType(1);

julia> obj.special  
2

julia> obj.x  
1

See alsogetfield,propertynamesandsetproperty!.  
source

```
Base.setproperty!– Function.

```

setproperty!(value, name:: Symbol , x)  
setproperty!(value, name:: Symbol , x, order:: Symbol )

Thesyntaxa.b = ccallssetproperty!(a, :b, c). Thesyntax@atomic order a.b = ccallssetproperty!(a,  
:b, c, :order)andthesyntax@atomic a.b = ccallsgetproperty(a, :b, :sequentially_consistent).  
See alsosetfield!,propertynamesandgetproperty.  
source

```

#### CHAPTER 41. ESSENTIALS 460

Base.propertynames– Function.

```

propertynames(x, private= false )

Get a tuple or a vector of the properties (x.property) of an objectx. This is typically the same as  
fieldnames(typeof(x)), but types that overloadgetpropertyshould generally overloadpropertynames  
as well to get the properties of an instance of the type.  
propertynames(x)may return only"public" property names that are part of the documented interface of  
x. If you want it to also return"private" fieldnames intended for internal use, passtruefor the optional  
second argument. REPL tab completion onx.shows only theprivate=falseproperties.  
See also:hasproperty,hasfield.  
source

```
Base.hasproperty– Function.

```

hasproperty(x, s:: Symbol )

Return a boolean indicating whether the objectxhassas one of its own properties.

Julia 1.2  
This function requires at least Julia 1.2.

See also:propertynames,hasfield.  
source

```
Core.getfield– Function.

```

getfield(value, name:: Symbol , [order:: Symbol ])  
getfield(value, i:: Int , [order:: Symbol ])

Extract a field from a compositevalueby name or position. Optionally, an ordering can be defined for the  
operation. If the field was declared@atomic, the specification is strongly recommended to be compatible  
withthestorestothatlocation. Otherwise,ifnotdeclaredas@atomic,thisparametermustbe:not_atomic  
if specified. See alsogetpropertyandfieldnames.  
Examples

julia> a = 1//2  
1//2

julia> getfield(a,:num)  
1

julia> a.num  
1

julia> getfield(a,1)  
1

source

```
Core.setfield!– Function.


#### CHAPTER 41. ESSENTIALS 461

```

setfield!(value, name:: Symbol , x, [order:: Symbol ])  
setfield!(value, i:: Int , x, [order:: Symbol ])

Assignxto a named field invalueof composite type. Thevaluemust be mutable andxmust be a subtype  
offieldtype(typeof(value), name). Additionally, an ordering can be specified for this operation. If the  
field was declared@atomic, this specification is mandatory. Otherwise, if not declared as@atomic, it must  
be:not_atomicif specified. See alsosetproperty!.  
Examples

julia> mutable struct MyMutableStruct  
field:: Int  
end

julia> a = MyMutableStruct(1);

julia> setfield!(a,:field,2);

julia> getfield(a,:field)  
2

julia> a = 1//2  
1//2

julia> setfield!(a,:num,3);  
ERROR: setfield!: immutable struct of type Rational cannot be changed

source

```
Core.isdefined– Function.

```

isdefined(m:: Module , s :: Symbol , [order:: Symbol ])  
isdefined(object, s:: Symbol , [order:: Symbol ])  
isdefined(object, index:: Int , [order:: Symbol ])

Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or  
a composite object and field name (as a symbol) or index. Optionally, an ordering can be defined for the  
operation. If the field was declared@atomic, the specification is strongly recommended to be compatible  
withthestorestothatlocation. Otherwise,ifnotdeclaredas@atomic,thisparametermustbe:not_atomic  
if specified.  
To test whether an array element is defined, useisassignedinstead.  
See also@isdefined.  
Examples

julia> isdefined(Base,:sum)  
true

julia> isdefined(Base,:NonExistentMethod)  
false

julia> a = 1//2;

julia> isdefined(a,2)  
true

```

#### CHAPTER 41. ESSENTIALS 462

```

julia> isdefined(a,3)  
false

julia> isdefined(a,:num)  
true

julia> isdefined(a,:numerator)  
false

source

```
Base.@isdefined– Macro.

```

@isdefineds -> Bool

Tests whether variablesis defined in the current scope.  
See alsoisdefinedfor field properties andisassignedfor array indexes orhaskeyfor other mappings.  
Examples

julia> @isdefinednewvar  
false

julia> newvar= 1  
1

julia> @isdefinednewvar  
true

julia>function f()  
println(@isdefinedx)  
x = 3  
println(@isdefinedx)  
end  
f (generic function with 1 method)

julia> f()  
false  
true

source

```
Base.convert– Function.

```

convert(T, x)

Convertxto a value of typeT.  
IfTis anIntegertype, anInexactErrorwill be raised ifxis not representable byT, for example ifxis  
not integer-valued, or is outside the range supported byT.  
Examples

julia> convert( Int , 3.0)  
3

```

#### CHAPTER 41. ESSENTIALS 463

```

julia> convert( Int , 3.5)  
ERROR: InexactError: Int64(3.5)  
Stacktrace:  
[...]

IfTis aAbstractFloatorRationaltype, then it will return the closest value toxrepresentable byT.

julia> x = 1/3  
0.3333333333333333

julia> convert( Float32 , x)  
0.33333334f0

julia> convert( Rational { Int32 }, x)  
1//3

julia> convert( Rational { Int64 }, x)  
6004799503160661//18014398509481984

IfTis a collection type andxa collection, the result ofconvert(T, x)may alias all or part ofx.

julia> x = Int [1, 2, 3];

julia> y = convert( Vector { Int }, x);

julia> y === x  
true

See also:round,trunc,oftype,reinterpret.  
source

```
Base.promote– Function.

```

promote(xs...)

Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be con-  
verted, an error is raised.  
See also: [promote_type], [promote_rule].  
Examples

julia> promote( Int8 (1), Float16 (4.5), Float32 (4.1))  
(1.0f0, 4.5f0, 4.1f0)

source

```
Base.oftype– Function.

```

oftype(x, y)

Convertyto the type ofx(convert(typeof(x), y)).  
Examples

```

#### CHAPTER 41. ESSENTIALS 464

```

julia> x = 4;

julia> y = 3.;

julia> oftype(x, y)  
3

julia> oftype(y, x)  
4.0

source

```
Base.widen– Function.

```

widen(x)

Ifxis a type, return a"larger " type, defined so that arithmetic operations+and-are guaranteed not to  
overflow nor lose precision for any combination of values that typexcan hold.  
For fixed-size integer types less than 128 bits,widenwill return a type with twice the number of bits.  
Ifxis a value, it is converted towiden(typeof(x)).  
Examples

julia> widen( Int32 )  
Int64

julia> widen(1.5f0)  
1.5

source

```
Base.identity– Function.

```

identity(x)

The identity function. Returns its argument.  
See also:one,oneunit, andLinearAlgebra'sI.  
Examples

julia> identity("Well, what did you expect?")  
"Well, what did you expect?"

source

```
### 41.7 Properties of Types

### Type relations

Base.supertype– Function.

```

supertype(T:: DataType )

Return the supertype of DataTypeT.  
Examples

```

#### CHAPTER 41. ESSENTIALS 465

```

julia> supertype( Int32 )  
Signed

source

```
Core.Type– Type.

```

Core. Type {T}

Core.Typeisanabstracttypewhichhasalltypeobjectsasitsinstances. Theonlyinstanceofthesingleton  
typeCore.Type{T}is the objectT.  
Examples

julia> isa( Type { Float64 }, Type )  
true

julia> isa( Float64 , Type )  
true

julia> isa( Real , Type { Float64 })  
false

julia> isa( Real , Type { Real })  
true

source

```
Core.DataType– Type.

```

DataType <: Type {T}

DataTyperepresents explicitly declared types that have names, explicitly declared supertypes, and, op-  
tionally, parameters. Every concrete value in the system is an instance of someDataType.  
Examples

julia> typeof( Real )  
DataType

julia> typeof( Int )  
DataType

julia> struct Point  
x:: Int  
y  
end

julia> typeof(Point)  
DataType

source

```
Core.:<:– Function.

```

<:(T1, T2)

```

#### CHAPTER 41. ESSENTIALS 466

```

Subtype operator: returnstrueif and only if all values of typeT1are also of typeT2.  
Examples

julia>Float64 <: AbstractFloat  
true

julia>Vector { Int } <: AbstractArray  
true

julia>Matrix { Float64 } <: Matrix { AbstractFloat }  
false

source

```
Base.:>:– Function.

```

> :(T1, T2)

Supertype operator, equivalent toT2 <: T1.  
source

```
Base.typejoin– Function.

```

typejoin(T, S)

Return the closest common ancestor ofTandS, i.e. the narrowest type from which they both inherit.  
source

```
Base.typeintersect– Function.

```

typeintersect(T, S)

Compute a type that contains the intersection ofTandS. Usually this will be the smallest such type or one  
close to it.  
source

```
Base.promote_type– Function.

```

promote_type(type1, type2)

Promotion refers to converting values of mixed types to a single common type.promote_typerepresents  
the default promotion behavior in Julia when operators (usually mathematical) are given arguments of dif-  
fering types.promote_typegenerally tries to return a type which can at least approximate most values of  
eitherinputtypewithoutexcessivelywidening. Somelossistolerated; forexample,promote_type(Int64,  
Float64)returnsFloat64eventhoughstrictly,notallInt64valuescanberepresentedexactlyasFloat64  
values.  
See also:promote,promote_typejoin,promote_rule.  
Examples

julia> promote_type( Int64 , Float64 )  
Float64

julia> promote_type( Int32 , Int64 )

```

#### CHAPTER 41. ESSENTIALS 467

```

Int64

julia> promote_type( Float32 , BigInt )  
BigFloat

julia> promote_type( Int16 , Float16 )  
Float16

julia> promote_type( Int64 , Float16 )  
Float16

julia> promote_type( Int8 , UInt16 )  
UInt16

source

```
Base.promote_rule– Function.

```

promote_rule(type1, type2)

Specifies what type should be used bypromotewhen given values of typestype1andtype2. This function  
should not be called directly, but should have definitions added to it for new types as appropriate.  
source

```
Base.promote_typejoin– Function.

```

promote_typejoin(T, S)

Compute a type that contains bothTandS, which could be either a parent of both types, or aUnionif  
appropriate. Falls back totypejoin.  
See insteadpromote,promote_type.  
Examples

julia> Base.promote_typejoin( Int , Float64 )  
Real

julia> Base.promote_type( Int , Float64 )  
Float64

source

```
Base.isdispatchtuple– Function.

```

isdispatchtuple(T)

Determine whether typeTis a tuple"leaf type", meaning it could appear as a type signature in dispatch  
and has no subtypes (or supertypes) which could appear in a call.  
source

```
### Declared structure

Base.ismutable– Function.

```

ismutable(v)-> Bool

```

#### CHAPTER 41. ESSENTIALS 468

```

Returntrueiff valuevis mutable. SeeMutable Composite Typesfor a discussion ofimmutability. Note that  
this function works on values, so if you give it a type, it will tell you that a value ofDataTypeis mutable.  
See alsoisbits,isstructtype.  
Examples

julia> ismutable(1)  
false

julia> ismutable([1,2])  
true

Julia 1.5  
This function requires at least Julia 1.5.

source

```
Base.isimmutable– Function.

```

isimmutable(v)-> Bool

Warning  
Consider using!ismutable(v)instead, asisimmutable(v)will be replaced by!ismutable(v)  
in a future release. (Since Julia 1.5)

Returntrueiff valuevis immutable. SeeMutable Composite Typesfor a discussion of immutability. Note  
thatthisfunctionworksonvalues, soifyougiveitatype, itwilltellyouthatavalueofDataTypeismutable.  
Examples

julia> isimmutable(1)  
true

julia> isimmutable([1,2])  
false

source

```
Base.isabstracttype– Function.

```

isabstracttype(T)

Determine whether typeTwas declared as an abstract type (i.e. using theabstractkeyword).  
Examples

julia> isabstracttype( AbstractArray )  
true

julia> isabstracttype( Vector )  
false

source

```
Base.isprimitivetype– Function.


#### CHAPTER 41. ESSENTIALS 469

```

isprimitivetype(T)-> Bool

Determine whether typeTwas declared as a primitive type (i.e. using theprimitivekeyword).  
source

```
Base.issingletontype– Function.

```

Base.issingletontype(T)

Determine whether typeThas exactly one possible instance; for example, a struct type with no fields.  
source

```
Base.isstructtype– Function.

```

isstructtype(T)-> Bool

Determine whether typeTwas declared as a struct type (i.e. using thestructormutable structkey-  
word).  
source

```
Base.nameof– Method.

```

nameof(t:: DataType ) -> Symbol

Get the name of a (potentiallyUnionAll-wrapped)DataType(without its parent module) as a symbol.  
Examples

julia>module Foo  
struct S{T}  
end  
end  
Foo

julia> nameof(Foo.S{T} where T)  
:S

source

```
Base.fieldnames– Function.

```

fieldnames(x:: DataType )

Get a tuple with the names of the fields of aDataType.  
See alsopropertynames,hasfield.  
Examples

julia> fieldnames( Rational )  
(:num, :den)

julia> fieldnames(typeof(1+im))  
(:re, :im)

source

```

#### CHAPTER 41. ESSENTIALS 470

Base.fieldname– Function.

```

fieldname(x:: DataType , i :: Integer )

Get the name of fieldiof aDataType.  
Examples

julia> fieldname( Rational , 1)  
:num

julia> fieldname( Rational , 2)  
:den

source

```
Base.hasfield– Function.

```

hasfield(T:: Type , name:: Symbol )

Return a boolean indicating whetherThasnameas one of its own fields.

Julia 1.2  
This function requires at least Julia 1.2.

source

```
### Memory layout

Base.sizeof– Method.

```

sizeof(T:: DataType )  
sizeof(obj)

Size, in bytes, of the canonical binary representation of the givenDataType T, if any. Size, in bytes, of  
objectobjif it is notDataType.  
Examples

julia> sizeof( Float32 )  
4

julia> sizeof(ComplexF64)  
16

julia> sizeof(1.0)  
8

julia> sizeof([1.0:10.0;])  
80

IfDataType Tdoes not have a specific size, an error is thrown.

julia> sizeof( AbstractArray )  
ERROR: Abstract type AbstractArray does not have a definite size.  
Stacktrace:  
[...]

```

#### CHAPTER 41. ESSENTIALS 471

```

source

```
Base.isconcretetype– Function.

```

isconcretetype(T)

Determine whether typeTis a concrete type, meaning it could have direct instances (valuesxsuch that  
typeof(x) === T).  
See also:isbits,isabstracttype,issingletontype.  
Examples

julia> isconcretetype( Complex )  
false

julia> isconcretetype( Complex { Float32 })  
true

julia> isconcretetype( Vector { Complex })  
true

julia> isconcretetype( Vector { Complex { Float32 }})  
true

julia> isconcretetype( Union {})  
false

julia> isconcretetype( Union { Int ,String})  
false

source

```
Base.isbits– Function.

```

isbits(x)

Returntrueifxis an instance of anisbitstypetype.  
source

```
Base.isbitstype– Function.

```

isbitstype(T)

Returntrueif typeTis a "plain data" type, meaning it is immutable and contains no references to other  
values, onlyprimitivetypes and otherisbitstypetypes. Typical examples are numeric types such as  
UInt8,Float64, andComplex{Float64}. This category of types is significant since they are valid as type  
parameters, may not trackisdefined/isassignedstatus, and have a defined layout that is compatible  
with C.  
See alsoisbits,isprimitivetype,ismutable.  
Examples

julia> isbitstype( Complex { Float64 })  
true

julia> isbitstype( Complex )  
false

```

#### CHAPTER 41. ESSENTIALS 472

```

source

```
Core.fieldtype– Function.

```

fieldtype(T, name:: Symbol | index:: Int )

Determine the declared type of a field (specified by name or index) in a composite DataTypeT.  
Examples

julia> struct Foo  
x:: Int64  
y::String  
end

julia> fieldtype(Foo,:x)  
Int64

julia> fieldtype(Foo,2)  
String

source

```
Base.fieldtypes– Function.

```

fieldtypes(T:: Type )

The declared types of all fields in a composite DataTypeTas a tuple.

Julia 1.1  
This function requires at least Julia 1.1.

Examples

julia> struct Foo  
x:: Int64  
y::String  
end

julia> fieldtypes(Foo)  
(Int64, String)

source

```
Base.fieldcount– Function.

```

fieldcount(t:: Type )

Get the number of fields that an instance of the given type would have. An error is thrown if the type is  
too abstract to determine this.  
source

```
Base.fieldoffset– Function.

```

fieldoffset( type , i)

```

#### CHAPTER 41. ESSENTIALS 473

```

The byte offset of fieldiof a type relative to the data start. For example, we could use it in the following  
manner to summarize information about a struct:

julia> structinfo(T)= [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i =  
↪→ 1:fieldcount(T)];

julia> structinfo(Base.Filesystem. StatStruct )  
13-element Vector{Tuple{UInt64, Symbol, Type}}:  
(0x0000000000000000, :desc, Union{RawFD, String})  
(0x0000000000000008, :device, UInt64)  
(0x0000000000000010, :inode, UInt64)  
(0x0000000000000018, :mode, UInt64)  
(0x0000000000000020, :nlink, Int64)  
(0x0000000000000028, :uid, UInt64)  
(0x0000000000000030, :gid, UInt64)  
(0x0000000000000038, :rdev, UInt64)  
(0x0000000000000040, :size, Int64)  
(0x0000000000000048, :blksize, Int64)  
(0x0000000000000050, :blocks, Int64)  
(0x0000000000000058, :mtime, Float64)  
(0x0000000000000060, :ctime, Float64)

source

```
Base.datatype_alignment– Function.

```

Base.datatype_alignment(dt:: DataType ) -> Int

Memory allocation minimum alignment for instances of this type. Can be called on anyisconcretetype.  
source

```
Base.datatype_haspadding– Function.

```

Base.datatype_haspadding(dt:: DataType ) -> Bool

Return whether the fields of instances of this type are packed in memory, with no intervening padding  
bytes. Can be called on anyisconcretetype.  
source

```
Base.datatype_pointerfree– Function.

```

Base.datatype_pointerfree(dt:: DataType ) -> Bool

Return whether instances of this type can contain references to gc-managed memory. Can be called on  
anyisconcretetype.  
source

```
### Special values

Base.typemin– Function.

```

typemin(T)

The lowest value representable by the given (real) numeric DataTypeT.  
Examples

```

#### CHAPTER 41. ESSENTIALS 474

```

julia> typemin( Float16 )  
-Inf16

julia> typemin( Float32 )  
-Inf32

source

```
Base.typemax– Function.

```

typemax(T)

The highest value representable by the given (real) numericDataType.  
See also:floatmax,typemin,eps.  
Examples

julia> typemax( Int8 )  
127

julia> typemax( UInt32 )  
0xffffffff

julia> typemax( Float64 )  
Inf

julia> floatmax( Float32 ) # largest finite floating point number  
3.4028235f38

source

```
Base.floatmin– Function.

```

floatmin(T= Float64 )

Return the smallest positive normal number representable by the floating-point typeT.  
Examples

julia> floatmin( Float16 )  
Float16(6.104e-5)

julia> floatmin( Float32 )  
1.1754944f-38

julia> floatmin()  
2.2250738585072014e-308

source

```
Base.floatmax– Function.

```

floatmax(T= Float64 )

Return the largest finite number representable by the floating-point typeT.  
See also:typemax,floatmin,eps.  
Examples

```

#### CHAPTER 41. ESSENTIALS 475

```

julia> floatmax( Float16 )  
Float16(6.55e4)

julia> floatmax( Float32 )  
3.4028235f38

julia> floatmax()  
1.7976931348623157e308

julia> typemax( Float64 )  
Inf

source

```
Base.maxintfloat– Function.

```

maxintfloat(T= Float64 )

The largest consecutive integer-valued floating-point number that is exactly represented in the given  
floating-point typeT(which defaults toFloat64).  
That is,maxintfloatreturns the smallest positive integer-valued floating-point numbernsuch thatn+1is  
not exactly representable in the typeT.  
When anInteger-type value is needed, useInteger(maxintfloat(T)).  
source  
maxintfloat(T, S)

The largest consecutive integer representable in the given floating-point typeTthat also does not exceed  
themaximumintegerrepresentablebytheintegertypeS.Equivalently,itistheminimumofmaxintfloat(T)  
andtypemax(S).  
source

```
Base.eps– Method.

```

eps(:: Type {T}) where T<: AbstractFloat  
eps()

ReturnthemachineepsilonofthefloatingpointtypeT(T = Float64bydefault). Thisisdefinedasthegap  
between1andthenextlargestvaluerepresentablebytypeof(one(T)),andisequivalenttoeps(one(T)).  
(Sinceeps(T)is a bound on the relative error ofT, it is a"dimensionless" quantity likeone.)  
Examples

julia> eps()  
2.220446049250313e-16

julia> eps( Float32 )  
1.1920929f-7

julia> 1.0 + eps()  
1.0000000000000002

julia> 1.0 + eps()/2  
1.0

```

#### CHAPTER 41. ESSENTIALS 476

```

source

```
Base.eps– Method.

```

eps(x:: AbstractFloat )

Return the unit in last place (ulp) ofx. This is the distance between consecutive representable floating  
point values atx. In most cases, if the distance on either side ofxis different, then the larger of the two  
is taken, that is  
eps(x) == max(x-prevfloat(x), nextfloat(x)-x)

Theexceptionstothisrulearethesmallestandlargestfinitevalues(e.g.nextfloat(-Inf)andprevfloat(Inf)  
forFloat64), which round to the smaller of the values.  
The rationale for this behavior is thatepsbounds the floating point rounding error. Under the default  
RoundNearestrounding mode, ifyis a real number andxis the nearest floating point number toy, then

```
|y−x|≤eps(x)/2.

```

See also:nextfloat,issubnormal,floatmax.  
Examples

julia> eps(1.0)  
2.220446049250313e-16

julia> eps(prevfloat(2.0))  
2.220446049250313e-16

julia> eps(2.0)  
4.440892098500626e-16

julia> x = prevfloat(Inf) # largest finite Float64  
1.7976931348623157e308

julia> x + eps(x)/2 # rounds up  
Inf

julia> x + prevfloat(eps(x)/2) # rounds down  
1.7976931348623157e308

source

```
Base.instances– Function.

```

instances(T:: Type )

Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see  
@enum).  
Example

julia> @enumColor red blue green

julia> instances(Color)  
(red, blue, green)

source

```

#### CHAPTER 41. ESSENTIALS 477

### 41.8 Special Types

Core.Any– Type.

```

Any :: DataType

Anyis the union of all types. It has the defining propertyisa(x, Any) == truefor anyx.Anytherefore  
describes the entire universe of possible values. For exampleIntegeris a subset ofAnythat includesInt,  
Int8, and other integer types.  
source

```
Core.Union– Type.

```

Union {Types...}

A type union is an abstract type which includes all instances of any of its argument types. The empty union  
Union{}is the bottom type of Julia.  
Examples

julia> IntOrString= Union { Int , AbstractString }  
Union{Int64, AbstractString}

julia> 1 :: IntOrString  
1

julia> "Hello!":: IntOrString  
"Hello!"

julia> 1.0 :: IntOrString  
ERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type  
↪→ Float64

source

```
Union{}– Keyword.

```

Union {}

Union{}, the emptyUnionof types, is the type that has no values. That is, it has the defining property  
isa(x, Union{}) == falsefor anyx. Base.Bottomis defined as its alias and the type ofUnion{}is  
Core.TypeofBottom.  
Examples

julia> isa(nothing, Union {})  
false

source

```
Core.UnionAll– Type.

```

UnionAll

A union of types over all values of a type parameter.UnionAllis used to describe parametric types where  
the values of some parameters are not known.  
Examples

```

#### CHAPTER 41. ESSENTIALS 478

```

julia> typeof( Vector )  
UnionAll

julia> typeof( Vector { Int })  
DataType

source

```
Core.Tuple– Type.

```

Tuple {Types...}

Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of  
a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized  
immutable type where each parameter is the type of one field. Tuple types may have any number of  
parameters.  
Tupletypesarecovariantintheirparameters:Tuple{Int}isasubtypeofTuple{Any}. ThereforeTuple{Any}  
is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not  
have field names; fields are only accessed by index.  
See the manual section onTuple Types.  
See alsoVararg,NTuple,tuple,NamedTuple.  
source

```
Core.NTuple– Type.

```

NTuple {N, T}

A compact way of representing the type for a tuple of lengthNwhere all elements are of typeT.  
Examples

julia> isa((1, 2, 3, 4, 5, 6), NTuple {6, Int })  
true

source

```
Core.NamedTuple– Type.

```

NamedTuple

NamedTuples are, as their name suggests, namedTuples. That is, they're a tuple-like collection of values,  
where each entry has a unique name, represented as aSymbol. LikeTuples,NamedTuples are immutable;  
neither the names nor the values can be modified in place after construction.  
Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g.  
x.a, or usinggetindex, e.g. x[:a]orx[(:a, :b)]. A tuple of the names can be obtained usingkeys,  
and a tuple of the values can be obtained usingvalues.

Note  
Iteration overNamedTuples produces the values without the names. (See example below.) To  
iterate over the name-value pairs, use thepairsfunction.

The@NamedTuplemacro can be used for conveniently declaringNamedTupletypes.  
Examples

```

#### CHAPTER 41. ESSENTIALS 479

```

julia> x = (a=1, b =2)  
(a = 1, b = 2)

julia> x.a  
1

julia> x[:a]  
1

julia> x[(:a,)]  
(a = 1,)

julia> keys(x)  
(:a, :b)

julia> values(x)  
(1, 2)

julia> collect(x)  
2-element Vector{Int64}:  
1  
2

julia> collect(pairs(x))  
2-element Vector{Pair{Symbol, Int64}}:  
:a => 1  
:b => 2

In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can  
be created by giving a pairname::Symbol => valueor splatting an iterator yielding such pairs after a  
semicolon inside a tuple literal:

julia> (; :a => 1)  
(a = 1,)

julia> keys= (:a, :b, :c); values= (1, 2, 3);

julia> (; zip(keys, values)...)  
(a = 1, b = 2, c = 3)

As in keyword arguments, identifiers and dot expressions imply names:

julia> x = 0  
0

julia> t = (; x)  
(x = 0,)

julia> (; t .x)  
(x = 0,)

Julia 1.5  
Implicit names from identifiers and dot expressions are available as of Julia 1.5.

Julia 1.7  
Use ofgetindexmethods with multipleSymbols is available as of Julia 1.7.

```

#### CHAPTER 41. ESSENTIALS 480

```

source

```
Base.@NamedTuple– Macro.

```

@NamedTuple{key1::Type1, key2::Type2,...}  
@NamedTuple begin key1::Type1; key2::Type2;...; end

This macro gives a more convenient syntax for declaringNamedTupletypes. It returns aNamedTupletype  
withthegivenkeysandtypes,equivalenttoNamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}.  
If the::Typedeclaration is omitted, it is taken to beAny. Thebegin ... endform allows the declarations  
to be split across multiple lines (similar to astructdeclaration), but is otherwise equivalent.  
Forexample,thetuple(a=3.1, b="hello")hasatypeNamedTuple{(:a, :b),Tuple{Float64,String}},  
which can also be declared via@NamedTupleas:

julia> @NamedTuple{a:: Float64 , b ::String}  
NamedTuple{(:a, :b), Tuple{Float64, String}}

julia> @NamedTuple begin  
a:: Float64  
b::String  
end  
NamedTuple{(:a, :b), Tuple{Float64, String}}

Julia 1.5  
This macro is available as of Julia 1.5.

source

```
Base.Val– Type.

```

Val (c)

ReturnVal{c}(), which contains no run-time data. Types like this can be used to pass the information  
between functions through the valuec, which must be anisbitsvalue or aSymbol. The intent of this  
construct is to be able to dispatch on constants directly (at compile time) without having to test the value  
of the constant at run time.  
Examples

julia> f(:: Val { true }) = "Good"  
f (generic function with 1 method)

julia> f(:: Val { false }) = "Bad"  
f (generic function with 2 methods)

julia> f( Val ( true ))  
"Good"

source

```
Core.Vararg– Constant.

```

Vararg {T,N}

```

#### CHAPTER 41. ESSENTIALS 481

```

The last parameter of a tuple typeTuplecan be the special valueVararg, which denotes any number of  
trailingelements.Vararg{T,N}correspondstoexactlyNelementsoftypeT.FinallyVararg{T}corresponds  
to zero or more elements of typeT.Varargtuple types are used to represent the arguments accepted by  
varargs methods (see the section onVarargs Functionsin the manual.)  
See alsoNTuple.  
Examples

julia> mytupletype= Tuple { AbstractString , Vararg { Int }}  
Tuple{AbstractString, Vararg{Int64}}

julia> isa(("1",), mytupletype)  
true

julia> isa(("1",1), mytupletype)  
true

julia> isa(("1",1,2), mytupletype)  
true

julia> isa(("1",1,2,3.0), mytupletype)  
false

source

```
Core.Nothing– Type.

```

Nothing

A type with no fields that is the type ofnothing.  
See also:isnothing,Some,Missing.  
source

```
Base.isnothing– Function.

```

isnothing(x)

Returntrueifx === nothing, and returnfalseif not.

Julia 1.1  
This function requires at least Julia 1.1.

See alsosomething,notnothing,ismissing.  
source

```
Base.notnothing– Function.

```

notnothing(x)

Throw an error ifx === nothing, and returnxif not.  
source

```
Base.Some– Type.


#### CHAPTER 41. ESSENTIALS 482

```

Some{T}

AwrappertypeusedinUnion{Some{T}, Nothing}todistinguishbetweentheabsenceofavalue(nothing)  
and the presence of anothingvalue (i.e.Some(nothing)).  
Usesomethingto access the value wrapped by aSomeobject.  
source

```
Base.something– Function.

```

something(x...)

Return the first value in the arguments which is not equal tonothing, if any. Otherwise throw an error.  
Arguments of typeSomeare unwrapped.  
See alsocoalesce,skipmissing,@something.  
Examples

julia> something(nothing, 1)  
1

julia> something(Some(1), nothing)  
1

julia> something(missing,nothing)  
missing

julia> something(nothing, nothing)  
ERROR: ArgumentError: No value arguments present

source

```
Base.@something– Macro.

```

@something(x...)

Short-circuiting version ofsomething.  
Examples

julia> f(x)= (println("f( $x )"); nothing);

julia> a = 1;

julia> a = @somethinga f( 2) f( 3) error("Unable to find default for `a`")  
1

julia> b = nothing;

julia> b = @somethingb f( 2) f( 3) error("Unable to find default for `b`")  
f(2)  
f(3)  
ERROR: Unable to find default for `b`  
[...]

julia> b = @somethingb f( 2) f( 3) Some(nothing)

```

#### CHAPTER 41. ESSENTIALS 483

```

f(2)  
f(3)

julia> b === nothing  
true

Julia 1.7  
This macro is available as of Julia 1.7.

source

```
Base.Enums.Enum– Type.

```

Enum {T<: Integer }

The abstract supertype of all enumerated types defined with@enum.  
source

```
Base.Enums.@enum– Macro.

```

@enumEnumName[::BaseType] value1[=x] value2[=y]

Create anEnum{BaseType}subtype with nameEnumNameand enum member values ofvalue1andvalue2  
with optional assigned values ofxandy, respectively. EnumNamecan be used just like other types and  
enum member values as regular values, such as  
Examples

julia> @enumFruit apple=1 orange=2 kiwi=3

julia> f(x::Fruit)= "I'm a Fruit with value: $ ( Int (x))"  
f (generic function with 1 method)

julia> f(apple)  
"I'm a Fruit with value: 1"

julia> Fruit(1)  
apple::Fruit = 1

Values can also be specified inside abeginblock, e.g.

@enumEnumName begin  
value1  
value2  
end

BaseType, which defaults toInt32, must be a primitive subtype ofInteger. Member values can be con-  
verted between the enum type andBaseType.readandwriteperform these conversions automatically.  
In case the enum is created with a non-defaultBaseType,Integer(value1)will return the integervalue1  
with the typeBaseType.  
To list all the instances of an enum useinstances, e.g.

julia> instances(Fruit)  
(apple, orange, kiwi)

```

#### CHAPTER 41. ESSENTIALS 484

```

source

```
Core.Expr– Type.

```

Expr (head:: Symbol , args...)

A type representing compound expressions in parsed julia code (ASTs). Each expression consists of ahead  
Symbolidentifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and  
subexpressions (e.g. the arguments of a call). The subexpressions are stored in aVector{Any}field called  
args.  
See the manual chapter onMetaprogrammingand the developer documentationJulia ASTs.  
Examples

julia>Expr (:call,:+, 1, 2)  
:(1 + 2)

julia> dump(:(a? b : c))  
Expr  
head: Symbol if  
args: Array{Any}((3,))  
1: Symbol a  
2: Symbol b  
3: Symbol c

source

```
Core.Symbol– Type.

```

Symbol

The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or  
label to identify an entity (e.g. as a dictionary key).Symbols can be entered using the:quote operator:

julia> :name  
:name

julia> typeof(:name)  
Symbol

julia> x = 42  
42

julia> eval(:x)  
42

Symbols can also be constructed from strings or other values by calling the constructorSymbol(x...).  
Symbols are immutable and should be compared using===. The implementation re-uses the same object  
for allSymbols with the same name, so comparison tends to be efficient (it can just compare pointers).  
Unlike strings,Symbols are "atomic" or "scalar" entities that do not support iteration over characters.  
source

```
Core.Symbol– Method.


#### CHAPTER 41. ESSENTIALS 485

```

Symbol (x...) -> Symbol

Create aSymbolby concatenating the string representations of the arguments together.  
Examples

julia>Symbol ("my", "name")  
:myname

julia>Symbol ("day", 4)  
:day4

source

```
Core.Module– Type.

```

Module

AModuleis a separate global variable workspace. Seemoduleand themanual section about modulesfor  
details.  
source

```
### 41.9 Generic Functions

Core.Function– Type.

```

Function

Abstract type of all functions.  
Examples

julia> isa(+, Function )  
true

julia> typeof(sin)  
typeof(sin) (singleton type of function sin, subtype of Function)

julia> ans <: Function  
true

source

```
Base.hasmethod– Function.

```

hasmethod(f, t:: Type {<: Tuple }[, kwnames]; world=typemax( UInt )) -> Bool

Determine whether the given generic function has a method matching the givenTupleof argument types  
with the upper bound of world age given byworld.  
If a tuple of keyword argument nameskwnamesis provided, this also checks whether the method off  
matchingthas the given keyword argument names. If the matching method accepts a variable number  
of keyword arguments, e.g. withkwargs..., any names given inkwnamesare considered valid. Otherwise  
the provided names must be a subset of the method's keyword arguments.  
See alsoapplicable.

```

#### CHAPTER 41. ESSENTIALS 486

```

Julia 1.2  
Providing keyword argument names requires Julia 1.2 or later.

Examples

julia> hasmethod(length, Tuple { Array })  
true

julia> f(; oranges=0) = oranges;

julia> hasmethod(f, Tuple {}, (:oranges,))  
true

julia> hasmethod(f, Tuple {}, (:apples,:bananas))  
false

julia> g(; xs...) = 4;

julia> hasmethod(g, Tuple {}, (:a, :b, :c, :d)) # g accepts arbitrary kwargs  
true

source

```
Core.applicable– Function.

```

applicable(f, args...) -> Bool

Determine whether the given generic function has a method applicable to the given arguments.  
See alsohasmethod.  
Examples

julia>function f(x, y)  
x + y  
end ;

julia> applicable(f,1)  
false

julia> applicable(f,1, 2)  
true

source

```
Base.isambiguous– Function.

```

Base.isambiguous(m1, m2; ambiguous_bottom= false ) -> Bool

Determine whether two methodsm1andm2may be ambiguous for some call signature. This test is per-  
formed in the context of other methods of the same function; in isolation,m1andm2might be ambiguous,  
but if a third method resolving the ambiguity has been defined, this returnsfalse. Alternatively, in iso-  
lationm1andm2might be ordered, but if a third method cannot be sorted with them, they may cause an  
ambiguity together.  
For parametric types, theambiguous_bottomkeyword argument controls whetherUnion{}counts as an  
ambiguous intersection of type parameters – whentrue, it is considered ambiguous, whenfalseit is not.  
Examples

```

#### CHAPTER 41. ESSENTIALS 487

```

julia> foo(x:: Complex {<: Integer }) = 1  
foo (generic function with 1 method)

julia> foo(x:: Complex {<: Rational }) = 2  
foo (generic function with 2 methods)

julia> m1, m2= collect(methods(foo));

julia> typeintersect(m1.sig, m2.sig)  
Tuple{typeof(foo), Complex{Union{}}}

julia> Base.isambiguous(m1, m2, ambiguous_bottom= true )  
true

julia> Base.isambiguous(m1, m2, ambiguous_bottom= false )  
false

source

```
Core.invoke– Function.

```

invoke(f, argtypes:: Type , args...; kwargs...)

Invoke a method for the given generic functionfmatching the specified typesargtypeson the specified  
argumentsargsand passing the keyword argumentskwargs. The argumentsargsmust conform with the  
specified types inargtypes, i.e. conversion is not automatically performed. This method allows invoking  
a method other than the most specific matching method, which is useful when the behavior of a more  
general definition is explicitly needed (often as part of the implementation of a more specific method of  
the same function).  
Be careful when usinginvokefor functions that you don't write. What definition is used for givenargtypes  
is an implementation detail unless the function is explicitly states that calling with certainargtypesis a  
part of public API. For example, the change betweenf1andf2in the example below is usually considered  
compatible because the change is invisible by the caller with a normal (non-invoke) call. However, the  
change is visible if you useinvoke.  
Examples

julia> f(x:: Real ) = x^2;

julia> f(x:: Integer ) = 1 + invoke(f, Tuple { Real }, x);

julia> f(2)  
5

julia> f1(:: Integer ) = Integer  
f1(:: Real ) = Real ;

julia> f2(x:: Real ) = _f2(x)  
_f2(:: Integer ) = Integer  
_f2(_)= Real ;

julia> f1(1)  
Integer

julia> f2(1)

```

#### CHAPTER 41. ESSENTIALS 488

```

Integer

julia> invoke(f1, Tuple { Real }, 1)  
Real

julia> invoke(f2, Tuple { Real }, 1)  
Integer

source

```
Base.@invoke– Macro.

```

@invokef(arg::T, ...; kwargs...)

Provides a convenient way to callinvoke;@invoke f(arg1::T1, arg2::T2; kwargs...) will be ex-  
panded intoinvoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...). When an argument's type annota-  
tion is omitted, it's specified asAnyargument, e.g. @invoke f(arg1::T, arg2)will be expanded into  
invoke(f, Tuple{T,Any}, arg1, arg2).

Julia 1.7  
This macro requires Julia 1.7 or later.

source

```
Base.invokelatest– Function.

```

invokelatest(f, args...; kwargs...)

Callsf(args...; kwargs...), but guarantees that the most recent method offwill be executed. This  
is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call  
obsolete versions of a functionf. (The drawback is thatinvokelatestis somewhat slower than callingf  
directly, and the type of the result cannot be inferred by the compiler.)  
source

```
Base.@invokelatest– Macro.

```

@invokelatestf(args...; kwargs...)

Provides a convenient way to callBase.invokelatest. @invokelatest f(args...; kwargs...) will  
simply be expanded intoBase.invokelatest(f, args...; kwargs...).

Julia 1.7  
This macro requires Julia 1.7 or later.

source

```
new– Keyword.

```

new

Special function available to inner constructors which created a new object of the type. See the manual  
section onInner Constructor Methodsfor more information.  
source

```

#### CHAPTER 41. ESSENTIALS 489

Base.:|>– Function.

```

|>(x, f)

Applies a function to the preceding argument. This allows for easy function chaining.  
Examples

julia> [1:5;] |> x->x.^2 |> sum |> inv  
0.01818181818181818

source

```
Base.:∘– Function.

```

f ∘ g

Composefunctions: i.e.(f ∘ g)(args...; kwargs...)meansf(g(args...; kwargs...)). The∘sym-  
bol can be entered in the Julia REPL (and most editors, appropriately configured) by typing\circ.  
Function composition also works in prefix form:∘(f, g)is the same asf ∘ g. The prefix form supports  
composition of multiple functions:∘(f, g, h) = f ∘ g ∘ hand splatting∘(fs...) for composing an  
iterable collection of functions.

Julia 1.4  
Multiple function composition requires at least Julia 1.4.

Julia 1.5  
Composition of one function ∘(f) requires at least Julia 1.5.

Julia 1.7  
Using keyword arguments requires at least Julia 1.7.

Examples

julia> map(uppercase∘first, ["apple", "banana", "carrot"])  
3-element Vector{Char}:  
'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)  
'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)  
'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)

julia> fs = [  
x -> 2x  
x -> x/2  
x -> x-1  
x -> x+1  
];

julia> ∘(fs...)(3)  
3.0

See alsoComposedFunction,!f::Function.  
source

```
Base.ComposedFunction– Type.


#### CHAPTER 41. ESSENTIALS 490

```

ComposedFunction{Outer,Inner}<: Function

Represents the composition of two callable objectsouter::Outerandinner::Inner. That is

ComposedFunction(outer, inner)(args...; kw ...) === outer(inner(args...; kw ...))

The preferred way to construct instance ofComposedFunctionis to use the composition operator∘:

julia> sin ∘ cos=== ComposedFunction(sin, cos)  
true

julia> typeof(sin∘cos)  
ComposedFunction{typeof(sin), typeof(cos)}

The composed pieces are stored in the fields ofComposedFunctionand can be retrieved as follows:

julia> composition= sin ∘ cos  
sin ∘ cos

julia> composition.outer=== sin  
true

julia> composition.inner=== cos  
true

Julia 1.6  
ComposedFunction requires at least Julia 1.6. In earlier versions∘returns an anonymous func-  
tion instead.

See also∘.  
source

```
Base.splat– Function.

```

splat(f)

Defined as

splat(f)= args->f(args...)

i.e. given a function returns a new function that takes one argument and splats its argument into the  
original function. This is useful as an adaptor to pass a multi-argument function in a context that expects  
a single argument, but passes a tuple as that single argument.  
Example usage:

julia> map(Base.splat(+), zip(1:3,4:6))  
3-element Vector{Int64}:  
5  
7  
9

source

```

#### CHAPTER 41. ESSENTIALS 491

Base.Fix1– Type.

```

Fix1(f, x)

A type representing a partially-applied version of the two-argument functionf, with the first argument  
fixed to the value"x". In other words,Fix1(f, x)behaves similarly toy->f(x, y).  
See alsoFix2.  
source

```
Base.Fix2– Type.

```

Fix2(f, x)

A type representing a partially-applied version of the two-argument functionf, with the second argument  
fixed to the value"x". In other words,Fix2(f, x)behaves similarly toy->f(y, x).  
source

```
### 41.10Syntax.

Core.eval– Function.

```

Core.eval(m:: Module , expr)

Evaluate an expression in the given module and return the result.  
source

```
Base.MainInclude.eval– Function.

```

eval(expr)

Evaluate an expression in the global scope of the containing module. EveryModule(except those defined  
withbaremodule) has its own 1-argument definition ofeval, which evaluates expressions in that module.  
source

```
Base.@eval– Macro.

```

@eval[mod,] ex

Evaluate an expression with values interpolated into it usingeval. If two arguments are provided, the first  
is the module to evaluate in.  
source

```
Base.evalfile– Function.

```

evalfile(path:: AbstractString , args:: Vector {String}=String[])

Load the file usinginclude, evaluate all expressions, and return the value of the last one.  
source

```
Base.esc– Function.

```

esc(e)

```

#### CHAPTER 41. ESSENTIALS 492

```

Only valid in the context of anExprreturned from a macro. Prevents the macro hygiene pass from turning  
embedded variables into gensym variables. See theMacrossection of the Metaprogramming chapter of  
the manual for more details and examples.  
source

```
Base.@inbounds– Macro.

```

@inbounds(blk)

Eliminates array bounds checking within expressions.  
In the example below the in-range check for referencing elementiof arrayAis skipped to improve perfor-  
mance.

function sum(A:: AbstractArray )  
r = zero(eltype(A))  
for i in eachindex(A)  
@inboundsr += A[i]  
end  
return r  
end

Warning  
Using@inboundsmay return incorrect results/crashes/corruption for out-of-bounds indices. The  
user is responsible for checking it manually. Only use@inboundswhen it is certain from the  
information locally available that all accesses are in bounds.

source

```
Base.@boundscheck– Macro.

```

@boundscheck(blk)

Annotates the expressionblkas a bounds checking block, allowing it to be elided by@inbounds.

Note  
Thefunctioninwhich@boundscheckiswrittenmustbeinlinedintoitscallerinorderfor@inbounds  
to have effect.

Examples

julia> @inline function g(A, i)  
@boundscheckcheckbounds(A, i)  
return "accessing ( $A )[ $i ]"  
end ;

julia> f1()= return g(1:2, -1);

julia> f2()= @inbounds return g(1:2, -1);

julia> f1()  
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]  
Stacktrace:  
[1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455  
[2] checkbounds at ./abstractarray.jl:420 [inlined]

```

#### CHAPTER 41. ESSENTIALS 493

```

[3] g at ./none:2 [inlined]  
[4] f1() at ./none:1  
[5] top-level scope

julia> f2()  
"accessing (1:2)[-1]"

Warning  
The@boundscheckannotation allows you, as a library writer, to opt-in to allowing other code  
to remove your bounds checks with@inbounds. As noted there, the caller must verify—using  
informationtheycanaccess—thattheiraccessesarevalidbeforeusing@inbounds. Forindexing  
into yourAbstractArraysubclasses, for example, this involves checking the indices against its  
axes. Therefore,@boundscheckannotations should only be added to agetindexorsetindex!  
implementation after you are certain its behavior is correct.

source

```
Base.@propagate_inbounds– Macro.

```

@propagate_inbounds

Tells the compiler to inline a function while retaining the caller's inbounds context.  
source

```
Base.@inline– Macro.

```

@inline

Give a hint to the compiler that this function is worth inlining.  
Small functions typically do not need the@inlineannotation, as the compiler does it automatically. By  
using@inlineon bigger functions, an extra nudge can be given to the compiler to inline it. This is shown  
in the following example:

@inline function bigfunction(x)  
#=  
Function Definition  
=#  
end

source

```
Base.@noinline– Macro.

```

@noinline

Give a hint to the compiler that it should not inline a function.  
Small functions are typically inlined automatically. By using@noinlineon small functions, auto-inlining  
can be prevented. This is shown in the following example:

@noinline function smallfunction(x)  
#=  
Function Definition  
=#  
end

```

#### CHAPTER 41. ESSENTIALS 494

```

Note  
If the function is trivial (for example returning a constant) it might get inlined anyway.

source

```
Base.@nospecialize– Macro.

```

@nospecialize

Applied to a function argument name, hints to the compiler that the method should not be specialized for  
different types of that argument, but instead to use precisely the declared type for each argument. This is  
only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument  
list, or in the function body. When applied to an argument, the macro must wrap the entire argument  
expression. When used in a function body, the macro must occur in statement position and before any  
code.  
When used without arguments, it applies to all arguments of the parent scope. In local scope, this means  
all arguments of the containing function. In global (top-level) scope, this means all methods subsequently  
defined in the current module.  
Specialization can reset back to the default by using@specialize.

function example_function(@nospecializex)  
...  
end

function example_function(x,@nospecialize(y = 1))  
...  
end

function example_function(x, y, z)  
@nospecializex y  
...  
end

@nospecialize  
f(y)= [x for x in y]  
@specialize

source

```
Base.@specialize– Macro.

```

@specialize

Reset the specialization hint for an argument back to the default. For details, see@nospecialize.  
source

```
Base.gensym– Function.

```

gensym([tag])

Generates a symbol which will not conflict with other variable names.  
source

```
Base.@gensym– Macro.


#### CHAPTER 41. ESSENTIALS 495

```

@gensym

Generatesagensymsymbolforavariable. Forexample,@gensym x yistransformedintox = gensym("x");  
y = gensym("y").  
source

```
var"name"– Keyword.

```

var

The syntaxvar"#example#"refers to a variable namedSymbol("#example#"), even though#example#  
is not a valid Julia identifier name.  
This can be useful for interoperability with programming languages which have different rules for the  
construction of valid identifiers. For example, to refer to theRvariabledraw.segments, you can use  
var"draw.segments"in your Julia code.  
It is also used toshowjulia source code which has gone through macro hygiene or otherwise contains  
variable names which can't be parsed normally.  
Note that this syntax requires parser support so it is expanded directly by the parser rather than being  
implemented as a normal string macro@var_str.

Julia 1.3  
This syntax requires at least Julia 1.3.

source

```
Base.@goto– Macro.

```

@gotoname

@goto nameunconditionally jumps to the statement at the location@label name.  
@labeland@gotocannot create jumps to different top-level statements. Attempts cause an error. To still  
use@goto, enclose the@labeland@gotoin a block.  
source

```
Base.@label– Macro.

```

@labelname

Labels a statement with the symbolic labelname. The label marks the end-point of an unconditional jump  
with@goto name.  
source

```
Base.SimdLoop.@simd– Macro.

```

@simd

Annotate aforloop to allow the compiler to take extra liberties to allow loop re-ordering

Warning  
This feature is experimental and could change or disappear in future versions of Julia. Incorrect  
use of the@simdmacro may cause unexpected results.

```

#### CHAPTER 41. ESSENTIALS 496

```

The object iterated over in a@simd forloop should be a one-dimensional range. By using@simd, you are  
asserting several properties of the loop:

```
- It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduc-
    tion variables.
- Floating-point operations on reduction variables can be reordered, possibly causing different results
    than without@simd.

```

In many cases, Julia is able to automatically vectorize inner for loops without the use of@simd. Using@simd  
gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner  
loop should have the following properties to allow vectorization:

```
- The loop must be an innermost loop
- The loop body must be straight-line code. Therefore,@inboundsis currently needed for all array
    accesses. The compiler can sometimes turn short&&,||, and?:expressions into straight-line code
    if it is safe to evaluate all operands unconditionally. Consider using theifelsefunction instead of?:
    in the loop if it is safe to do so.
- Accesses must have a stride pattern and cannot be"gathers" (random-index reads) or"scatters"
    (random-index writes).
- The stride should be unit stride.

```

Note  
The@simddoes not assert by default that the loop is completely free of loop-carried memory  
dependencies, which is an assumption that can easily be violated in generic code. If you are  
writing non-generic code, you can use@simd ivdep for ... endto also assert that:

```
- There exists no loop-carried memory dependencies
- No iteration ever waits on a previous iteration to make forward progress.

```

source

```
Base.@polly– Macro.

```

@polly

Tells the compiler to apply the polyhedral optimizer Polly to a function.  
source

```
Base.@generated– Macro.

```

@generatedf  
@generated(f)

@generatedis used to annotate a function which will be generated. In the body of the generated function,  
only types of arguments can be read (not the values). The function returns a quoted expression evaluated  
when the function is called. The@generatedmacro should not be used on functions mutating the global  
scope or depending on mutable elements.  
See Metaprogrammingfor further details.  
Example:

```

#### CHAPTER 41. ESSENTIALS 497

```

julia> @generated function bar(x)  
if x <: Integer  
return :(x ^ 2)  
else  
return :(x)  
end  
end  
bar (generic function with 1 method)

julia> bar(4)  
16

julia> bar("baz")  
"baz"

source

```
Base.@pure– Macro.

```

@pureex  
@pure(ex)

@puregives the compiler a hint for the definition of a pure function, helping for type inference.  
This macro is intended for internal compiler use and may be subject to changes.  
source

```
Base.@deprecate– Macro.

```

@deprecateold new [ex= true ]

Deprecate methodoldand specify the replacement callnew. Prevent@deprecatefrom exportingoldby  
settingextofalse.@deprecatedefines a new method with the same signature asold.

Julia 1.5  
As of Julia 1.5, functions defined by@deprecatedo not print warning whenjuliais run without  
the--depwarn=yesflag set, as the default value of--depwarnoption isno. The warnings are  
printed from tests run byPkg.test().

Examples

julia> @deprecateold(x) new(x)  
old (generic function with 1 method)

julia> @deprecateold(x) new(x) false  
old (generic function with 1 method)

source

```
### 41.11Missing Values.

Base.Missing– Type.

```

Missing

```

#### CHAPTER 41. ESSENTIALS 498

```

A type with no fields whose singleton instancemissingis used to represent missing values.  
See also:skipmissing,nonmissingtype,Nothing.  
source

```
Base.missing– Constant.

```

missing

The singleton instance of typeMissingrepresenting a missing value.  
See also:NaN,skipmissing,nonmissingtype.  
source

```
Base.coalesce– Function.

```

coalesce(x...)

Return the first value in the arguments which is not equal tomissing, if any. Otherwise returnmissing.  
See alsoskipmissing,something,@coalesce.  
Examples

julia> coalesce(missing,1)  
1

julia> coalesce(1, missing)  
1

julia> coalesce(nothing, 1) # returns `nothing`

julia> coalesce(missing, missing)  
missing

source

```
Base.@coalesce– Macro.

```

@coalesce(x...)

Short-circuiting version ofcoalesce.  
Examples

julia> f(x)= (println("f( $x )"); missing);

julia> a = 1;

julia> a = @coalescea f( 2) f( 3) error("`a` is still missing")  
1

julia> b = missing;

julia> b = @coalesceb f( 2) f( 3) error("`b` is still missing")  
f(2)  
f(3)  
ERROR: `b` is still missing  
[...]

```

#### CHAPTER 41. ESSENTIALS 499

```

Julia 1.7  
This macro is available as of Julia 1.7.

source

```
Base.ismissing– Function.

```

ismissing(x)

Indicate whetherxismissing.  
See also:skipmissing,isnothing,isnan.  
source

```
Base.skipmissing– Function.

```

skipmissing(itr)

Return an iterator over the elements initrskippingmissingvalues. The returned object can be indexed  
using indices ofitrif the latter is indexable. Indices corresponding to missing values are not valid: they  
are skipped bykeysandeachindex, and aMissingExceptionis thrown when trying to use them.  
Usecollectto obtain anArraycontaining the non-missingvalues initr. Note that even ifitris a  
multidimensional array, the result will always be aVectorsince it is not possible to remove missings while  
preserving dimensions of the input.  
See alsocoalesce,ismissing,something.  
Examples

julia> x = skipmissing([1, missing,2])  
skipmissing(Union{Missing, Int64}[1, missing, 2])

julia> sum(x)  
3

julia> x[1]  
1

julia> x[2]  
ERROR: MissingException: the value at index (2,) is missing  
[...]

julia> argmax(x)  
3

julia> collect(keys(x))  
2-element Vector{Int64}:  
1  
3

julia> collect(skipmissing([1, missing,2]))  
2-element Vector{Int64}:  
1  
2

julia> collect(skipmissing([1 missing;2 missing]))

```

#### CHAPTER 41. ESSENTIALS 500

```

2-element Vector{Int64}:  
1  
2

source

```
Base.nonmissingtype– Function.

```

nonmissingtype(T:: Type )

IfTis a union of types containingMissing, return a new type withMissingremoved.  
Examples

julia> nonmissingtype( Union { Int64 ,Missing})  
Int64

julia> nonmissingtype( Any )  
Any

Julia 1.3  
This function is exported as of Julia 1.3.

source

```
### 41.12System.

Base.run– Function.

```

run(command, args...; wait:: Bool = true )

Run a command object, constructed with backticks (see theRunning External Programssection in the  
manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status  
(whenwaitis true).  
Ifwaitis false, the process runs asynchronously. You can later wait for it and check its exit status by calling  
successon the returned process object.  
Whenwaitis false, the process' I/O streams are directed todevnull. Whenwaitis true, I/O streams are  
shared with the parent process. Usepipelineto control I/O redirection.  
source

```
Base.devnull– Constant.

```

devnull

Used in a stream redirect to discard all data written to it. Essentially equivalent to/dev/nullon Unix or  
NULon Windows. Usage:

run(pipeline(`cat test.txt`, devnull))

source

```
Base.success– Function.

```

success(command)

```

#### CHAPTER 41. ESSENTIALS 501

```

Run a command object, constructed with backticks (see theRunning External Programssection in the  
manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process  
cannot be started.  
source

```
Base.process_running– Function.

```

process_running(p::Process)

Determine whether a process is currently running.  
source

```
Base.process_exited– Function.

```

process_exited(p::Process)

Determine whether a process has exited.  
source

```
Base.kill– Method.

```

kill(p::Process, signum=Base.SIGTERM)

Send a signal to a process. The default is to terminate the process. Returns successfully if the process  
has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient  
permissions).  
source

```
Base.Sys.set_process_title– Function.

```

Sys.set_process_title(title:: AbstractString )

Set the process title. No-op on some operating systems.  
source

```
Base.Sys.get_process_title– Function.

```

Sys.get_process_title()

Get the process title. On some systems, will always return an empty string.  
source

```
Base.ignorestatus– Function.

```

ignorestatus(command)

Mark a command object so that running it will not throw an error if the result code is non-zero.  
source

```
Base.detach– Function.

```

detach(command)

```

#### CHAPTER 41. ESSENTIALS 502

```

Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process,  
and not have Ctrl-C interrupts passed to it.  
source

```
Base.Cmd– Type.

```

Cmd (cmd:: Cmd ; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)

Construct a newCmdobject, representing an external program and arguments, fromcmd, while changing  
the settings of the optional keyword arguments:

```
- ignorestatus::Bool: Iftrue(defaults tofalse), then theCmdwill not throw an error if the return
    code is nonzero.
- detach::Bool: Iftrue(defaults tofalse), then theCmdwill be run in a new process group, allowing
    it to outlive thejuliaprocess and not have Ctrl-C passed to it.
- windows_verbatim::Bool: Iftrue(defaultstofalse),thenonWindowstheCmdwillsendacommand-
    line string to the process with no quoting or escaping of arguments, even arguments containing
    spaces. (On Windows, arguments are sent to a program as a single"command-line" string, and pro-
    grams are responsible for parsing it into arguments. By default, empty arguments and arguments
    with spaces or tabs are quoted with double quotes"in the command line, and\or"are preceded by
    backslashes. windows_verbatim=trueis useful for launching programs that parse their command
    line in nonstandard ways.) Has no effect on non-Windows systems.
- windows_hide::Bool: Iftrue(defaults tofalse), then on Windows no new console window is dis-
    played when theCmdis executed. This has no effect if a console is already open or on non-Windows
    systems.
- env: Set environment variables to use when running theCmd. envis either a dictionary mapping
    strings to strings, an array of strings of the form"var=val", an array or tuple of"var"=>valpairs.
    In order to modify (rather than replace) the existing environment, initializeenvwithcopy(ENV)and
    then setenv["var"]=valas desired. To add to an environment block within aCmdobject without
    replacing all elements, useaddenv()which will return aCmdobject with the updated environment.
- dir::AbstractString: Specify a working directory for the command (instead of the current direc-
    tory).

```

For any keywords that are not specified, the current settings fromcmdare used. Normally, to create aCmd  
object in the first place, one uses backticks, e.g.  
Cmd(`echo "Hello world"`, ignorestatus=true, detach=false)

source

```
Base.setenv– Function.

```

setenv(command:: Cmd , env; dir)

Set environment variables to use when running the givencommand. envis either a dictionary mapping  
strings to strings, an array of strings of the form"var=val", or zero or more"var"=>valpair arguments.  
In order to modify (rather than replace) the existing environment, createenvthroughcopy(ENV)and then  
settingenv["var"]=valas desired, or useaddenv.  
Thedirkeyword argument can be used to specify a working directory for the command.dirdefaults to  
the currently setdirforcommand(which is the current working directory if not specified already).  
See alsoCmd,addenv,ENV,pwd.  
source

```

#### CHAPTER 41. ESSENTIALS 503

Base.addenv– Function.

```

addenv(command:: Cmd , env...; inherit:: Bool = true )

Merge new environment mappings into the givenCmdobject, returning a newCmdobject. Duplicate keys  
are replaced. Ifcommanddoes not contain any environment values set already, it inherits the current  
environment at time ofaddenv()call ifinheritistrue.  
See alsoCmd,setenv,ENV.

Julia 1.6  
This function requires Julia 1.6 or later.

source

```
Base.withenv– Function.

```

withenv(f:: Function , kv :: Pair ...)

Executefin an environment that is temporarily modified (not replaced as insetenv) by zero or more  
"var"=>valargumentskv. withenvis generally used via thewithenv(kv...) do ... endsyntax. A  
value ofnothingcan be used to temporarily unset an environment variable (if it is set). Whenwithenv  
returns, the original environment has been restored.  
source

```
Base.pipeline– Method.

```

pipeline(from, to,...)

Create a pipeline from a data source to a destination. The source and destination can be commands, I/O  
streams, strings, or results of otherpipelinecalls. At least one argument must be a command. Strings  
refer to filenames. When called with more than two arguments, they are chained together from left to  
right. Forexample,pipeline(a,b,c)isequivalenttopipeline(pipeline(a,b),c). This providesamore  
concise way to specify multi-stage pipelines.  
Examples :

run(pipeline(`ls`, `grep xyz`))  
run(pipeline(`ls`, "out.txt"))  
run(pipeline("out.txt", `grep xyz`))

source

```
Base.pipeline– Method.

```

pipeline(command; stdin, stdout, stderr, append= false )

Redirect I/O to or from the givencommand. Keyword arguments specify which of the command's streams  
shouldberedirected.appendcontrolswhetherfileoutputappendstothefile. Thisisamoregeneralversion  
ofthe2-argumentpipelinefunction.pipeline(from, to)isequivalenttopipeline(from, stdout=to)  
whenfromis a command, and topipeline(to, stdin=from)whenfromis another kind of data source.  
Examples :

run(pipeline(`dothings`, stdout="out.txt", stderr="errs.txt"))  
run(pipeline(`update`, stdout="log.txt", append= true ))

```

#### CHAPTER 41. ESSENTIALS 504

```

source

```
Base.Libc.gethostname– Function.

```

gethostname()-> AbstractString

Get the local machine's host name.  
source

```
Base.Libc.getpid– Function.

```

getpid()-> Int32

Get Julia's process ID.  
source  
getpid(process) -> Int32

Get the child process ID, if it still exists.

Julia 1.1  
This function requires at least Julia 1.1.

source

```
Base.Libc.time– Method.

```

time()

Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.  
source

```
Base.time_ns– Function.

```

time_ns()

Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.  
source

```
Base.@time– Macro.

```

@time

A macro to execute an expression, printing the time it took to execute, the number of allocations, and the  
total number of bytes its execution caused to be allocated, before returning the value of the expression.  
Any time spent garbage collecting (gc) or compiling is shown as a percentage.  
In some cases the system will look inside the@timeexpression and compile some of the called code  
before execution of the top-level expression begins. When that happens, some compilation time will not  
be counted. To include this time you can run@time @eval ....  
See also@timev,@timed,@elapsed, and@allocated.

Note  
For more serious benchmarking, consider the@btimemacro from the BenchmarkTools.jl pack-  
age which among other things evaluates the function multiple times in order to reduce noise.

```

#### CHAPTER 41. ESSENTIALS 505

```

julia> x = rand(10,10);

julia> @timex * x;  
0.606588 seconds (2.19 M allocations: 116.555 MiB, 3.75% gc time, 99.94% compilation time)

julia> @timex * x;  
0.000009 seconds (1 allocation: 896 bytes)

julia> @time begin  
sleep(0.3)  
1+1  
end  
0.301395 seconds (8 allocations: 336 bytes)  
2

source

```
Base.@timev– Macro.

```

@timev

This is a verbose version of the@timemacro. It first prints the same information as@time, then any  
non-zero memory allocation counters, and then returns the value of the expression.  
See also@time,@timed,@elapsed, and@allocated.

julia> x = rand(10,10);

julia> @timevx * x;  
0.546770 seconds (2.20 M allocations: 116.632 MiB, 4.23% gc time, 99.94% compilation time)  
elapsed time (ns): 546769547  
gc time (ns): 23115606  
bytes allocated: 122297811  
pool allocs: 2197930  
non-pool GC allocs:1327  
malloc() calls: 36  
realloc() calls: 5  
GC pauses: 3

julia> @timevx * x;  
0.000010 seconds (1 allocation: 896 bytes)  
elapsed time (ns): 9848  
bytes allocated: 896  
pool allocs: 1

source

```
Base.@timed– Macro.

```

@timed

A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allo-  
cated, garbage collection time, and an object with various memory allocation counters.  
In some cases the system will look inside the@timedexpression and compile some of the called code  
before execution of the top-level expression begins. When that happens, some compilation time will not  
be counted. To include this time you can run@timed @eval ....  
See also@time,@timev,@elapsed, and@allocated.

```

#### CHAPTER 41. ESSENTIALS 506

```

julia> stats= @timedrand(10^6);

julia> stats.time  
0.006634834

julia> stats.bytes  
8000256

julia> stats.gctime  
0.0055765

julia> propertynames(stats.gcstats)  
(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)

julia> stats.gcstats.total_time  
5576500

Julia 1.5  
The return type of this macro was changed fromTupletoNamedTuplein Julia 1.5.

source

```
Base.@elapsed– Macro.

```

@elapsed

Amacrotoevaluateanexpression, discardingtheresultingvalue, insteadreturningthenumberofseconds  
it took to execute as a floating-point number.  
In some cases the system will look inside the@elapsedexpression and compile some of the called code  
before execution of the top-level expression begins. When that happens, some compilation time will not  
be counted. To include this time you can run@elapsed @eval ....  
See also@time,@timev,@timed, and@allocated.

julia> @elapsedsleep(0.3)  
0.301391426

source

```
Base.@allocated– Macro.

```

@allocated

A macro to evaluate an expression, discarding the resulting value, instead returning the total number of  
bytes allocated during evaluation of the expression.  
See also@time,@timev,@timed, and@elapsed.

julia> @allocatedrand(10^6)  
8000080

source

```
Base.EnvDict– Type.

```

EnvDict()-> EnvDict

```

#### CHAPTER 41. ESSENTIALS 507

```

A singleton of this type provides a hash table interface to environment variables.  
source

```
Base.ENV– Constant.

```

ENV

Reference to the singletonEnvDict, providing a dictionary interface to system environment variables.  
(On Windows, system environment variables are case-insensitive, andENVcorrespondingly converts all  
keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distin-  
guish variables by case, and should beware that setting an ostensibly lowercase variable may result in an  
uppercaseENVkey.)  
source

```
Base.Sys.isunix– Function.

```

Sys.isunix([os])

Predicate for testing if the OS provides a Unix-like interface. See documentation inHandling Operating  
System Variation.  
source

```
Base.Sys.isapple– Function.

```

Sys.isapple([os])

Predicate for testing if the OS is a derivative of Apple Macintosh OS X or Darwin. See documentation in  
Handling Operating System Variation.  
source

```
Base.Sys.islinux– Function.

```

Sys.islinux([os])

Predicate for testing if the OS is a derivative of Linux. See documentation inHandling Operating System  
Variation.  
source

```
Base.Sys.isbsd– Function.

```

Sys.isbsd([os])

Predicate for testing if the OS is a derivative of BSD. See documentation inHandling Operating System  
Variation.

Note  
The Darwin kernel descends from BSD, which means thatSys.isbsd()istrueon macOS sys-  
tems. To exclude macOS from a predicate, useSys.isbsd() && !Sys.isapple().

source

```
Base.Sys.isfreebsd– Function.


#### CHAPTER 41. ESSENTIALS 508

```

Sys.isfreebsd([os])

Predicate for testing if the OS is a derivative of FreeBSD. See documentation inHandling Operating System  
Variation.

Note  
Not to be confused withSys.isbsd(), which istrueon FreeBSD but also on other BSD-based  
systems.Sys.isfreebsd()refers only to FreeBSD.

Julia 1.1  
This function requires at least Julia 1.1.

source

```
Base.Sys.isopenbsd– Function.

```

Sys.isopenbsd([os])

PredicatefortestingiftheOSisaderivativeofOpenBSD.SeedocumentationinHandlingOperatingSystem  
Variation.

Note  
Not to be confused withSys.isbsd(), which istrueon OpenBSD but also on other BSD-based  
systems.Sys.isopenbsd()refers only to OpenBSD.

Julia 1.1  
This function requires at least Julia 1.1.

source

```
Base.Sys.isnetbsd– Function.

```

Sys.isnetbsd([os])

Predicate for testing if the OS is a derivative of NetBSD. See documentation inHandling Operating System  
Variation.

Note  
Not to be confused withSys.isbsd(), which istrueon NetBSD but also on other BSD-based  
systems.Sys.isnetbsd()refers only to NetBSD.

Julia 1.1  
This function requires at least Julia 1.1.

source

```
Base.Sys.isdragonfly– Function.

```

Sys.isdragonfly([os])

Predicate for testing if the OS is a derivative of DragonFly BSD. See documentation inHandling Operating  
System Variation.

```

#### CHAPTER 41. ESSENTIALS 509

```

Note  
Not to be confused withSys.isbsd(), which istrueon DragonFly but also on other BSD-based  
systems.Sys.isdragonfly()refers only to DragonFly.

Julia 1.1  
This function requires at least Julia 1.1.

source

```
Base.Sys.iswindows– Function.

```

Sys.iswindows([os])

Predicate for testing if the OS is a derivative of Microsoft Windows NT. See documentation inHandling  
Operating System Variation.  
source

```
Base.Sys.windows_version– Function.

```

Sys.windows_version()

Return the version number for the Windows NT Kernel as aVersionNumber, i.e.v"major.minor.build",  
orv"0.0.0"if this is not running on Windows.  
source

```
Base.Sys.free_memory– Function.

```

Sys.free_memory()

Get the total free memory in RAM in bytes.  
source

```
Base.Sys.total_memory– Function.

```

Sys.total_memory()

Get the total memory in RAM (including that which is currently used) in bytes.  
source

```
Base.@static– Macro.

```

@static

Partially evaluate an expression at parse time.  
For example,@static Sys.iswindows()? foo : barwill evaluateSys.iswindows()and insert either  
fooorbarinto the expression. This is useful in cases where a construct would be invalid on other plat-  
forms, such as accallto a non-existent function. @static if Sys.isapple() foo endand@static  
foo <&&,||> barare also valid syntax.  
source

```

#### CHAPTER 41. ESSENTIALS 510

### 41.13Versioning

Base.VersionNumber– Type.

```

VersionNumber

Version number type which follow the specifications ofsemantic versioning, composed of major, minor and  
patch numeric values, followed by pre-release and build alpha-numeric annotations. See also@v_str.  
Examples

julia>VersionNumber ("1.2.3")  
v"1.2.3"

julia>VersionNumber ("2.0.1-rc1")  
v"2.0.1-rc1"

source

```
Base.@v_str– Macro.

```

@v_str

String macro used to parse a string to aVersionNumber.  
Examples

julia> v"1.2.3"  
v"1.2.3"

julia> v"2.0.1-rc1"  
v"2.0.1-rc1"

source

```
### 41.14Errors

Base.error– Function.

```

error(message:: AbstractString )

Raise anErrorExceptionwith the given message.  
source  
error(msg...)

Raise anErrorExceptionwith the given message.  
source

```
Core.throw– Function.

```

throw(e)

Throw an object as an exception.  
source

```

#### CHAPTER 41. ESSENTIALS 511

Base.rethrow– Function.

```

rethrow()

Rethrowthecurrentexceptionfromwithinacatchblock. Therethrownexceptionwillcontinuepropagation  
as if it had not been caught.

Note  
The alternative formrethrow(e)allows you to associate an alternative exception objectewith  
the current backtrace. However this misrepresents the program state at the time of the er-  
ror so you're encouraged to instead throw a new exception usingthrow(e). In Julia 1.1 and  
above, usingthrow(e)will preserve the root cause exception on the stack, as described in  
current_exceptions.

source

```
Base.backtrace– Function.

```

backtrace()

Get a backtrace object for the current program point.  
source

```
Base.catch_backtrace– Function.

```

catch_backtrace()

Get the backtrace of the current exception, for use withincatchblocks.  
source

```
Base.current_exceptions– Function.

```

current_exceptions(task:: Task =current_task(); [backtrace:: Bool = true ])

Get the stack of exceptions currently being handled. For nested catch blocks there may be more than  
one current exception in which case the most recently thrown exception is last in the stack. The stack is  
returned as anExceptionStackwhich is an AbstractVector of named tuples(exception,backtrace). If  
backtraceis false, the backtrace in each pair will be set tonothing.  
Explicitly passingtaskwill return the current exception stack on an arbitrary task. This is useful for in-  
specting tasks which have failed due to uncaught exceptions.

Julia 1.7  
This function went by the experimental namecatch_stack()in Julia 1.1–1.6, and had a plain  
Vector-of-tuples as a return type.

source

```
Base.@assert– Macro.

```

@assertcond [text]

Throw anAssertionErrorifcondisfalse. Preferred syntax for writing assertions. Messagetextis  
optionally displayed upon assertion failure.

```

#### CHAPTER 41. ESSENTIALS 512

```

Warning  
Anassertmightbedisabledatvariousoptimizationlevels. Assertshouldthereforeonlybeused  
as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor  
should side effects needed for the function to work correctly be used inside of asserts.

Examples

julia> @assertiseven(3) "3 is an odd number!"  
ERROR: AssertionError: 3 is an odd number!

julia> @assertisodd(3) "What even are numbers?"

source

```
Base.Experimental.register_error_hint– Function.

```

Experimental.register_error_hint(handler, exceptiontype)

Register a"hinting" functionhandler(io, exception)that can suggest potential ways for users to cir-  
cumvent errors.handlershould examineexceptionto see whether the conditions appropriate for a hint  
are met, and if so generate output toio. Packages should callregister_error_hintfrom within their  
__init__function.  
For specific exception types,handleris required to accept additional arguments:

```
- MethodError: providehandler(io, exc::MethodError, argtypes, kwargs),whichsplitsthecom-
    bined arguments into positional and keyword arguments.

```

When issuing a hint, the output should typically start with\n.  
Ifyoudefinecustomexceptiontypes,yourshowerrormethodcansupporthintsbycallingExperimental.show_error_hints.  
Example  
julia> module Hinter

only_int(x::Int) = 1  
any_number(x::Number) = 2

function **init**()  
Base.Experimental.register_error_hint(MethodError) do io, exc, argtypes, kwargs  
if exc.f == only_int

# Color is not necessary, this is just to show it's possible.

print(io, "\nDid you mean to call ")  
printstyled(io, "`any_number`?", color=:cyan)  
end  
end  
end

end

Then if you callHinter.only_inton something that isn't anInt(thereby triggering aMethodError), it  
issues the hint:  
julia> Hinter.only_int(1.0)  
ERROR: MethodError: no method matching only_int(::Float64)  
Did you mean to call `any_number`?  
Closest candidates are:  
...

```

#### CHAPTER 41. ESSENTIALS 513

```

Julia 1.5  
Custom error hints are available as of Julia 1.5.

Warning  
Thisinterfaceisexperimentalandsubjecttochangeorremovalwithoutnotice. Toinsulateyour-  
selfagainstchanges,considerputtinganyregistrationsinsideanif isdefined(Base.Experimental,  
:register_error_hint) ... endblock.

source

```
Base.Experimental.show_error_hints– Function.

```

Experimental.show_error_hints(io, ex, args...)

InvokeallhandlersfromExperimental.register_error_hintfortheparticularexceptiontypetypeof(ex).  
argsmust contain any other arguments expected by the handler for that type.

Julia 1.5  
Custom error hints are available as of Julia 1.5.

Warning  
This interface is experimental and subject to change or removal without notice.

source

```
Core.ArgumentError– Type.

```

ArgumentError (msg)

The parameters to a function call do not match a valid signature. Argumentmsgis a descriptive error  
string.  
source

```
Core.AssertionError– Type.

```

AssertionError ([msg])

The asserted condition did not evaluate totrue. Optional argumentmsgis a descriptive error string.  
Examples

julia> @assert false "this is not true"  
ERROR: AssertionError: this is not true

AssertionErroris usually thrown from@assert.  
source

```
Core.BoundsError– Type.

```

BoundsError ([a],[i])

An indexing operation into an array,a, tried to access an out-of-bounds element at indexi.  
Examples

```

#### CHAPTER 41. ESSENTIALS 514

```

julia> A = fill(1.0, 7);

julia> A[8]  
ERROR: BoundsError: attempt to access 7-element Vector{Float64} at index [8]

julia> B = fill(1.0, ( 2,3));

julia> B[2, 4]  
ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [2, 4]

julia> B[9]  
ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [9]

source

```
Base.CompositeException– Type.

```

CompositeException

Wrap aVectorof exceptions thrown by aTask(e.g. generated from a remote worker over a channel or  
an asynchronously executing local I/O write or a remote worker underpmap) with information about the  
series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers  
fail, the resultingCompositeExceptionwill contain a"bundle" of information from each worker indicating  
where and why the exception(s) occurred.  
source

```
Base.DimensionMismatch– Type.

```

DimensionMismatch ([msg])

The objects called do not have matching dimensionality. Optional argumentmsgis a descriptive error  
string.  
source

```
Core.DivideError– Type.

```

DivideError ()

Integer division was attempted with a denominator value of 0.  
Examples

julia> 2/0  
Inf

julia> div(2, 0)  
ERROR: DivideError: integer division error  
Stacktrace:  
[...]

source

```
Core.DomainError– Type.


#### CHAPTER 41. ESSENTIALS 515

```

DomainError (val)  
DomainError (val, msg)

The argumentvalto a function or constructor is outside the valid domain.  
Examples

julia> sqrt(-1)  
ERROR: DomainError with -1.0:  
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).  
Stacktrace:  
[...]

source

```
Base.EOFError– Type.

```

EOFError ()

No more data was available to read from a file or stream.  
source

```
Core.ErrorException– Type.

```

ErrorException (msg)

Generic error type. The error message, in the.msgfield, may provide more specific details.  
Examples

julia> ex = ErrorException ("I've done a bad thing");

julia> ex.msg  
"I've done a bad thing"

source

```
Core.InexactError– Type.

```

InexactError (name:: Symbol , T, val)

Cannot exactly convertvalto typeTin a method of functionname.  
Examples

julia> convert( Float64 , 1+2im)  
ERROR: InexactError: Float64(1 + 2im)  
Stacktrace:  
[...]

source

```
Core.InterruptException– Type.

```

InterruptException ()

```

#### CHAPTER 41. ESSENTIALS 516

```

The process was stopped by a terminal interrupt (CTRL+C).  
Note that, in Julia script started without-i(interactive) option,InterruptExceptionis not thrown by  
default. CallingBase.exit_on_sigint(false)in the script can recover the behavior of the REPL. Alter-  
natively, a Julia script can be started with  
julia -e "include(popfirst!(ARGS))" script.jl

to letInterruptExceptionbe thrown by CTRL+C during the execution.  
source

```
Base.KeyError– Type.

```

KeyError (key)

An indexing operation into anAbstractDict(Dict) orSetlike object tried to access or delete a non-  
existent element.  
source

```
Core.LoadError– Type.

```

LoadError (file:: AbstractString , line:: Int , error)

An error occurred whileincludeing,requireing, orusinga file. The error specifics should be available in  
the.errorfield.

Julia 1.7  
LoadErrors are no longer emitted by@macroexpand,@macroexpand1, andmacroexpandas of  
Julia 1.7.

source

```
Core.MethodError– Type.

```

MethodError (f, args)

A method with the required type signature does not exist in the given generic function. Alternatively, there  
is no unique most-specific method.  
source

```
Base.MissingException– Type.

```

MissingException(msg)

Exception thrown when amissingvalue is encountered in a situation where it is not supported. The error  
message, in themsgfield may provide more specific details.  
source

```
Core.OutOfMemoryError– Type.

```

OutOfMemoryError ()

An operation allocated too much memory for either the system or the garbage collector to handle properly.  
source

```

#### CHAPTER 41. ESSENTIALS 517

Core.ReadOnlyMemoryError– Type.

```

ReadOnlyMemoryError ()

An operation tried to write to memory that is read-only.  
source

```
Core.OverflowError– Type.

```

OverflowError (msg)

The result of an expression is too large for the specified type and will cause a wraparound.  
source

```
Base.ProcessFailedException– Type.

```

ProcessFailedException

Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to  
indicate a nonzero exit code was returned (i.e. that the invoked process failed).  
source

```
Core.StackOverflowError– Type.

```

StackOverflowError ()

Thefunctioncallgrewbeyondthesizeofthecallstack. Thisusuallyhappenswhenacallrecursesinfinitely.  
source

```
Base.SystemError– Type.

```

SystemError (prefix:: AbstractString , [errno:: Int32 ])

A system call failed with an error code (in theerrnoglobal variable).  
source

```
Core.TypeError– Type.

```

TypeError (func:: Symbol , context:: AbstractString , expected:: Type , got)

A type assertion failure, or calling an intrinsic function with an incorrect argument type.  
source

```
Core.UndefKeywordError– Type.

```

UndefKeywordError(var:: Symbol )

The required keyword argumentvarwas not assigned in a function call.  
Examples

```

#### CHAPTER 41. ESSENTIALS 518

```

julia>function my_func(;my_arg)  
return my_arg+ 1  
end  
my_func (generic function with 1 method)

julia> my_func()  
ERROR: UndefKeywordError: keyword argument my_arg not assigned  
Stacktrace:  
[1] my_func() at ./REPL[1]:2  
[2] top-level scope at REPL[2]:1

source

```
Core.UndefRefError– Type.

```

UndefRefError ()

The item or field is not defined for the given object.  
Examples

julia> struct MyType  
a:: Vector { Int }  
MyType()= new()  
end

julia> A = MyType()  
MyType(#undef)

julia> A.a  
ERROR: UndefRefError: access to undefined reference  
Stacktrace:  
[...]

source

```
Core.UndefVarError– Type.

```

UndefVarError (var:: Symbol )

A symbol in the current scope is not defined.  
Examples

julia> a  
ERROR: UndefVarError: a not defined

julia> a = 1;

julia> a  
1

source

```
Base.StringIndexError– Type.

```

StringIndexError(str, i)

```

#### CHAPTER 41. ESSENTIALS 519

```

An error occurred when trying to accessstrat indexithat is not valid.  
source

```
Core.InitError– Type.

```

InitError (mod:: Symbol , error)

An error occurred when running a module's__init__function. The actual error thrown is available in the  
.errorfield.  
source

```
Base.retry– Function.

```

retry(f; delays=ExponentialBackOff(), check=nothing) -> Function

Return an anonymous function that calls functionf. If an exception arises,fis repeatedly called again,  
eachtimecheckreturnstrue, afterwaitingthenumberofsecondsspecifiedindelays.checkshouldinput  
delays's current state and theException.

Julia 1.2  
Before Julia 1.2 this signature was restricted tof::Function.

Examples

retry(f, delays=fill(5.0, 3))  
retry(f, delays=rand(5:10, 2))  
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))  
retry(http_get, check=(s,e)->e.status== "503")(url)  
retry(read, check=(s,e)->isa(e, IOError))(io,128; all= false )

source

```
Base.ExponentialBackOff– Type.

```

ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)

AFloat64iterator of lengthnwhose elements exponentially increase at a rate in the intervalfactor* (1  
±jitter). The first element isfirst_delayand all elements are clamped tomax_delay.  
source

```
### 41.15Events

Base.Timer– Method.

```

Timer (callback:: Function , delay; interval= 0)

Create a timer that runs the functioncallbackat each timer expiration.  
Waiting tasks are woken and the functioncallbackis called after an initial delay ofdelayseconds, and  
then repeating with the givenintervalin seconds. Ifintervalis equal to 0 , the callback is only run once.  
The functioncallbackis called with a single argument, the timer itself. Stop a timer by callingclose. The  
cbmay still be run one final time, if the timer has already expired.  
Examples  
Here the first number is printed after a delay of two seconds, then the following numbers are printed  
quickly.

```

#### CHAPTER 41. ESSENTIALS 520

```

julia>begin  
i = 0  
cb(timer)= ( global i += 1; println(i))  
t = Timer (cb,2, interval=0.2)  
wait(t)  
sleep(0.5)  
close(t)  
end  
1  
2  
3

source

```
Base.Timer– Type.

```

Timer (delay; interval= 0)

Create a timer that wakes up tasks waiting for it (by callingwaiton the timer object).  
Waiting tasks are woken after an initial delay of at leastdelayseconds, and then repeating after at least  
intervalseconds again elapse. Ifintervalis equal to 0 , the timer is only triggered once. When the timer  
is closed (byclose) waiting tasks are woken with an error. Useisopento check whether a timer is still  
active.  
Note:intervalis subject to accumulating time skew. If you need precise events at a particular absolute  
time, create a new timer at each expiration with the difference to the next time computed.  
source

```
Base.AsyncCondition– Type.

```

AsyncCondition()

Create a async condition that wakes up tasks waiting for it (by callingwaiton the object) when notified  
from C by a call touv_async_send. Waiting tasks are woken with an error when the object is closed (by  
close). Useisopento check whether it is still active.  
source

```
Base.AsyncCondition– Method.

```

AsyncCondition(callback:: Function )

Create a async condition that calls the givencallbackfunction. Thecallbackis passed one argument,  
the async condition object itself.  
source

```
### 41.16Reflection

Base.nameof– Method.

```

nameof(m:: Module ) -> Symbol

Get the name of aModuleas aSymbol.  
Examples

```

#### CHAPTER 41. ESSENTIALS 521

```

julia> nameof(Base.Broadcast)  
:Broadcast

source

```
Base.parentmodule– Function.

```

parentmodule(m:: Module ) -> Module

Get a module's enclosingModule.Mainis its own parent.  
See also:names,nameof,fullname,@**MODULE**.  
Examples

julia> parentmodule(Main)  
Main

julia> parentmodule(Base.Broadcast)  
Base

source  
parentmodule(t::DataType) -> Module

Determine the module containing the definition of a (potentiallyUnionAll-wrapped)DataType.  
Examples

julia>module Foo  
struct Int end  
end  
Foo

julia> parentmodule( Int )  
Core

julia> parentmodule(Foo. Int )  
Foo

source  
parentmodule(f::Function) -> Module

Determine the module containing the (first) definition of a generic function.  
source  
parentmodule(f::Function, types) -> Module

Determine the module containing a given definition of a generic function.  
source

```
Base.pathof– Method.

```

pathof(m:: Module )

```

#### CHAPTER 41. ESSENTIALS 522

```

Return the path of them.jlfile that was used toimportmodulem, ornothingifmwas not imported from  
a package.  
Usedirnameto get the directory part andbasenameto get the file name part of the path.  
source

```
Base.pkgdir– Method.

```

pkgdir(m:: Module [, paths::String...])

Return the root directory of the package that imported modulem, ornothingifmwas not imported from a  
package. Optionallyfurtherpathcomponentstringscanbeprovidedtoconstructapathwithinthepackage  
root.

julia> pkgdir(Foo)  
"/path/to/Foo.jl"

julia> pkgdir(Foo,"src", "file.jl")  
"/path/to/Foo.jl/src/file.jl"

Julia 1.7  
The optional argumentpathsrequires at least Julia 1.7.

source

```
Base.moduleroot– Function.

```

moduleroot(m:: Module ) -> Module

Find the root module of a given module. This is the first module in the chain of parent modules ofmwhich  
is either a registered root module or which is its own parent module.  
source

```
__module__– Keyword.

```

**module**

The argument__module__is only visible inside the macro, and it provides information (in the form of a  
Moduleobject) about the expansion context of the macro invocation. See the manual section onMacro  
invocationfor more information.  
source

```
__source__– Keyword.

```

**source**

The argument__source__is only visible inside the macro, and it provides information (in the form of a  
LineNumberNodeobject) about the parser location of the@sign from the macro invocation. See the manual  
section onMacro invocationfor more information.  
source

```
Base.@__MODULE__– Macro.

```

@**MODULE**-> Module

```

#### CHAPTER 41. ESSENTIALS 523

```

Get theModuleof the toplevel eval, which is theModulecode is currently being read from.  
source

```
Base.@__FILE__– Macro.

```

@**FILE**-> AbstractString

Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by  
julia -e . Returnnothingif the macro was missing parser source information. Alternatively see  
PROGRAM_FILE.  
source

```
Base.@__DIR__– Macro.

```

@**DIR**-> AbstractString

Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the  
current working directory if run from a REPL or if evaluated byjulia -e .  
source

```
Base.@__LINE__– Macro.

```

@**LINE**-> Int

Expand to the line number of the location of the macrocall. Return 0 if the line number could not be  
determined.  
source

```
Base.fullname– Function.

```

fullname(m:: Module )

Get the fully-qualified name of a module as a tuple of symbols. For example,  
Examples

julia> fullname(Base.Iterators)  
(:Base, :Iterators)

julia> fullname(Main)  
(:Main,)

source

```
Base.names– Function.

```

names(x:: Module ; all:: Bool = false , imported:: Bool = false )

Get an array of the names exported by aModule, excluding deprecated names. Ifallis true, then the  
list also includes non-exported names defined in the module, deprecated names, and compiler-generated  
names. Ifimportedis true, then names explicitly imported from other modules are also included.  
As a special case, all names defined inMainare considered"exported", since it is not idiomatic to explicitly  
export names fromMain.  
See also:@locals,@**MODULE**.  
source

```

#### CHAPTER 41. ESSENTIALS 524

Core.nfields– Function.

```

nfields(x)-> Int

Get the number of fields in the given object.  
Examples

julia> a = 1//2;

julia> nfields(a)  
2

julia> b = 1  
1

julia> nfields(b)  
0

julia> ex = ErrorException ("I've done a bad thing");

julia> nfields(ex)  
1

In these examples,ais aRational, which has two fields.bis anInt, which is a primitive bitstype with no  
fields at all.exis anErrorException, which has one field.  
source

```
Base.isconst– Function.

```

isconst(m:: Module , s :: Symbol ) -> Bool

Determine whether a global is declaredconstin a givenModule.  
source

```
Base.nameof– Method.

```

nameof(f:: Function ) -> Symbol

Get the name of a genericFunctionas a symbol. For anonymous functions, this is a compiler-generated  
name. For explicitly-declared subtypes ofFunction, it is the name of the function's type.  
source

```
Base.functionloc– Method.

```

functionloc(f:: Function , types)

Returns a tuple(filename,line)giving the location of a genericFunctiondefinition.  
source

```
Base.functionloc– Method.

```

functionloc(m:: Method )

```

#### CHAPTER 41. ESSENTIALS 525

```

Returns a tuple(filename,line)giving the location of aMethoddefinition.  
source

```
Base.@locals– Macro.

```

@locals()

Construct a dictionary of the names (as symbols) and values of all local variables defined as of the call  
site.

Julia 1.1  
This macro requires at least Julia 1.1.

Examples

julia>let x = 1, y = 2  
Base.@locals  
end  
Dict{Symbol, Any} with 2 entries:  
:y => 2  
:x => 1

julia>function f(x)  
local y  
show(Base.@locals); println()  
for i = 1:1  
show(Base.@locals); println()  
end  
y = 2  
show(Base.@locals); println()  
nothing  
end ;

julia> f(42)  
Dict{Symbol, Any}(:x => 42)  
Dict{Symbol, Any}(:i => 1, :x => 42)  
Dict{Symbol, Any}(:y => 2, :x => 42)

source

```
### 41.17Internals.

Base.GC.gc– Function.

```

GC.gc([full= true ])

Performgarbagecollection. Theargumentfulldeterminesthekindofcollection: Afullcollection(default)  
sweeps all objects, which makes the next GC scan much slower, while an incremental collection may only  
sweep so-called young objects.

Warning  
Excessive use will likely lead to poor performance.

source

```

#### CHAPTER 41. ESSENTIALS 526

Base.GC.enable– Function.

```

GC.enable(on:: Bool )

Control whether garbage collection is enabled using a boolean argument (truefor enabled,falsefor  
disabled). Return previous GC state.

Warning  
Disabling garbage collection should be used only with caution, as it can cause memory use to  
grow without bound.

source

```
Base.GC.@preserve– Macro.

```

GC.@preservex1 x2... xn expr

Mark the objectsx1, x2, ...as being in use during the evaluation of the expressionexpr. This is only  
required in unsafe code whereexprimplicitly uses memory or other resources owned by one of thexs.  
Implicit use ofxcovers any indirect use of resources logically owned byxwhich the compiler cannot see.  
Some examples:

```
- Accessing memory of an object directly via aPtr
- Passing a pointer toxtoccall
- Using resources ofxwhich would be cleaned up in the finalizer.

```

@preserveshould generally not have any performance impact in typical use cases where it briefly extends  
object lifetime. In implementation,@preservehas effects such as protecting dynamically allocated objects  
from garbage collection.  
Examples  
When loading from a pointer withunsafe_load, the underlying object is implicitly used, for examplexis  
implicitly used byunsafe_load(p)in the following:

julia>let  
x = Ref { Int }(101)  
p = Base.unsafe_convert( Ptr { Int }, x)  
GC.@preservex unsafe_load(p)  
end  
101

When passing pointers toccall, the pointed-to object is implicitly used and should be preserved. (Note  
however that you should normally just passxdirectly toccallwhich counts as an explicit use.)

julia>let  
x = "Hello"  
p = pointer(x)  
Int (GC.@preservex @ccallstrlen(p:: Cstring ):: Csize_t )

# Preferred alternative

Int (@ccallstrlen(x:: Cstring ):: Csize_t )  
end  
5

```

#### CHAPTER 41. ESSENTIALS 527

```

source

```
Base.GC.safepoint– Function.

```

GC.safepoint()

Inserts a point in the program where garbage collection may run. This can be useful in rare cases in  
multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but  
other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function  
periodically in non-allocating threads allows garbage collection to run.

Julia 1.4  
This function is available as of Julia 1.4.

source

```
Base.Meta.lower– Function.

```

lower(m, x)

Takes the expressionxand returns an equivalent expression in lowered form for executing in modulem.  
See alsocode_lowered.  
source

```
Base.Meta.@lower– Macro.

```

@lower[m] x

Return lowered form of the expressionxin modulem. By defaultmis the module in which the macro is  
called. See alsolower.  
source

```
Base.Meta.parse– Method.

```

parse(str, start; greedy= true , raise= true , depwarn= true )

Parse the expression string and return an expression (which could later be passed to eval for execution).  
startis the code unit index intostrof the first character to start parsing at (as with all string indexing,  
these are not character indices). Ifgreedyistrue(default),parsewill try to consume as much input as it  
can; otherwise, it will stop as soon as it has parsed a valid expression. Incomplete but otherwise syntac-  
tically valid expressions will returnExpr(:incomplete, "(error message)"). Ifraiseistrue(default),  
syntax errors other than incomplete expressions will raise an error. Ifraiseisfalse,parsewill return  
an expression that will raise an error upon evaluation. Ifdepwarnisfalse, deprecation warnings will be  
suppressed.

julia> Meta.parse("(α, β) = 3, 5", 1) # start of string  
(:((α, β) = (3, 5)), 16)

julia> Meta.parse("(α, β) = 3, 5", 1, greedy= false )  
(:((α, β)), 9)

julia> Meta.parse("(α, β) = 3, 5", 16) # end of string  
(nothing, 16)

```

#### CHAPTER 41. ESSENTIALS 528

```

julia> Meta.parse("(α, β) = 3, 5", 11) # index of 3  
(:((3, 5)), 16)

julia> Meta.parse("(α, β) = 3, 5", 11, greedy= false )  
(3, 13)

source

```
Base.Meta.parse– Method.

```

parse(str; raise= true , depwarn= true )

Parsethe expressionstring greedily, returninga single expression. An erroris thrown if thereare additional  
characters after the first expression. Ifraiseistrue(default), syntax errors will raise an error; otherwise,  
parsewill return an expression that will raise an error upon evaluation. Ifdepwarnisfalse, deprecation  
warnings will be suppressed.

julia> Meta.parse("x = 3")  
:(x = 3)

julia> Meta.parse("x = ")  
:($(Expr(:incomplete, "incomplete: premature end of input")))

julia> Meta.parse("1.0.2")  
ERROR: Base.Meta.ParseError("invalid numeric constant "1.0."")  
Stacktrace:  
[...]

julia> Meta.parse("1.0.2"; raise= false )  
:($(Expr(:error, "invalid numeric constant "1.0."")))

source

```
Base.Meta.ParseError– Type.

```

ParseError (msg)

The expression passed to theparsefunction could not be interpreted as a valid Julia expression.  
source

```
Core.QuoteNode– Type.

```

QuoteNode

A quoted piece of code, that does not support interpolation. See themanual section about QuoteNodes  
for details.  
source

```
Base.macroexpand– Function.

```

macroexpand(m:: Module , x; recursive= true )

Take the expressionxand return an equivalent expression with all macros removed (expanded) for ex-  
ecuting in modulem. Therecursivekeyword controls whether deeper levels of nested macros are also  
expanded. This is demonstrated in the example below:

```

#### CHAPTER 41. ESSENTIALS 529

```

julia>module M  
macro m1()  
42  
end  
macro m2()  
:(@m1())  
end  
end  
M

julia> macroexpand(M,:(@m2()), recursive= true )  
42

julia> macroexpand(M,:(@m2()), recursive= false )  
:(#= REPL[16]:6 =# M.@m1)

source

```
Base.@macroexpand– Macro.

```

@macroexpand

Return equivalent expression with all macros removed (expanded).  
There are differences between@macroexpandandmacroexpand.

```
- Whilemacroexpandtakes a keyword argumentrecursive,@macroexpandis always recursive. For a
    non recursive macro version, see@macroexpand1.
- Whilemacroexpandhas an explicitmoduleargument,@macroexpandalways expands with respect to
    the module in which it is called.

```

This is best seen in the following example:

julia>module M  
macro m()  
1  
end  
function f()  
(@macroexpand(@m),  
macroexpand(M,:(@m)),  
macroexpand(Main,:(@m))  
)  
end  
end  
M

julia>macro m()  
2  
end  
@m (macro with 1 method)

julia> M.f()  
(1, 1, 2)

With@macroexpandthe expression expands where@macroexpandappears in the code (moduleMin the  
example). Withmacroexpandthe expression expands in the module given as the first argument.

```

#### CHAPTER 41. ESSENTIALS 530

```

source

```
Base.@macroexpand1– Macro.

```

@macroexpand1

Non recursive version of@macroexpand.  
source

```
Base.code_lowered– Function.

```

code_lowered(f, types; generated= true , debuginfo=:default)

Return an array of the lowered forms (IR) for the methods matching the given generic function and type  
signature.  
Ifgeneratedisfalse, the returnedCodeInfoinstances will correspond to fallback implementations. An  
error is thrown if no fallback implementation exists. Ifgeneratedistrue, theseCodeInfoinstances will  
correspond to the method bodies yielded by expanding the generators.  
The keyworddebuginfocontrols the amount of code metadata present in the output.  
Note that an error will be thrown iftypesare not leaf types whengeneratedistrueand any of the  
corresponding methods are an@generatedmethod.  
source

```
Base.code_typed– Function.

```

code_typed(f, types; optimize= true , debuginfo=:default)

Returns an array of type-inferred lowered form (IR) for the methods matching the given generic function  
and type signature. The keyword argumentoptimizecontrols whether additional optimizations, such as  
inlining, are also applied. The keyworddebuginfocontrols the amount of code metadata present in the  
output, possible options are:sourceor:none.  
source

```
Base.precompile– Function.

```

precompile(f, args:: Tuple { Vararg { Any }})

Compile the given functionffor the argument tuple (of types)args, but do not execute it.  
source

```
### 41.18Meta.

Base.Meta.quot– Function.

```

Meta.quot(ex):: Expr

Quote expressionexto produce an expression with headquote. This can for instance be used to represent  
objects of typeExprin the AST. See also the manual section aboutQuoteNode.  
Examples

```

#### CHAPTER 41. ESSENTIALS 531

```

julia> eval(Meta.quot(:x))  
:x

julia> dump(Meta.quot(:x))  
Expr  
head: Symbol quote  
args: Array{Any}((1,))  
1: Symbol x

julia> eval(Meta.quot(:(1+2)))  
:(1 + 2)

source

```
Base.isexpr– Function.

```

Meta.isexpr(ex, head[, n]):: Bool

Return true ifexis anExprwith the given typeheadand optionally that the argument list is of lengthn.  
headmay be aSymbolor collection ofSymbols. For example, to check that a macro was passed a function  
call expression, you might useisexpr(ex, :call).  
Examples

julia> ex = :(f(x))  
:(f(x))

julia> Meta.isexpr(ex,:block)  
false

julia> Meta.isexpr(ex,:call)  
true

julia> Meta.isexpr(ex, [:block,:call])# multiple possible heads  
true

julia> Meta.isexpr(ex,:call,1)  
false

julia> Meta.isexpr(ex,:call,2)  
true

source

```
Base.isidentifier– Function.

```

isidentifier(s)-> Bool

Return whether the symbol or stringscontains characters that are parsed as a valid identifier in Julia code.  
Internally Julia allows any sequence of characters in aSymbol(except\0s), and macros automatically  
use variable names containing#in order to avoid naming collision with the surrounding code. In order  
for the parser to recognize a variable, it uses a limited set of characters (greatly extended by Unicode).  
isidentifier()makesitpossibletoquerytheparserdirectlywhetherasymbolcontainsvalidcharacters.  
Examples

```

#### CHAPTER 41. ESSENTIALS 532

```

julia> Meta.isidentifier(:x), Meta.isidentifier("1x")  
(true, false)

source

```
Base.isoperator– Function.

```

isoperator(s:: Symbol )

Returntrueif the symbol can be used as an operator,falseotherwise.  
Examples

julia> Meta.isoperator(:+), Meta.isoperator(:f)  
(true, false)

source

```
Base.isunaryoperator– Function.

```

isunaryoperator(s:: Symbol )

Returntrueif the symbol can be used as a unary (prefix) operator,falseotherwise.  
Examples

julia> Meta.isunaryoperator(:-), Meta.isunaryoperator(:√), Meta.isunaryoperator(:f)  
(true, true, false)

source

```
Base.isbinaryoperator– Function.

```

isbinaryoperator(s:: Symbol )

Returntrueif the symbol can be used as a binary (infix) operator,falseotherwise.  
Examples

julia> Meta.isbinaryoperator(:-), Meta.isbinaryoperator(:√), Meta.isbinaryoperator(:f)  
(true, false, false)

source

```
Base.Meta.show_sexpr– Function.

```

Meta.show_sexpr([io:: IO ,], ex)

Show expressionexas a lisp style S-expression.  
Examples

julia> Meta.show_sexpr(:(f(x, g(y,z))))  
(:call, :f, :x, (:call, :g, :y, :z))

source

```

**Chapter 42**

**Collections and Data Structures**

### 42.1 Iteration

Sequential iteration is implemented by theiteratefunction. The generalforloop:

```

for i in iter # or "for i = iter"

# body

end

```
is translated into:

```

next= iterate(iter)  
while next!== nothing  
(i, state)= next

# body

next= iterate(iter, state)  
end

```
Thestateobject may be anything, and should be chosen appropriately for each iterable type. See themanual
section on the iteration interfacefor more details about defining a custom iterable type.

Base.iterate– Function.

```

iterate(iter [, state])-> Union {Nothing, Tuple { Any , Any }}

Advance the iterator to obtain the next element. If no elements remain,nothingshould be returned.  
Otherwise, a 2-tuple of the next element and the new iteration state should be returned.  
source

```
Base.IteratorSize– Type.

```

IteratorSize(itertype:: Type ) -> IteratorSize

Given the type of an iterator, return one of the following values:

```
- SizeUnknown()if the length (number of elements) cannot be determined in advance.
- HasLength()if there is a fixed, finite length.
- HasShape{N}()if there is a known length plus a notion of multidimensional shape (as for an array).
    In this caseNshould give the number of dimensions, and theaxesfunction is valid for the iterator.

#### 533


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 534

- IsInfinite()if the iterator yields values forever.

```

The default value (for iterators that do not define this function) isHasLength(). This means that most  
iterators are assumed to implementlength.  
This trait is generally used to select between algorithms that pre-allocate space for their result, and algo-  
rithms that resize their result incrementally.

julia> Base.IteratorSize(1:5)  
Base.HasShape{1}()

julia> Base.IteratorSize((2,3))  
Base.HasLength()

source

```
Base.IteratorEltype– Type.

```

IteratorEltype(itertype:: Type ) -> IteratorEltype

Given the type of an iterator, return one of the following values:

```
- EltypeUnknown()if the type of elements yielded by the iterator is not known in advance.
- HasEltype()if the element type is known, andeltypewould return a meaningful value.

```

HasEltype()is the default, since iterators are assumed to implementeltype.  
This trait is generally used to select between algorithms that pre-allocate a specific type of result, and  
algorithms that pick a result type based on the types of yielded values.

julia> Base.IteratorEltype(1:5)  
Base.HasEltype()

source

```
Fully implemented by:

- AbstractRange
- UnitRange
- Tuple
- Number
- AbstractArray
- BitSet
- IdDict
- Dict
- WeakKeyDict
- EachLine


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 535

- AbstractString
- Set
- Pair
- NamedTuple

### 42.2 Constructors and Types

Base.AbstractRange– Type.

```

AbstractRange{T}

Supertype for ranges with elements of typeT.UnitRangeand other types are subtypes of this.  
source

```
Base.OrdinalRange– Type.

```

OrdinalRange {T, S}<: AbstractRange{T}

Supertype for ordinal ranges with elements of typeTwith spacing(s) of typeS. The steps should be always-  
exact multiples ofoneunit, andTshould be a"discrete" type, which cannot have values smaller than  
oneunit. For example,IntegerorDatetypes would qualify, whereasFloat64would not (since this type  
can represent values smaller thanoneunit(Float64).UnitRange,StepRange, and other types are sub-  
types of this.  
source

```
Base.AbstractUnitRange– Type.

```

AbstractUnitRange{T}<: OrdinalRange {T, T}

Supertype for ranges with a step size ofoneunit(T)with elements of typeT.UnitRangeand other types  
are subtypes of this.  
source

```
Base.StepRange– Type.

```

StepRange {T, S}<: OrdinalRange {T, S}

Ranges with elements of typeTwith spacing of typeS. The step between each element is constant, and  
the range is defined in terms of astartandstopof typeTand astepof typeS. NeitherTnorSshould  
be floating point types. The syntaxa:b:cwithb > 1anda,b, andcall integers creates aStepRange.  
Examples

julia> collect( StepRange (1, Int8 (2), 10))  
5-element Vector{Int64}:  
1  
3  
5  
7  
9

julia> typeof( StepRange (1, Int8 (2), 10))

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 536

```

StepRange{Int64, Int8}

julia> typeof(1:3:6)  
StepRange{Int64, Int64}

source

```
Base.UnitRange– Type.

```

UnitRange {T<: Real }

A range parameterized by astartandstopof typeT, filled with elements spaced by 1 fromstartuntil  
stopis exceeded. The syntaxa:bwithaandbbothIntegers creates aUnitRange.  
Examples

julia> collect( UnitRange (2.3, 5.2))  
3-element Vector{Float64}:  
2.3  
3.3  
4.3

julia> typeof(1:10)  
UnitRange{Int64}

source

```
Base.LinRange– Type.

```

LinRange{T,L}

Arangewithlenlinearlyspacedelementsbetweenitsstartandstop. Thesizeofthespacingiscontrolled  
bylen, which must be anInteger.  
Examples

julia> LinRange(1.5, 5.5, 9)  
9-element LinRange{Float64, Int64}:  
1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5

Compared to usingrange, directly constructing aLinRangeshould have less overhead but won't try to  
correct for floating point errors:

julia> collect(range(-0.1, 0.3, length=5))  
5-element Array { Float64 ,1}:  
-0.1  
0.0  
0.1  
0.2  
0.3

julia> collect(LinRange(-0.1, 0.3, 5))  
5-element Array { Float64 ,1}:  
-0.1  
-1.3877787807814457e-17  
0.09999999999999999  
0.19999999999999998  
0.3

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 537

### 42.3 General Collections

Base.isempty– Function.

```

isempty(collection)-> Bool

Determine whether a collection is empty (has no elements).  
Examples

julia> isempty([])  
true

julia> isempty([1 2 3])  
false

source  
isempty(condition)

Returntrueif no tasks are waiting on the condition,falseotherwise.  
source

```
Base.empty!– Function.

```

empty!(collection)-> collection

Remove all elements from acollection.  
Examples

julia> A = Dict ("a" => 1, "b" => 2)  
Dict{String, Int64} with 2 entries:  
"b" => 2  
"a" => 1

julia> empty!(A);

julia> A  
Dict{String, Int64}()

source

```
Base.length– Function.

```

length(collection)-> Integer

Return the number of elements in the collection.  
Uselastindexto get the last valid index of an indexable collection.  
See also:size,ndims,eachindex.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 538

```

julia> length(1:5)  
5

julia> length([1, 2, 3, 4])  
4

julia> length([1 2; 3 4])  
4

source

```
Base.checked_length– Function.

```

Base.checked_length(r)

Calculateslength(r), but may check for overflow errors where applicable when the result doesn't fit into  
Union{Integer(eltype(r)),Int}.  
source

```
Fully implemented by:

- AbstractRange
- UnitRange
- Tuple
- Number
- AbstractArray
- BitSet
- IdDict
- Dict
- WeakKeyDict
- AbstractString
- Set
- NamedTuple

### 42.4 Iterable Collections

Base.in– Function.

```

in (item, collection)-> Bool  
∈(item, collection)-> Bool

Determinewhetheranitemisinthegivencollection,inthesensethatitis==tooneofthevaluesgenerated  
by iterating over the collection. Returns aBoolvalue, except ifitemismissingorcollectioncontains  
missingbut notitem, in which casemissingis returned (three-valued logic, matching the behavior ofany  
and==).

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 539

```

Some collections follow a slightly different definition. For example,Sets check whether the itemisequal  
to one of the elements.Dicts look forkey=>valuepairs, and the key is compared usingisequal. To test  
for the presence of a key in a dictionary, usehaskeyork in keys(dict). For these collections, the result  
is always aBooland nevermissing.  
To determine whether an item is not in a given collection, see:∉. You may also negate theinby doing  
!(a in b)which is logically similar to"not in ".  
When broadcasting within.(items, collection)oritems .∈ collection, bothitemandcollection  
are broadcasted over, which is often not what is intended. For example, if both arguments are vectors  
(and the dimensions match), the result is a vector indicating whether each value in collectionitemsisin  
the value at the corresponding position incollection. To get a vector indicating whether each value in  
itemsis incollection, wrapcollectionin a tuple or aReflike this:in.(items, Ref(collection))or  
items .∈ Ref(collection).  
Examples

julia> a = 1:3:20  
1:3:19

julia> 4 in a  
true

julia> 5 in a  
false

julia> missing in [1, 2]  
missing

julia> 1 in [2, missing]  
missing

julia> 1 in [1, missing]  
true

julia> missing in Set ([1, 2])  
false

julia> !(21 in a)  
true

julia> !(19 in a)  
false

julia> [1, 2] .∈ [2, 3]  
2-element BitVector:  
0  
0

julia> [1, 2] .∈ ([2, 3],)  
2-element BitVector:  
0  
1

See also:insorted,contains,occursin,issubset.  
source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 540

Base.:∉– Function.

```

∉(item, collection)-> Bool  
∌(collection, item)-> Bool

Negation of∈and∋, i.e. checks thatitemis not incollection.  
When broadcasting withitems .∉ collection, bothitemandcollectionare broadcasted over, which  
is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the  
result is a vector indicating whether each value in collectionitemsis not in the value at the corresponding  
position incollection. To get a vector indicating whether each value initemsis not incollection, wrap  
collectionin a tuple or aReflike this:items .∉ Ref(collection).  
Examples

julia> 1 ∉ 2:4  
true

julia> 1 ∉ 1:3  
false

julia> [1, 2] .∉ [2, 3]  
2-element BitVector:  
1  
1

julia> [1, 2] .∉ ([2, 3],)  
2-element BitVector:  
1  
0

source

```
Base.eltype– Function.

```

eltype( type )

Determine the type of the elements generated by iterating a collection of the giventype. For dictionary  
types,thiswillbeaPair{KeyType,ValType}. Thedefinitioneltype(x) = eltype(typeof(x))isprovided  
for convenience so that instances can be passed instead of types. However the form that accepts a type  
argument should be defined for new types.  
See also:keytype,typeof.  
Examples

julia> eltype(fill(1f0, ( 2,2)))  
Float32

julia> eltype(fill(0x1, ( 2,2)))  
UInt8

source

```
Base.indexin– Function.

```

indexin(a, b)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 541

```

Return an array containing the first index inbfor each value inathat is a member ofb. The output array  
containsnothingwhereverais not a member ofb.  
See also:sortperm,findfirst.  
Examples

julia> a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia> b = ['a', 'b', 'c'];

julia> indexin(a, b)  
6-element Vector{Union{Nothing, Int64}}:  
1  
2  
3  
2  
nothing  
1

julia> indexin(b, a)  
3-element Vector{Union{Nothing, Int64}}:  
1  
2  
3

source

```
Base.unique– Function.

```

unique(itr)

Return an array containing only the unique elements of collectionitr, as determined byisequal, in the  
order that the first of each set of equivalent elements originally appears. The element type of the input is  
preserved.  
See also:unique!,allunique.  
Examples

julia> unique([1, 2, 6, 2])  
3-element Vector{Int64}:  
1  
2  
6

julia> unique( Real [1, 1.0, 2])  
2-element Vector{Real}:  
1  
2

source  
unique(f, itr)

Returns an array containing one value fromitrfor each unique value produced byfapplied to elements  
ofitr.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 542

```

julia> unique(x-> x^2, [ 1, -1, 3, -3, 4])  
3-element Vector{Int64}:  
1  
3  
4

source  
unique(A::AbstractArray; dims::Int)

Return unique regions ofAalong dimensiondims.  
Examples

julia> A = map(isodd, reshape( Vector (1:8), ( 2,2,2)))  
2×2×2 Array{Bool, 3}:  
[:, :, 1] =  
1 1  
0 0

[:, :, 2] =  
1 1  
0 0

julia> unique(A)  
2-element Vector{Bool}:  
1  
0

julia> unique(A, dims=2)  
2×1×2 Array{Bool, 3}:  
[:, :, 1] =  
1  
0

[:, :, 2] =  
1  
0

julia> unique(A, dims=3)  
2×2×1 Array{Bool, 3}:  
[:, :, 1] =  
1 1  
0 0

source

```
Base.unique!– Function.

```

unique!(f, A:: AbstractVector )

Selects one value fromAfor each unique value produced byfapplied to elements ofA, then return the  
modified A.

Julia 1.1  
This method is available as of Julia 1.1.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 543

```

Examples

julia> unique!(x-> x^2, [ 1, -1, 3, -3, 4])  
3-element Vector{Int64}:  
1  
3  
4

julia> unique!(n-> n%3, [ 5, 1, 8, 9, 3, 4, 10, 7, 2, 6])  
3-element Vector{Int64}:  
5  
1  
9

julia> unique!(iseven, [2, 3, 5, 7, 9])  
2-element Vector{Int64}:  
2  
3

source  
unique!(A::AbstractVector)

Remove duplicate items as determined byisequal, then return the modifiedA.unique!will return the  
elements ofAin the order that they occur. If you do not care about the order of the returned data, then  
calling(sort!(A); unique!(A))will be much more efficient as long as the elements ofAcan be sorted.  
Examples

julia> unique!([1, 1, 1])  
1-element Vector{Int64}:  
1

julia> A = [7, 3, 2, 3, 7, 5];

julia> unique!(A)  
4-element Vector{Int64}:  
7  
3  
2  
5

julia> B = [7, 6, 42, 6, 7, 42];

julia> sort!(B); # unique! is able to process sorted data much more efficiently.

julia> unique!(B)  
3-element Vector{Int64}:  
6  
7  
42

source

```
Base.allunique– Function.

```

allunique(itr)-> Bool

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 544

```

Returntrueif all values fromitrare distinct when compared withisequal.  
See also:unique,issorted.  
Examples

julia> a = [1; 2; 3]  
3-element Vector{Int64}:  
1  
2  
3

julia> allunique(a)  
true

julia> allunique([a, a])  
false

source

```
Base.reduce– Method.

```

reduce(op, itr; [init])

Reduce the given collectionitrwith the given binary operatorop. If provided, the initial valueinitmust  
be a neutral element foropthat will be returned for empty collections. It is unspecified whetherinitis  
used for non-empty collections.  
For empty collections, providinginitwill be necessary, except for some special cases (e.g. whenopis  
one of+,*,max,min,&,|) when Julia can determine the neutral element ofop.  
Reductions for certain commonly-used operators may have special implementations, and should be used  
instead:maximum(itr),minimum(itr),sum(itr),prod(itr),any(itr),all(itr).  
The associativity of the reduction is implementation dependent. This means that you can't use non-  
associative operations like-because it is undefined whetherreduce(-,[1,2,3])should be evaluated  
as(1-2)-3or1-(2-3). Usefoldlorfoldrinstead for guaranteed left or right associativity.  
Some operations accumulate error. Parallelism will be easier if the reduction can be executed in groups.  
Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use  
an ordered collection.  
Examples

julia> reduce(*, [ 2; 3; 4])  
24

julia> reduce(*, [ 2; 3; 4]; init=-1)  
-24

source

```
Base.foldl– Method.

```

foldl(op, itr; [init])

Likereduce, but with guaranteed left associativity. If provided, the keyword argumentinitwill be used  
exactly once. In general, it will be necessary to provideinitto work with empty collections.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 545

```

julia> foldl(=>, 1:4)  
((1 => 2) => 3) => 4

julia> foldl(=>, 1:4; init=0)  
(((0 => 1) => 2) => 3) => 4

source

```
Base.foldr– Method.

```

foldr(op, itr; [init])

Likereduce, but with guaranteed right associativity. If provided, the keyword argumentinitwill be used  
exactly once. In general, it will be necessary to provideinitto work with empty collections.  
Examples

julia> foldr(=>, 1:4)  
1 => (2 => (3 => 4))

julia> foldr(=>, 1:4; init=0)  
1 => (2 => (3 => (4 => 0)))

source

```
Base.maximum– Function.

```

maximum(f, itr; [init])

Returns the largest result of calling functionfon each element ofitr.  
The value returned for emptyitrcan be specified byinit. It must be a neutral element formax(i.e.  
which is less than or equal to any other element) as it is unspecified whetherinitis used for non-empty  
collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

julia> maximum(length, ["Julion", "Julia", "Jule"])  
6

julia> maximum(length, []; init=-1)  
-1

julia> maximum(sin, Real []; init=-1.0) # good, since output of sin is >= -1  
-1.0

source  
maximum(itr; [init])

Returns the largest element in a collection.  
The value returned for emptyitrcan be specified byinit. It must be a neutral element formax(i.e.  
which is less than or equal to any other element) as it is unspecified whetherinitis used for non-empty  
collections.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 546

```

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

julia> maximum(-20.5:10)  
9.5

julia> maximum([1,2,3])  
3

julia> maximum(())  
ERROR: ArgumentError: reducing over an empty collection is not allowed  
Stacktrace:  
[...]

julia> maximum((); init=-Inf)  
-Inf

source  
maximum(A::AbstractArray; dims)

Compute the maximum value of an array over the given dimensions. See also themax(a,b)function to  
take the maximum of two or more arguments, which can be applied elementwise to arrays viamax.(a,b).  
See also:maximum!,extrema,findmax,argmax.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> maximum(A, dims=1)  
1×2 Matrix{Int64}:  
3 4

julia> maximum(A, dims=2)  
2×1 Matrix{Int64}:  
2  
4

source  
maximum(f, A::AbstractArray; dims)

Compute the maximum value by calling the functionfon each element of an array over the given dimen-  
sions.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 547

```

julia> maximum(abs2, A, dims=1)  
1×2 Matrix{Int64}:  
9 16

julia> maximum(abs2, A, dims=2)  
2×1 Matrix{Int64}:  
4  
16

source

```
Base.maximum!– Function.

```

maximum!(r, A)

Compute the maximum value ofAover the singleton dimensions ofr, and write results tor.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> maximum!([1; 1], A)  
2-element Vector{Int64}:  
2  
4

julia> maximum!([1 1], A)  
1×2 Matrix{Int64}:  
3 4

source

```
Base.minimum– Function.

```

minimum(f, itr; [init])

Returns the smallest result of calling functionfon each element ofitr.  
The value returned for emptyitrcan be specified byinit. It must be a neutral element formin(i.e.  
which is greater than or equal to any other element) as it is unspecified whetherinitis used for non-  
empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

julia> minimum(length, ["Julion", "Julia", "Jule"])  
4

julia> minimum(length, []; init=typemax( Int64 ))  
9223372036854775807

julia> minimum(sin, Real []; init=1.0) # good, since output of sin is <= 1  
1.0

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 548

```

source  
minimum(itr; [init])

Returns the smallest element in a collection.  
The value returned for emptyitrcan be specified byinit. It must be a neutral element formin(i.e.  
which is greater than or equal to any other element) as it is unspecified whetherinitis used for non-  
empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

julia> minimum(-20.5:10)  
-20.5

julia> minimum([1,2,3])  
1

julia> minimum([])  
ERROR: ArgumentError: reducing over an empty collection is not allowed  
Stacktrace:  
[...]

julia> minimum([]; init=Inf)  
Inf

source  
minimum(A::AbstractArray; dims)

Compute the minimum value of an array over the given dimensions. See also themin(a,b)function to  
take the minimum of two or more arguments, which can be applied elementwise to arrays viamin.(a,b).  
See also:minimum!,extrema,findmin,argmin.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> minimum(A, dims=1)  
1×2 Matrix{Int64}:  
1 2

julia> minimum(A, dims=2)  
2×1 Matrix{Int64}:  
1  
3

source  
minimum(f, A::AbstractArray; dims)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 549

```

Compute the minimum value by calling the functionfon each element of an array over the given dimen-  
sions.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> minimum(abs2, A, dims=1)  
1×2 Matrix{Int64}:  
1 4

julia> minimum(abs2, A, dims=2)  
2×1 Matrix{Int64}:  
1  
9

source

```
Base.minimum!– Function.

```

minimum!(r, A)

Compute the minimum value ofAover the singleton dimensions ofr, and write results tor.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> minimum!([1; 1], A)  
2-element Vector{Int64}:  
1  
3

julia> minimum!([1 1], A)  
1×2 Matrix{Int64}:  
1 2

source

```
Base.extrema– Function.

```

extrema(itr)-> Tuple

Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.  
Examples

julia> extrema(2:10)  
(2, 10)

julia> extrema([9,pi,4.5])  
(3.141592653589793, 9.0)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 550

```

source  
extrema(f, itr) -> Tuple

Compute both the minimum and maximum offapplied to each element initrand return them as a  
2-tuple. Only one pass is made overitr.

Julia 1.2  
This method requires Julia 1.2 or later.

Examples

julia> extrema(sin,0:π)  
(0.0, 0.9092974268256817)

source  
extrema(A::AbstractArray; dims) -> Array{Tuple}

Compute the minimum and maximum elements of an array over the given dimensions.  
Examples

julia> A = reshape( Vector (1:2:16), ( 2,2,2))  
2×2×2 Array{Int64, 3}:  
[:, :, 1] =  
1 5  
3 7

[:, :, 2] =  
9 13  
11 15

julia> extrema(A, dims= (1,2))  
1×1×2 Array{Tuple{Int64, Int64}, 3}:  
[:, :, 1] =  
(1, 7)

[:, :, 2] =  
(9, 15)

source  
extrema(f, A::AbstractArray; dims) -> Array{Tuple}

Compute the minimum and maximum offapplied to each element in the given dimensions ofA.

Julia 1.2  
This method requires Julia 1.2 or later.

source

```
Base.argmax– Function.

```

argmax(r::AbstractRange)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 551

```

Ranges can have multiple maximal elements. In that caseargmaxwill return a maximal index, but not  
necessarily the first one.  
source  
argmax(f, domain)

Return a valuexin the domain offfor whichf(x)is maximised. If there are multiple maximal values for  
f(x)then the first one will be found.  
domainmust be a non-empty iterable.  
Values are compared withisless.

Julia 1.7  
This method requires Julia 1.7 or later.

Examples

julia> argmax(abs,-10:5)  
-10

julia> argmax(cos,0:π/2:2π)  
0.0

source  
argmax(itr)

Return the index or key of the maximal element in a collection. If there are multiple maximal elements,  
then the first one will be returned.  
The collection must not be empty.  
Values are compared withisless.  
See also:argmin,findmax.  
Examples

julia> argmax([8, 0.1, -9, pi])  
1

julia> argmax([1, 7, 7, 6])  
2

julia> argmax([1, 7, 7, NaN])  
4

source  
argmax(A; dims) -> indices

For an array input, return the indices of the maximum elements over the given dimensions.NaNis treated  
as greater than all other values exceptmissing.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 552

```

julia> A = [1.0 2; 3 4]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> argmax(A, dims=1)  
1×2 Matrix{CartesianIndex{2}}:  
CartesianIndex(2, 1) CartesianIndex(2, 2)

julia> argmax(A, dims=2)  
2×1 Matrix{CartesianIndex{2}}:  
CartesianIndex(1, 2)  
CartesianIndex(2, 2)

source

```
Base.argmin– Function.

```

argmin(r::AbstractRange)

Ranges can have multiple minimal elements. In that caseargminwill return a minimal index, but not  
necessarily the first one.  
source  
argmin(f, domain)

Return a valuexin the domain offfor whichf(x)is minimised. If there are multiple minimal values for  
f(x)then the first one will be found.  
domainmust be a non-empty iterable.  
NaNis treated as less than all other values exceptmissing.

Julia 1.7  
This method requires Julia 1.7 or later.

Examples

julia> argmin(sign,-10:5)  
-10

julia> argmin(x-> -x^3 + x^2 - 10, -5:5)  
5

julia> argmin(acos,0:0.1:1)  
1.0

source  
argmin(itr)

Return the index or key of the minimal element in a collection. If there are multiple minimal elements,  
then the first one will be returned.  
The collection must not be empty.  
NaNis treated as less than all other values exceptmissing.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 553

```

See also:argmax,findmin.  
Examples

julia> argmin([8, 0.1, -9, pi])  
3

julia> argmin([7, 1, 1, 6])  
2

julia> argmin([7, 1, 1, NaN])  
4

source  
argmin(A; dims) -> indices

For an array input, return the indices of the minimum elements over the given dimensions.NaNis treated  
as less than all other values exceptmissing.  
Examples

julia> A = [1.0 2; 3 4]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> argmin(A, dims=1)  
1×2 Matrix{CartesianIndex{2}}:  
CartesianIndex(1, 1) CartesianIndex(1, 2)

julia> argmin(A, dims=2)  
2×1 Matrix{CartesianIndex{2}}:  
CartesianIndex(1, 1)  
CartesianIndex(2, 1)

source

```
Base.findmax– Function.

```

findmax(f, domain)-> (f(x), index)

Returns a pair of a value in the codomain (outputs off) and the index of the corresponding value in the  
domain(inputs tof) such thatf(x)is maximised. If there are multiple maximal points, then the first one  
will be returned.  
domainmust be a non-empty iterable.  
Values are compared withisless.

Julia 1.7  
This method requires Julia 1.7 or later.

Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 554

```

julia> findmax(identity,5:9)  
(9, 5)

julia> findmax(-, 1:10)  
(-1, 1)

julia> findmax(first, [(1, :a), (3, :b), (3, :c)])  
(3, 2)

julia> findmax(cos,0:π/2:2π)  
(1.0, 1)

source  
findmax(itr) -> (x, index)

Return the maximal element of the collectionitrand its index or key. If there are multiple maximal  
elements, then the first one will be returned. Values are compared withisless.  
See also:findmin,argmax,maximum.  
Examples

julia> findmax([8, 0.1, -9, pi])  
(8.0, 1)

julia> findmax([1, 7, 7, 6])  
(7, 2)

julia> findmax([1, 7, 7, NaN])  
(NaN, 4)

source  
findmax(A; dims) -> (maxval, index)

For an array input, returns the value and index of the maximum over the given dimensions.NaNis treated  
as greater than all other values exceptmissing.  
Examples

julia> A = [1.0 2; 3 4]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> findmax(A, dims=1)  
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia> findmax(A, dims=2)  
([2.0; 4.0;;], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2);;])

source

```
Base.findmin– Function.

```

findmin(f, domain)-> (f(x), index)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 555

```

Returns a pair of a value in the codomain (outputs off) and the index of the corresponding value in the  
domain(inputs tof) such thatf(x)is minimised. If there are multiple minimal points, then the first one  
will be returned.  
domainmust be a non-empty iterable.  
NaNis treated as less than all other values exceptmissing.

Julia 1.7  
This method requires Julia 1.7 or later.

Examples

julia> findmin(identity,5:9)  
(5, 1)

julia> findmin(-, 1:10)  
(-10, 10)

julia> findmin(first, [(2, :a), (2, :b), (3, :c)])  
(2, 1)

julia> findmin(cos,0:π/2:2π)  
(-1.0, 3)

source  
findmin(itr) -> (x, index)

Return the minimal element of the collectionitrand its index or key. If there are multiple minimal ele-  
ments, then the first one will be returned.NaNis treated as less than all other values exceptmissing.  
See also:findmax,argmin,minimum.  
Examples

julia> findmin([8, 0.1, -9, pi])  
(-9.0, 3)

julia> findmin([1, 7, 7, 6])  
(1, 1)

julia> findmin([1, 7, 7, NaN])  
(NaN, 4)

source  
findmin(A; dims) -> (minval, index)

For an array input, returns the value and index of the minimum over the given dimensions.NaNis treated  
as less than all other values exceptmissing.  
Examples

julia> A = [1.0 2; 3 4]  
2×2 Matrix{Float64}:  
1.0 2.0

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 556

```

3.0 4.0

julia> findmin(A, dims=1)  
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia> findmin(A, dims=2)  
([1.0; 3.0;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1);;])

source

```
Base.findmax!– Function.

```

findmax!(rval, rind, A)-> (maxval, index)

Find the maximum ofAand the corresponding linear index along singleton dimensions ofrvalandrind,  
and store the results inrvalandrind.NaNis treated as greater than all other values exceptmissing.  
source

```
Base.findmin!– Function.

```

findmin!(rval, rind, A)-> (minval, index)

Find the minimum ofAand the corresponding linear index along singleton dimensions ofrvalandrind,  
and store the results inrvalandrind.NaNis treated as less than all other values exceptmissing.  
source

```
Base.sum– Function.

```

sum(f, itr; [init])

Sum the results of calling functionfon each element ofitr.  
The return type isIntfor signed integers of less than system word size, andUIntfor unsigned integers of  
less than system word size. For all other arguments, a common return type is found to which all arguments  
are promoted.  
The value returned for emptyitrcan be specified byinit. It must be the additive identity (i.e. zero) as  
it is unspecified whetherinitis used for non-empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

julia> sum(abs2, [2; 3; 4])  
29

Note the important difference betweensum(A)andreduce(+, A)for arrays with small integer eltype:

julia> sum( Int8 [100, 28])  
128

julia> reduce(+, Int8 [100, 28])  
-128

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 557

```

In the former case, the integers are widened to system word size and therefore the result is 128. In the  
latter case, no such widening happens and integer overflow results in -128.  
source  
sum(itr; [init])

Returns the sum of all elements in a collection.  
The return type isIntfor signed integers of less than system word size, andUIntfor unsigned integers of  
less than system word size. For all other arguments, a common return type is found to which all arguments  
are promoted.  
The value returned for emptyitrcan be specified byinit. It must be the additive identity (i.e. zero) as  
it is unspecified whetherinitis used for non-empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

See also:reduce,mapreduce,count,union.  
Examples

julia> sum(1:20)  
210

julia> sum(1:20; init= 0.0)  
210.0

source  
sum(A::AbstractArray; dims)

Sum elements of an array over the given dimensions.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> sum(A, dims=1)  
1×2 Matrix{Int64}:  
4 6

julia> sum(A, dims=2)  
2×1 Matrix{Int64}:  
3  
7

source  
sum(f, A::AbstractArray; dims)

Sum the results of calling functionfon each element of an array over the given dimensions.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 558

```

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> sum(abs2, A, dims=1)  
1×2 Matrix{Int64}:  
10 20

julia> sum(abs2, A, dims=2)  
2×1 Matrix{Int64}:  
5  
25

source

```
Base.sum!– Function.

```

sum!(r, A)

Sum elements ofAover the singleton dimensions ofr, and write results tor.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> sum!([1; 1], A)  
2-element Vector{Int64}:  
3  
7

julia> sum!([1 1], A)  
1×2 Matrix{Int64}:  
4 6

source

```
Base.prod– Function.

```

prod(f, itr; [init])

Returns the product offapplied to each element ofitr.  
The return type isIntfor signed integers of less than system word size, andUIntfor unsigned integers of  
less than system word size. For all other arguments, a common return type is found to which all arguments  
are promoted.  
The value returned for emptyitrcan be specified byinit. It must be the multiplicative identity (i.e. one)  
as it is unspecified whetherinitis used for non-empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 559

```

julia> prod(abs2, [2; 3; 4])  
576

source  
prod(itr; [init])

Returns the product of all elements of a collection.  
The return type isIntfor signed integers of less than system word size, andUIntfor unsigned integers of  
less than system word size. For all other arguments, a common return type is found to which all arguments  
are promoted.  
The value returned for emptyitrcan be specified byinit. It must be the multiplicative identity (i.e. one)  
as it is unspecified whetherinitis used for non-empty collections.

Julia 1.6  
Keyword argumentinitrequires Julia 1.6 or later.

See also:reduce,cumprod,any.  
Examples

julia> prod(1:5)  
120

julia> prod(1:5; init= 1.0)  
120.0

source  
prod(A::AbstractArray; dims)

Multiply elements of an array over the given dimensions.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> prod(A, dims=1)  
1×2 Matrix{Int64}:  
3 8

julia> prod(A, dims=2)  
2×1 Matrix{Int64}:  
2  
12

source  
prod(f, A::AbstractArray; dims)

Multiply the results of calling the functionfon each element of an array over the given dimensions.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 560

```

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> prod(abs2, A, dims=1)  
1×2 Matrix{Int64}:  
9 64

julia> prod(abs2, A, dims=2)  
2×1 Matrix{Int64}:  
4  
144

source

```
Base.prod!– Function.

```

prod!(r, A)

Multiply elements ofAover the singleton dimensions ofr, and write results tor.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> prod!([1; 1], A)  
2-element Vector{Int64}:  
2  
12

julia> prod!([1 1], A)  
1×2 Matrix{Int64}:  
3 8

source

```
Base.any– Method.

```

any(itr)-> Bool

Test whether any elements of a boolean collection aretrue, returningtrueas soon as the firsttruevalue  
initris encountered (short-circuiting). To short-circuit onfalse, useall.  
If the input containsmissingvalues, returnmissingif all non-missing values arefalse(or equivalently,  
if the input contains notruevalue), followingthree-valued logic.  
See also:all,count,sum,|, ,||.  
Examples

julia> a = [ true , false , false , true ]  
4-element Vector{Bool}:  
1  
0

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 561

```

0  
1

julia> any(a)  
true

julia> any((println(i); v) for (i, v) in enumerate(a))  
1  
true

julia> any([missing, true ])  
true

julia> any([ false , missing])  
missing

source

```
Base.any– Method.

```

any(p, itr)-> Bool

Determine whether predicatepreturnstruefor any elements ofitr, returningtrueas soon as the first  
item initrfor whichpreturnstrueis encountered (short-circuiting). To short-circuit onfalse, useall.  
If the input containsmissingvalues, returnmissingif all non-missing values arefalse(or equivalently,  
if the input contains notruevalue), followingthree-valued logic.  
Examples

julia> any(i->(4<=i<=6), [ 3,5,7])  
true

julia> any(i-> (println(i); i> 3), 1:10)  
1  
2  
3  
4  
true

julia> any(i-> i > 0, [ 1, missing])  
true

julia> any(i-> i > 0, [ -1, missing])  
missing

julia> any(i-> i > 0, [ -1, 0])  
false

source

```
Base.any!– Function.

```

any!(r, A)

Test whether any values inAalong the singleton dimensions ofraretrue, and write results tor.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 562

```

julia> A = [ truefalse ; truefalse ]  
2×2 Matrix{Bool}:  
1 0  
1 0

julia> any!([1; 1], A)  
2-element Vector{Int64}:  
1  
1

julia> any!([1 1], A)  
1×2 Matrix{Int64}:  
1 0

source

```
Base.all– Method.

```

all(itr)-> Bool

Test whether all elements of a boolean collection aretrue, returningfalseas soon as the firstfalsevalue  
initris encountered (short-circuiting). To short-circuit ontrue, useany.  
If the input containsmissingvalues, returnmissingif all non-missing values aretrue(or equivalently, if  
the input contains nofalsevalue), followingthree-valued logic.  
See also:all!,any,count,&, ,&&,allunique.  
Examples

julia> a = [ true , false , false , true ]  
4-element Vector{Bool}:  
1  
0  
0  
1

julia> all(a)  
false

julia> all((println(i); v) for (i, v) in enumerate(a))  
1  
2  
false

julia> all([missing, false ])  
false

julia> all([ true , missing])  
missing

source

```
Base.all– Method.

```

all(p, itr)-> Bool

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 563

```

Determine whether predicatepreturnstruefor all elements ofitr, returningfalseas soon as the first  
item initrfor whichpreturnsfalseis encountered (short-circuiting). To short-circuit ontrue, useany.  
If the input containsmissingvalues, returnmissingif all non-missing values aretrue(or equivalently, if  
the input contains nofalsevalue), followingthree-valued logic.  
Examples

julia> all(i->(4<=i<=6), [ 4,5,6])  
true

julia> all(i-> (println(i); i< 3), 1:10)  
1  
2  
3  
false

julia> all(i-> i > 0, [ 1, missing])  
missing

julia> all(i-> i > 0, [ -1, missing])  
false

julia> all(i-> i > 0, [ 1, 2])  
true

source

```
Base.all!– Function.

```

all!(r, A)

Test whether all values inAalong the singleton dimensions ofraretrue, and write results tor.  
Examples

julia> A = [ truefalse ; truefalse ]  
2×2 Matrix{Bool}:  
1 0  
1 0

julia> all!([1; 1], A)  
2-element Vector{Int64}:  
0  
0

julia> all!([1 1], A)  
1×2 Matrix{Int64}:  
1 0

source

```
Base.count– Function.

```

count([f=identity,] itr; init=0) -> Integer

Count the number of elements initrfor which the functionfreturnstrue. Iffis omitted, count the  
number oftrueelements initr(which should be a collection of boolean values).initoptionally specifies  
the value to start counting from and therefore also determines the output type.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 564

```

Julia 1.6  
initkeyword was added in Julia 1.6.

See also:any,sum.  
Examples

julia> count(i->(4<=i<=6), [ 2,3,4,5,6])  
3

julia> count([ true , false , true , true ])  
3

julia> count(>(3), 1:7, init=0x03)  
0x07

source  
count(  
pattern::Union{AbstractChar,AbstractString,AbstractPattern},  
string::AbstractString;  
overlap::Bool = false,  
)

Returnthenumberofmatchesforpatterninstring. Thisisequivalenttocallinglength(findall(pattern,  
string))but more efficient.  
Ifoverlap=true, the matching sequences are allowed to overlap indices in the original string, otherwise  
they must be from disjoint character ranges.

Julia 1.3  
This method requires at least Julia 1.3.

Julia 1.7  
Using a character as the pattern requires at least Julia 1.7.

source  
count([f=identity,] A::AbstractArray; dims=:)

Count the number of elements inAfor whichfreturnstrueover the given dimensions.

Julia 1.5  
dimskeyword was added in Julia 1.5.

Julia 1.6  
initkeyword was added in Julia 1.6.

Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 565

```

julia> count(<=(2), A, dims=1)  
1×2 Matrix{Int64}:  
1 1

julia> count(<=(2), A, dims=2)  
2×1 Matrix{Int64}:  
2  
0

source

```
Base.foreach– Function.

```

foreach(f, c...) -> Nothing

Call functionfon each element of iterablec. For multiple iterable arguments,fis called elementwise, and  
iteration stops when any iterator is finished.  
foreachshouldbeusedinsteadofmapwhentheresultsoffarenotneeded,forexampleinforeach(println,  
array).  
Examples

julia> tri = 1:3:7; res= Int [];

julia> foreach(x-> push!(res, x^2), tri)

julia> res  
3-element Vector{Int64}:  
1  
16  
49

julia> foreach((x, y)-> println(x," with ", y), tri,'a':'z')  
1 with a  
4 with b  
7 with c

source

```
Base.map– Function.

```

map(f, c...) -> collection

Transform collectioncby applyingfto each element. For multiple collection arguments, applyfelemen-  
twise, and stop when when any of them is exhausted.  
See alsomap!,foreach,mapreduce,mapslices,zip,Iterators.map.  
Examples

julia> map(x-> x * 2, [ 1, 2, 3])  
3-element Vector{Int64}:  
2  
4  
6

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 566

```

julia> map(+, [ 1, 2, 3], [ 10, 20, 30, 400, 5000])  
3-element Vector{Int64}:  
11  
22  
33

source

```
Base.map!– Function.

```

map!( function , destination, collection...)

Likemap, but stores the result indestinationrather than a new collection.destinationmust be at least  
as large as the smallest collection.  
See also:map,foreach,zip,copyto!.  
Examples

julia> a = zeros(3);

julia> map!(x-> x * 2, a, [1, 2, 3]);

julia> a  
3-element Vector{Float64}:  
2.0  
4.0  
6.0

julia> map!(+, zeros( Int , 5), 100:999, 1:3)  
5-element Vector{Int64}:  
101  
103  
105  
0  
0

source  
map!(f, values(dict::AbstractDict))

Modifiesdictby transforming each value fromvaltof(val). Note that the type ofdictcannot be  
changed: iff(val)is not an instance of the value type ofdictthen it will be converted to the value type  
if possible and otherwise raise an error.

Julia 1.2  
map!(f, values(dict::AbstractDict))requires Julia 1.2 or later.

Examples

julia> d = Dict (:a => 1, :b => 2)  
Dict{Symbol, Int64} with 2 entries:  
:a => 1  
:b => 2

julia> map!(v-> v-1, values(d))

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 567

```

ValueIterator for a Dict{Symbol, Int64} with 2 entries. Values:  
0  
1

source

```
Base.mapreduce– Method.

```

mapreduce(f, op, itrs...; [init])

Apply functionfto each element(s) initrs, and then reduce the result using the binary functionop. If  
provided,initmustbeaneutralelementforopthatwillbereturnedforemptycollections. Itisunspecified  
whetherinitis used for non-empty collections. In general, it will be necessary to provideinitto work  
with empty collections.  
mapreduceisfunctionallyequivalenttocallingreduce(op, map(f, itr); init=init), butwillingeneral  
execute faster since no intermediate collection needs to be created. See documentation forreduceand  
map.

Julia 1.2  
mapreducewith multiple iterators requires Julia 1.2 or later.

Examples

julia> mapreduce(x->x^2, +, [ 1:3;]) # == 1 + 4 + 9  
14

The associativity of the reduction is implementation-dependent. Additionally, some implementations may  
reuse the return value offfor elements that appear multiple times initr. Usemapfoldlormapfoldr  
instead for guaranteed left or right associativity and invocation offfor every value.  
source

```
Base.mapfoldl– Method.

```

mapfoldl(f, op, itr; [init])

Likemapreduce,butwithguaranteedleftassociativity,asinfoldl. Ifprovided,thekeywordargumentinit  
will be used exactly once. In general, it will be necessary to provideinitto work with empty collections.  
source

```
Base.mapfoldr– Method.

```

mapfoldr(f, op, itr; [init])

Likemapreduce, but with guaranteed right associativity, as infoldr. If provided, the keyword argument  
initwill be used exactly once. In general, it will be necessary to provideinitto work with empty collec-  
tions.  
source

```
Base.first– Function.

```

first(coll)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 568

```

Get the first element of an iterable collection. Return the start point of anAbstractRangeeven if it is  
empty.  
See also:only,firstindex,last.  
Examples

julia> first(2:2:10)  
2

julia> first([1; 2; 3; 4])  
1

source  
first(itr, n::Integer)

Get the firstnelements of the iterable collectionitr, or fewer elements ifitris not long enough.  
See also:startswith,Iterators.take.

Julia 1.6  
This method requires at least Julia 1.6.

Examples

julia> first(["foo", "bar", "qux"], 2)  
2-element Vector{String}:  
"foo"  
"bar"

julia> first(1:6, 10)  
1:6

julia> first( Bool [], 1)  
Bool[]

source

first(s:: AbstractString , n :: Integer )

Get a string consisting of the firstncharacters ofs.  
Examples

julia> first("∀ε≠0: ε²>0", 0)  
""

julia> first("∀ε≠0: ε²>0", 1)  
"∀"

julia> first("∀ε≠0: ε²>0", 3)  
"∀ε≠"

source

```
Base.last– Function.


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 569

```

last(coll)

Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by  
callinglastindexto get the last index. Return the end point of anAbstractRangeeven if it is empty.  
See alsofirst,endswith.  
Examples

julia> last(1:2:10)  
9

julia> last([1; 2; 3; 4])  
4

source  
last(itr, n::Integer)

Get the lastnelements of the iterable collectionitr, or fewer elements ifitris not long enough.

Julia 1.6  
This method requires at least Julia 1.6.

Examples

julia> last(["foo", "bar", "qux"], 2)  
2-element Vector{String}:  
"bar"  
"qux"

julia> last(1:6, 10)  
1:6

julia> last( Float64 [], 1)  
Float64[]

source

last(s:: AbstractString , n :: Integer )

Get a string consisting of the lastncharacters ofs.  
Examples

julia> last("∀ε≠0: ε²>0", 0)  
""

julia> last("∀ε≠0: ε²>0", 1)  
"0"

julia> last("∀ε≠0: ε²>0", 3)  
"²>0"

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 570

Base.front– Function.

```

front(x:: Tuple ):: Tuple

Return aTupleconsisting of all but the last component ofx.  
See also:first,tail.  
Examples

julia> Base.front((1,2,3))  
(1, 2)

julia> Base.front(())  
ERROR: ArgumentError: Cannot call front on an empty tuple.

source

```
Base.tail– Function.

```

tail(x:: Tuple ):: Tuple

Return aTupleconsisting of all but the first component ofx.  
See also:front,rest,first,Iterators.peel.  
Examples

julia> Base.tail((1,2,3))  
(2, 3)

julia> Base.tail(())  
ERROR: ArgumentError: Cannot call tail on an empty tuple.

source

```
Base.step– Function.

```

step(r)

Get the step size of anAbstractRangeobject.  
Examples

julia> step(1:10)  
1

julia> step(1:2:10)  
2

julia> step(2.5:0.3:10.9)  
0.3

julia> step(range(2.5, stop=10.9, length=85))  
0.1

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 571

Base.collect– Method.

```

collect(collection)

Return anArrayof all items in a collection or iterator. For dictionaries, returnsPair{KeyType, ValType}.  
If the argument is array-like or is an iterator with theHasShapetrait, the result will have the same shape  
and number of dimensions as the argument.  
Used by comprehensions to turn a generator into anArray.  
Examples

julia> collect(1:2:13)  
7-element Vector{Int64}:  
1  
3  
5  
7  
9  
11  
13

julia> [x^2 for x in 1:8 if isodd(x)]  
4-element Vector{Int64}:  
1  
9  
25  
49

source

```
Base.collect– Method.

```

collect(element_type, collection)

Return anArraywith the given element type of all items in a collection or iterable. The result has the  
same shape and number of dimensions ascollection.  
Examples

julia> collect( Float64 , 1:2:5)  
3-element Vector{Float64}:  
1.0  
3.0  
5.0

source

```
Base.filter– Function.

```

filter(f, a)

Return a copy of collectiona, removing elements for whichfisfalse. The functionfis passed one  
argument.

Julia 1.4  
Support foraas a tuple requires at least Julia 1.4.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 572

```

See also:filter!,Iterators.filter.  
Examples

julia> a = 1:10  
1:10

julia> filter(isodd, a)  
5-element Vector{Int64}:  
1  
3  
5  
7  
9

source  
filter(f, d::AbstractDict)

Return a copy ofd, removing elements for whichfisfalse. The functionfis passedkey=>valuepairs.  
Examples

julia> d = Dict (1=>"a", 2=>"b")  
Dict{Int64, String} with 2 entries:  
2 => "b"  
1 => "a"

julia> filter(p->isodd(p.first), d)  
Dict{Int64, String} with 1 entry:  
1 => "a"

source  
filter(f, itr::SkipMissing{<:AbstractArray})

Return a vector similar to the array wrapped by the givenSkipMissingiterator but with all missing ele-  
ments and those for whichfreturnsfalseremoved.

Julia 1.2  
This method requires Julia 1.2 or later.

Examples

julia> x = [1 2; missing4]  
2×2 Matrix{Union{Missing, Int64}}:  
1 2  
missing 4

julia> filter(isodd, skipmissing(x))  
1-element Vector{Int64}:  
1

source

```
Base.filter!– Function.


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 573

```

filter!(f, a)

Update collectiona, removing elements for whichfisfalse. The functionfis passed one argument.  
Examples

julia> filter!(isodd, Vector (1:10))  
5-element Vector{Int64}:  
1  
3  
5  
7  
9

source  
filter!(f, d::AbstractDict)

Updated, removing elements for whichfisfalse. The functionfis passedkey=>valuepairs.  
Example

julia> d = Dict (1=>"a", 2=>"b", 3=>"c")  
Dict{Int64, String} with 3 entries:  
2 => "b"  
3 => "c"  
1 => "a"

julia> filter!(p->isodd(p.first), d)  
Dict{Int64, String} with 2 entries:  
3 => "c"  
1 => "a"

source

```
Base.replace– Method.

```

replace(A, old_new:: Pair ...; [count:: Integer ])

Return a copy of collectionAwhere, for each pairold=>newinold_new, all occurrences ofoldare replaced  
bynew. Equalityisdeterminedusingisequal. Ifcountisspecified,thenreplaceatmostcountoccurrences  
in total.  
The element type of the result is chosen using promotion (seepromote_type) based on the element type  
ofAand on the types of thenewvalues in pairs. Ifcountis omitted and the element type ofAis aUnion,  
the element type of the result will not include singleton types which are replaced with values of a different  
type: for example,Union{T,Missing}will becomeTifmissingis replaced.  
See alsoreplace!,splice!,delete!,insert!.

Julia 1.7  
Version 1.7 is required to replace elements of aTuple.

Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 574

```

julia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)  
4-element Vector{Int64}:  
0  
4  
1  
3

julia> replace([1, missing], missing=>0)  
2-element Vector{Int64}:  
1  
0

source

```
Base.replace– Method.

```

replace(new:: Function , A; [count:: Integer ])

Return a copy ofAwhere each valuexinAis replaced bynew(x). Ifcountis specified, then replace at  
mostcountvalues in total (replacements being defined asnew(x) !== x).

Julia 1.7  
Version 1.7 is required to replace elements of aTuple.

Examples

julia> replace(x-> isodd(x)? 2x : x, [ 1, 2, 3, 4])  
4-element Vector{Int64}:  
2  
2  
6  
4

julia> replace( Dict (1=>2, 3=>4)) do kv  
first(kv)< 3? first(kv)=>3 : kv  
end  
Dict{Int64, Int64} with 2 entries:  
3 => 4  
1 => 3

source

```
Base.replace!– Function.

```

replace!(A, old_new:: Pair ...; [count:: Integer ])

For each pairold=>newinold_new, replace all occurrences ofoldin collectionAbynew. Equality is  
determined usingisequal. Ifcountis specified, then replace at mostcountoccurrences in total. See also  
replace.  
Examples

julia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)  
4-element Vector{Int64}:  
0  
4

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 575

```

1  
3

julia> replace!( Set ([1, 2, 3]), 1=>0)  
Set{Int64} with 3 elements:  
0  
2  
3

source  
replace!(new::Function, A; [count::Integer])

Replace each elementxin collectionAbynew(x). Ifcountis specified, then replace at mostcountvalues  
in total (replacements being defined asnew(x) !== x).  
Examples

julia> replace!(x-> isodd(x)? 2x : x, [ 1, 2, 3, 4])  
4-element Vector{Int64}:  
2  
2  
6  
4

julia> replace!( Dict (1=>2, 3=>4)) do kv  
first(kv)< 3? first(kv)=>3 : kv  
end  
Dict{Int64, Int64} with 2 entries:  
3 => 4  
1 => 3

julia> replace!(x->2x, Set ([3, 6]))  
Set{Int64} with 2 elements:  
6  
12

source

```
Base.rest– Function.

```

Base.rest(collection[, itr_state])

Genericfunctionfortakingthetailofcollection,startingfromaspecificiterationstateitr_state. Return  
aTuple, ifcollectionitselfisaTuple, asubtypeofAbstractVector, ifcollectionisanAbstractArray,  
a subtype ofAbstractStringifcollectionis anAbstractString, and an arbitrary iterator, falling back  
toIterators.rest(collection[, itr_state]), otherwise.  
Can be overloaded for user-defined collection types to customize the behavior ofslurping in assignments,  
likea, b... = collection.

Julia 1.6  
Base.restrequires at least Julia 1.6.

See also:first,Iterators.rest.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 576

```

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> first, state= iterate(a)  
(1, 2)

julia> first, Base.rest(a, state)  
(1, [3, 2, 4])

source

```
### 42.5 Indexable Collections

Base.getindex– Function.

```

getindex(collection, key...)

Retrieve the value(s) stored at the given key or index within a collection. The syntaxa[i,j,...] is  
converted by the compiler togetindex(a, i, j, ...).  
See alsoget,keys,eachindex.  
Examples

julia> A = Dict ("a" => 1, "b" => 2)  
Dict{String, Int64} with 2 entries:  
"b" => 2  
"a" => 1

julia> getindex(A,"a")  
1

source

```
Base.setindex!– Function.

```

setindex!(collection, value, key...)

Storethegivenvalueatthegivenkeyorindexwithinacollection. Thesyntaxa[i,j,...] = xisconverted  
by the compiler to(setindex!(a, x, i, j, ...); x).  
source

```
Base.firstindex– Function.

```

firstindex(collection)-> Integer  
firstindex(collection, d)-> Integer

Return the first index ofcollection. Ifdis given, return the first index ofcollectionalong dimensiond.  
The syntaxesA[begin]andA[1, begin]lower toA[firstindex(A)]andA[1, firstindex(A, 2)], re-  
spectively.  
See also:first,axes,lastindex,nextind.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 577

```

julia> firstindex([1,2,4])  
1

julia> firstindex(rand(3,4,5), 2)  
1

source

```
Base.lastindex– Function.

```

lastindex(collection)-> Integer  
lastindex(collection, d)-> Integer

Return the last index ofcollection. Ifdis given, return the last index ofcollectionalong dimensiond.  
ThesyntaxesA[end]andA[end, end]lowertoA[lastindex(A)]andA[lastindex(A, 1), lastindex(A,  
2)], respectively.  
See also:axes,firstindex,eachindex,prevind.  
Examples

julia> lastindex([1,2,4])  
3

julia> lastindex(rand(3,4,5), 2)  
4

source

```
Fully implemented by:

- Array
- BitArray
- AbstractArray
- SubArray

Partially implemented by:

- AbstractRange
- UnitRange
- Tuple
- AbstractString
- Dict
- IdDict
- WeakKeyDict
- NamedTuple


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 578

### 42.6 Dictionaries

Dictis the standard dictionary. Its implementation useshashas the hashing function for the key, andisequal
to determine equality. Define these two functions for custom types to override how they are stored in a hash
table.

IdDictis a special hash table where the keys are always object identities.

WeakKeyDictis a hash table implementation where the keys are weak references to objects, and thus may be
garbage collected even when referenced in a hash table. LikeDictit useshashfor hashing andisequalfor
equality, unlikeDictit does not convert keys on insertion.

Dicts can be created by passing pair objects constructed with=>to aDictconstructor: Dict("A"=>1,
"B"=>2). This call will attempt to infer type information from the keys and values (i.e. this example cre-
ates aDict{String, Int64}). To explicitly specify types use the syntaxDict{KeyType,ValueType}(...).
For example,Dict{String,Int32}("A"=>1, "B"=>2).

Dictionaries may also be created with generators. For example,Dict(i => f(i) for i = 1:10).

Given a dictionaryD, the syntaxD[x]returns the value of keyx(if it exists) or throws an error, andD[x] = y
stores the key-value pairx => yinD(replacing any existing value for the keyx). Multiple arguments toD[...]
are converted to tuples; for example, the syntaxD[x,y]is equivalent toD[(x,y)], i.e. it refers to the value
keyed by the tuple(x,y).

Base.AbstractDict– Type.

```

AbstractDict{K, V}

Supertype for dictionary-like types with keys of typeKand values of typeV.Dict,IdDictand other types  
are subtypes of this. AnAbstractDict{K, V}should be an iterator ofPair{K, V}.  
source

```
Base.Dict– Type.

```

Dict ([itr])

Dict{K,V}()constructs a hash table with keys of typeKand values of typeV. Keys are compared with  
isequaland hashed withhash.  
Givenasingleiterableargument,constructsaDictwhosekey-valuepairsaretakenfrom2-tuples(key,value)  
generated by the argument.  
Examples

julia>Dict ([("A", 1), ( "B", 2)])  
Dict{String, Int64} with 2 entries:  
"B" => 2  
"A" => 1

Alternatively, a sequence of pair arguments may be passed.

julia>Dict ("A"=>1, "B"=>2)  
Dict{String, Int64} with 2 entries:  
"B" => 2  
"A" => 1

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 579

Base.IdDict– Type.

```

IdDict([itr])

IdDict{K,V}()constructs a hash table usingobjectidas hash and===as equality with keys of typeK  
and values of typeV.  
SeeDictfor further help. In the example below, TheDictkeys are allisequaland therefore get hashed  
the same, so they get overwritten. TheIdDicthashes by object-id, and thus preserves the 3 different  
keys.  
Examples

julia>Dict ( true => "yes", 1 => "no", 1.0 => "maybe")  
Dict{Real, String} with 1 entry:  
1.0 => "maybe"

julia> IdDict( true => "yes", 1 => "no", 1.0 => "maybe")  
IdDict{Any, String} with 3 entries:  
true => "yes"  
1.0 => "maybe"  
1 => "no"

source

```
Base.WeakKeyDict– Type.

```

WeakKeyDict ([itr])

WeakKeyDict()constructs a hash table where the keys are weak references to objects which may be  
garbage collected even when referenced in a hash table.  
SeeDictforfurtherhelp. Note, unlikeDict,WeakKeyDictdoesnotconvertkeysoninsertion, asthiswould  
imply the key object was unreferenced anywhere before insertion.  
source

```
Base.ImmutableDict– Type.

```

ImmutableDict

ImmutableDictis a dictionary implemented as an immutable linked list, which is optimal for small dictio-  
naries that are constructed over many individual insertions. Note that it is not possible to remove a value,  
although it can be partially overridden and hidden by inserting a new value with the same key.  
ImmutableDict(KV::Pair)

Create a new entry in theImmutableDictfor akey => valuepair

```
- use(key => value) in dictto see if this particular combination is in the properties set
- useget(dict, key, default)to retrieve the most recent value for a particular key

```

source

```
Base.haskey– Function.

```

haskey(collection, key)-> Bool

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 580

```

Determine whether a collection has a mapping for a givenkey.  
Examples

julia> D = Dict ('a'=>2, 'b'=>3)  
Dict{Char, Int64} with 2 entries:  
'a' => 2  
'b' => 3

julia> haskey(D,'a')  
true

julia> haskey(D,'c')  
false

source

```
Base.get– Function.

```

get(collection, key, default)

Return the value stored for the given key, or the given default value if no mapping for the key is present.

Julia 1.7  
For tuples and numbers, this function requires at least Julia 1.7.

Examples

julia> d = Dict ("a"=>1, "b"=>2);

julia> get(d,"a", 3)  
1

julia> get(d,"c", 3)  
3

source  
get(f::Function, collection, key)

Return the value stored for the given key, or if no mapping for the key is present, returnf(). Useget!to  
also store the default value in the dictionary.  
This is intended to be called usingdoblock syntax

get(dict, key) do

# default value calculated here

time()  
end

source

```
Base.get!– Function.

```

get!(collection, key, default)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 581

```

Return the value stored for the given key, or if no mapping for the key is present, storekey => default,  
and returndefault.  
Examples

julia> d = Dict ("a"=>1, "b"=>2, "c"=>3);

julia> get!(d,"a", 5)  
1

julia> get!(d,"d", 4)  
4

julia> d  
Dict{String, Int64} with 4 entries:  
"c" => 3  
"b" => 2  
"a" => 1  
"d" => 4

source  
get!(f::Function, collection, key)

Return the value stored for the given key, or if no mapping for the key is present, storekey => f(), and  
returnf().  
This is intended to be called usingdoblock syntax.  
Examples

julia> squares= Dict { Int , Int }();

julia>function get_square!(d, i)  
get!(d, i) do  
i^2  
end  
end  
get_square! (generic function with 1 method)

julia> get_square!(squares,2)  
4

julia> squares  
Dict{Int64, Int64} with 1 entry:  
2 => 4

source

```
Base.getkey– Function.

```

getkey(collection, key, default)

Return the key matching argumentkeyif one exists incollection, otherwise returndefault.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 582

```

julia> D = Dict ('a'=>2, 'b'=>3)  
Dict{Char, Int64} with 2 entries:  
'a' => 2  
'b' => 3

julia> getkey(D,'a', 1)  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> getkey(D,'d', 'a')  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

source

```
Base.delete!– Function.

```

delete!(collection, key)

Delete the mapping for the given key in a collection, if any, and return the collection.  
Examples

julia> d = Dict ("a"=>1, "b"=>2)  
Dict{String, Int64} with 2 entries:  
"b" => 2  
"a" => 1

julia> delete!(d,"b")  
Dict{String, Int64} with 1 entry:  
"a" => 1

julia> delete!(d,"b") # d is left unchanged  
Dict{String, Int64} with 1 entry:  
"a" => 1

source

```
Base.pop!– Method.

```

pop!(collection, key[, default])

Delete and return the mapping forkeyif it exists incollection, otherwise returndefault, or throw an  
error ifdefaultis not specified.  
Examples

julia> d = Dict ("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d,"a")  
1

julia> pop!(d,"d")  
ERROR: KeyError: key "d" not found  
Stacktrace:  
[...]

julia> pop!(d,"e", 4)  
4

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 583

```

source

```
Base.keys– Function.

```

keys(iterator)

For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over  
the keys.  
source

```
Base.values– Function.

```

values(iterator)

For an iterator or collection that has keys and values, return an iterator over the values. This function  
simply returns its argument by default, since the elements of a general iterator are normally considered  
its "values".  
Examples

julia> d = Dict ("a"=>1, "b"=>2);

julia> values(d)  
ValueIterator for a Dict{String, Int64} with 2 entries. Values:  
2  
1

julia> values([2])  
1-element Vector{Int64}:  
2

source  
values(a::AbstractDict)

Return an iterator over all values in a collection.collect(values(a))returns an array of values. When  
the values are stored internally in a hash table, as is the case forDict, the order in which they are returned  
may vary. Butkeys(a)andvalues(a)both iterateaand return the elements in the same order.  
Examples

julia> D = Dict ('a'=>2, 'b'=>3)  
Dict{Char, Int64} with 2 entries:  
'a' => 2  
'b' => 3

julia> collect(values(D))  
2-element Vector{Int64}:  
2  
3

source

```
Base.pairs– Function.

```

pairs(collection)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 584

```

Return an iterator overkey => valuepairs for any collection that maps a set of keys to a set of values.  
This includes arrays, where the keys are the array indices.  
source  
pairs(IndexLinear(), A)  
pairs(IndexCartesian(), A)  
pairs(IndexStyle(A), A)

An iterator that accesses each element of the arrayA, returningi => x, whereiis the index for the  
element andx = A[i]. Identical topairs(A), except that the style of index can be selected. Also similar  
toenumerate(A), exceptiwill be a valid index forA, whileenumeratealways counts from 1 regardless of  
the indices ofA.  
SpecifyingIndexLinear()ensures thatiwill be an integer; specifyingIndexCartesian()ensures thati  
will be aCartesianIndex; specifyingIndexStyle(A)chooses whichever has been defined as the native  
indexing style for arrayA.  
Mutation of the bounds of the underlying array will invalidate this iterator.  
Examples

julia> A = ["a" "d"; "b" "e"; "c" "f"];

julia>for (index, value) in pairs(IndexStyle(A), A)  
println(" $index$value ")  
end  
1 a  
2 b  
3 c  
4 d  
5 e  
6 f

julia> S = view(A,1:2, :);

julia>for (index, value) in pairs(IndexStyle(S), S)  
println(" $index$value ")  
end  
CartesianIndex(1, 1) a  
CartesianIndex(2, 1) b  
CartesianIndex(1, 2) d  
CartesianIndex(2, 2) e

See alsoIndexStyle,axes.  
source

```
Base.merge– Function.

```

merge(d::AbstractDict, others::AbstractDict...)

Construct a merged collection from the given collections. If necessary, the types of the resulting collection  
willbepromotedtoaccommodatethetypesofthemergedcollections. Ifthesamekeyispresentinanother  
collection, the value for that key will be the value it has in the last collection listed. See alsomergewith  
for custom handling of values with the same key.  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 585

```

julia> a = Dict ("foo"=> 0.0, "bar"=> 42.0)  
Dict{String, Float64} with 2 entries:  
"bar" => 42.0  
"foo" => 0.0

julia> b = Dict ("baz"=> 17, "bar"=> 4711)  
Dict{String, Int64} with 2 entries:  
"bar" => 4711  
"baz" => 17

julia> merge(a, b)  
Dict{String, Float64} with 3 entries:  
"bar" => 4711.0  
"baz" => 17.0  
"foo" => 0.0

julia> merge(b, a)  
Dict{String, Float64} with 3 entries:  
"bar" => 42.0  
"baz" => 17.0  
"foo" => 0.0

source  
merge(a::NamedTuple, bs::NamedTuple...)

Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging  
proceedsleft-to-right,betweenpairsofnamedtuples,andsotheorderoffieldspresentinboththeleftmost  
and rightmost named tuples take the same position as they are found in the leftmost named tuple. How-  
ever, values are taken from matching fields in the rightmost named tuple that contains that field. Fields  
present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented  
for when only a single named tuple is supplied, with signaturemerge(a::NamedTuple).

Julia 1.1  
Merging 3 or moreNamedTuplerequires at least Julia 1.1.

Examples

julia> merge((a=1, b =2, c =3), (b=4, d =5))  
(a = 1, b = 4, c = 3, d = 5)

julia> merge((a=1, b =2), (b=3, c =(d=1,)), (c=(d=2,),))  
(a = 1, b = 3, c = (d = 2,))

source  
merge(a::NamedTuple, iterable)

Interpret an iterable of key-value pairs as a named tuple, and perform a merge.

julia> merge((a=1, b =2, c =3), [ :b=>4, :d=>5])  
(a = 1, b = 4, c = 3, d = 5)

source

```
Base.mergewith– Function.


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 586

```

mergewith(combine, d::AbstractDict, others::AbstractDict...)  
mergewith(combine)  
merge(combine, d::AbstractDict, others::AbstractDict...)

Construct a merged collection from the given collections. If necessary, the types of the resulting collection  
will be promoted to accommodate the types of the merged collections. Values with the same key will  
be combined using the combiner function. The curried formmergewith(combine)returns the function  
(args...) -> mergewith(combine, args...).  
Methodmerge(combine::Union{Function,Type}, args...)asanaliasofmergewith(combine, args...)  
is still available for backward compatibility.

Julia 1.5  
mergewithrequires Julia 1.5 or later.

Examples

julia> a = Dict ("foo"=> 0.0, "bar"=> 42.0)  
Dict{String, Float64} with 2 entries:  
"bar" => 42.0  
"foo" => 0.0

julia> b = Dict ("baz"=> 17, "bar"=> 4711)  
Dict{String, Int64} with 2 entries:  
"bar" => 4711  
"baz" => 17

julia> mergewith(+, a, b)  
Dict{String, Float64} with 3 entries:  
"bar" => 4753.0  
"baz" => 17.0  
"foo" => 0.0

julia> ans == mergewith(+)(a, b)  
true

source

```
Base.merge!– Function.

```

merge!(d::AbstractDict, others::AbstractDict...)

Update collection with pairs from the other collections. See alsomerge.  
Examples

julia> d1 = Dict (1 => 2, 3 => 4);

julia> d2 = Dict (1 => 4, 4 => 5);

julia> merge!(d1, d2);

julia> d1  
Dict{Int64, Int64} with 3 entries:  
4 => 5  
3 => 4  
1 => 4

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 587

```

source

```
Base.mergewith!– Function.

```

mergewith!(combine, d::AbstractDict, others::AbstractDict...) -> d  
mergewith!(combine)  
merge!(combine, d::AbstractDict, others::AbstractDict...) -> d

Update collection with pairs from the other collections. Values with the same key will be combined us-  
ing the combiner function. The curried formmergewith!(combine)returns the function(args...) ->  
mergewith!(combine, args...).  
Methodmerge!(combine::Union{Function,Type}, args...)asanaliasofmergewith!(combine, args...)  
is still available for backward compatibility.

Julia 1.5  
mergewith!requires Julia 1.5 or later.

Examples

julia> d1 = Dict (1 => 2, 3 => 4);

julia> d2 = Dict (1 => 4, 4 => 5);

julia> mergewith!(+, d1, d2);

julia> d1  
Dict{Int64, Int64} with 3 entries:  
4 => 5  
3 => 4  
1 => 6

julia> mergewith!(-, d1, d1);

julia> d1  
Dict{Int64, Int64} with 3 entries:  
4 => 0  
3 => 0  
1 => 0

julia> foldl(mergewith!(+), [d1, d2]; init= Dict { Int64 , Int64 }())  
Dict{Int64, Int64} with 3 entries:  
4 => 5  
3 => 0  
1 => 4

source

```
Base.sizehint!– Function.

```

sizehint!(s, n)

Suggest that collectionsreserve capacity for at leastnelements. This can improve performance.  
Notes on the performance model  
For types that supportsizehint!,

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 588

1. push!andappend!methods generally may (but are not required to) preallocate extra storage. For
    types implemented inBase, they typically do, using a heuristic optimized for a general use case.
2. sizehint!may control this preallocation. Again, it typically does this for types inBase.
3. empty!is nearly costless (and O(1)) for types that support this kind of preallocation.

```

source

```
Base.keytype– Function.

```

keytype(T:: Type {<: AbstractArray })  
keytype(A:: AbstractArray )

Return the key type of an array. This is equal to theeltypeof the result ofkeys(...), and is provided  
mainly for compatibility with the dictionary interface.  
Examples

julia> keytype([1, 2, 3]) == Int  
true

julia> keytype([1 2; 3 4])  
CartesianIndex{2}

Julia 1.2  
For arrays, this function requires at least Julia 1.2.

source  
keytype(type)

Get the key type of a dictionary type. Behaves similarly toeltype.  
Examples

julia> keytype( Dict ( Int32 (1) => "foo"))  
Int32

source

```
Base.valtype– Function.

```

valtype(T:: Type {<: AbstractArray })  
valtype(A:: AbstractArray )

Return the value type of an array. This is identical toeltypeand is provided mainly for compatibility with  
the dictionary interface.  
Examples

julia> valtype(["one", "two", "three"])  
String

Julia 1.2  
For arrays, this function requires at least Julia 1.2.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 589

```

source  
valtype(type)

Get the value type of a dictionary type. Behaves similarly toeltype.  
Examples

julia> valtype( Dict ( Int32 (1) => "foo"))  
String

source

```
Fully implemented by:

- IdDict
- Dict
- WeakKeyDict

Partially implemented by:

- BitSet
- Set
- EnvDict
- Array
- BitArray
- ImmutableDict
- Iterators.Pairs

### 42.7 Set-Like Collections

Base.AbstractSet– Type.

```

AbstractSet{T}

Supertype for set-like types whose elements are of typeT.Set,BitSetand other types are subtypes of  
this.  
source

```
Base.Set– Type.

```

Set ([itr])

Construct aSetof the values generated by the given iterable object, or an empty set. Should be used  
instead ofBitSetfor sparse integer sets, or for sets of arbitrary objects.  
See also:push!,empty!,union!,in.  
source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 590

Base.BitSet– Type.

```

BitSet([itr])

Construct a sorted set ofInts generated by the given iterable object, or an empty set. Implemented as a  
bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a  
few very large integers), useSetinstead.  
source

```
Base.union– Function.

```

union(s, itrs...)  
∪(s, itrs...)

Construct the union of sets. Maintain order with arrays.  
See also:intersect,isdisjoint,vcat,Iterators.flatten.  
Examples

julia> union([1, 2], [ 3, 4])  
4-element Vector{Int64}:  
1  
2  
3  
4

julia> union([1, 2], [ 2, 4])  
3-element Vector{Int64}:  
1  
2  
4

julia> union([4, 2], 1:2)  
3-element Vector{Int64}:  
4  
2  
1

julia> union( Set ([1, 2]), 2:3)  
Set{Int64} with 3 elements:  
2  
3  
1

source

```
Base.union!– Function.

```

union!(s:: Union {AbstractSet, AbstractVector }, itrs...)

Construct the union of passed in sets and overwriteswith the result. Maintain order with arrays.  
Examples

julia> a = Set ([1, 3, 4, 5]);

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 591

```

julia> union!(a,1:2:8);

julia> a  
Set{Int64} with 5 elements:  
5  
4  
7  
3  
1

source

```
Base.intersect– Function.

```

intersect(s, itrs...)  
∩(s, itrs...)

Construct the intersection of sets. Maintain order with arrays.  
See also:setdiff,isdisjoint,issubset,issetequal.  
Examples

julia> intersect([1, 2, 3], [ 3, 4, 5])  
1-element Vector{Int64}:  
3

julia> intersect([1, 4, 4, 5, 6], [ 4, 6, 6, 7, 8])  
2-element Vector{Int64}:  
4  
6

julia> intersect( Set ([1, 2]), BitSet([2, 3]))  
Set{Int64} with 1 element:  
2

source

```
Base.setdiff– Function.

```

setdiff(s, itrs...)

Construct the set of elements insbut not in any of the iterables initrs. Maintain order with arrays.  
See alsosetdiff!,unionandintersect.  
Examples

julia> setdiff([1,2,3], [ 3,4,5])  
2-element Vector{Int64}:  
1  
2

source

```
Base.setdiff!– Function.

```

setdiff!(s, itrs...)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 592

```

Remove from sets(in-place) each element of each iterable fromitrs. Maintain order with arrays.  
Examples

julia> a = Set ([1, 3, 4, 5]);

julia> setdiff!(a,1:2:6);

julia> a  
Set{Int64} with 1 element:  
4

source

```
Base.symdiff– Function.

```

symdiff(s, itrs...)

Construct the symmetric difference of elements in the passed in sets. Whensis not anAbstractSet, the  
order is maintained. Note that in this case the multiplicity of elements matters.  
See alsosymdiff!,setdiff,unionandintersect.  
Examples

julia> symdiff([1,2,3], [ 3,4,5], [ 4,5,6])  
3-element Vector{Int64}:  
1  
2  
6

julia> symdiff([1,2,1], [ 2, 1, 2])  
2-element Vector{Int64}:  
1  
2

julia> symdiff(unique([1,2,1]), unique([2, 1, 2]))  
Int64[]

source

```
Base.symdiff!– Function.

```

symdiff!(s:: Union {AbstractSet, AbstractVector }, itrs...)

Construct the symmetric difference of the passed in sets, and overwriteswith the result. Whensis an  
array, the order is maintained. Note that in this case the multiplicity of elements matters.  
source

```
Base.intersect!– Function.

```

intersect!(s:: Union {AbstractSet, AbstractVector }, itrs...)

Intersect all passed in sets and overwriteswith the result. Maintain order with arrays.  
source

```
Base.issubset– Function.


#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 593

```

issubset(a, b)-> Bool  
⊆(a, b)-> Bool  
⊇(b, a)-> Bool

Determine whether every element ofais also inb, usingin.  
See also⊊,⊈,∩,∪,contains.  
Examples

julia> issubset([1, 2], [ 1, 2, 3])  
true

julia> [1, 2, 3] ⊆ [1, 2]  
false

julia> [1, 2, 3] ⊇ [1, 2]  
true

source

```
Base.:⊈– Function.

```

⊈(a, b)-> Bool  
⊉(b, a)-> Bool

Negation of⊆and⊇, i.e. checks thatais not a subset ofb.  
See alsoissubset(⊆),⊊.  
Examples

julia> (1, 2) ⊈ (2, 3)  
true

julia> (1, 2) ⊈ (1, 2, 3)  
false

source

```
Base.:⊊– Function.

```

⊊(a, b)-> Bool  
⊋(b, a)-> Bool

Determines ifais a subset of, but not equal to,b.  
See alsoissubset(⊆),⊈.  
Examples

julia> (1, 2) ⊊ (1, 2, 3)  
true

julia> (1, 2) ⊊ (1, 2)  
false

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 594

Base.issetequal– Function.

```

issetequal(a, b)-> Bool

Determine whetheraandbhave the same elements. Equivalent toa ⊆ b && b ⊆ abut more efficient  
when possible.  
See also:isdisjoint,union.  
Examples

julia> issetequal([1, 2], [ 1, 2, 3])  
false

julia> issetequal([1, 2], [ 2, 1])  
true

source

```
Base.isdisjoint– Function.

```

isdisjoint(v1, v2)-> Bool

Return whether the collectionsv1andv2are disjoint, i.e. whether their intersection is empty.  
See also:issetequal,intersect.

Julia 1.5  
This function requires at least Julia 1.5.

source

```
Fully implemented by:

- BitSet
- Set

Partially implemented by:

- Array

### 42.8 Dequeues

Base.push!– Function.

```

push!(collection, items...) -> collection

Insert one or moreitemsincollection. Ifcollectionis an ordered container, the items are inserted at  
the end (in the given order).  
Examples

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 595

```

julia> push!([1, 2, 3], 4, 5, 6)  
6-element Vector{Int64}:  
1 2 3 4 5 6

Ifcollectionis ordered, useappend!to add all the elements of another collection to it. The result of the  
preceding example is equivalent toappend!([1, 2, 3], [4, 5, 6]). ForAbstractSetobjects,union!  
can be used instead.  
Seesizehint!for notes about the performance model.  
See alsopushfirst!.  
source

```
Base.pop!– Function.

```

pop!(collection)-> item

Remove an item incollectionand return it. Ifcollectionis an ordered container, the last item is  
returned; for unordered containers, an arbitrary element is returned.  
See also:popfirst!,popat!,delete!,deleteat!,splice!, andpush!.  
Examples

julia> A=[1, 2, 3]  
3-element Vector{Int64}:  
1  
2  
3

julia> pop!(A)  
3

julia> A  
2-element Vector{Int64}:  
1  
2

julia> S = Set ([1, 2])  
Set{Int64} with 2 elements:  
2  
1

julia> pop!(S)  
2

julia> S  
Set{Int64} with 1 element:  
1

julia> pop!( Dict (1=>2))  
1 => 2

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 596

```

source

pop!(collection, key[, default])

Delete and return the mapping forkeyif it exists incollection, otherwise returndefault, or throw an  
error ifdefaultis not specified.  
Examples

julia> d = Dict ("a"=>1, "b"=>2, "c"=>3);

julia> pop!(d,"a")  
1

julia> pop!(d,"d")  
ERROR: KeyError: key "d" not found  
Stacktrace:  
[...]

julia> pop!(d,"e", 4)  
4

source

```
Base.popat!– Function.

```

popat!(a:: Vector , i :: Integer , [default])

Remove the item at the giveniand return it. Subsequent items are shifted to fill the resulting gap. When  
iis not a valid index fora, returndefault, or throw an error ifdefaultis not specified.  
See also:pop!,popfirst!,deleteat!,splice!.

Julia 1.5  
This function is available as of Julia 1.5.

Examples

julia> a = [4, 3, 2, 1]; popat!(a,2)  
3

julia> a  
3-element Vector{Int64}:  
4  
2  
1

julia> popat!(a,4, missing)  
missing

julia> popat!(a,4)  
ERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]  
[...]

source

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 597

Base.pushfirst!– Function.

```

pushfirst!(collection, items...) -> collection

Insert one or moreitemsat the beginning ofcollection.  
This function is calledunshiftin many other programming languages.  
Examples

julia> pushfirst!([1, 2, 3, 4], 5, 6)  
6-element Vector{Int64}:  
5 6 1 2 3 4

source

```
Base.popfirst!– Function.

```

popfirst!(collection)-> item

Remove the firstitemfromcollection.  
This function is calledshiftin many other programming languages.  
See also:pop!,popat!,delete!.  
Examples

julia> A = [1, 2, 3, 4, 5, 6]  
6-element Vector{Int64}:  
1 2 3 4 5 6

julia> popfirst!(A)  
1

julia> A  
5-element Vector{Int64}:  
2  
3  
4  
5  
6

source

```
Base.insert!– Function.

```

insert!(a:: Vector , index:: Integer , item)

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 598

```

Insert anitemintoaat the givenindex.indexis the index ofitemin the resultinga.  
See also:push!,replace,popat!,splice!.  
Examples

julia> insert!([6, 5, 4, 2, 1], 4, 3)  
6-element Vector{Int64}:  
6 5 4 3 2 1

source

```
Base.deleteat!– Function.

```

deleteat!(a:: Vector , i :: Integer )

Remove the item at the giveniand return the modifieda. Subsequent items are shifted to fill the resulting  
gap.  
See also:delete!,popat!,splice!.  
Examples

julia> deleteat!([6, 5, 4, 3, 2, 1], 2)  
5-element Vector{Int64}:  
6  
4  
3  
2  
1

source  
deleteat!(a::Vector, inds)

Remove the items at the indices given byinds, and return the modifieda. Subsequent items are shifted  
to fill the resulting gap.  
indscan be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of  
the same length asawithtrueindicating entries to delete.  
Examples

julia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)  
3-element Vector{Int64}:  
5  
3  
1

julia> deleteat!([6, 5, 4, 3, 2, 1], [ true , false , true , false , true , false ])  
3-element Vector{Int64}:  
5  
3

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 599

```

1

julia> deleteat!([6, 5, 4, 3, 2, 1], ( 2, 2))  
ERROR: ArgumentError: indices must be unique and sorted  
Stacktrace:  
[...]

source

```
Base.keepat!– Function.

```

keepat!(a:: Vector , inds)

Remove the items at all the indices which are not given byinds, and return the modifieda. Items which  
are kept are shifted to fill the resulting gaps.  
indsmust be an iterator of sorted and unique integer indices. See alsodeleteat!.

Julia 1.7  
This function is available as of Julia 1.7.

Examples

julia> keepat!([6, 5, 4, 3, 2, 1], 1:2:5)  
3-element Vector{Int64}:  
6  
4  
2

source  
keepat!(a::Vector, m::AbstractVector{Bool})

The in-place version of logical indexinga = a[m]. That is,keepat!(a, m)on vectors of equal lengtha  
andmwill remove all elements fromafor whichmat the corresponding index isfalse.  
Examples

julia> a = [:a, :b, :c];

julia> keepat!(a, [ true , false , true ])  
2-element Vector{Symbol}:  
:a  
:c

julia> a  
2-element Vector{Symbol}:  
:a  
:c

source

```
Base.splice!– Function.

```

splice!(a:: Vector , index:: Integer , [replacement])-> item

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 600

```

Remove the item at the given index, and return the removed item. Subsequent items are shifted left to  
fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of  
the removed item.  
See also:replace,delete!,deleteat!,pop!,popat!.  
Examples

julia> A = [6, 5, 4, 3, 2, 1]; splice!(A,5)  
2

julia> A  
5-element Vector{Int64}:  
6  
5  
4  
3  
1

julia> splice!(A,5, -1)  
1

julia> A  
5-element Vector{Int64}:  
6  
5  
4  
3  
-1

julia> splice!(A,1, [ -1, -2, -3])  
6

julia> A  
7-element Vector{Int64}:  
-1  
-2  
-3  
5  
4  
3  
-1

To insertreplacementbefore an indexnwithout removing any items, usesplice!(collection, n:n-1,  
replacement).  
source  
splice!(a::Vector, indices, [replacement]) -> items

Remove items at specified indices, and return a collection containing the removed items. Subsequent  
items are shifted left to fill the resulting gaps. If specified, replacement values from an ordered collection  
will be spliced in place of the removed items; in this case,indicesmust be aUnitRange.  
To insertreplacementbefore an indexnwithout removing any items, usesplice!(collection, n:n-1,  
replacement).

Julia 1.5

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 601

```

Prior to Julia 1.5,indicesmust always be aUnitRange.

Examples

julia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A,4:3, 2)  
Int64[]

julia> A  
8-element Vector{Int64}:  
-1  
-2  
-3  
2  
5  
4  
3  
-1

source

```
Base.resize!– Function.

```

resize!(a:: Vector , n :: Integer ) -> Vector

Resizeato containnelements. Ifnis smaller than the current collection length, the firstnelements will  
be retained. Ifnis larger, the new elements are not guaranteed to be initialized.  
Examples

julia> resize!([6, 5, 4, 3, 2, 1], 3)  
3-element Vector{Int64}:  
6  
5  
4

julia> a = resize!([6, 5, 4, 3, 2, 1], 8);

julia> length(a)  
8

julia> a[1:6]  
6-element Vector{Int64}:  
6 5 4 3 2 1

source

```
Base.append!– Function.

```

append!(collection, collections...) -> collection.

For an ordered containercollection, add the elements of eachcollectionsto the end of it.

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 602

```

Julia 1.6  
Specifying multiple collections to be appended requires at least Julia 1.6.

Examples

julia> append!([1], [ 2, 3])  
3-element Vector{Int64}:  
1  
2  
3

julia> append!([1, 2, 3], [ 4, 5], [ 6])  
6-element Vector{Int64}:  
1 2 3 4 5 6

Usepush!to add individual items tocollectionwhich are not already themselves in another collection.  
The result of the preceding example is equivalent topush!([1, 2, 3], 4, 5, 6).  
Seesizehint!for notes about the performance model.  
See alsovcatfor vectors,union!for sets, andprepend!andpushfirst!for the opposite order.  
source

```
Base.prepend!– Function.

```

prepend!(a:: Vector , collections...) -> collection

Insert the elements of eachcollectionsto the beginning ofa.  
Whencollectionsspecifies multiple collections, order is maintained: elements ofcollections[1]will  
appear leftmost ina, and so on.

Julia 1.6  
Specifying multiple collections to be prepended requires at least Julia 1.6.

Examples

julia> prepend!([3], [ 1, 2])  
3-element Vector{Int64}:  
1  
2  
3

julia> prepend!([6], [ 1, 2], [ 3, 4, 5])  
6-element Vector{Int64}:  
1 2 3 4 5 6

```

#### CHAPTER 42. COLLECTIONS AND DATA STRUCTURES 603

```

source

```
Fully implemented by:

- Vector(a.k.a. 1-dimensionalArray)
- BitVector(a.k.a. 1-dimensionalBitArray)

### 42.9 Utility Collections

Core.Pair– Type.

```

Pair (x, y)  
x => y

Construct aPairobject with typePair{typeof(x), typeof(y)}. The elements are stored in the fields  
firstandsecond. They can also be accessed via iteration (but aPairis treated as a single"scalar" for  
broadcasting operations).  
See alsoDict.  
Examples

julia> p = "foo"=> 7  
"foo" => 7

julia> typeof(p)  
Pair{String, Int64}

julia> p.first  
"foo"

julia>for x in p  
println(x)  
end  
foo  
7

source

```
Base.Pairs– Type.

```

Iterators.Pairs(values, keys)<: AbstractDict{eltype(keys), eltype(values)}

Transforms an indexable container into a Dictionary-view of the same data. Modifying the key-space of the  
underlying data may invalidate this object.  
source

```

**Chapter 43**

**Mathematics**

### 43.1 Mathematical Operators.

Base.:-– Method.

```

-(x)

Unary minus operator.  
See also:abs,flipsign.  
Examples

julia> -1  
-1

julia> -(2)  
-2

julia> -[1 2; 3 4]  
2×2 Matrix{Int64}:  
-1 -2  
-3 -4

source

```
Base.:+– Function.

```

+(x, y...)

Addition operator.x+y+z+...calls this function with all arguments, i.e.+(x, y, z, ...).  
Examples

julia> 1 + 20 + 4  
25

julia> +(1, 20, 4)  
25

source  
dt::Date + t::Time -> DateTime

```
#### 604


#### CHAPTER 43. MATHEMATICS 605

```

The addition of aDatewith aTimeproduces aDateTime. The hour, minute, second, and millisecond parts  
oftheTimeareusedalongwiththeyear, month, anddayoftheDatetocreatethenewDateTime. Non-zero  
microseconds or nanoseconds in theTimetype will result in anInexactErrorbeing thrown.

```
Base.:-– Method.

```

-(x, y)

Subtraction operator.  
Examples

julia> 2 - 3  
-1

julia> -(2, 4.5)  
-2.5

source

```
Base.:*– Method.

```

*(x, y...)

Multiplication operator.x_y_z_...calls this function with all arguments, i.e._(x, y, z, ...).  
Examples

julia> 2 * 7 * 8  
112

julia> *(2, 7, 8)  
112

source

```
Base.:/– Function.

```

/(x, y)

Right division operator: multiplication ofxby the inverse ofyon the right. Gives floating-point results for  
integer arguments.  
Examples

julia> 1/2  
0.5

julia> 4/2  
2.0

julia> 4.5/2  
2.25

source

```
Base.:\– Method.


#### CHAPTER 43. MATHEMATICS 606

```

(x, y)

Left division operator: multiplication ofyby the inverse ofxon the left. Gives floating-point results for  
integer arguments.  
Examples

julia> 3 \ 6  
2.0

julia> inv(3) * 6  
2.0

julia> A = [4 3; 2 1]; x= [5, 6];

julia> A \ x  
2-element Vector{Float64}:  
6.5  
-7.0

julia> inv(A)* x  
2-element Vector{Float64}:  
6.5  
-7.0

source

```
Base.:^– Method.

```

^(x, y)

Exponentiation operator. Ifxis a matrix, computes matrix exponentiation.  
Ifyis anIntliteral (e.g. 2 inx^2or-3inx^-3), the Julia codex^yis transformed by the compiler  
toBase.literal_pow(^, x, Val(y)), to enable compile-time specialization on the value of the expo-  
nent. (As a default fallback we haveBase.literal_pow(^, x, Val(y)) = ^(x,y), where usually^ ==  
Base.^unless^has been defined in the calling namespace.) Ifyis a negative integer literal, then  
Base.literal_powtransforms the operation toinv(x)^-yby default, where-yis positive.  
Examples

julia> 3^5  
243

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> A^3  
2×2 Matrix{Int64}:  
37 54  
81 118

source

```
Base.fma– Function.


#### CHAPTER 43. MATHEMATICS 607

```

fma(x, y, z)

Computesx_y+zwithout rounding the intermediate resultx_y. On some systems this is significantly more  
expensive thanx*y+z.fmais used to improve accuracy in certain algorithms. Seemuladd.  
source

```
Base.muladd– Function.

```

muladd(A, y, z)

Combined multiply-add,A_y .+ z, for matrix-matrix or matrix-vector multiplication. The result is always  
the same size asA_y, butzmay be smaller, or a scalar.

Julia 1.6  
These methods require Julia 1.6 or later.

Examples

julia> A=[1.0 2.0; 3.0 4.0]; B =[1.0 1.0; 1.0 1.0]; z =[0, 100];

julia> muladd(A, B, z)  
2×2 Matrix{Float64}:  
3.0 3.0  
107.0 107.0

muladd(x, y, z)

Combined multiply-add: computesx*y+z, but allowing the add and multiply to be merged with each other  
or with surrounding operations for performance. For example, this may be implemented as anfmaif the  
hardware supports it efficiently. The result can be different on different machines and can also be different  
on the same machine due to constant propagation or other optimizations. Seefma.  
Examples

julia> muladd(3, 2, 1)  
7

julia> 3 * 2 + 1  
7

source

```
Base.inv– Method.

```

inv(x)

Return the multiplicative inverse ofx, such thatx_inv(x)orinv(x)_xyieldsone(x)(the multiplicative  
identity) up to roundoff errors.  
Ifxis a number, this is essentially the same asone(x)/x, but for some typesinv(x)may be slightly more  
efficient.  
Examples

```

#### CHAPTER 43. MATHEMATICS 608

```

julia> inv(2)  
0.5

julia> inv(1 + 2im)  
0.2 - 0.4im

julia> inv(1 + 2im) * (1 + 2im)  
1.0 + 0.0im

julia> inv(2//3)  
3//2

Julia 1.2  
inv(::Missing)requires at least Julia 1.2.

source

```
Base.div– Function.

```

div(x, y)  
÷(x, y)

The quotient from Euclidean (integer) division. Generally equivalent to a mathematical operation x/y with-  
out a fractional part.  
See also:cld,fld,rem,divrem.  
Examples

julia> 9 ÷ 4  
2

julia> -5 ÷ 3  
-1

julia> 5.0 ÷ 2  
2.0

julia> div.(-5:5, 3)'  
1×11 adjoint(::Vector{Int64}) with eltype Int64:  
-1 -1 -1 0 0 0 0 0 1 1 1

source

```
Base.fld– Function.

```

fld(x, y)

Largest integer less than or equal tox/y. Equivalent todiv(x, y, RoundDown).  
See alsodiv,cld,fld1.  
Examples

julia> fld(7.3,5.5)  
1.0

julia> fld.(-5:5, 3)'  
1×11 adjoint(::Vector{Int64}) with eltype Int64:  
-2 -2 -1 -1 -1 0 0 0 1 1 1

```

#### CHAPTER 43. MATHEMATICS 609

```

Becausefld(x, y)implements strictly correct floored rounding based on the true value of floating-point  
numbers, unintuitive situations can arise. For example:

julia> fld(6.0,0.1)  
59.0  
julia> 6.0/0.1  
60.0  
julia> 6.0/big(0.1)  
59.99999999999999666933092612453056361837965690217069245739573412231113406246995

What is happening here is that the true value of the floating-point number written as0.1is slightly larger  
than the numerical value 1/10 while6.0represents the number 6 precisely. Therefore the true value of  
6.0 / 0.1is slightly less than 60. When doing division, this is rounded to precisely60.0, butfld(6.0,  
0.1)always takes the floor or the true value, so the result is59.0.  
source

```
Base.cld– Function.

```

cld(x, y)

Smallest integer larger than or equal tox/y. Equivalent todiv(x, y, RoundUp).  
See alsodiv,fld.  
Examples

julia> cld(5.5,2.2)  
3.0

julia> cld.(-5:5, 3)'  
1×11 adjoint(::Vector{Int64}) with eltype Int64:  
-1 -1 -1 0 0 0 1 1 1 2 2

source

```
Base.mod– Function.

```

mod(x:: Integer , r ::AbstractUnitRange)

Findyin the rangersuch thatxy(modn), wheren = length(r), i.e. y = mod(x - first(r), n) +  
first(r).  
See alsomod1.  
Examples

julia> mod(0, Base.OneTo(3))  
3

julia> mod(3, 0:2)  
0

Julia 1.3  
This method requires at least Julia 1.3.

source

```

#### CHAPTER 43. MATHEMATICS 610

```

mod(x, y)  
rem(x, y, RoundDown)

The reduction ofxmoduloy, or equivalently, the remainder ofxafter floored division byy, i.e. x -  
y*fld(x,y)if computed without intermediate rounding.  
The result will have the same sign asy, and magnitude less thanabs(y)(with some exceptions, see note  
below).

Note  
When used with floating point values, the exact result may not be representable by the type,  
and so rounding error may occur. In particular, if the exact result is very close toy, then it may  
be rounded toy.

See also:rem,div,fld,mod1,invmod.

julia> mod(8, 3)  
2

julia> mod(9, 3)  
0

julia> mod(8.9, 3)  
2.9000000000000004

julia> mod(eps(),3)  
2.220446049250313e-16

julia> mod(-eps(),3)  
3.0

julia> mod.(-5:5, 3)'  
1×11 adjoint(::Vector{Int64}) with eltype Int64:  
1 2 0 1 2 0 1 2 0 1 2

source  
rem(x::Integer, T::Type{<:Integer}) -> T  
mod(x::Integer, T::Type{<:Integer}) -> T  
%(x::Integer, T::Type{<:Integer}) -> T

Findy::Tsuch thatx≡y(mod n), where n is the number of integers representable inT, andyis an integer  
in[typemin(T),typemax(T)]. IfTcan represent any integer (e.g. T == BigInt), then this operation  
corresponds to a conversion toT.  
Examples

julia> 129 % Int8  
-127

source

```
Base.rem– Function.

```

rem(x, y)  
%(x, y)

```

#### CHAPTER 43. MATHEMATICS 611

```

Remainder from Euclidean division, returning a value of the same sign asx, and smaller in magnitude than  
y. This value is always exact.  
See also:div,mod,mod1,divrem.  
Examples

julia> x = 15; y = 4;

julia> x % y  
3

julia> x == div(x, y)* y + rem(x, y)  
true

julia> rem.(-5:5, 3)'  
1×11 adjoint(::Vector{Int64}) with eltype Int64:  
-2 -1 0 -2 -1 0 1 2 0 1 2

source

```
Base.Math.rem2pi– Function.

```

rem2pi(x, r:: RoundingMode )

Compute the remainder ofxafter integer division by2π, with the quotient rounded according to the round-  
ing moder. In other words, the quantity  
x - π2*round(xπ/(2),r)

without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will  
give a more accurate result thanrem(x,2π,r)

```
- ifr == RoundNearest, then the result is in the interval[−,]. This will generally be the most accurate
    result. See alsoRoundNearest.
- ifr == RoundToZero, then the result is in the interval[0,2]ifxis positive,. or[− 2 ,0]otherwise. See
    alsoRoundToZero.
- ifr == RoundDown, then the result is in the interval[0,2]. See alsoRoundDown.
- ifr == RoundUp, then the result is in the interval[− 2 ,0]. See alsoRoundUp.

```

Examples

julia> rem2pi(7pi/4, RoundNearest)  
-0.7853981633974485

julia> rem2pi(7pi/4, RoundDown)  
5.497787143782138

source

```
Base.Math.mod2pi– Function.

```

mod2pi(x)

```

#### CHAPTER 43. MATHEMATICS 612

```

Modulus after division by2π, returning in the range[0,2).  
This function computes a floating point representation of the modulus after division by numerically exact  
2π, and is therefore not exactly the same asmod(x,2π), which would compute the modulus ofxrelative  
to division by the floating-point number2π.

Note  
Depending on the format of the input value, the closest representable value to 2π may be less  
than 2π. For example, the expressionmod2pi(2π)will not return 0 , because the intermediate  
value of2_πis aFloat64and2_Float64(π) < 2*big(π). Seerem2pifor more refined control  
of this behavior.

Examples

julia> mod2pi(9*pi/4)  
0.7853981633974481

source

```
Base.divrem– Function.

```

divrem(x, y, r:: RoundingMode =RoundToZero)

The quotient and remainder from Euclidean division. Equivalent to(div(x,y,r), rem(x,y,r)). Equiva-  
lently, with the default value ofr, this call is equivalent to(x÷y, x%y).  
See also:fldmod,cld.  
Examples

julia> divrem(3,7)  
(0, 3)

julia> divrem(7,3)  
(2, 1)

source

```
Base.fldmod– Function.

```

fldmod(x, y)

The floored quotient and modulus after division. A convenience wrapper fordivrem(x, y, RoundDown).  
Equivalent to(fld(x,y), mod(x,y)).  
See also:fld,cld,fldmod1.  
source

```
Base.fld1– Function.

```

fld1(x, y)

Flooring division, returning a value consistent withmod1(x,y)  
See alsomod1,fldmod1.  
Examples

```

#### CHAPTER 43. MATHEMATICS 613

```

julia> x = 15; y = 4;

julia> fld1(x, y)  
4

julia> x == fld(x, y)* y + mod(x, y)  
true

julia> x == (fld1(x, y)- 1) * y + mod1(x, y)  
true

source

```
Base.mod1– Function.

```

mod1(x, y)

Modulus after flooring division, returning a valuersuch thatmod(r, y) == mod(x, y)in the range(0, y]  
for positiveyand in the range[y,0)for negativey.  
See alsofld1,fldmod1.  
Examples

julia> mod1(4, 2)  
2

julia> mod1(4, 3)  
1

source

```
Base.fldmod1– Function.

```

fldmod1(x, y)

Return(fld1(x,y), mod1(x,y)).  
See alsofld1,mod1.  
source

```
Base.://– Function.

```

//(num, den)

Divide two integers or rational numbers, giving aRationalresult.  
Examples

julia> 3 // 5  
3//5

julia> (3 // 5) // (2 // 1)  
3//10

source

```
Base.rationalize– Function.


#### CHAPTER 43. MATHEMATICS 614

```

rationalize([T<: Integer = Int ,] x; tol:: Real =eps(x))

Approximate floating point numberxas aRationalnumber with components of the given integer type.  
The result will differ fromxby no more thantol.  
Examples

julia> rationalize(5.6)  
28//5

julia> a = rationalize( BigInt , 10.3)  
103//10

julia> typeof(numerator(a))  
BigInt

source

```
Base.numerator– Function.

```

numerator(x)

Numerator of the rational representation ofx.  
Examples

julia> numerator(2//3)  
2

julia> numerator(4)  
4

source

```
Base.denominator– Function.

```

denominator(x)

Denominator of the rational representation ofx.  
Examples

julia> denominator(2//3)  
3

julia> denominator(4)  
1

source

```
Base.:<<– Function.

```

<<(x, n)

Left bit shift operator,x << n. Forn >= 0, the result isxshifted left bynbits, filling with 0 s. This is  
equivalent tox * 2^n. Forn < 0, this is equivalent tox >> -n.  
Examples

```

#### CHAPTER 43. MATHEMATICS 615

```

julia>Int8 (3) << 2  
12

julia> bitstring( Int8 (3))  
"00000011"

julia> bitstring( Int8 (12))  
"00001100"

See also>>,>>>,exp2,ldexp.  
source  
<<(B::BitVector, n) -> BitVector

Left bit shift operator,B << n. Forn >= 0, the result isBwith elements shiftednpositions backwards,  
filling withfalsevalues. Ifn < 0, elements are shifted forwards. Equivalent toB >> -n.  
Examples

julia> B = BitVector ([ true , false , true , false , false ])  
5-element BitVector:  
1  
0  
1  
0  
0

julia> B << 1  
5-element BitVector:  
0  
1  
0  
0  
0

julia> B << -1  
5-element BitVector:  
0  
1  
0  
1  
0

source

```
Base.:>>– Function.

```

> > (x, n)

Right bit shift operator,x >> n. Forn >= 0, the result isxshifted right bynbits, wheren >= 0, filling with  
0 s ifx >= 0, 1 s ifx < 0, preserving the sign ofx. This is equivalent tofld(x, 2^n). Forn < 0, this is  
equivalent tox << -n.  
Examples

julia>Int8 (13) >> 2  
3

```

#### CHAPTER 43. MATHEMATICS 616

```

julia> bitstring( Int8 (13))  
"00001101"

julia> bitstring( Int8 (3))  
"00000011"

julia>Int8 (-14) >> 2  
-4

julia> bitstring( Int8 (-14))  
"11110010"

julia> bitstring( Int8 (-4))  
"11111100"

See also>>>,<<.  
source

> > (B::BitVector, n) -> BitVector

Right bit shift operator,B >> n. Forn >= 0, the result isBwith elements shiftednpositions forward, filling  
withfalsevalues. Ifn < 0, elements are shifted backwards. Equivalent toB << -n.  
Examples

julia> B = BitVector ([ true , false , true , false , false ])  
5-element BitVector:  
1  
0  
1  
0  
0

julia> B >> 1  
5-element BitVector:  
0  
1  
0  
1  
0

julia> B >> -1  
5-element BitVector:  
0  
1  
0  
0  
0

source

```
Base.:>>>– Function.

```

> > > (x, n)

```

#### CHAPTER 43. MATHEMATICS 617

```

Unsigned right bit shift operator,x >>> n. Forn >= 0, the result isxshifted right bynbits, wheren >=  
0 , filling with 0 s. Forn < 0, this is equivalent tox << -n.  
ForUnsignedinteger types, this is equivalent to>>. ForSignedinteger types, this is equivalent to  
signed(unsigned(x) >> n).  
Examples

julia>Int8 (-14) >>> 2  
60

julia> bitstring( Int8 (-14))  
"11110010"

julia> bitstring( Int8 (60))  
"00111100"

BigInts are treated as if having infinite size, so no filling is required and this is equivalent to>>.  
See also>>,<<.  
source

> > > (B::BitVector, n) -> BitVector

Unsigned right bitshift operator,B >>> n. Equivalent toB >> n. See>>for details and examples.  
source

```
Base.bitrotate– Function.

```

bitrotate(x::Base.BitInteger, k:: Integer )

bitrotate(x, k)implements bitwise rotation. It returns the value ofxwith its bits rotated leftktimes. A  
negative value ofkwill rotate to the right instead.

Julia 1.5  
This function requires Julia 1.5 or later.

See also:<<,circshift,BitArray.

julia> bitrotate( UInt8 (114), 2)  
0xc9

julia> bitstring(bitrotate(0b01110010, 2))  
"11001001"

julia> bitstring(bitrotate(0b01110010, -2))  
"10011100"

julia> bitstring(bitrotate(0b01110010, 8))  
"01110010"

source

```
Base.::– Function.

```

(:)(start, [step], stop)

```

#### CHAPTER 43. MATHEMATICS 618

```

Range operator.a:bconstructs a range fromatobwith a step size of 1 (aUnitRange) , anda:s:bis  
similar but uses a step size ofs(aStepRange).  
:is also used in indexing to select whole dimensions and forSymbolliterals, as in e.g.:hello.  
source  
(:)(start::CartesianIndex, [step::CartesianIndex], stop::CartesianIndex)

ConstructCartesianIndicesfrom twoCartesianIndexand an optional step.

Julia 1.1  
This method requires at least Julia 1.1.

Julia 1.6  
The step range method start:step:stop requires at least Julia 1.6.

Examples

julia> I = CartesianIndex (2,1);

julia> J = CartesianIndex (3,3);

julia> I:J  
2×3 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:  
CartesianIndex(2, 1) CartesianIndex(2, 2) CartesianIndex(2, 3)  
CartesianIndex(3, 1) CartesianIndex(3, 2) CartesianIndex(3, 3)

julia> I: CartesianIndex (1, 2):J  
2×2 CartesianIndices{2, Tuple{StepRange{Int64, Int64}, StepRange{Int64, Int64}}}:  
CartesianIndex(2, 1) CartesianIndex(2, 3)  
CartesianIndex(3, 1) CartesianIndex(3, 3)

source

```
Base.range– Function.

```

range(start, stop, length)  
range(start, stop; length, step)  
range(start; length, stop, step)  
range(;start, length, stop, step)

Construct a specialized array with evenly spaced elements and optimized storage (anAbstractRange)  
from the arguments. Mathematically a range is uniquely determined by any three ofstart,step,stop  
andlength. Valid invocations of range are:

```
- Callrangewith any three ofstart,step,stop,length.
- Callrangewith two ofstart,stop,length. In this casestepwill be assumed

```

to be one. If both arguments are Integers, aUnitRangewill be returned.  
Examples

```

#### CHAPTER 43. MATHEMATICS 619

```

julia> range(1, length=100)  
1:100

julia> range(1, stop=100)  
1:100

julia> range(1, step=5, length=100)  
1:5:496

julia> range(1, step=5, stop=100)  
1:5:96

julia> range(1, 10, length=101)  
1.0:0.09:10.0

julia> range(1, 100, step=5)  
1:5:96

julia> range(stop=10, length=5)  
6:10

julia> range(stop=10, step=1, length=5)  
6:1:10

julia> range(start=1, step=1, stop=10)  
1:1:10

Iflengthis not specified andstop - startis not an integer multiple ofstep, a range that ends before  
stopwill be produced.

julia> range(1, 3.5, step=2)  
1.0:2.0:3.0

Special care is taken to ensure intermediate values are computed rationally. To avoid this induced over-  
head, see theLinRangeconstructor.

Julia 1.1  
stopas a positional argument requires at least Julia 1.1.

Julia 1.7  
The versions without keyword arguments andstartas a keyword argument require at least  
Julia 1.7.

source

```
Base.OneTo– Type.

```

Base.OneTo(n)

Define anAbstractUnitRangethat behaves like1:n, with the added distinction that the lower limit is  
guaranteed (by the type system) to be 1.  
source

```
Base.StepRangeLen– Type.


#### CHAPTER 43. MATHEMATICS 620

```

StepRangeLen( ref::R, step::S, len, [offset=1]) where { R,S}  
StepRangeLen{T,R,S}( ref::R, step::S, len, [offset=1]) where {T,R,S}  
StepRangeLen{T,R,S,L}(ref::R, step::S, len, [offset=1]) where {T,R,S,L}

A rangerwherer[i]produces values of typeT(in the first form,Tis deduced automatically), param-  
eterized by areference value, astep, and thelength. By defaultrefis the starting valuer[1], but  
alternatively you can supply it as the value ofr[offset]for some other index1 <= offset <= len. In  
conjunction withTwicePrecisionthis can be used to implement ranges that are free of roundoff error.  
source

```
Base.:==– Function.

```

==(x, y)

Generic equality operator. Falls back to===. Should be implemented for all types with a notion of equality,  
based on the abstract value that an instance represents. For example, all numeric types are compared by  
numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For  
collections,==is generally called recursively on all contents, though other properties (like the shape for  
arrays) may also be taken into account.  
This operator follows IEEE semantics for floating-point numbers:0.0 == -0.0andNaN != NaN.  
The result is of typeBool, except when one of the operands ismissing, in which casemissingis returned  
(three-valued logic). For collections,missingis returned if at least one of the operands contains amissing  
value and all non-missing values are equal. Useisequalor===to always get aBoolresult.  
Implementation  
New numeric types should implement this function for two arguments of the new type, and handle com-  
parison to other types via promotion rules where possible.  
isequalfalls back to==, so new methods of==will be used by theDicttype to compare keys. If your  
type will be used as a dictionary key, it should therefore also implementhash.  
If some type defines==,isequal, andislessthen it should also implement<to ensure consistency of  
comparisons.  
source

```
Base.:!=– Function.

```

!=(x, y)  
≠(x,y)

Not-equals comparison operator. Always gives the opposite answer as==.  
Implementation  
New types should generally not implement this, and rely on the fallback definition!=(x,y) = !(x==y)  
instead.  
Examples

julia> 3 != 2  
true

julia> "foo"≠ "foo"  
false

```

#### CHAPTER 43. MATHEMATICS 621

```

source  
!=(x)

Create a function that compares its argument toxusing!=, i.e. a function equivalent toy -> y != x.  
The returned function is of typeBase.Fix2{typeof(!=)}, which can be used to implement specialized  
methods.

Julia 1.2  
This functionality requires at least Julia 1.2.

source

```
Base.:!==– Function.

```

!==(x, y)  
≢(x,y)

Always gives the opposite answer as===.  
Examples

julia> a = [1, 2]; b= [1, 2];

julia> a ≢ b  
true

julia> a ≢ a  
false

source

```
Base.:<– Function.

```

<(x, y)

Less-thancomparisonoperator. Fallsbacktoisless. Becauseofthebehavioroffloating-pointNaNvalues,  
this operator implements a partial order.  
Implementation  
New numeric types with a canonical partial order should implement this function for two arguments of the  
new type. Types with a canonical total order should implementislessinstead.  
Examples

julia> 'a' < 'b'  
true

julia> "abc"< "abd"  
true

julia> 5 < 3  
false

source  
<(x)

```

#### CHAPTER 43. MATHEMATICS 622

```

Create a function that compares its argument toxusing<, i.e. a function equivalent toy -> y < x. The  
returnedfunctionisoftypeBase.Fix2{typeof(<)}, whichcanbeusedtoimplementspecializedmethods.

Julia 1.2  
This functionality requires at least Julia 1.2.

source

```
Base.:<=– Function.

```

<=(x, y)  
≤(x,y)

Less-than-or-equals comparison operator. Falls back to(x < y) | (x == y).  
Examples

julia> 'a' <= 'b'  
true

julia> 7 ≤ 7 ≤ 9  
true

julia> "abc"≤ "abc"  
true

julia> 5 <= 3  
false

source  
<=(x)

Create a function that compares its argument toxusing<=, i.e. a function equivalent toy -> y <= x.  
The returned function is of typeBase.Fix2{typeof(<=)}, which can be used to implement specialized  
methods.

Julia 1.2  
This functionality requires at least Julia 1.2.

source

```
Base.:>– Function.

```

> (x, y)

Greater-than comparison operator. Falls back toy < x.  
Implementation  
Generally, new types should implement<instead of this function, and rely on the fallback definition>(x,  
y) = y < x.  
Examples

```

#### CHAPTER 43. MATHEMATICS 623

```

julia> 'a' > 'b'  
false

julia> 7 > 3 > 1  
true

julia> "abc"> "abd"  
false

julia> 5 > 3  
true

source

> (x)

Create a function that compares its argument toxusing>, i.e. a function equivalent toy -> y > x. The  
returnedfunctionisoftypeBase.Fix2{typeof(>)}, whichcanbeusedtoimplementspecializedmethods.

Julia 1.2  
This functionality requires at least Julia 1.2.

source

```
Base.:>=– Function.

```

> =(x, y)  
> ≥(x,y)

Greater-than-or-equals comparison operator. Falls back toy <= x.  
Examples

julia> 'a' >= 'b'  
false

julia> 7 ≥ 7 ≥ 3  
true

julia> "abc"≥ "abc"  
true

julia> 5 >= 3  
true

source

> =(x)

Create a function that compares its argument toxusing>=, i.e. a function equivalent toy -> y >= x.  
The returned function is of typeBase.Fix2{typeof(>=)}, which can be used to implement specialized  
methods.

Julia 1.2  
This functionality requires at least Julia 1.2.

```

#### CHAPTER 43. MATHEMATICS 624

```

source

```
Base.cmp– Function.

```

cmp(x,y)

Return -1, 0, or 1 depending on whetherxis less than, equal to, or greater thany, respectively. Uses the  
total order implemented byisless.  
Examples

julia> cmp(1, 2)  
-1

julia> cmp(2, 1)  
1

julia> cmp(2+im, 3-im)  
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})  
[...]

source  
cmp(<, x, y)

Return -1, 0, or 1 depending on whetherxis less than, equal to, or greater thany, respectively. The first  
argument specifies a less-than comparison function to use.  
source

cmp(a:: AbstractString , b :: AbstractString ) -> Int

Compare two strings. Return 0 if both strings have the same length and the character at each index is the  
same in both strings. Return-1ifais a prefix ofb, or ifacomes beforebin alphabetical order. Return 1 if  
bis a prefix ofa, or ifbcomes beforeain alphabetical order (technically, lexicographical order by Unicode  
code points).  
Examples

julia> cmp("abc", "abc")  
0

julia> cmp("ab", "abc")  
-1

julia> cmp("abc", "ab")  
1

julia> cmp("ab", "ac")  
-1

julia> cmp("ac", "ab")  
1

julia> cmp("α", "a")  
1

julia> cmp("b", "β")  
-1

```

#### CHAPTER 43. MATHEMATICS 625

```

source

```
Base.:~– Function.

```

~(x)

Bitwise not.  
See also:!,&,|.  
Examples

julia> ~4  
-5

julia> ~10  
-11

julia> ~ true  
false

source

```
Base.:&– Function.

```

x & y

Bitwise and. Implementsthree-valued logic, returningmissingif one operand ismissingand the other is  
true. Add parentheses for function application form:(&)(x, y).  
See also:|,xor,&&.  
Examples

julia> 4 & 10  
0

julia> 4 & 12  
4

julia>true & missing  
missing

julia>false & missing  
false

source

```
Base.:|– Function.

```

x | y

Bitwise or. Implementsthree-valued logic, returningmissingif one operand ismissingand the other is  
false.  
See also:&,xor,||.  
Examples

```

#### CHAPTER 43. MATHEMATICS 626

```

julia> 4 | 10  
14

julia> 4 | 1  
5

julia>true | missing  
true

julia>false | missing  
missing

source

```
Base.xor– Function.

```

xor(x, y)  
⊻(x, y)

Bitwise exclusive or ofxandy. Implementsthree-valued logic, returningmissingif one of the arguments  
ismissing.  
The infix operationa⊻bis a synonym forxor(a,b), and ⊻ can be typed by tab-completing\xoror  
\veebarin the Julia REPL.  
Examples

julia> xor( true , false )  
true

julia> xor( true , true )  
false

julia> xor( true , missing)  
missing

julia>false ⊻false  
false

julia> [ true ; true ; false ] .⊻[true; false; false]  
3-element BitVector:  
0  
1  
0

source

```
Base.nand– Function.

```

nand(x, y)  
(x, y)

Bitwisenand(notand)ofxandy. Implementsthree-valuedlogic,returningmissingifoneofthearguments  
ismissing.  
The infix operationa bis a synonym fornand(a,b), and can be typed by tab-completing\nandor  
\barwedgein the Julia REPL.  
Examples

```

#### CHAPTER 43. MATHEMATICS 627

```

julia> nand( true , false )  
true

julia> nand( true , true )  
false

julia> nand( true , missing)  
missing

julia>false false  
true

julia> [ true ; true ; false ]. [ true ; false ; false ]  
3-element BitVector:  
0  
1  
1

source

```
Base.nor– Function.

```

nor(x, y)  
(x, y)

Bitwise nor (not or) ofxandy. Implementsthree-valued logic, returningmissingif one of the arguments  
ismissing.  
The infix operationa bis a synonym fornor(a,b), and can be typed by tab-completing\noror\veebar  
in the Julia REPL.  
Examples

julia> nor( true , false )  
false

julia> nor( true , true )  
false

julia> nor( true , missing)  
false

julia>false false  
true

julia> [ true ; true ; false ]. [ true ; false ; false ]  
3-element BitVector:  
0  
0  
1

source

```
Base.:!– Function.

```

!(x)

```

#### CHAPTER 43. MATHEMATICS 628

```

Boolean not. Implementsthree-valued logic, returningmissingifxismissing.  
See also~for bitwise not.  
Examples

julia>! true  
false

julia>! false  
true

julia> !missing  
missing

julia> .![ truefalsetrue ]  
1×3 BitMatrix:  
0 1 0

source  
!f::Function

Predicate function negation: when the argument of!is a function, it returns a function which computes  
the boolean negation off.  
See also∘.  
Examples

julia> str = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"  
"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"

julia> filter(isletter, str)  
"εδxyδfxfyε"

julia> filter(!isletter, str)  
"∀ > 0, ∃ > 0: |-| < ⇒ |()-()| < "

source

```
&&– Keyword.

```

x && y

Short-circuiting boolean AND.  
See also&, the ternary operator? :, and the manual section oncontrol flow.  
Examples

julia> x = 3;

julia> x > 1 && x < 10 && x isa Int  
true

julia> x < 0 && error("expected positive x")  
false

```

#### CHAPTER 43. MATHEMATICS 629

```

source

```
||– Keyword.

```

x || y

Short-circuiting boolean OR.  
See also:|,xor,&&.  
Examples

julia> pi < 3 || < 3  
true

julia>false || true || println("neither is true!")  
true

source

```
### 43.2 Mathematical Functions

Base.isapprox– Function.

```

isapprox(x, y; atol:: Real =0, rtol:: Real =atol>0? 0 : √eps, nans:: Bool = false [, norm:: Function ])

Inexact equality comparison. Two numbers compare equal if their relative distance or their absolute dis-  
tanceiswithintolerancebounds:isapproxreturnstrueifnorm(x-y) <= max(atol, rtol*max(norm(x),  
norm(y))). The defaultatolis zero and the defaultrtoldepends on the types ofxandy. The keyword  
argumentnansdetermines whether or not NaN values are considered equal (defaults to false).  
For real or complex floating-point values, if anatol > 0is not specified,rtoldefaults to the square root  
ofepsof the type ofxory, whichever is bigger (least precise). This corresponds to requiring equality of  
about half of the significand digits. Otherwise, e.g. for integer arguments or if anatol > 0is supplied,  
rtoldefaults to zero.  
Thenormkeyword defaults toabsfor numeric(x,y)and toLinearAlgebra.normfor arrays (where an  
alternativenormchoice is sometimes useful). Whenxandyare arrays, ifnorm(x-y)is not finite (i.e.±Inf  
orNaN), the comparison falls back to checking whether all elements ofxandyare approximately equal  
component-wise.  
The binary operator≈is equivalent toisapproxwith the default arguments, andx ≉ yis equivalent to  
!isapprox(x,y).  
Note thatx ≈ 0(i.e., comparing to zero with the default tolerances) is equivalent tox == 0since the  
defaultatolis 0. In such cases, you should either supply an appropriateatol(or usenorm(x) ≤ atol)  
or rearrange your code (e.g. usex ≈ yrather thanx - y ≈ 0). It is not possible to pick a nonzeroatol  
automatically because it depends on the overall scaling (the"units") of your problem: for example, inx -  
y ≈ 0,atol=1e-9is an absurdly small tolerance ifxis the radius of the Earthin meters, but an absurdly  
large tolerance ifxis the radius of a Hydrogen atomin meters.

Julia 1.6  
Passing thenormkeyword argument when comparing numeric (non-array) arguments requires  
Julia 1.6 or later.

Examples

```

#### CHAPTER 43. MATHEMATICS 630

```

julia> isapprox(0.1, 0.15; atol=0.05)  
true

julia> isapprox(0.1, 0.15; rtol=0.34)  
true

julia> isapprox(0.1, 0.15; rtol=0.33)  
false

julia> 0.1 + 1e-10≈ 0.1  
true

julia> 1e-10≈ 0  
false

julia> isapprox(1e-10, 0, atol=1e-8)  
true

julia> isapprox([10.0^9, 1.0], [ 10.0^9, 2.0]) # using `norm`  
true

source  
isapprox(x; kwargs...) / ≈(x; kwargs...)

Create a function that compares its argument toxusing≈, i.e. a function equivalent toy -> y ≈ x.  
The keyword arguments supported here are the same as those in the 2-argumentisapprox.

Julia 1.5  
This method requires Julia 1.5 or later.

source

```
Base.sin– Method.

```

sin(x)

Compute sine ofx, wherexis in radians.  
See also [sind], [sinpi], [sincos], [cis].  
source

```
Base.cos– Method.

```

cos(x)

Compute cosine ofx, wherexis in radians.  
See also [cosd], [cospi], [sincos], [cis].  
source

```
Base.Math.sincos– Method.

```

sincos(x)

```

#### CHAPTER 43. MATHEMATICS 631

```

Simultaneously compute the sine and cosine ofx, wherexis in radians, returning a tuple(sine, cosine).  
See alsocis,sincospi,sincosd.  
source

```
Base.tan– Method.

```

tan(x)

Compute tangent ofx, wherexis in radians.  
source

```
Base.Math.sind– Function.

```

sind(x)

Compute sine ofx, wherexis in degrees. Ifxis a matrix,xneeds to be a square matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.cosd– Function.

```

cosd(x)

Compute cosine ofx, wherexis in degrees. Ifxis a matrix,xneeds to be a square matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.tand– Function.

```

tand(x)

Compute tangent ofx, wherexis in degrees. Ifxis a matrix,xneeds to be a square matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.sincosd– Function.

```

sincosd(x)

Simultaneously compute the sine and cosine ofx, wherexis in degrees.

Julia 1.3  
This function requires at least Julia 1.3.

```

#### CHAPTER 43. MATHEMATICS 632

```

source

```
Base.Math.sinpi– Function.

```

sinpi(x)

Computesin(πx)more accurately thansin(pi*x), especially for largex.  
See alsosind,cospi,sincospi.  
source

```
Base.Math.cospi– Function.

```

cospi(x)

Computecos(πx)more accurately thancos(pi*x), especially for largex.  
source

```
Base.Math.sincospi– Function.

```

sincospi(x)

Simultaneously computesinpi(x)andcospi(x)(the sine and cosine ofπ*x, wherexis in radians), re-  
turning a tuple(sine, cosine).

Julia 1.6  
This function requires Julia 1.6 or later.

See also:cispi,sincosd,sinpi.  
source

```
Base.sinh– Method.

```

sinh(x)

Compute hyperbolic sine ofx.  
source

```
Base.cosh– Method.

```

cosh(x)

Compute hyperbolic cosine ofx.  
source

```
Base.tanh– Method.

```

tanh(x)

Compute hyperbolic tangent ofx.  
source

```
Base.asin– Method.


#### CHAPTER 43. MATHEMATICS 633

```

asin(x)

Compute the inverse sine ofx, where the output is in radians.  
source

```
Base.acos– Method.

```

acos(x)

Compute the inverse cosine ofx, where the output is in radians  
source

```
Base.atan– Method.

```

atan(y)  
atan(y, x)

Compute the inverse tangent ofyory/x, respectively.  
For one argument, this is the angle in radians between the positive x-axis and the point (1, y), returning a  
value in the interval[−π/2, π/2].  
For two arguments, this is the angle in radians between the positive x-axis and the point (x, y), returning  
a value in the interval[−π, π]. This corresponds to a standardatan2function. Note that by convention  
atan(0.0,x)is defined asπandatan(-0.0,x)is defined as−πwhenx < 0.  
source

```
Base.Math.asind– Function.

```

asind(x)

Compute the inverse sine ofx, where the output is in degrees. Ifxis a matrix,xneeds to be a square  
matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.acosd– Function.

```

acosd(x)

Compute the inverse cosine ofx, where the output is in degrees. Ifxis a matrix,xneeds to be a square  
matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.atand– Function.

```

atand(y)  
atand(y,x)

```

#### CHAPTER 43. MATHEMATICS 634

```

Compute the inverse tangent ofyory/x, respectively, where the output is in degrees.

Julia 1.7  
The one-argument method supports square matrix arguments as of Julia 1.7.

source

```
Base.Math.sec– Method.

```

sec(x)

Compute the secant ofx, wherexis in radians.  
source

```
Base.Math.csc– Method.

```

csc(x)

Compute the cosecant ofx, wherexis in radians.  
source

```
Base.Math.cot– Method.

```

cot(x)

Compute the cotangent ofx, wherexis in radians.  
source

```
Base.Math.secd– Function.

```

secd(x)

Compute the secant ofx, wherexis in degrees.  
source

```
Base.Math.cscd– Function.

```

cscd(x)

Compute the cosecant ofx, wherexis in degrees.  
source

```
Base.Math.cotd– Function.

```

cotd(x)

Compute the cotangent ofx, wherexis in degrees.  
source

```
Base.Math.asec– Method.

```

asec(x)

```

#### CHAPTER 43. MATHEMATICS 635

```

Compute the inverse secant ofx, where the output is in radians.  
source

```
Base.Math.acsc– Method.

```

acsc(x)

Compute the inverse cosecant ofx, where the output is in radians.  
source

```
Base.Math.acot– Method.

```

acot(x)

Compute the inverse cotangent ofx, where the output is in radians.  
source

```
Base.Math.asecd– Function.

```

asecd(x)

Compute the inverse secant ofx, where the output is in degrees. Ifxis a matrix,xneeds to be a square  
matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.acscd– Function.

```

acscd(x)

Compute the inverse cosecant ofx, where the output is in degrees. Ifxis a matrix,xneeds to be a square  
matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.acotd– Function.

```

acotd(x)

Compute the inverse cotangent ofx, where the output is in degrees. Ifxis a matrix,xneeds to be a square  
matrix.

Julia 1.7  
Matrix arguments require Julia 1.7 or later.

source

```
Base.Math.sech– Method.


#### CHAPTER 43. MATHEMATICS 636

```

sech(x)

Compute the hyperbolic secant ofx.  
source

```
Base.Math.csch– Method.

```

csch(x)

Compute the hyperbolic cosecant ofx.  
source

```
Base.Math.coth– Method.

```

coth(x)

Compute the hyperbolic cotangent ofx.  
source

```
Base.asinh– Method.

```

asinh(x)

Compute the inverse hyperbolic sine ofx.  
source

```
Base.acosh– Method.

```

acosh(x)

Compute the inverse hyperbolic cosine ofx.  
source

```
Base.atanh– Method.

```

atanh(x)

Compute the inverse hyperbolic tangent ofx.  
source

```
Base.Math.asech– Method.

```

asech(x)

Compute the inverse hyperbolic secant ofx.  
source

```
Base.Math.acsch– Method.

```

acsch(x)

Compute the inverse hyperbolic cosecant ofx.  
source

```

#### CHAPTER 43. MATHEMATICS 637

Base.Math.acoth– Method.

```

acoth(x)

Compute the inverse hyperbolic cotangent ofx.  
source

```
Base.Math.sinc– Function.

```

sinc(x)

Computesin(πx)/(πx)ifx 6 = 0, and 1 ifx= 0.  
See alsocosc, its derivative.  
source

```
Base.Math.cosc– Function.

```

cosc(x)

Computecos(πx)/x−sin(πx)/(πx^2 )ifx 6 = 0, and 0 ifx= 0. This is the derivative ofsinc(x).  
source

```
Base.Math.deg2rad– Function.

```

deg2rad(x)

Convertxfrom degrees to radians.  
See also:rad2deg,sind.  
Examples

julia> deg2rad(90)  
1.5707963267948966

source

```
Base.Math.rad2deg– Function.

```

rad2deg(x)

Convertxfrom radians to degrees.  
Examples

julia> rad2deg(pi)  
180.0

source

```
Base.Math.hypot– Function.

```

hypot(x, y)

```

#### CHAPTER 43. MATHEMATICS 638

```

Compute the hypotenuse

√  
|x|^2 +|y|^2 avoiding overflow and underflow.  
This code is an implementation of the algorithm described in: An Improved Algorithm forhypot(a,b)by  
Carlos F. Borges The article is available online at ArXiv at the link https://arxiv.org/abs/1904.09481  
hypot(x...)

Compute the hypotenuse

√∑  
|xi|^2 avoiding overflow and underflow.  
Examples

julia> a = Int64 (10)^10;

julia> hypot(a, a)  
1.4142135623730951e10

julia> √(a^2 + a^2) # a^2 overflows  
ERROR: DomainError with -2.914184810805068e18:  
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).  
Stacktrace:  
[...]

julia> hypot(3, 4im)  
5.0

julia> hypot(-5.7)  
5.7

julia> hypot(3, 4im, 12.0)  
13.0

source

```
Base.log– Method.

```

log(x)

Compute the natural logarithm ofx. ThrowsDomainErrorfor negativeRealarguments. Use complex  
negative arguments to obtain complex results.  
See also [log1p], [log2], [log10].  
Examples

julia> log(2)  
0.6931471805599453

julia> log(-3)  
ERROR: DomainError with -3.0:  
log will only return a complex result if called with a complex argument. Try log(Complex(x)).  
Stacktrace:  
[1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31  
[...]

source

```
Base.log– Method.


#### CHAPTER 43. MATHEMATICS 639

```

log(b,x)

Compute the baseblogarithm ofx. ThrowsDomainErrorfor negativeRealarguments.  
Examples

julia> log(4,8)  
1.5

julia> log(4,2)  
0.5

julia> log(-2, 3)  
ERROR: DomainError with -2.0:  
log will only return a complex result if called with a complex argument. Try log(Complex(x)).  
Stacktrace:  
[1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31  
[...]

julia> log(2, -3)  
ERROR: DomainError with -3.0:  
log will only return a complex result if called with a complex argument. Try log(Complex(x)).  
Stacktrace:  
[1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31  
[...]

Note  
Ifbis a power of 2 or 10,log2orlog10should be used, as these will typically be faster and  
more accurate. For example,  
julia> log(100,1000000)  
2.9999999999999996

julia> log10( 1000000 )/2  
3.0

source

```
Base.log2– Function.

```

log2(x)

Compute the logarithm ofxto base 2. ThrowsDomainErrorfor negativeRealarguments.  
See also:exp2,ldexp,ispow2.  
Examples

julia> log2(4)  
2.0

julia> log2(10)  
3.321928094887362

julia> log2(-2)  
ERROR: DomainError with -2.0:  
log2 will only return a complex result if called with a complex argument. Try log2(Complex(x)).

```

#### CHAPTER 43. MATHEMATICS 640

```

Stacktrace:  
[1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31  
[...]

source

```
Base.log10– Function.

```

log10(x)

Compute the logarithm ofxto base 10. ThrowsDomainErrorfor negativeRealarguments.  
Examples

julia> log10(100)  
2.0

julia> log10(2)  
0.3010299956639812

julia> log10(-2)  
ERROR: DomainError with -2.0:  
log10 will only return a complex result if called with a complex argument. Try  
↪→ log10(Complex(x)).  
Stacktrace:  
[1] throw_complex_domainerror(f::Symbol, x::Float64) at ./math.jl:31  
[...]

source

```
Base.log1p– Function.

```

log1p(x)

Accurate natural logarithm of1+x. ThrowsDomainErrorforRealarguments less than -1.  
Examples

julia> log1p(-0.5)  
-0.6931471805599453

julia> log1p(0)  
0.0

julia> log1p(-2)  
ERROR: DomainError with -2.0:  
log1p will only return a complex result if called with a complex argument. Try  
↪→ log1p(Complex(x)).  
Stacktrace:  
[1] throw_complex_domainerror(::Symbol, ::Float64) at ./math.jl:31  
[...]

source

```
Base.Math.frexp– Function.

```

frexp(val)

```

#### CHAPTER 43. MATHEMATICS 641

```

Return(x,exp)such thatxhas a magnitude in the interval[1/2,1)or 0, andvalis equal tox× 2 exp.  
Examples

julia> frexp(12.8)  
(0.8, 4)

source

```
Base.exp– Method.

```

exp(x)

Compute the natural base exponential ofx, in other wordsx.  
See alsoexp2,exp10andcis.  
Examples

julia> exp(1.0)  
2.718281828459045

julia> exp(im * pi) == cis(pi)  
true

source

```
Base.exp2– Function.

```

exp2(x)

Compute the base 2 exponential ofx, in other words 2 x.  
See alsoldexp,<<.  
Examples

julia> exp2(5)  
32.0

julia> 2^5  
32

julia> exp2(63) > typemax( Int )  
true

source

```
Base.exp10– Function.

```

exp10(x)

Compute the base 10 exponential ofx, in other words 10 x.  
Examples

julia> exp10(2)  
100.0

julia> 10^2  
100

```

#### CHAPTER 43. MATHEMATICS 642

```

source

```
Base.Math.ldexp– Function.

```

ldexp(x, n)

Computex× 2 n.  
Examples

julia> ldexp(5., 2)  
20.0

source

```
Base.Math.modf– Function.

```

modf(x)

Return a tuple(fpart, ipart)of the fractional and integral parts of a number. Both parts have the same  
sign as the argument.  
Examples

julia> modf(3.5)  
(0.5, 3.0)

julia> modf(-3.5)  
(-0.5, -3.0)

source

```
Base.expm1– Function.

```

expm1(x)

Accurately computeex− 1. It avoids the loss of precision involved in the direct evaluation of exp(x)-1 for  
small values of x.  
Examples

julia> expm1(1e-16)  
1.0e-16

julia> exp(1e-16) - 1  
0.0

source

```
Base.round– Method.

```

round([T,] x, [r:: RoundingMode ])  
round(x, [r:: RoundingMode ]; digits:: Integer =0, base= 10)  
round(x, [r:: RoundingMode ]; sigdigits:: Integer , base= 10)

```

#### CHAPTER 43. MATHEMATICS 643

```

Rounds the numberx.  
Without keyword arguments,xis rounded to an integer value, returning a value of typeT, or of the same  
type ofxif noTis provided. AnInexactErrorwill be thrown if the value is not representable byT, similar  
toconvert.  
If thedigitskeyword argument is provided, it rounds to the specified number of digits after the decimal  
place (or before if negative), in basebase.  
If thesigdigitskeyword argument is provided, it rounds to the specified number of significant digits, in  
basebase.  
TheRoundingModercontrols the direction of the rounding; the default isRoundNearest, which rounds to  
the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note  
thatroundmay give incorrect results if the global rounding mode is changed (seerounding).  
Examples

julia> round(1.7)  
2.0

julia> round( Int , 1.7)  
2

julia> round(1.5)  
2.0

julia> round(2.5)  
2.0

julia> round(pi; digits=2)  
3.14

julia> round(pi; digits=3, base=2)  
3.125

julia> round(123.456; sigdigits=2)  
120.0

julia> round(357.913; sigdigits=4, base=2)  
352.0

Note  
Rounding to specified digits in bases other than 2 can be inexact when operating on binary  
floating point numbers. For example, theFloat64value represented by1.15is actually less  
than 1.15, yet will be rounded to 1.2.

```

**Chapter 44**

**Examples**

```

julia> x = 1.15  
1.15

julia> @sprintf" %.20f " x  
"1.14999999999999991118"

julia> x < 115//100  
true

julia> round(x, digits=1)  
1.2

Extensions  
Toextendroundtonewnumerictypes,itistypicallysufficienttodefineBase.round(x::NewType, r::RoundingMode).  
source

```
Base.Rounding.RoundingMode– Type.

```

RoundingMode

A type used for controlling the rounding mode of floating point operations (viarounding/setrounding  
functions), or as optional arguments for rounding to the nearest integer (via theroundfunction).  
Currently supported rounding modes are:

```
- RoundNearest(default)
- RoundNearestTiesAway
- RoundNearestTiesUp
- RoundToZero
- RoundFromZero(BigFloatonly)
- RoundUp
- RoundDown

```

source

```
Base.Rounding.RoundNearest– Constant.

```

RoundNearest

```
#### 644


#### CHAPTER 44. EXAMPLES 645

```

Thedefaultroundingmode. Roundstothenearestinteger,withties(fractionalvaluesof0.5)beingrounded  
to the nearest even integer.  
source

```
Base.Rounding.RoundNearestTiesAway– Constant.

```

RoundNearestTiesAway

Rounds to nearest integer, with ties rounded away from zero (C/C++roundbehaviour).  
source

```
Base.Rounding.RoundNearestTiesUp– Constant.

```

RoundNearestTiesUp

Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScriptroundbehaviour).  
source

```
Base.Rounding.RoundToZero– Constant.

```

RoundToZero

roundusing this rounding mode is an alias fortrunc.  
source

```
Base.Rounding.RoundFromZero– Constant.

```

RoundFromZero

Rounds away from zero. This rounding mode may only be used withT == BigFloatinputs toround.  
Examples

julia>BigFloat ("1.0000000000000001", 5, RoundFromZero)  
1.06

source

```
Base.Rounding.RoundUp– Constant.

```

RoundUp

roundusing this rounding mode is an alias forceil.  
source

```
Base.Rounding.RoundDown– Constant.

```

RoundDown

roundusing this rounding mode is an alias forfloor.  
source

```
Base.round– Method.


#### CHAPTER 44. EXAMPLES 646

```

round(z:: Complex [, RoundingModeReal, [RoundingModeImaginary]])  
round(z:: Complex [, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)  
round(z:: Complex [, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)

Return the nearest integral value of the same type as the complex-valuedztoz, breaking ties using the  
specifiedRoundingModes. The firstRoundingModeis used for rounding the real components while the  
second is used for rounding the imaginary components.  
Example

julia> round(3.14+ 4.5im)  
3.0 + 4.0im

source

```
Base.ceil– Function.

```

ceil([T,] x)  
ceil(x; digits:: Integer = [, base= 10])  
ceil(x; sigdigits:: Integer = [, base= 10])

ceil(x)returns the nearest integral value of the same type asxthat is greater than or equal tox.  
ceil(T, x)converts the result to typeT, throwing anInexactErrorif the value is not representable.  
Keywordsdigits,sigdigitsandbasework as forround.  
source

```
Base.floor– Function.

```

floor([T,] x)  
floor(x; digits:: Integer = [, base= 10])  
floor(x; sigdigits:: Integer = [, base= 10])

floor(x)returns the nearest integral value of the same type asxthat is less than or equal tox.  
floor(T, x)converts the result to typeT, throwing anInexactErrorif the value is not representable.  
Keywordsdigits,sigdigitsandbasework as forround.  
source

```
Base.trunc– Function.

```

trunc([T,] x)  
trunc(x; digits:: Integer = [, base= 10])  
trunc(x; sigdigits:: Integer = [, base= 10])

trunc(x)returns the nearest integral value of the same type asxwhose absolute value is less than or  
equal to the absolute value ofx.  
trunc(T, x)converts the result to typeT, throwing anInexactErrorif the value is not representable.  
Keywordsdigits,sigdigitsandbasework as forround.  
See also:%,floor,unsigned,unsafe_trunc.  
Examples

```

#### CHAPTER 44. EXAMPLES 647

```

julia> trunc(2.22)  
2.0

julia> trunc(-2.22, digits=1)  
-2.2

julia> trunc( Int , -2.22)  
-2

source

```
Base.unsafe_trunc– Function.

```

unsafe_trunc(T, x)

Return the nearest integral value of typeTwhose absolute value is less than or equal to the absolute value  
ofx. If the value is not representable byT, an arbitrary value will be returned. See alsotrunc.  
Examples

julia> unsafe_trunc( Int , -2.2)  
-2

julia> unsafe_trunc( Int , NaN)  
-9223372036854775808

source

```
Base.min– Function.

```

min(x, y,...)

Return the minimum of the arguments (with respect toisless). See also theminimumfunction to take the  
minimum element from a collection.  
Examples

julia> min(2, 5, 1)  
1

source

```
Base.max– Function.

```

max(x, y,...)

Return the maximum of the arguments (with respect toisless). See also themaximumfunction to take  
the maximum element from a collection.  
Examples

julia> max(2, 5, 1)  
5

source

```
Base.minmax– Function.


#### CHAPTER 44. EXAMPLES 648

```

minmax(x, y)

Return(min(x,y), max(x,y)).  
See alsoextremathat returns(minimum(x), maximum(x)).  
Examples

julia> minmax('c','b')  
('b', 'c')

source

```
Base.Math.clamp– Function.

```

clamp(x, lo, hi)

Returnxiflo <= x <= hi. Ifx > hi, returnhi. Ifx < lo, returnlo. Arguments are promoted to a  
common type.  
See alsoclamp!,min,max.  
Examples

julia> clamp.([pi, 1.0, big(10)], 2.0, 9.0)  
3-element Vector{BigFloat}:  
3.141592653589793238462643383279502884197169399375105820974944592307816406286198  
2.0  
9.0

julia> clamp.([11, 8, 5], 10, 6) # an example where lo > hi  
3-element Vector{Int64}:  
6  
6  
10

source  
clamp(x, T)::T

Clampxbetweentypemin(T)andtypemax(T)and convert the result to typeT.  
See alsotrunc.  
Examples

julia> clamp(200, Int8 )  
127

julia> clamp(-200, Int8 )  
-128

julia> trunc( Int , 4pi^2)  
39

source  
clamp(x::Integer, r::AbstractUnitRange)

```

#### CHAPTER 44. EXAMPLES 649

```

Clampxto lie within ranger.

Julia 1.6  
This method requires at least Julia 1.6.

source

```
Base.Math.clamp!– Function.

```

clamp!(array:: AbstractArray , lo, hi)

Restrict values inarrayto the specified range, in-place. See alsoclamp.  
Examples

julia> row = collect(-4:4)';

julia> clamp!(row,0, Inf)  
1×9 adjoint(::Vector{Int64}) with eltype Int64:  
0 0 0 0 0 1 2 3 4

julia> clamp.((-4:4)', 0, Inf)  
1×9 Matrix{Float64}:  
0.0 0.0 0.0 0.0 0.0 1.0 2.0 3.0 4.0

source

```
Base.abs– Function.

```

abs(x)

The absolute value ofx.  
Whenabsis applied to signed integers, overflow may occur, resulting in the return of a negative value.  
This overflow occurs only whenabsis applied to the minimum representable value of a signed integer.  
That is, whenx == typemin(typeof(x)),abs(x) == x < 0, not-xas might be expected.  
See also:abs2,unsigned,sign.  
Examples

julia> abs(-3)  
3

julia> abs(1 + im)  
1.4142135623730951

julia> abs(typemin( Int64 ))  
-9223372036854775808

source

```
Base.Checked.checked_abs– Function.

```

Base.checked_abs(x)

```

#### CHAPTER 44. EXAMPLES 650

```

Calculatesabs(x), checking for overflow errors where applicable. For example, standard two's comple-  
ment signed integers (e.g.Int) cannot representabs(typemin(Int)), thus leading to an overflow.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_neg– Function.

```

Base.checked_neg(x)

Calculates-x, checking for overflow errors where applicable. For example, standard two's complement  
signed integers (e.g.Int) cannot represent-typemin(Int), thus leading to an overflow.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_add– Function.

```

Base.checked_add(x, y)

Calculatesx+y, checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_sub– Function.

```

Base.checked_sub(x, y)

Calculatesx-y, checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_mul– Function.

```

Base.checked_mul(x, y)

Calculatesx*y, checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_div– Function.

```

Base.checked_div(x, y)

Calculatesdiv(x,y), checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_rem– Function.

```

Base.checked_rem(x, y)

```

#### CHAPTER 44. EXAMPLES 651

```

Calculatesx%y, checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_fld– Function.

```

Base.checked_fld(x, y)

Calculatesfld(x,y), checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_mod– Function.

```

Base.checked_mod(x, y)

Calculatesmod(x,y), checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.checked_cld– Function.

```

Base.checked_cld(x, y)

Calculatescld(x,y), checking for overflow errors where applicable.  
The overflow protection may impose a perceptible performance penalty.  
source

```
Base.Checked.add_with_overflow– Function.

```

Base.add_with_overflow(x, y)-> (r, f)

Calculatesr = x+y, with the flagfindicating whether overflow has occurred.  
source

```
Base.Checked.sub_with_overflow– Function.

```

Base.sub_with_overflow(x, y)-> (r, f)

Calculatesr = x-y, with the flagfindicating whether overflow has occurred.  
source

```
Base.Checked.mul_with_overflow– Function.

```

Base.mul_with_overflow(x, y)-> (r, f)

Calculatesr = x*y, with the flagfindicating whether overflow has occurred.  
source

```
Base.abs2– Function.

```

abs2(x)

```

#### CHAPTER 44. EXAMPLES 652

```

Squared absolute value ofx.  
Examples

julia> abs2(-3)  
9

source

```
Base.copysign– Function.

```

copysign(x, y)-> z

Returnzwhich has the magnitude ofxand the same sign asy.  
Examples

julia> copysign(1, -2)  
-1

julia> copysign(-1, 2)  
1

source

```
Base.sign– Function.

```

sign(x)

Return zero ifx==0andx/|x|otherwise (i.e., ±1 for realx).  
See alsosignbit,zero,copysign,flipsign.  
Examples

julia> sign(-4.0)  
-1.0

julia> sign(99)  
1

julia> sign(-0.0)  
-0.0

julia> sign(0 + im)  
0.0 + 1.0im

source

```
Base.signbit– Function.

```

signbit(x)

Returnstrueif the value of the sign ofxis negative, otherwisefalse.  
See alsosignandcopysign.  
Examples

```

#### CHAPTER 44. EXAMPLES 653

```

julia> signbit(-4)  
true

julia> signbit(5)  
false

julia> signbit(5.5)  
false

julia> signbit(-4.1)  
true

source

```
Base.flipsign– Function.

```

flipsign(x, y)

Returnxwith its sign flipped ifyis negative. For exampleabs(x) = flipsign(x,x).  
Examples

julia> flipsign(5, 3)  
5

julia> flipsign(5, -3)  
-5

source

```
Base.sqrt– Method.

```

sqrt(x)

Return

√  
x. ThrowsDomainErrorfor negativeRealarguments. Use complex negative arguments instead.  
The prefix operator√is equivalent tosqrt.  
See also:hypot.  
Examples

julia> sqrt(big(81))  
9.0

julia> sqrt(big(-81))  
ERROR: DomainError with -81.0:  
NaN result for non-NaN input.  
Stacktrace:  
[1] sqrt(::BigFloat) at ./mpfr.jl:501  
[...]

julia> sqrt(big(complex(-81)))  
0.0 + 9.0im

julia> .√(1:4)  
4-element Vector{Float64}:  
1.0

```

#### CHAPTER 44. EXAMPLES 654

```

1.4142135623730951  
1.7320508075688772  
2.0

source

```
Base.isqrt– Function.

```

isqrt(n:: Integer )

Integer square root: the largest integermsuch thatm*m <= n.

julia> isqrt(5)  
2

source

```
Base.Math.cbrt– Function.

```

cbrt(x:: Real )

Return the cube root ofx, i.e.x1/3. Negative values are accepted (returning the negative real root when  
x < 0 ).  
The prefix operator∛is equivalent tocbrt.  
Examples

julia> cbrt(big(27))  
3.0

julia> cbrt(big(-27))  
-3.0

source

```
Base.real– Method.

```

real(z)

Return the real part of the complex numberz.  
See also:imag,reim,complex,isreal,Real.  
Examples

julia> real(1 + 3im)  
1

source

```
Base.imag– Function.

```

imag(z)

Return the imaginary part of the complex numberz.  
See also:conj,reim,adjoint,angle.  
Examples

```

#### CHAPTER 44. EXAMPLES 655

```

julia> imag(1 + 3im)  
3

source

```
Base.reim– Function.

```

reim(z)

Return both the real and imaginary parts of the complex numberz.  
Examples

julia> reim(1 + 3im)  
(1, 3)

source

```
Base.conj– Function.

```

conj(z)

Compute the complex conjugate of a complex numberz.  
See also:angle,adjoint.  
Examples

julia> conj(1 + 3im)  
1 - 3im

source

```
Base.angle– Function.

```

angle(z)

Compute the phase angle in radians of a complex numberz.  
See also:atan,cis.  
Examples

julia> rad2deg(angle(1 + im))  
45.0

julia> rad2deg(angle(1 - im))  
-45.0

julia> rad2deg(angle(-1 - im))  
-135.0

source

```
Base.cis– Function.

```

cis(z)

```

#### CHAPTER 44. EXAMPLES 656

```

Returnexp(iz).  
See alsocispi,angle.  
Examples

julia> cis(π) ≈ -1  
true

source

cis(A:: AbstractMatrix )

```
Computeexp(iA)for a square matrixA.

```

Julia 1.7  
Support for usingciswith matrices was added in Julia 1.7.

Examples

julia> cis([π 0; 0 π]) ≈-I  
true

```
Base.cispi– Function.

```

cispi(z)

Computeexp(iπx)more accurately thancis(pi*x), especially for largex.  
Examples

julia> cispi(1)  
-1.0 + 0.0im

julia> cispi(0.25+ 1im)  
0.030556854645952924 + 0.030556854645952924im

Julia 1.6  
This function requires Julia 1.6 or later.

source

```
Base.binomial– Function.

```

binomial(n:: Integer , k :: Integer )

The binomial coefficient

(n  
k

)  
, being the coefficient of thekth term in the polynomial expansion of(1+x)n.  
Ifnis non-negative, then it is the number of ways to choosekout ofnitems:

(  
n  
k

# )

n!  
k!(n−k)!

```
wheren!is thefactorialfunction.


#### CHAPTER 44. EXAMPLES 657

Ifnis negative, then it is defined in terms of the identity

```

(  
n  
k

)  
= (−1)k

(  
k−n− 1  
k

```
)

```

See alsofactorial.  
Examples

julia> binomial(5, 3)  
10

julia> factorial(5) ÷ (factorial(5-3) * factorial(3))  
10

julia> binomial(-5, 3)  
-35

External links

```
- Binomial coefficienton Wikipedia.

```

source

```
Base.factorial– Function.

```

factorial(n:: Integer )

Factorial ofn. Ifnis anInteger, the factorial is computed as an integer (promoted to at least 64 bits).  
Note that this may overflow ifnis not small, but you can usefactorial(big(n))to compute the result  
exactly in arbitrary precision.  
See alsobinomial.  
Examples

julia> factorial(6)  
720

julia> factorial(21)  
ERROR: OverflowError: 21 is too large to look up in the table; consider using  
↪→ `factorial(big(21))` instead  
Stacktrace:  
[...]

julia> factorial(big(21))  
51090942171709440000

External links

```
- Factorialon Wikipedia.

```

source

```
Base.gcd– Function.


#### CHAPTER 44. EXAMPLES 658

```

gcd(x, y...)

Greatest common (positive) divisor (or zero if all arguments are zero). The arguments may be integer and  
rational numbers.

Julia 1.4  
Rational arguments require Julia 1.4 or later.

Examples

julia> gcd(6,9)  
3

julia> gcd(6,-9)  
3

julia> gcd(6,0)  
6

julia> gcd(0,0)  
0

julia> gcd(1//3,2//3)  
1//3

julia> gcd(1//3,-2//3)  
1//3

julia> gcd(1//3,2)  
1//3

julia> gcd(0, 0, 10, 15)  
5

source

```
Base.lcm– Function.

```

lcm(x, y...)

Least common (positive) multiple (or zero if any argument is zero). The arguments may be integer and  
rational numbers.

Julia 1.4  
Rational arguments require Julia 1.4 or later.

Examples

julia> lcm(2,3)  
6

julia> lcm(-2,3)  
6

julia> lcm(0,3)

```

#### CHAPTER 44. EXAMPLES 659

```

0

julia> lcm(0,0)  
0

julia> lcm(1//3,2//3)  
2//3

julia> lcm(1//3,-2//3)  
2//3

julia> lcm(1//3,2)  
2//1

julia> lcm(1,3,5,7)  
105

source

```
Base.gcdx– Function.

```

gcdx(a, b)

Computes the greatest common (positive) divisor ofaandband their Bézout coefficients, i.e. the integer  
coefficientsuandvthat satisfyua+vb=d=gcd(a, b).gcdx(a, b)returns(d, u, v).  
The arguments may be integer and rational numbers.

Julia 1.4  
Rational arguments require Julia 1.4 or later.

Examples

julia> gcdx(12, 42)  
(6, -3, 1)

julia> gcdx(240, 46)  
(2, -9, 47)

Note  
Bézout coefficients are not uniquely defined. gcdxreturns the minimal Bézout coefficients  
that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325,  
Algorithm X.) For signed integers, these coefficientsuandvare minimal in the sense that  
|u|<|y/d|and|v|<|x/d|. Furthermore, the signs ofuandvare chosen so thatdis positive.  
For unsigned integers, the coefficientsuandvmight be near theirtypemax, and the identity  
then holds only via the unsigned integers' modulo arithmetic.

source

```
Base.ispow2– Function.

```

ispow2(n:: Number ) -> Bool

Test whethernis an integer power of two.  
See alsocount_ones,prevpow,nextpow.  
Examples

```

#### CHAPTER 44. EXAMPLES 660

```

julia> ispow2(4)  
true

julia> ispow2(5)  
false

julia> ispow2(4.5)  
false

julia> ispow2(0.25)  
true

julia> ispow2(1//8)  
true

Julia 1.6  
Support for non-Integerarguments was added in Julia 1.6.

source

```
Base.nextpow– Function.

```

nextpow(a, x)

The smallesta^nnot less thanx, wherenis a non-negative integer.amust be greater than 1, andxmust  
be greater than 0.  
See alsoprevpow.  
Examples

julia> nextpow(2, 7)  
8

julia> nextpow(2, 9)  
16

julia> nextpow(5, 20)  
25

julia> nextpow(4, 16)  
16

source

```
Base.prevpow– Function.

```

prevpow(a, x)

The largesta^nnot greater thanx, wherenis a non-negative integer.amust be greater than 1, andx  
must not be less than 1.  
See alsonextpow,isqrt.  
Examples

```

#### CHAPTER 44. EXAMPLES 661

```

julia> prevpow(2, 7)  
4

julia> prevpow(2, 9)  
8

julia> prevpow(5, 20)  
5

julia> prevpow(4, 16)  
16

source

```
Base.nextprod– Function.

```

nextprod(factors:: Union { Tuple , AbstractVector }, n)

Nextintegergreaterthanorequaltonthatcanbewrittenas

∏  
kpiiforintegersp 1 ,p 2 , etcetera, forfactors  
kiinfactors.  
Examples

julia> nextprod((2, 3), 105)  
108

julia> 2^2 * 3^3  
108

Julia 1.6  
The method that accepts a tuple requires Julia 1.6 or later.

source

```
Base.invmod– Function.

```

invmod(n, m)

Take the inverse ofnmodulom:ysuch thatny= 1 (modm), anddiv(y, m) = 0. This will throw an  
error ifm= 0, or ifgcd(n, m) 6 = 1.  
Examples

julia> invmod(2,5)  
3

julia> invmod(2,3)  
2

julia> invmod(5,6)  
5

source

```
Base.powermod– Function.

```

powermod(x:: Integer , p :: Integer , m)

```

#### CHAPTER 44. EXAMPLES 662

```

Computexp(modm).  
Examples

julia> powermod(2, 6, 5)  
4

julia> mod(2^6, 5)  
4

julia> powermod(5, 2, 20)  
5

julia> powermod(5, 2, 19)  
6

julia> powermod(5, 3, 19)  
11

source

```
Base.ndigits– Function.

```

ndigits(n:: Integer ; base:: Integer =10, pad:: Integer =1)

Computethenumberofdigitsinintegernwritteninbasebase(basemustnotbein[-1, 0, 1]),optionally  
padded with zeros to a specified size (the result will never be less thanpad).  
See alsodigits,count_ones.  
Examples

julia> ndigits( 12345 )  
5

julia> ndigits(1022, base=16)  
3

julia> string(1022, base=16)  
"3fe"

julia> ndigits(123, pad=5)  
5

julia> ndigits(-123)  
3

source

```
Base.add_sum– Function.

```

Base.add_sum(x, y)

The reduction operator used insum. The main difference from+is that small integers are promoted to  
Int/UInt.  
source

```

#### CHAPTER 44. EXAMPLES 663

Base.widemul– Function.

```

widemul(x, y)

Multiplyxandy, giving the result as a larger type.  
See alsopromote,Base.add_sum.  
Examples

julia> widemul( Float32 (3.0), 4.0) isa BigFloat  
true

julia> typemax( Int8 ) * typemax( Int8 )  
1

julia> widemul(typemax( Int8 ), typemax( Int8 )) # == 127^2  
16129

source

```
Base.Math.evalpoly– Function.

```

evalpoly(x, p)

Evaluate the polynomial

∑  
kx

```
k− (^1) p[k]for the coefficientsp[1],p[2], ...; that is, the coefficients are given
in ascending order by power ofx. Loops are unrolled at compile time if the number of coefficients is
statically known, i.e. whenpis aTuple. This function generates efficient code using Horner's method ifx
is real, or using a Goertzel-like^1 algorithm ifxis complex.
**Julia 1.4**
This function requires Julia 1.4 or later.
**Example
julia>** evalpoly(2, ( 1, 2, 3))
17
source
Base.Math.@evalpoly– Macro.
@evalpoly(z, c...)
Evaluate the polynomial
∑
kz
k− (^1) c[k]for the coefficientsc[1],c[2], ...; that is, the coefficients are given
in ascending order by power ofz. This macro expands to efficient inline code that uses either Horner's
method or, for complexz, a more efficient Goertzel-like algorithm.
See alsoevalpoly.
**Examples**
(^1) Donald Knuth, Art of Computer Programming, Volume 2: Seminumerical Algorithms, Sec. 4.6.4.


#### CHAPTER 44. EXAMPLES 664

```

julia> @evalpoly(3, 1, 0, 1)  
10

julia> @evalpoly(2, 1, 0, 1)  
5

julia> @evalpoly(2, 1, 1, 1)  
7

source

```
Base.FastMath.@fastmath– Macro.

```

@fastmathexpr

Execute a transformed version of the expression, which calls functions that may violate strict IEEE seman-  
tics. This allows the fastest possible operation, but results are undefined – be careful when doing this, as  
it may change numerical results.  
This sets theLLVM Fast-Math flags, and corresponds to the-ffast-mathoption in clang. Seethe notes on  
performance annotationsfor more details.  
Examples

julia> @fastmath1+2  
3

julia> @fastmath(sin(3))  
0.1411200080598672

source

```
### 44.1 Customizable binary operators

Some unicode characters can be used to define new binary operators that support infix notation. For example
⊗(x,y) = kron(x,y)defines the⊗(otimes) function to be the Kronecker product, and one can call it as binary
operator using infix syntax:C = A ⊗ Bas well as with the usual prefix syntaxC = ⊗(A,B).

Other characters that support such extensions include \odot⊙and \oplus⊕

The complete list is in the parser code:https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm

Those that are parsed like*(in terms of precedence) include* / ÷ % & ⋅ ∘ × |\\| ∩ ∧ ⊗ ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓
∗ ∙ ⋄ ⋆ ⋏ ⊍ ▷ and those that are parsed like+
include+ - |\|| ⊕ ⊖ ⊞ ⊟ |++| ∪ ∨ ⊔ ± ∓ ∸ ≏ ⊎⊻ ⋎ ⧺ ⧻ There
are many others that are related to arrows, comparisons, and powers.


**Chapter 45**

**Numbers**

### 45.1 Standard Numeric Types.

### Abstract number types

Core.Number– Type.

```

Number

Abstract supertype for all number types.  
source

```
Core.Real– Type.

```

Real <: Number

Abstract supertype for all real numbers.  
source

```
Core.AbstractFloat– Type.

```

AbstractFloat <: Real

Abstract supertype for all floating point numbers.  
source

```
Core.Integer– Type.

```

Integer <: Real

Abstract supertype for all integers.  
source

```
Core.Signed– Type.

```

Signed <: Integer

Abstract supertype for all signed integers.  
source

```
#### 665


#### CHAPTER 45. NUMBERS 666

Core.Unsigned– Type.

```

Unsigned <: Integer

Abstract supertype for all unsigned integers.  
source

```
Base.AbstractIrrational– Type.

```

AbstractIrrational<: Real

Numbertyperepresentinganexactirrationalvalue, whichisautomaticallyroundedtothecorrectprecision  
in arithmetic operations with other numeric quantities.  
SubtypesMyIrrational <: AbstractIrrationalshouldimplementatleast==(::MyIrrational, ::MyIrrational),  
hash(x::MyIrrational, h::UInt),andconvert(::Type{F}, x::MyIrrational) where {F <: Union{BigFloat,Float32,Float64}}.  
If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that  
represents√nfor integersnwill give a rational result whennis a perfect square), then it should also  
implementisinteger,iszero,isone, and==withRealvalues (since all of these default tofalsefor  
AbstractIrrationaltypes), as well as defininghashto equal that of the correspondingRational.  
source

```
### Concrete number types

Core.Float16– Type.

```

Float16 <: AbstractFloat

16-bit floating point number type (IEEE 754 standard).  
Binary format: 1 sign, 5 exponent, 10 fraction bits.  
source

```
Core.Float32– Type.

```

Float32 <: AbstractFloat

32-bit floating point number type (IEEE 754 standard).  
Binary format: 1 sign, 8 exponent, 23 fraction bits.  
source

```
Core.Float64– Type.

```

Float64 <: AbstractFloat

64-bit floating point number type (IEEE 754 standard).  
Binary format: 1 sign, 11 exponent, 52 fraction bits.  
source

```
Base.MPFR.BigFloat– Type.

```

BigFloat <: AbstractFloat

```

#### CHAPTER 45. NUMBERS 667

```

Arbitrary precision floating point number type.  
source

```
Core.Bool– Type.

```

Bool <: Integer

Boolean type, containing the valuestrueandfalse.  
Boolis a kind of number:falseis numerically equal to 0 andtrueis numerically equal to 1. Moreover,  
falseacts as a multiplicative"strong zero":

julia>false == 0  
true

julia>true == 1  
true

julia> 0 * NaN  
NaN

julia>false * NaN  
0.0

See also:digits,iszero,NaN.  
source

```
Core.Int8– Type.

```

Int8 <: Signed

8-bit signed integer type.  
source

```
Core.UInt8– Type.

```

UInt8 <: Unsigned

8-bit unsigned integer type.  
source

```
Core.Int16– Type.

```

Int16 <: Signed

16-bit signed integer type.  
source

```
Core.UInt16– Type.

```

UInt16 <: Unsigned

16-bit unsigned integer type.  
source

```

#### CHAPTER 45. NUMBERS 668

Core.Int32– Type.

```

Int32 <: Signed

32-bit signed integer type.  
source

```
Core.UInt32– Type.

```

UInt32 <: Unsigned

32-bit unsigned integer type.  
source

```
Core.Int64– Type.

```

Int64 <: Signed

64-bit signed integer type.  
source

```
Core.UInt64– Type.

```

UInt64 <: Unsigned

64-bit unsigned integer type.  
source

```
Core.Int128– Type.

```

Int128 <: Signed

128-bit signed integer type.  
source

```
Core.UInt128– Type.

```

UInt128 <: Unsigned

128-bit unsigned integer type.  
source

```
Base.GMP.BigInt– Type.

```

BigInt <: Signed

Arbitrary precision integer type.  
source

```
Base.Complex– Type.

```

Complex {T<: Real } <: Number

```

#### CHAPTER 45. NUMBERS 669

```

Complex number type with real and imaginary part of typeT.  
ComplexF16,ComplexF32andComplexF64arealiasesforComplex{Float16},Complex{Float32}andComplex{Float64}  
respectively.  
See also:Real,complex,real.  
source

```
Base.Rational– Type.

```

Rational {T<: Integer } <: Real

Rational number type, with numerator and denominator of typeT. Rationals are checked for overflow.  
source

```
Base.Irrational– Type.

```

Irrational {sym}<: AbstractIrrational

Number type representing an exact irrational value denoted by the symbolsym, such asπ, andγ.  
See also [@irrational],AbstractIrrational.  
source

```
### 45.2 Data Formats

Base.digits– Function.

```

digits([T<: Integer ], n :: Integer ; base::T = 10, pad:: Integer = 1)

ReturnanarraywithelementtypeT(defaultInt)ofthedigitsofninthegivenbase, optionallypaddedwith  
zerostoaspecifiedsize. Moresignificantdigitsareathigherindices,suchthatn == sum(digits[k]*base^(k-1)  
for k=1:length(digits)).  
See alsondigits,digits!, and for base 2 alsobitstring,count_ones.  
Examples

julia> digits(10)  
2-element Vector{Int64}:  
0  
1

julia> digits(10, base= 2)  
4-element Vector{Int64}:  
0  
1  
0  
1

julia> digits(-256, base= 10, pad= 5)  
5-element Vector{Int64}:  
-6  
-5  
-2  
0

```

#### CHAPTER 45. NUMBERS 670

```

0

julia> n = rand(-999:999);

julia> n == evalpoly(13, digits(n, base= 13))  
true

source

```
Base.digits!– Function.

```

digits!(array, n:: Integer ; base:: Integer = 10)

Fills an array of the digits ofnin the given base. More significant digits are at higher indices. If the array  
length is insufficient, the least significant digits are filled up to the array length. If the array length is  
excessive, the excess portion is filled with zeros.  
Examples

julia> digits!([2,2,2,2], 10, base= 2)  
4-element Vector{Int64}:  
0  
1  
0  
1

julia> digits!([2,2,2,2,2,2], 10, base= 2)  
6-element Vector{Int64}:  
0 1 0 1 0 0

source

```
Base.bitstring– Function.

```

bitstring(n)

A string giving the literal bit representation of a number.  
See alsocount_ones,count_zeros,digits.  
Examples

julia> bitstring( Int32 (4))  
"00000000000000000000000000000100"

julia> bitstring(2.2)  
"0100000000000001100110011001100110011001100110011001100110011010"

source

```
Base.parse– Function.

```

parse( type , str; base)

```

#### CHAPTER 45. NUMBERS 671

```

Parse a string as a number. ForIntegertypes, a base can be specified (the default is 10). For floating-  
pointtypes,thestringisparsedasadecimalfloating-pointnumber.Complextypesareparsedfromdecimal  
strings of the form"R±Iim"as aComplex(R,I)of the requested type;"i"or"j"can also be used instead  
of"im", and"R"or"Iim"are also permitted. If the string does not contain a valid number, an error is  
raised.

Julia 1.1  
parse(Bool, str)requires at least Julia 1.1.

Examples

julia> parse( Int , "1234")  
1234

julia> parse( Int , "1234", base= 5)  
194

julia> parse( Int , "afc", base= 16)  
2812

julia> parse( Float64 , "1.2e-3")  
0.0012

julia> parse( Complex { Float64 }, "3.2e-1 + 4.5im")  
0.32 + 4.5im

source  
parse(::Type{Platform}, triplet::AbstractString)

Parses a string platform triplet back into aPlatformobject.  
source

```
Base.tryparse– Function.

```

tryparse( type , str; base)

Likeparse, but returns either a value of the requested type, ornothingif the string does not contain a  
valid number.  
source

```
Base.big– Function.

```

big(x)

Convert a number to a maximum precision representation (typicallyBigIntorBigFloat). SeeBigFloat  
for information about some pitfalls with floating-point numbers.  
source

```
Base.signed– Function.

```

signed(T:: Integer )

Convert an integer bitstype to the signed type of the same size.  
Examples

```

#### CHAPTER 45. NUMBERS 672

```

julia> signed( UInt16 )  
Int16  
julia> signed( UInt64 )  
Int64

source  
signed(x)

Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without  
checking for overflow.  
See also:unsigned,sign,signbit.  
source

```
Base.unsigned– Function.

```

unsigned(T:: Integer )

Convert an integer bitstype to the unsigned type of the same size.  
Examples

julia> unsigned( Int16 )  
UInt16  
julia> unsigned( UInt64 )  
UInt64

source

```
Base.float– Method.

```

float(x)

Convert a number or array to a floating point data type.  
See also:complex,oftype,convert.  
Examples

julia> float(1:1000)  
1.0:1.0:1000.0

julia> float(typemax( Int32 ))  
2.147483647e9

source

```
Base.Math.significand– Function.

```

significand(x)

Extractthesignificand(s)(a.k.a. mantissa), inbinaryrepresentation, ofafloating-pointnumber. Ifxisa  
non-zero finite number, then the result will be a number of the same type on the interval[1,2). Otherwise  
xis returned.  
Examples

```

#### CHAPTER 45. NUMBERS 673

```

julia> significand(15.2)/15.2  
0.125

julia> significand(15.2)*8  
15.2

source

```
Base.Math.exponent– Function.

```

exponent(x:: AbstractFloat ) -> Int

Get the exponent of a normalized floating-point number. Returns the largest integerysuch that2^y ≤  
abs(x).  
Examples

julia> exponent(6.5)  
2

julia> exponent(16.0)  
4

source

```
Base.complex– Method.

```

complex(r, [i])

Convert real numbers or arrays to complex.idefaults to zero.  
Examples

julia> complex(7)  
7 + 0im

julia> complex([1, 2, 3])  
3-element Vector{Complex{Int64}}:  
1 + 0im  
2 + 0im  
3 + 0im

source

```
Base.bswap– Function.

```

bswap(n)

Reverse the byte order ofn.  
(See alsontohandhtonto convert between the current native byte order and big-endian order.)  
Examples

julia> a = bswap(0x10203040)  
0x40302010

julia> bswap(a)

```

#### CHAPTER 45. NUMBERS 674

```

0x10203040

julia> string(1, base= 2)  
"1"

julia> string(bswap(1), base= 2)  
"100000000000000000000000000000000000000000000000000000000"

source

```
Base.hex2bytes– Function.

```

hex2bytes(itr)

Given an iterableitrof ASCII codes for a sequence of hexadecimal digits, returns aVector{UInt8}of  
bytes corresponding to the binary representation: each successive pair of hexadecimal digits initrgives  
the value of one byte in the return vector.  
The length ofitrmust be even, and the returned array has half of the length ofitr. See alsohex2bytes!  
for an in-place version, andbytes2hexfor the inverse.

Julia 1.7  
Callinghex2byteswith iterators producingUInt8values requires Julia 1.7 or later. In earlier  
versions, you cancollectthe iterator before callinghex2bytes.

Examples

julia> s = string( 12345 , base= 16)  
"3039"

julia> hex2bytes(s)  
2-element Vector{UInt8}:  
0x30  
0x39

julia> a = b"01abEF"  
6-element Base.CodeUnits{UInt8, String}:  
0x30  
0x31  
0x61  
0x62  
0x45  
0x46

julia> hex2bytes(a)  
3-element Vector{UInt8}:  
0x01  
0xab  
0xef

source

```
Base.hex2bytes!– Function.

```

hex2bytes!(dest:: AbstractVector { UInt8 }, itr)

```

#### CHAPTER 45. NUMBERS 675

```

Convert an iterableitrof bytes representing a hexadecimal string to its binary representation, similar to  
hex2bytesexcept that the output is written in-place todest. The length ofdestmust be half the length  
ofitr.

Julia 1.7  
Calling hex2bytes! with iterators producing UInt8 requires version 1.7. In earlier versions, you  
can collect the iterable before calling instead.

source

```
Base.bytes2hex– Function.

```

bytes2hex(itr)-> String  
bytes2hex(io:: IO , itr)

Convert an iteratoritrof bytes to its hexadecimal string representation, either returning aStringvia  
bytes2hex(itr)or writing the string to aniostream viabytes2hex(io, itr). The hexadecimal charac-  
ters are all lowercase.

Julia 1.7  
Callingbytes2hexwith arbitrary iterators producingUInt8values requires Julia 1.7 or later. In  
earlier versions, you cancollectthe iterator before callingbytes2hex.

Examples

julia> a = string( 12345 , base= 16)  
"3039"

julia> b = hex2bytes(a)  
2-element Vector{UInt8}:  
0x30  
0x39

julia> bytes2hex(b)  
"3039"

source

```
### 45.3 General Number Functions and Constants

Base.one– Function.

```

one(x)  
one(T:: type )

Returnamultiplicativeidentityforx: avaluesuchthatone(x)_x == x_one(x) == x. Alternativelyone(T)  
can take a typeT, in which caseonereturns a multiplicative identity for anyxof typeT.  
If possible,one(x)returns a value of the same type asx, andone(T)returns a value of typeT. However,  
this may not be the case for types representing dimensionful quantities (e.g. time in days), since the  
multiplicative identity must be dimensionless. In that case,one(x)should return an identity value of the  
same precision (and shape, for matrices) asx.  
If you want a quantity that is of the same type asx, or of typeT, even ifxis dimensionful, useoneunit  
instead.

```

#### CHAPTER 45. NUMBERS 676

```

See also theidentityfunction, andIinLinearAlgebrafor the identity matrix.  
Examples

julia> one(3.7)  
1.0

julia> one( Int )  
1

julia>import Dates; one(Dates.Day(1))  
1

source

```
Base.oneunit– Function.

```

oneunit(x::T)  
oneunit(T:: Type )

ReturnsT(one(x)), whereTis either the type of the argument or (if a type is passed) the argument. This  
differs fromonefor dimensionful quantities:oneis dimensionless (a multiplicative identity) whileoneunit  
is dimensionful (of the same type asx, or of typeT).  
Examples

julia> oneunit(3.7)  
1.0

julia>import Dates; oneunit(Dates.Day)  
1 day

source

```
Base.zero– Function.

```

zero(x)  
zero(:: Type )

Get the additive identity element for the type ofx(xcan also specify the type itself).  
See alsoiszero,one,oneunit,oftype.  
Examples

julia> zero(1)  
0

julia> zero(big"2.0")  
0.0

julia> zero(rand(2,2))  
2×2 Matrix{Float64}:  
0.0 0.0  
0.0 0.0

source

```

#### CHAPTER 45. NUMBERS 677

Base.im– Constant.

```

im

The imaginary unit.  
See also:imag,angle,complex.  
Examples

julia> im * im  
-1 + 0im

julia> (2.0 + 3im)^2  
-5.0 + 12.0im

source

```
Base.MathConstants.pi– Constant.

```

π  
pi

The constant pi.  
Unicodeπcan be typed by writing\pithen pressing tab in the Julia REPL, and in many editors.  
See also:sinpi,sincospi,deg2rad.  
Examples

julia> pi  
π = 3.1415926535897...

julia> 1/2pi  
0.15915494309189535

source

```
Base.MathConstants.– Constant.

```

e

The constant ℯ.  
Unicode can be typed by writing\eulerand pressing tab in the Julia REPL, and in many editors.  
See also:exp,cis,cispi.  
Examples

julia>  
= 2.7182818284590...

julia> log()  
1

julia> ^(im)π ≈ -1  
true

```

#### CHAPTER 45. NUMBERS 678

```

source

```
Base.MathConstants.catalan– Constant.

```

catalan

Catalan's constant.  
Examples

julia> Base.MathConstants.catalan  
catalan = 0.9159655941772...

julia> sum(log(x)/(1+x^2) for x in 1:0.01:10^6) * 0.01  
0.9159466120554123

source

```
Base.MathConstants.eulergamma– Constant.

```

γ  
eulergamma

Euler's constant.  
Examples

julia> Base.MathConstants.eulergamma  
γ = 0.5772156649015...

julia> dx = 10^-6;

julia> sum(-exp(-x) * log(x) for x in dx:dx:100) * dx  
0.5772078382499134

source

```
Base.MathConstants.golden– Constant.

```

φ  
golden

The golden ratio.  
Examples

julia> Base.MathConstants.golden  
φ = 1.6180339887498...

julia> (2ans - 1)^2 ≈ 5  
true

source

```
Base.Inf– Constant.

```

Inf, Inf64

```

#### CHAPTER 45. NUMBERS 679

```

Positive infinity of typeFloat64.  
See also:isfinite,typemax,NaN,Inf32.  
Examples

julia> π/0  
Inf

julia> +1.0 / -0.0  
-Inf

julia> ^-Inf  
0.0

source

```
Base.Inf32– Constant.

```

Inf32

Positive infinity of typeFloat32.  
source

```
Base.Inf16– Constant.

```

Inf16

Positive infinity of typeFloat16.  
source

```
Base.NaN– Constant.

```

NaN, NaN64

A not-a-number value of typeFloat64.  
See also:isnan,missing,NaN32,Inf.  
Examples

julia> 0/0  
NaN

julia> Inf - Inf  
NaN

julia> NaN == NaN, isequal(NaN, NaN), NaN === NaN  
(false, true, true)

source

```
Base.NaN32– Constant.

```

NaN32

A not-a-number value of typeFloat32.  
source

```

#### CHAPTER 45. NUMBERS 680

Base.NaN16– Constant.

```

NaN16

A not-a-number value of typeFloat16.  
source

```
Base.issubnormal– Function.

```

issubnormal(f)-> Bool

Test whether a floating point number is subnormal.  
source

```
Base.isfinite– Function.

```

isfinite(f)-> Bool

Test whether a number is finite.  
Examples

julia> isfinite(5)  
true

julia> isfinite(NaN32)  
false

source

```
Base.isinf– Function.

```

isinf(f)-> Bool

Test whether a number is infinite.  
See also:Inf,iszero,isfinite,isnan.  
source

```
Base.isnan– Function.

```

isnan(f)-> Bool

Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite  
number ("not a number").  
See also:iszero,isone,isinf,ismissing.  
source

```
Base.iszero– Function.

```

iszero(x)

Returntrueifx == zero(x); ifxis an array, this checks whether all of the elements ofxare zero.  
See also:isone,isinteger,isfinite,isnan.  
Examples

```

#### CHAPTER 45. NUMBERS 681

```

julia> iszero(0.0)  
true

julia> iszero([1, 9, 0])  
false

julia> iszero([ false , 0, 0])  
true

source

```
Base.isone– Function.

```

isone(x)

Returntrueifx == one(x); ifxis an array, this checks whetherxis an identity matrix.  
Examples

julia> isone(1.0)  
true

julia> isone([1 0; 0 2])  
false

julia> isone([1 0; 0 true ])  
true

source

```
Base.nextfloat– Function.

```

nextfloat(x:: AbstractFloat , n :: Integer )

The result ofniterative applications ofnextfloattoxifn >= 0, or-napplications ofprevfloatifn < 0.  
source  
nextfloat(x::AbstractFloat)

Return the smallest floating point numberyof the same type asxsuchx < y. If no suchyexists (e.g. if  
xisInforNaN), then returnx.  
See also:prevfloat,eps,issubnormal.  
source

```
Base.prevfloat– Function.

```

prevfloat(x:: AbstractFloat , n :: Integer )

The result ofniterative applications ofprevfloattoxifn >= 0, or-napplications ofnextfloatifn < 0.  
source  
prevfloat(x::AbstractFloat)

Return the largest floating point numberyof the same type asxsuchy < x. If no suchyexists (e.g. ifx  
is-InforNaN), then returnx.  
source

```

#### CHAPTER 45. NUMBERS 682

Base.isinteger– Function.

```

isinteger(x)-> Bool

Test whetherxis numerically equal to some integer.  
Examples

julia> isinteger(4.0)  
true

source

```
Base.isreal– Function.

```

isreal(x)-> Bool

Test whetherxor all its elements are numerically equal to some real number including infinities and NaNs.  
isreal(x)is true ifisequal(x, real(x))is true.  
Examples

julia> isreal(5.)  
true

julia> isreal(Inf + 0im)  
true

julia> isreal([4.; complex(0,1)])  
false

source

```
Core.Float32– Method.

```

Float32 (x [, mode:: RoundingMode ])

Create aFloat32fromx. Ifxis not exactly representable thenmodedetermines howxis rounded.  
Examples

julia>Float32 (1/3, RoundDown)  
0.3333333f0

julia>Float32 (1/3, RoundUp)  
0.33333334f0

SeeRoundingModefor available rounding modes.  
source

```
Core.Float64– Method.

```

Float64 (x [, mode:: RoundingMode ])

Create aFloat64fromx. Ifxis not exactly representable thenmodedetermines howxis rounded.  
Examples

```

#### CHAPTER 45. NUMBERS 683

```

julia>Float64 (pi, RoundDown)  
3.141592653589793

julia>Float64 (pi, RoundUp)  
3.1415926535897936

SeeRoundingModefor available rounding modes.  
source

```
Base.Rounding.rounding– Function.

```

rounding(T)

Get the current floating point rounding mode for typeT, controlling the rounding of basic arithmetic func-  
tions (+,-,*,/andsqrt) and type conversion.  
SeeRoundingModefor available modes.  
source

```
Base.Rounding.setrounding– Method.

```

setrounding(T, mode)

Set the rounding mode of floating point typeT, controlling the rounding of basic arithmetic functions (+,-,  
*,/andsqrt) and type conversion. Other numerical functions may give incorrect or invalid values when  
using rounding modes other than the defaultRoundNearest.  
Note that this is currently only supported forT == BigFloat.

Warning  
This function is not thread-safe. It will affect code running on all threads, but its behavior is  
undefined if called concurrently with computations that use the setting.

source

```
Base.Rounding.setrounding– Method.

```

setrounding(f:: Function , T, mode)

Change the rounding mode of floating point typeTfor the duration off. It is logically equivalent to:  
old = rounding(T)  
setrounding(T, mode)  
f()  
setrounding(T, old)

SeeRoundingModefor available rounding modes.  
source

```
Base.Rounding.get_zero_subnormals– Function.

```

get_zero_subnormals()-> Bool

Returnfalseifoperationsonsubnormalfloating-pointvalues("denormals")obeyrulesforIEEEarithmetic,  
andtrueif they might be converted to zeros.

```

#### CHAPTER 45. NUMBERS 684

```

Warning  
This function only affects the current thread.

source

```
Base.Rounding.set_zero_subnormals– Function.

```

set_zero_subnormals(yes:: Bool ) -> Bool

Ifyesisfalse, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values  
("denormals"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal  
inputs or outputs to zero. Returnstrueunlessyes==truebut the hardware does not support zeroing of  
subnormal numbers.  
set_zero_subnormals(true)can speed up some computations on some hardware. However, it can break  
identities such as(x-y==0) == (x==y).

Warning  
This function only affects the current thread.

source

```
### Integers

Base.count_ones– Function.

```

count_ones(x:: Integer ) -> Integer

Number of ones in the binary representation ofx.  
Examples

julia> count_ones(7)  
3

julia> count_ones( Int32 (-1))  
32

source

```
Base.count_zeros– Function.

```

count_zeros(x:: Integer ) -> Integer

Number of zeros in the binary representation ofx.  
Examples

julia> count_zeros( Int32 (2 ^ 16 - 1))  
16

julia> count_zeros(-1)  
0

source

```

#### CHAPTER 45. NUMBERS 685

Base.leading_zeros– Function.

```

leading_zeros(x:: Integer ) -> Integer

Number of zeros leading the binary representation ofx.  
Examples

julia> leading_zeros( Int32 (1))  
31

source

```
Base.leading_ones– Function.

```

leading_ones(x:: Integer ) -> Integer

Number of ones leading the binary representation ofx.  
Examples

julia> leading_ones( UInt32 (2 ^ 32 - 2))  
31

source

```
Base.trailing_zeros– Function.

```

trailing_zeros(x:: Integer ) -> Integer

Number of zeros trailing the binary representation ofx.  
Examples

julia> trailing_zeros(2)  
1

source

```
Base.trailing_ones– Function.

```

trailing_ones(x:: Integer ) -> Integer

Number of ones trailing the binary representation ofx.  
Examples

julia> trailing_ones(3)  
2

source

```
Base.isodd– Function.

```

isodd(x:: Number ) -> Bool

Returntrueifxis an odd integer (that is, an integer not divisible by 2), andfalseotherwise.

```

#### CHAPTER 45. NUMBERS 686

```

Julia 1.7  
Non-Integerarguments require Julia 1.7 or later.

Examples

julia> isodd(9)  
true

julia> isodd(10)  
false

source

```
Base.iseven– Function.

```

iseven(x:: Number ) -> Bool

Returntrueifxis an even integer (that is, an integer divisible by 2), andfalseotherwise.

Julia 1.7  
Non-Integerarguments require Julia 1.7 or later.

Examples

julia> iseven(9)  
false

julia> iseven(10)  
true

source

```
Core.@int128_str– Macro.

```

@int128_strstr  
@int128_str(str)

@int128_strparses a string into a Int128 Throws anArgumentErrorif the string is not a valid integer  
source

```
Core.@uint128_str– Macro.

```

@uint128_strstr  
@uint128_str(str)

@uint128_strparses a string into a UInt128 Throws anArgumentErrorif the string is not a valid integer  
source

```

#### CHAPTER 45. NUMBERS 687

### 45.4 BigFloats and BigInts

TheBigFloatandBigInttypes implements arbitrary-precision floating point and integer arithmetic, respec-
tively. ForBigFloattheGNUMPFRlibraryisused, andforBigInttheGNUMultiplePrecisionArithmeticLibrary
(GMP) is used.

Base.MPFR.BigFloat– Method.

```

BigFloat (x:: Union { Real , AbstractString } [, rounding:: RoundingMode =rounding( BigFloat )];  
↪→ [precision:: Integer =precision( BigFloat )])

Create an arbitrary precision floating point number fromx, with precisionprecision. Theroundingargu-  
mentspecifiesthedirectioninwhichtheresultshouldberoundediftheconversioncannotbedoneexactly.  
If not provided, these are set by the current global values.  
BigFloat(x::Real)is the same asconvert(BigFloat,x), except ifxitself is alreadyBigFloat, in which  
case it will return a value with the precision set to the current global precision;convertwill always return  
x.  
BigFloat(x::AbstractString)is identical toparse. This is provided for convenience since decimal lit-  
erals are converted toFloat64when parsed, soBigFloat(2.1)may not yield what you expect.  
See also:

```
- @big_str
- roundingandsetrounding
- precisionandsetprecision

```

Julia 1.1  
precisionas a keyword argument requires at least Julia 1.1. In Julia 1.0precisionis the  
second positional argument (BigFloat(x, precision)).

Examples

julia>BigFloat (2.1) # 2.1 here is a Float64  
2.100000000000000088817841970012523233890533447265625

julia>BigFloat ("2.1") # the closest BigFloat to 2.1  
2.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia>BigFloat ("2.1", RoundUp)  
2.100000000000000000000000000000000000000000000000000000000000000000000000000021

julia>BigFloat ("2.1", RoundUp, precision=128)  
2.100000000000000000000000000000000000007

source

```
Base.precision– Function.

```

precision(num:: AbstractFloat )

Get the precision of a floating point number, as defined by the effective number of bits in the significand.  
source

```
Base.precision– Method.


#### CHAPTER 45. NUMBERS 688

```

precision( BigFloat )

Get the precision (in bits) currently used forBigFloatarithmetic.  
source

```
Base.MPFR.setprecision– Function.

```

setprecision([T= BigFloat ,] precision:: Int )

Set the precision (in bits) to be used forTarithmetic.

Warning  
This function is not thread-safe. It will affect code running on all threads, but its behavior is  
undefined if called concurrently with computations that use the setting.

source  
setprecision(f::Function, [T=BigFloat,] precision::Integer)

Change theTarithmetic precision (in bits) for the duration off. It is logically equivalent to:  
old = precision(BigFloat)  
setprecision(BigFloat, precision)  
f()  
setprecision(BigFloat, old)

Often used assetprecision(T, precision) do ... end  
Note:nextfloat(),prevfloat()do not use the precision mentioned bysetprecision  
source

```
Base.GMP.BigInt– Method.

```

BigInt (x)

Create an arbitrary precision integer.xmay be anInt(or anything that can be converted to anInt). The  
usual mathematical operators are defined for this type, and results are promoted to aBigInt.  
Instances can be constructed from strings viaparse, or using thebigstring literal.  
Examples

julia> parse( BigInt , "42")  
42

julia> big"313"  
313

julia>BigInt (10)^19  
10000000000000000000

source

```
Core.@big_str– Macro.

```

@big_strstr  
@big_str(str)

```

#### CHAPTER 45. NUMBERS 689

```

Parse a string into aBigIntorBigFloat, and throw anArgumentErrorif the string is not a valid number.  
For integers_is allowed in the string as a separator.  
Examples

julia> big"123_456"  
123456

julia> big"7891.5"  
7891.5

source

```

**Chapter 46**

**Strings**

Core.AbstractChar– Type.

```

TheAbstractChartype is the supertype of all character implementations in Julia. A character represents  
a Unicode code point, and can be converted to an integer via thecodepointfunction in order to obtain the  
numericalvalueofthecodepoint,orconstructedfromthesameinteger. Thesenumericalvaluesdetermine  
how characters are compared with<and==, for example. NewT <: AbstractChartypes should define a  
codepoint(::T)method and aT(::UInt32)constructor, at minimum.  
A givenAbstractCharsubtype may be capable of representing only a subset of Unicode, in which case  
conversion from an unsupportedUInt32value may throw an error. Conversely, the built-inChartype  
represents a superset of Unicode (in order to losslessly encode invalid byte streams), in which case con-  
version of a non-Unicode value toUInt32throws an error. Theisvalidfunction can be used to check  
which codepoints are representable in a givenAbstractChartype.  
Internally, anAbstractChartype may use a variety of encodings. Conversion viacodepoint(char)will  
notrevealthisencodingbecauseitalwaysreturnstheUnicodevalueofthecharacter.print(io, c)ofany  
c::AbstractCharproduces an encoding determined byio(UTF-8 for all built-inIOtypes), via conversion  
toCharif necessary.  
write(io, c), in contrast, may emit an encoding depending ontypeof(c), andread(io, typeof(c))  
should read the same encoding aswrite. NewAbstractChartypes must provide their own implementa-  
tions ofwriteandread.  
source

```
Core.Char– Type.

```

Char (c:: Union { Number ,AbstractChar})

Charis a 32-bitAbstractChartype that is the default representation of characters in Julia.Charis the  
type used for character literals like'x'and it is also the element type ofString.  
In order to losslessly represent arbitrary byte streams stored in aString, aCharvalue may store infor-  
mation that cannot be converted to a Unicode codepoint — converting such aChartoUInt32will throw  
an error. Theisvalid(c::Char)function can be used to query whethercrepresents a valid Unicode  
character.  
source

```
Base.codepoint– Function.

```

codepoint(c::AbstractChar)-> Integer

```
#### 690


#### CHAPTER 46. STRINGS 691

```

ReturntheUnicodecodepoint(anunsignedinteger)correspondingtothecharacterc(orthrowanexception  
ifcdoes not represent a valid character). ForChar, this is aUInt32value, butAbstractChartypes that  
represent only a subset of Unicode may return a different-sized integer (e.g.UInt8).  
source

```
Base.length– Method.

```

length(s:: AbstractString ) -> Int  
length(s:: AbstractString , i :: Integer , j :: Integer ) -> Int

Return the number of characters in stringsfrom indicesithroughj.  
This is computed as the number of code unit indices fromitojwhich are valid character indices. With  
only a single string argument, this computes the number of characters in the entire string. Withiandj  
arguments it computes the number of indices betweeniandjinclusive that are valid indices in the string  
s. In addition to in-bounds values,imay take the out-of-bounds valuencodeunits(s) + 1andjmay  
take the out-of-bounds value 0.

Note  
The time complexity of this operation is linear in general. That is, it will take the time propor-  
tional to the number of bytes or characters in the string because it counts the value on the fly.  
This is in contrast to the method for arrays, which is a constant-time operation.

See alsoisvalid,ncodeunits,lastindex,thisind,nextind,prevind.  
Examples

julia> length("jμΛIα")  
5

source

```
Base.sizeof– Method.

```

sizeof(str:: AbstractString )

Size, in bytes, of the stringstr. Equal to the number of code units instrmultiplied by the size, in bytes,  
of one code unit instr.  
Examples

julia> sizeof("")  
0

julia> sizeof("∀")  
3

source

```
Base.:*– Method.

```

*(s:: Union { AbstractString , AbstractChar}, t:: Union { AbstractString , AbstractChar}...) ->  
↪→ AbstractString

```

#### CHAPTER 46. STRINGS 692

```

Concatenate strings and/or characters, producing aString. This is equivalent to calling thestringfunc-  
tion on the arguments. Concatenation of built-in string types always produces a value of typeStringbut  
other string types may choose to return a string of a different type as appropriate.  
Examples

julia> "Hello "* "world"  
"Hello world"

julia> 'j' * "ulia"  
"julia"

source

```
Base.:^– Method.

```

^(s:: Union { AbstractString ,AbstractChar}, n:: Integer )

Repeat a string or characterntimes. This can also be written asrepeat(s, n).  
See alsorepeat.  
Examples

julia> "Test "^3  
"Test Test Test "

source

```
Base.string– Function.

```

string(n:: Integer ; base:: Integer = 10, pad:: Integer = 1)

Convert an integernto a string in the givenbase, optionally specifying a number of digits to pad to.  
See alsodigits,bitstring,count_zeros.  
Examples

julia> string(5, base= 13, pad= 4)  
"0005"

julia> string(-13, base= 5, pad= 4)  
"-0023"

source  
string(xs...)

Create a string from any values using theprintfunction.  
stringshould usually not be defined directly. Instead, define a methodprint(io::IO, x::MyType).  
Ifstring(x)for a certain type needs to be highly efficient, then it may make sense to add a method  
tostringand defineprint(io::IO, x::MyType) = print(io, string(x))to ensure the functions are  
consistent.  
See also:String,repr,sprint,show.  
Examples

```

#### CHAPTER 46. STRINGS 693

```

julia> string("a", 1, true )  
"a1true"

source

```
Base.repeat– Method.

```

repeat(s:: AbstractString , r :: Integer )

Repeat a stringrtimes. This can be written ass^r.  
See also^.  
Examples

julia> repeat("ha", 3)  
"hahaha"

source

```
Base.repeat– Method.

```

repeat(c::AbstractChar, r:: Integer ) -> String

Repeat a characterrtimes. This can equivalently be accomplished by callingc^r.  
Examples

julia> repeat('A', 3)  
"AAA"

source

```
Base.repr– Method.

```

repr(x; context=nothing)

Create a string from any value using theshowfunction. You should not add methods torepr; define ashow  
method instead.  
The optional keyword argumentcontextcan be set to a:key=>valuepair, a tuple of:key=>valuepairs,  
or anIOorIOContextobject whose attributes are used for the I/O stream passed toshow.  
Notethatrepr(x)isusuallysimilartohowthevalueofxwouldbeenteredinJulia. Seealsorepr(MIME("text/plain"),  
x)to instead return a"pretty-printed" version ofxdesigned more for human consumption, equivalent to  
the REPL display ofx.

Julia 1.7  
Passing a tuple to keywordcontextrequires Julia 1.7 or later.

Examples

julia> repr(1)  
"1"

julia> repr(zeros(3))  
"[0.0, 0.0, 0.0]"

```

#### CHAPTER 46. STRINGS 694

```

julia> repr(big(1/3))  
"0.333333333333333314829616256247390992939472198486328125"

julia> repr(big(1/3), context=:compact=> true )  
"0.333333"

source

```
Core.String– Method.

```

String(s:: AbstractString )

Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is  
often appropriate for passing strings to C.  
source

```
Base.SubString– Type.

```

SubString (s:: AbstractString , i :: Integer , j :: Integer =lastindex(s))  
SubString (s:: AbstractString , r :: UnitRange {<: Integer })

Likegetindex, but returns a view into the parent stringswithin rangei:jorrrespectively instead of  
making a copy.  
Examples

julia>SubString ("abc", 1, 2)  
"ab"

julia>SubString ("abc", 1:2)  
"ab"

julia>SubString ("abc", 2)  
"bc"

source

```
Base.transcode– Function.

```

transcode(T, src)

Convert string data between Unicode encodings.srcis either aStringor aVector{UIntXX}of UTF-XX  
code units, whereXXis 8, 16, or 32.Tindicates the encoding of the return value:Stringto return a (UTF-8  
encoded)StringorUIntXXto return aVector{UIntXX}of UTF-XXdata. (The aliasCwchar_tcan also be  
used as the integer type, for convertingwchar_t*strings used by external C libraries.)  
Thetranscodefunction succeeds as long as the input data can be reasonably represented in the target  
encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.  
Only conversion to/from UTF-8 is currently supported.  
source

```
Base.unsafe_string– Function.

```

unsafe_string(p:: Ptr { UInt8 }, [length:: Integer ])

```

#### CHAPTER 46. STRINGS 695

```

Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be  
safely freed afterwards.) Iflengthis specified (the length of the data in bytes), the string does not have  
to be NUL-terminated.  
This function is labeled"unsafe" because it will crash ifpis not a valid memory address to data of the  
requested length.  
source

```
Base.ncodeunits– Method.

```

ncodeunits(s:: AbstractString ) -> Int

Return the number of code units in a string. Indices that are in bounds to access this string must satisfy 1  
≤ i ≤ ncodeunits(s). Not all such indices are valid – they may not be the start of a character, but they  
will return a code unit value when callingcodeunit(s,i).  
Examples

julia> ncodeunits("The Julia Language")  
18

julia> ncodeunits("∫eˣ")  
6

julia> ncodeunits('∫'), ncodeunits('e'), ncodeunits('ˣ')  
(3, 1, 2)

See alsocodeunit,checkbounds,sizeof,length,lastindex.  
source

```
Base.codeunit– Function.

```

codeunit(s:: AbstractString ) -> Type {<: Union { UInt8 , UInt16 , UInt32 }}

Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this  
would beUInt8; for UCS-2 and UTF-16 it would beUInt16; for UTF-32 it would beUInt32. The code unit  
type need not be limited to these three types, but it's hard to think of widely used string encodings that  
don't use one of these units.codeunit(s)is the same astypeof(codeunit(s,1))whensis a non-empty  
string.  
See alsoncodeunits.  
source  
codeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}

Return the code unit value in the stringsat indexi. Note that  
codeunit(s, i) :: codeunit(s)

I.e. the value returned bycodeunit(s, i)is of the type returned bycodeunit(s).  
Examples

julia> a = codeunit("Hello", 2)  
0x65

julia> typeof(a)  
UInt8

```

#### CHAPTER 46. STRINGS 696

```

See alsoncodeunits,checkbounds.  
source

```
Base.codeunits– Function.

```

codeunits(s:: AbstractString )

Obtain a vector-like object containing the code units of a string. Returns aCodeUnitswrapper by default,  
butcodeunitsmay optionally be defined for new string types if necessary.  
Examples

julia> codeunits("Juλia")  
6-element Base.CodeUnits{UInt8, String}:  
0x4a  
0x75  
0xce  
0xbb  
0x69  
0x61

source

```
Base.ascii– Function.

```

ascii(s:: AbstractString )

ConvertastringtoStringtypeandcheckthatitcontainsonlyASCIIdata,otherwisethrowinganArgumentError  
indicating the position of the first non-ASCII byte.  
Examples

julia> ascii("abcdeγfgh")  
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeγfgh"  
Stacktrace:  
[...]

julia> ascii("abcdefgh")  
"abcdefgh"

source

```
Base.Regex– Type.

```

Regex (pattern[, flags])

A type representing a regular expression.Regexobjects can be used to match strings withmatch.  
Regexobjects can be created using the@r_strstring macro. TheRegex(pattern[, flags])constructor  
is usually used if thepatternstring needs to be interpolated. See the documentation of the string macro  
for details on flags.

Note  
To escape interpolated variables use\Qand\E(e.g.Regex("\Q$x\E"))

source

```

#### CHAPTER 46. STRINGS 697

Base.@r_str– Macro.

```

@r_str-> Regex

Construct a regex, such asr"^[a-z]*$", without interpolation and unescaping (except for quotation mark  
"which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote,  
to change its behaviour:

```
- ienables case-insensitive matching
- mtreats the^and$tokens as matching the start and end of individual lines, as opposed to the whole
    string.
- sallows the.modifier to match newlines.
- xenables"comment mode": whitespace is enabled except when escaped with\, and#is treated as
    starting a comment.
- adisablesUCPmode (enables ASCII mode). By default\B,\b,\D,\d,\S,\s,\W,\w, etc. match based
    on Unicode character properties. With this option, these sequences only match ASCII characters.

```

SeeRegexif interpolation is needed.  
Examples

julia> match(r"a+._b+._?d$"ism,"Goodbye, \n Oh, angry, \n Bad world \n ")  
RegexMatch("angry,\nBad world")

This regex has the first three flags enabled.  
source

```
Base.SubstitutionString– Type.

```

SubstitutionString(substr)

Stores the given stringsubstras aSubstitutionString, for use in regular expression substitutions. Most  
commonly constructed using the@s_strmacro.

julia> SubstitutionString("Hello \ g, it's \ 1")  
s"Hello \g, it's \1"

julia> subst= s"Hello \g, it's \1 "  
s"Hello \g, it's \1"

julia> typeof(subst)  
SubstitutionString{String}

source

```
Base.@s_str– Macro.

```

@s_str-> SubstitutionString

Construct a substitution string, used for regular expression substitutions. Within the string, sequences of  
the form\Nrefer to the Nth capture group in the regex, and\grefers to a named capture  
group with namegroupname.

```

#### CHAPTER 46. STRINGS 698

```

julia> msg = "#Hello# from Julia";

julia> replace(msg,r"#(.+)# from (?\w+)"=> s"FROM: \g; MESSAGE: \1 ")  
"FROM: Julia; MESSAGE: Hello"

source

```
Base.@raw_str– Macro.

```

@raw_str-> String

Create a raw string without interpolation and unescaping. The exception is that quotation marks still must  
beescaped. Backslashesescapebothquotationmarksandotherbackslashes,butonlywhenasequenceof  
backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes  
and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by  
a quote character.  
Examples

julia> println(raw"\ $x ")  
\ $x

julia> println(raw" " ")  
"

julia> println(raw" \" ")  
"

julia> println(raw" \ x \" ")  
\x "

source

```
Base.@b_str– Macro.

```

@b_str

Create an immutable byte (UInt8) vector using string syntax.  
Examples

julia> v = b"12 \x01\x02 "  
4-element Base.CodeUnits{UInt8, String}:  
0x31  
0x32  
0x01  
0x02

julia> v[2]  
0x32

source

```
Base.Docs.@html_str– Macro.

```

@html_str-> Docs. HTML

```

#### CHAPTER 46. STRINGS 699

```

Create anHTMLobject from a literal string.  
Examples

julia> html"Julia"  
HTML{String}("Julia")

source

```
Base.Docs.@text_str– Macro.

```

@text_str-> Docs. Text

Create aTextobject from a literal string.  
Examples

julia> text"Julia"  
Julia

source

```
Base.isvalid– Method.

```

isvalid(value)-> Bool

Returnstrueif the given value is valid for its type, which currently can be eitherAbstractCharorString  
orSubString{String}.  
Examples

julia> isvalid( Char (0xd800))  
false

julia> isvalid( SubString (String( UInt8 [0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))  
false

julia> isvalid( Char (0xd799))  
true

source

```
Base.isvalid– Method.

```

isvalid(T, value)-> Bool

Returnstrueifthegivenvalueisvalidforthattype. TypescurrentlycanbeeitherAbstractCharorString.  
Values forAbstractCharcan be of typeAbstractCharorUInt32. Values forStringcan be of that type,  
SubString{String},Vector{UInt8}, or a contiguous subarray thereof.  
Examples

julia> isvalid( Char , 0xd800)  
false

julia> isvalid(String, SubString ("thisisvalid",1,5))  
true

julia> isvalid( Char , 0xd799)  
true

```

#### CHAPTER 46. STRINGS 700

```

Julia 1.6  
Support for subarray values was added in Julia 1.6.

source

```
Base.isvalid– Method.

```

isvalid(s:: AbstractString , i :: Integer ) -> Bool

Predicate indicating whether the given index is the start of the encoding of a character insor not. If  
isvalid(s, i)is true thens[i]will return the character whose encoding starts at that index, if it's false,  
thens[i]will raise an invalid index error or a bounds error depending on ifiis in bounds. In order  
forisvalid(s, i)to be an O(1) function, the encoding ofsmust beself-synchronizing. This is a basic  
assumption of Julia's generic string support.  
See alsogetindex,iterate,thisind,nextind,prevind,length.  
Examples

julia> str = "αβγdef";

julia> isvalid(str,1)  
true

julia> str[1]  
'α': Unicode U+03B1 (category Ll: Letter, lowercase)

julia> isvalid(str,2)  
false

julia> str[2]  
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'α', [3]=>'β'  
Stacktrace:  
[...]

source

```
Base.match– Function.

```

match(r:: Regex , s :: AbstractString [, idx:: Integer [, addopts]])

Search for the first match of the regular expressionrinsand return aRegexMatchobject containing the  
match, or nothing if the match failed. The matching substring can be retrieved by accessingm.matchand  
the captured sequences can be retrieved by accessingm.capturesThe optionalidxargument specifies  
an index at which to start the search.  
Examples

julia> rx = r"a(.)a"  
r"a(.)a"

julia> m = match(rx,"cabac")  
RegexMatch("aba", 1="b")

julia> m.captures  
1-element Vector{Union{Nothing, SubString{String}}}:

```

#### CHAPTER 46. STRINGS 701

```

"b"

julia> m.match  
"aba"

julia> match(rx,"cabac", 3) === nothing  
true

source

```
Base.eachmatch– Function.

```

eachmatch(r:: Regex , s :: AbstractString ; overlap:: Bool = false )

Search for all matches of the regular expressionrinsand return an iterator over the matches. Ifoverlap  
istrue, the matching sequences are allowed to overlap indices in the original string, otherwise they must  
be from distinct character ranges.  
Examples

julia> rx = r"a.a"  
r"a.a"

julia> m = eachmatch(rx,"a1a2a3a")  
Base.RegexMatchIterator(r"a.a", "a1a2a3a", false)

julia> collect(m)  
2-element Vector{RegexMatch}:  
RegexMatch("a1a")  
RegexMatch("a3a")

julia> collect(eachmatch(rx,"a1a2a3a", overlap= true ))  
3-element Vector{RegexMatch}:  
RegexMatch("a1a")  
RegexMatch("a2a")  
RegexMatch("a3a")

source

```
Base.RegexMatch– Type.

```

RegexMatch

A type representing a single match to aRegexfound in a string. Typically created from thematchfunction.  
Thematchfield stores the substring of the entire matched string. Thecapturesfield stores the substrings  
for each capture group, indexed by number. To index by capture group name, the entire match object  
should be indexed instead, as shown in the examples. The location of the start of the match is stored in  
theoffsetfield. Theoffsetsfield stores the locations of the start of each capture group, with 0 denoting  
a group that was not captured.  
This type can be used as an iterator over the capture groups of theRegex, yielding the substrings captured  
in each group. Because of this, the captures of a match can be destructured. If a group was not captured,  
nothingwill be yielded instead of a substring.  
Methods that accept aRegexMatchobject are defined foriterate,length,eltype,keys,haskey, and  
getindex, where keys are the the names or numbers of a capture group. Seekeysfor more information.  
Examples

```

#### CHAPTER 46. STRINGS 702

```

julia> m = match(r"(?\d+):(?\d+)(am|pm)?", "11:30 in the morning")  
RegexMatch("11:30", hour="11", minute="30", 3=nothing)

julia> hr, min, ampm= m;

julia> hr  
"11"

julia> m["minute"]  
"30"

julia> m.match  
"11:30"

source

```
Base.keys– Method.

```

keys(m:: RegexMatch ) -> Vector

Return a vector of keys for all capture groups of the underlying regex. A key is included even if the capture  
group fails to match. That is,idxwill be in the return value even ifm[idx] == nothing.  
Unnamed capture groups will have integer keys corresponding to their index. Named capture groups will  
have string keys.

Julia 1.6  
This method was added in Julia 1.6

Examples

julia> keys(match(r"(?\d+):(?\d+)(am|pm)?", "11:30"))  
3-element Vector{Any}:  
"hour"  
"minute"  
3

source

```
Base.isless– Method.

```

isless(a:: AbstractString , b :: AbstractString ) -> Bool

Test whether stringacomes before stringbin alphabetical order (technically, in lexicographical order by  
Unicode code points).  
Examples

julia> isless("a", "b")  
true

julia> isless("β", "α")  
false

julia> isless("a", "a")  
false

```

#### CHAPTER 46. STRINGS 703

```

source

```
Base.:==– Method.

```

==(a:: AbstractString , b :: AbstractString ) -> Bool

Test whether two strings are equal character by character (technically, Unicode code point by code point).  
Examples

julia> "abc"== "abc"  
true

julia> "abc"== "αβγ"  
false

source

```
Base.cmp– Method.

```

cmp(a:: AbstractString , b :: AbstractString ) -> Int

Compare two strings. Return 0 if both strings have the same length and the character at each index is the  
same in both strings. Return-1ifais a prefix ofb, or ifacomes beforebin alphabetical order. Return 1 if  
bis a prefix ofa, or ifbcomes beforeain alphabetical order (technically, lexicographical order by Unicode  
code points).  
Examples

julia> cmp("abc", "abc")  
0

julia> cmp("ab", "abc")  
-1

julia> cmp("abc", "ab")  
1

julia> cmp("ab", "ac")  
-1

julia> cmp("ac", "ab")  
1

julia> cmp("α", "a")  
1

julia> cmp("b", "β")  
-1

source

```
Base.lpad– Function.

```

lpad(s, n:: Integer , p :: Union {AbstractChar, AbstractString }=' ' ) -> String

```

#### CHAPTER 46. STRINGS 704

```

Stringifysand pad the resulting string on the left withpto make itncharacters (intextwidth) long. Ifs  
is alreadyncharacters long, an equal string is returned. Pad with spaces by default.  
Examples

julia> lpad("March", 10)  
" March"

Julia 1.7  
InJulia1.7, thisfunctionwaschangedtousetextwidthratherthanarawcharacter(codepoint)  
count.

source

```
Base.rpad– Function.

```

rpad(s, n:: Integer , p :: Union {AbstractChar, AbstractString }=' ' ) -> String

Stringifysand pad the resulting string on the right withpto make itncharacters (intextwidth) long. If  
sis alreadyncharacters long, an equal string is returned. Pad with spaces by default.  
Examples

julia> rpad("March", 20)  
"March "

Julia 1.7  
InJulia1.7, thisfunctionwaschangedtousetextwidthratherthanarawcharacter(codepoint)  
count.

source

```
Base.findfirst– Method.

```

findfirst(pattern:: AbstractString , string:: AbstractString )  
findfirst(pattern::AbstractPattern, string::String)

Findthefirstoccurrenceofpatterninstring. Equivalenttofindnext(pattern, string, firstindex(s)).  
Examples

julia> findfirst("z", "Hello to the world") # returns nothing, but not printed in the REPL

julia> findfirst("Julia", "JuliaLang")  
1:5

source

```
Base.findnext– Method.

```

findnext(pattern:: AbstractString , string:: AbstractString , start:: Integer )  
findnext(pattern::AbstractPattern, string::String, start:: Integer )

```

#### CHAPTER 46. STRINGS 705

```

Find the next occurrence ofpatterninstringstarting at positionstart.patterncan be either a string,  
or a regular expression, in which casestringmust be of typeString.  
The return value is a range of indices where the matching sequence is found, such thats[findnext(x,  
s, i)] == x:  
findnext("substring", string, i)==start:stopsuch thatstring[start:stop] == "substring"  
andi <= start, ornothingif unmatched.  
Examples

julia> findnext("z", "Hello to the world", 1) === nothing  
true

julia> findnext("o", "Hello to the world", 6)  
8:8

julia> findnext("Lang", "JuliaLang", 2)  
6:9

source

```
Base.findnext– Method.

```

findnext(ch::AbstractChar, string:: AbstractString , start:: Integer )

Find the next occurrence of characterchinstringstarting at positionstart.

Julia 1.3  
This method requires at least Julia 1.3.

Examples

julia> findnext('z', "Hello to the world", 1) === nothing  
true

julia> findnext('o', "Hello to the world", 6)  
8

source

```
Base.findlast– Method.

```

findlast(pattern:: AbstractString , string:: AbstractString )

Findthelastoccurrenceofpatterninstring. Equivalenttofindprev(pattern, string, lastindex(string)).  
Examples

julia> findlast("o", "Hello to the world")  
15:15

julia> findfirst("Julia", "JuliaLang")  
1:5

source

```

#### CHAPTER 46. STRINGS 706

Base.findlast– Method.

```

findlast(ch::AbstractChar, string:: AbstractString )

Find the last occurrence of characterchinstring.

Julia 1.3  
This method requires at least Julia 1.3.

Examples

julia> findlast('p', "happy")  
4

julia> findlast('z', "happy") === nothing  
true

source

```
Base.findprev– Method.

```

findprev(pattern:: AbstractString , string:: AbstractString , start:: Integer )

Find the previous occurrence ofpatterninstringstarting at positionstart.  
The return value is a range of indices where the matching sequence is found, such thats[findprev(x,  
s, i)] == x:  
findprev("substring", string, i)==start:stopsuch thatstring[start:stop] == "substring"  
andstop <= i, ornothingif unmatched.  
Examples

julia> findprev("z", "Hello to the world", 18) === nothing  
true

julia> findprev("o", "Hello to the world", 18)  
15:15

julia> findprev("Julia", "JuliaLang", 6)  
1:5

source

```
Base.occursin– Function.

```

occursin(needle:: Union { AbstractString ,AbstractPattern,AbstractChar}, haystack:: AbstractString )

Determine whether the first argument is a substring of the second. Ifneedleis a regular expression,  
checks whetherhaystackcontains a match.  
Examples

julia> occursin("Julia", "JuliaLang is pretty cool!")  
true

julia> occursin('a', "JuliaLang is pretty cool!")

```

#### CHAPTER 46. STRINGS 707

```

true

julia> occursin(r"a.a", "aba")  
true

julia> occursin(r"a.a", "abba")  
false

See alsocontains.  
source  
occursin(haystack)

Createafunctionthatcheckswhetheritsargumentoccursinhaystack,i.e. afunctionequivalenttoneedle  
-> occursin(needle, haystack).  
The returned function is of typeBase.Fix2{typeof(occursin)}.

Julia 1.6  
This method requires Julia 1.6 or later.

source

```
Base.reverse– Method.

```

reverse(s:: AbstractString ) -> AbstractString

Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for  
reversed-orderstringprocessing,especiallyforreversedregular-expressionsearches. Seealsoreverseind  
to convert indices insto indices inreverse(s)and vice-versa, andgraphemesfrom moduleUnicodeto  
operate on user-visible"characters" (graphemes) rather than codepoints. See alsoIterators.reverse  
for reverse-order iteration without making a copy. Custom string types must implement thereverse  
function themselves and should typically return a string with the same type and encoding. If they re-  
turn a string with a different encoding, they must also overridereverseindfor that string type to satisfy  
s[reverseind(s,i)] == reverse(s)[i].  
Examples

julia> reverse("JuliaLang")  
"gnaLailuJ"

Note  
The examples below may be rendered differently on different systems. The comments indicate  
how they're supposed to be rendered

Combining characters can lead to surprising results:

julia> reverse("ax̂ e") # hat is above x in the input, above e in the output  
"ê xa"

julia>using Unicode

julia> join(reverse(collect(graphemes("ax̂ e"))))# reverses graphemes; hat is above x in both in-  
↪→ and output  
"ex̂ a"

```

#### CHAPTER 46. STRINGS 708

```

source

```
Base.replace– Method.

```

replace(s:: AbstractString , pat=>r, [pat2=>r2, ...]; [count:: Integer ])

Search for the given patternpatins, and replace each occurrence withr. Ifcountis provided, replace at  
mostcountoccurrences.patmaybeasinglecharacter,avectororasetofcharacters,astring,oraregular  
expression. Ifris a function, each occurrence is replaced withr(s)wheresis the matched substring  
(whenpatis aAbstractPatternorAbstractString) or character (whenpatis anAbstractCharor a  
collection ofAbstractChar). Ifpatis a regular expression andris aSubstitutionString, then capture  
group references inrare replaced with the corresponding matched text. To remove instances ofpatfrom  
string, setrto the emptyString("").  
Multiple patterns can be specified, and they will be applied left-to-right simultaneously, so only one pattern  
will be applied to any character, and the patterns will only be applied to the input text, not the replace-  
ments.

Julia 1.7  
Support for multiple patterns requires version 1.7.

Examples

julia> replace("Python is a programming language.", "Python"=> "Julia")  
"Julia is a programming language."

julia> replace("The quick foxes run quickly.", "quick"=> "slow", count=1)  
"The slow foxes run quickly."

julia> replace("The quick foxes run quickly.", "quick"=> "", count=1)  
"The foxes run quickly."

julia> replace("The quick foxes run quickly.", r"fox(es)?"=> s"bus \1 ")  
"The quick buses run quickly."

julia> replace("abcabc", "a" => "b", "b" => "c", r".+"=> "a")  
"bca"

source

```
Base.split– Function.

```

split(str:: AbstractString , dlm; limit:: Integer =0, keepempty:: Bool = true )  
split(str:: AbstractString ; limit:: Integer =0, keepempty:: Bool = false )

Splitstrinto an array of substrings on occurrences of the delimiter(s)dlm.dlmcan be any of the formats  
allowed byfindnext's first argument (i.e. as a string, regular expression or a function), or as a single  
character or collection of characters.  
Ifdlmis omitted, it defaults toisspace.  
The optional keyword arguments are:

```
- limit: the maximum size of the result.limit=0implies no maximum (default)
- keepempty: whether empty fields should be kept in the result. Default isfalsewithout adlmargu-
    ment,truewith adlmargument.


#### CHAPTER 46. STRINGS 709

```

See alsorsplit.  
Examples

julia> a = "Ma.rch"  
"Ma.rch"

julia> split(a,".")  
2-element Vector{SubString{String}}:  
"Ma"  
"rch"

source

```
Base.rsplit– Function.

```

rsplit(s:: AbstractString ; limit:: Integer =0, keepempty:: Bool = false )  
rsplit(s:: AbstractString , chars; limit:: Integer =0, keepempty:: Bool = true )

Similar tosplit, but starting from the end of the string.  
Examples

julia> a = "M.a.r.c.h"  
"M.a.r.c.h"

julia> rsplit(a,".")  
5-element Vector{SubString{String}}:  
"M"  
"a"  
"r"  
"c"  
"h"

julia> rsplit(a,"."; limit=1)  
1-element Vector{SubString{String}}:  
"M.a.r.c.h"

julia> rsplit(a,"."; limit=2)  
2-element Vector{SubString{String}}:  
"M.a.r.c"  
"h"

source

```
Base.strip– Function.

```

strip([pred=isspace,] str:: AbstractString ) -> SubString  
strip(str:: AbstractString , chars)-> SubString

Remove leading and trailing characters fromstr, either those specified bycharsor those for which the  
functionpredreturnstrue.  
The default behaviour is to remove leading and trailing whitespace and delimiters: seeisspacefor precise  
details.  
The optionalcharsargument specifies which characters to remove: it can be a single character, vector or  
set of characters.  
See alsolstripandrstrip.

```

#### CHAPTER 46. STRINGS 710

```

Julia 1.2  
The method which accepts a predicate function requires Julia 1.2 or later.

Examples

julia> strip("{3, 5} \n ", [ '{', '}', '\n'])  
"3, 5"

source

```
Base.lstrip– Function.

```

lstrip([pred=isspace,] str:: AbstractString ) -> SubString  
lstrip(str:: AbstractString , chars)-> SubString

Remove leading characters fromstr, either those specified bycharsor those for which the functionpred  
returnstrue.  
The default behaviour is to remove leading whitespace and delimiters: seeisspacefor precise details.  
Theoptionalcharsargumentspecifieswhichcharacterstoremove: itcanbeasinglecharacter, oravector  
or set of characters.  
See alsostripandrstrip.  
Examples

julia> a = lpad("March", 20)  
" March"

julia> lstrip(a)  
"March"

source

```
Base.rstrip– Function.

```

rstrip([pred=isspace,] str:: AbstractString ) -> SubString  
rstrip(str:: AbstractString , chars)-> SubString

Remove trailing characters fromstr, either those specified bycharsor those for which the functionpred  
returnstrue.  
The default behaviour is to remove trailing whitespace and delimiters: seeisspacefor precise details.  
Theoptionalcharsargumentspecifieswhichcharacterstoremove: itcanbeasinglecharacter, oravector  
or set of characters.  
See alsostripandlstrip.  
Examples

julia> a = rpad("March", 20)  
"March "

julia> rstrip(a)  
"March"

source

```

#### CHAPTER 46. STRINGS 711

Base.startswith– Function.

```

startswith(s:: AbstractString , prefix:: AbstractString )

Returntrueifsstartswithprefix. Ifprefixisavectororsetofcharacters,testwhetherthefirstcharacter  
ofsbelongs to that set.  
See alsoendswith,contains.  
Examples

julia> startswith("JuliaLang", "Julia")  
true

source  
startswith(prefix)

Create a function that checks whether its argument starts withprefix, i.e. a function equivalent toy ->  
startswith(y, prefix).  
The returned function is of typeBase.Fix2{typeof(startswith)}, which can be used to implement spe-  
cialized methods.

Julia 1.5  
The single argumentstartswith(prefix)requires at least Julia 1.5.

Examples

julia> startswith_julia= startswith("Julia");

julia> startswith_julia("Julia")  
true

julia> startswith_julia("NotJulia")  
false

source  
startswith(s::AbstractString, prefix::Regex)

Returntrueifsstarts with the regex pattern,prefix.

Note  
startswithdoes not compile the anchoring into the regular expression, but instead passes the  
anchoring asmatch_optionto PCRE. If compile time is amortized,occursin(r"^...", s)is  
faster thanstartswith(s, r"...").

See alsooccursinandendswith.

Julia 1.2  
This method requires at least Julia 1.2.

Examples

```

#### CHAPTER 46. STRINGS 712

```

julia> startswith("JuliaLang", r"Julia|Romeo")  
true

source

```
Base.endswith– Function.

```

endswith(s:: AbstractString , suffix:: AbstractString )

Returntrueifsends withsuffix. Ifsuffixis a vector or set of characters, test whether the last character  
ofsbelongs to that set.  
See alsostartswith,contains.  
Examples

julia> endswith("Sunday", "day")  
true

source  
endswith(suffix)

Create a function that checks whether its argument ends withsuffix, i.e. a function equivalent toy ->  
endswith(y, suffix).  
The returned function is of typeBase.Fix2{typeof(endswith)}, which can be used to implement special-  
ized methods.

Julia 1.5  
The single argumentendswith(suffix)requires at least Julia 1.5.

Examples

julia> endswith_julia= endswith("Julia");

julia> endswith_julia("Julia")  
true

julia> endswith_julia("JuliaLang")  
false

source  
endswith(s::AbstractString, suffix::Regex)

Returntrueifsends with the regex pattern,suffix.

Note  
endswithdoes not compile the anchoring into the regular expression, but instead passes the  
anchoring asmatch_optionto PCRE. If compile time is amortized,occursin(r"...$", s)is  
faster thanendswith(s, r"...").

See alsooccursinandstartswith.

```

#### CHAPTER 46. STRINGS 713

```

Julia 1.2  
This method requires at least Julia 1.2.

Examples

julia> endswith("JuliaLang", r"Lang|Roberts")  
true

source

```
Base.contains– Function.

```

contains(haystack:: AbstractString , needle)

Returntrueifhaystackcontainsneedle. This is the same asoccursin(needle, haystack), but is pro-  
vided for consistency withstartswith(haystack, needle)andendswith(haystack, needle).  
See alsooccursin,in,issubset.  
Examples

julia> contains("JuliaLang is pretty cool!", "Julia")  
true

julia> contains("JuliaLang is pretty cool!", 'a')  
true

julia> contains("aba", r"a.a")  
true

julia> contains("abba", r"a.a")  
false

Julia 1.5  
Thecontainsfunction requires at least Julia 1.5.

source  
contains(needle)

Createafunctionthatcheckswhetheritsargumentcontainsneedle, i.e. afunctionequivalenttohaystack  
-> contains(haystack, needle).  
The returned function is of typeBase.Fix2{typeof(contains)}, which can be used to implement special-  
ized methods.  
source

```
Base.first– Method.

```

first(s:: AbstractString , n :: Integer )

Get a string consisting of the firstncharacters ofs.  
Examples

```

#### CHAPTER 46. STRINGS 714

```

julia> first("∀ε≠0: ε²>0", 0)  
""

julia> first("∀ε≠0: ε²>0", 1)  
"∀"

julia> first("∀ε≠0: ε²>0", 3)  
"∀ε≠"

source

```
Base.last– Method.

```

last(s:: AbstractString , n :: Integer )

Get a string consisting of the lastncharacters ofs.  
Examples

julia> last("∀ε≠0: ε²>0", 0)  
""

julia> last("∀ε≠0: ε²>0", 1)  
"0"

julia> last("∀ε≠0: ε²>0", 3)  
"²>0"

source

```
Base.Unicode.uppercase– Function.

```

uppercase(s:: AbstractString )

Returnswith all characters converted to uppercase.  
See alsolowercase,titlecase,uppercasefirst.  
Examples

julia> uppercase("Julia")  
"JULIA"

source

```
Base.Unicode.lowercase– Function.

```

lowercase(s:: AbstractString )

Returnswith all characters converted to lowercase.  
See alsouppercase,titlecase,lowercasefirst.  
Examples

julia> lowercase("STRINGS AND THINGS")  
"strings and things"

```

#### CHAPTER 46. STRINGS 715

```

source

```
Base.Unicode.titlecase– Function.

```

titlecase(s:: AbstractString ; [wordsep:: Function ], strict:: Bool = true ) -> String

Capitalize the first character of each word ins; ifstrictis true, every other character is converted to  
lowercase, otherwise they are left unchanged. By default, all non-letters beginning a new grapheme are  
considered as word separators; a predicate can be passed as thewordsepkeyword to determine which  
characters should be considered as word separators. See alsouppercasefirstto capitalize only the first  
character ins.  
See alsouppercase,lowercase,uppercasefirst.  
Examples

julia> titlecase("the JULIA programming language")  
"The Julia Programming Language"

julia> titlecase("ISS - international space station", strict= false )  
"ISS - International Space Station"

julia> titlecase("a-a b-b", wordsep= c->c==' ' )  
"A-a B-b"

source

```
Base.Unicode.uppercasefirst– Function.

```

uppercasefirst(s:: AbstractString ) -> String

Returnswith the first character converted to uppercase (technically"title case" for Unicode). See also  
titlecaseto capitalize the first character of every word ins.  
See alsolowercasefirst,uppercase,lowercase,titlecase.  
Examples

julia> uppercasefirst("python")  
"Python"

source

```
Base.Unicode.lowercasefirst– Function.

```

lowercasefirst(s:: AbstractString )

Returnswith the first character converted to lowercase.  
See alsouppercasefirst,uppercase,lowercase,titlecase.  
Examples

julia> lowercasefirst("Julia")  
"julia"

source

```

#### CHAPTER 46. STRINGS 716

Base.join– Function.

```

join([io:: IO ,] iterator [, delim [, last]])

Join anyiteratorinto a single string, inserting the given delimiter (if any) between adjacent items. Iflast  
is given, it will be used instead ofdelimbetween the last two items. Each item ofiteratoris converted  
to a string viaprint(io::IOBuffer, x). Ifiois given, the result is written toiorather than returned as  
aString.  
Examples

julia> join(["apples", "bananas", "pineapples"], ", " , " and ")  
"apples, bananas and pineapples"

julia> join([1,2,3,4,5])  
"12345"

source

```
Base.chop– Function.

```

chop(s:: AbstractString ; head:: Integer = 0, tail:: Integer = 1)

Remove the firstheadand the lasttailcharacters froms. The callchop(s)removes the last character  
froms. If it is requested to remove more characters thanlength(s)then an empty string is returned.  
See alsochomp,startswith,first.  
Examples

julia> a = "March"  
"March"

julia> chop(a)  
"Marc"

julia> chop(a, head= 1, tail= 2)  
"ar"

julia> chop(a, head= 5, tail= 5)  
""

source

```
Base.chomp– Function.

```

chomp(s:: AbstractString ) -> SubString

Remove a single trailing newline from a string.  
See alsochop.  
Examples

julia> chomp("Hello \n ")  
"Hello"

source

```

#### CHAPTER 46. STRINGS 717

Base.thisind– Function.

```

thisind(s:: AbstractString , i :: Integer ) -> Int

Ifiis in bounds insreturn the index of the start of the character whose encoding code unitiis part of.  
In other words, ifiis the start of a character, returni; ifiis not the start of a character, rewind until the  
start of a character and return that index. Ifiis equal to 0 orncodeunits(s)+1returni. In all other cases  
throwBoundsError.  
Examples

julia> thisind("α", 0)  
0

julia> thisind("α", 1)  
1

julia> thisind("α", 2)  
1

julia> thisind("α", 3)  
3

julia> thisind("α", 4)  
ERROR: BoundsError: attempt to access 2-codeunit String at index [4]  
[...]

julia> thisind("α", -1)  
ERROR: BoundsError: attempt to access 2-codeunit String at index [-1]  
[...]

source

```
Base.nextind– Function.

```

nextind(str:: AbstractString , i :: Integer , n :: Integer =1) -> Int

```
- Casen == 1
    Ifiis in bounds insreturn the index of the start of the character whose encoding starts after index
    i. In other words, ifiis the start of a character, return the start of the next character; ifiis not the
    start of a character, move forward until the start of a character and return that index. Ifiis equal
    to 0 return 1. Ifiis in bounds but greater or equal tolastindex(str)returnncodeunits(str)+1.
    Otherwise throwBoundsError.
- Casen > 1
    Behaveslikeapplyingntimesnextindforn==1. Theonlydifferenceisthatifnissolargethatapplying
    nextindwouldreachncodeunits(str)+1theneachremainingiterationincreasesthereturnedvalue
    by 1. This means that in this casenextindcan return a value greater thanncodeunits(str)+1.
- Casen == 0
    Returnionly ifiis a valid index insor is equal to 0. OtherwiseStringIndexErrororBoundsError
    is thrown.

```

Examples

```

#### CHAPTER 46. STRINGS 718

```

julia> nextind("α", 0)  
1

julia> nextind("α", 1)  
3

julia> nextind("α", 3)  
ERROR: BoundsError: attempt to access 2-codeunit String at index [3]  
[...]

julia> nextind("α", 0, 2)  
3

julia> nextind("α", 1, 2)  
4

source

```
Base.prevind– Function.

```

prevind(str:: AbstractString , i :: Integer , n :: Integer =1) -> Int

```
- Casen == 1
    Ifiis in bounds insreturn the index of the start of the character whose encoding starts before index
    i. In other words, ifiis the start of a character, return the start of the previous character; ifiis not
    the start of a character, rewind until the start of a character and return that index. Ifiis equal to 1
    return 0. Ifiis equal toncodeunits(str)+1returnlastindex(str). Otherwise throwBoundsError.
- Casen > 1
    Behaves like applyingntimesprevindforn==1. The only difference is that ifnis so large that
    applyingprevindwould reach 0 then each remaining iteration decreases the returned value by 1.
    This means that in this caseprevindcan return a negative value.
- Casen == 0
    Returnionlyifiisavalidindexinstrorisequaltoncodeunits(str)+1. OtherwiseStringIndexError
    orBoundsErroris thrown.

```

Examples

julia> prevind("α", 3)  
1

julia> prevind("α", 1)  
0

julia> prevind("α", 0)  
ERROR: BoundsError: attempt to access 2-codeunit String at index [0]  
[...]

julia> prevind("α", 2, 2)  
0

julia> prevind("α", 2, 3)  
-1

source

```

#### CHAPTER 46. STRINGS 719

Base.Unicode.textwidth– Function.

```

textwidth(c)

Give the number of columns needed to print a character.  
Examples

julia> textwidth('α')  
1

julia> textwidth('')  
2

source  
textwidth(s::AbstractString)

Give the number of columns needed to print a string.  
Examples

julia> textwidth("March")  
5

source

```
Base.isascii– Function.

```

isascii(c:: Union {AbstractChar, AbstractString }) -> Bool

Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a  
string.  
Examples

julia> isascii('a')  
true

julia> isascii('α')  
false

julia> isascii("abc")  
true

julia> isascii("αβγ")  
false

source

```
Base.Unicode.iscntrl– Function.

```

iscntrl(c::AbstractChar)-> Bool

Tests whether a character is a control character. Control characters are the non-printing characters of the  
Latin-1 subset of Unicode.  
Examples

```

#### CHAPTER 46. STRINGS 720

```

julia> iscntrl('\x01')  
true

julia> iscntrl('a')  
false

source

```
Base.Unicode.isdigit– Function.

```

isdigit(c::AbstractChar)-> Bool

Tests whether a character is a decimal digit (0-9).  
Examples

julia> isdigit('❤')  
false

julia> isdigit('9')  
true

julia> isdigit('α')  
false

source

```
Base.Unicode.isletter– Function.

```

isletter(c::AbstractChar)-> Bool

Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general  
category Letter, i.e. a character whose category code begins with'L'.  
Examples

julia> isletter('❤')  
false

julia> isletter('α')  
true

julia> isletter('9')  
false

source

```
Base.Unicode.islowercase– Function.

```

islowercase(c::AbstractChar)-> Bool

Tests whether a character is a lowercase letter (according to the Unicode standard'sLowercasederived  
property).  
See alsoisuppercase.  
Examples

```

#### CHAPTER 46. STRINGS 721

```

julia> islowercase('α')  
true

julia> islowercase('Γ')  
false

julia> islowercase('❤')  
false

source

```
Base.Unicode.isnumeric– Function.

```

isnumeric(c::AbstractChar)-> Bool

Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode  
general category Number, i.e. a character whose category code begins with'N'.  
Note that this broad category includes characters such as ¾ and. Useisdigitto check whether a char-  
acter a decimal digit between 0 and 9.  
Examples

julia> isnumeric('')  
true

julia> isnumeric('9')  
true

julia> isnumeric('α')  
false

julia> isnumeric('❤')  
false

source

```
Base.Unicode.isprint– Function.

```

isprint(c::AbstractChar)-> Bool

Tests whether a character is printable, including spaces, but not a control character.  
Examples

julia> isprint('\x01')  
false

julia> isprint('A')  
true

source

```
Base.Unicode.ispunct– Function.

```

ispunct(c::AbstractChar)-> Bool

```

#### CHAPTER 46. STRINGS 722

```

Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose  
category code begins with'P'.  
Examples

julia> ispunct('α')  
false

julia> ispunct('/')  
true

julia> ispunct(';')  
true

source

```
Base.Unicode.isspace– Function.

```

isspace(c::AbstractChar)-> Bool

Tests whether a character is any whitespace character. Includes ASCII characters'\t', '\n', '\v', '\f', '\r', and  
' ' , Latin-1 character U+0085, and characters in Unicode category Zs.  
Examples

julia> isspace('\n')  
true

julia> isspace('\r')  
true

julia> isspace(' ' )  
true

julia> isspace('\x20')  
true

source

```
Base.Unicode.isuppercase– Function.

```

isuppercase(c::AbstractChar)-> Bool

Tests whether a character is an uppercase letter (according to the Unicode standard'sUppercasederived  
property).  
See alsoislowercase.  
Examples

julia> isuppercase('γ')  
false

julia> isuppercase('Γ')  
true

julia> isuppercase('❤')  
false

```

#### CHAPTER 46. STRINGS 723

```

source

```
Base.Unicode.isxdigit– Function.

```

isxdigit(c::AbstractChar)-> Bool

Test whether a character is a valid hexadecimal digit. Note that this does not includex(as in the standard  
0xprefix).  
Examples

julia> isxdigit('a')  
true

julia> isxdigit('x')  
false

source

```
Base.escape_string– Function.

```

escape_string(str:: AbstractString [, esc]; keep= ()):: AbstractString  
escape_string(io, str:: AbstractString [, esc]; keep= ())::Nothing

GeneralescapingoftraditionalCandUnicodeescapesequences. Thefirstformreturnstheescapedstring,  
the second prints the result toio.  
Backslashes () are escaped with a double-backslash ("\"). Non-printable characters are escaped either  
with their standard C escape codes,"\0"for NUL (if unambiguous), unicode code point ("\u"prefix) or  
hex ("\x"prefix).  
Theoptionalescargumentspecifiesanyadditionalcharactersthatshouldalsobeescapedbyaprepending  
backslash ("is also escaped by default in the first form).  
The argumentkeepspecifies a collection of characters which are to be kept as they are. Notice thatesc  
has precedence here.  
See alsounescape_stringfor the reverse operation.

Julia 1.7  
Thekeepargument is available as of Julia 1.7.

Examples

julia> escape_string("aaa \n bbb")  
"aaa\nbbb"

julia> escape_string("aaa \n bbb"; keep= '\n')  
"aaa\nbbb"

julia> escape_string(" \xfe\xff ") # invalid utf-8  
"\xfe\xff"

julia> escape_string(string('\u2135','\0')) # unambiguous  
"\0"

julia> escape_string(string('\u2135','\0','0')) # \0 would be ambiguous  
"\x000"

```

#### CHAPTER 46. STRINGS 724

```

source

```
Base.unescape_string– Function.

```

unescape_string(str:: AbstractString , keep= ()):: AbstractString  
unescape_string(io, s:: AbstractString , keep= ())::Nothing

General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped  
string, the second prints the result toio. The argumentkeepspecifies a collection of characters which  
(along with backlashes) are to be kept as they are.  
The following escape sequences are recognised:

```
- Escaped backslash (\\)
- Escaped double-quote (\")
- Standard C escape sequences (\a,\b,\t,\n,\v,\f,\r,\e)
- Unicode BMP code points (\uwith 1-4 trailing hex digits)
- All Unicode code points (\Uwith 1-8 trailing hex digits; max value = 0010ffff)
- Hex bytes (\xwith 1-2 trailing hex digits)
- Octal bytes (\with 1-3 trailing octal digits)

```

See alsoescape_string.  
Examples

julia> unescape_string("aaa \ nbbb") # C escape sequence  
"aaa\nbbb"

julia> unescape_string(" \ u03c0") # unicode  
"π"

julia> unescape_string(" \ 101") # octal  
"A"

julia> unescape_string("aaa \ g \ n", [ 'g']) # using `keep` argument  
"aaa \g \n"

source

```

**Chapter 47**

**Arrays**

### 47.1 Constructors and Types

Core.AbstractArray– Type.

```

AbstractArray {T,N}

Supertype forN-dimensional arrays (or array-like types) with elements of typeT.Arrayand other types  
are subtypes of this. See the manual section on theAbstractArrayinterface.  
See also:AbstractVector,AbstractMatrix,eltype,ndims.  
source

```
Base.AbstractVector– Type.

```

AbstractVector {T}

Supertypeforone-dimensionalarrays(orarray-liketypes)withelementsoftypeT.AliasforAbstractArray{T,1}.  
source

```
Base.AbstractMatrix– Type.

```

AbstractMatrix {T}

Supertypefortwo-dimensionalarrays(orarray-liketypes)withelementsoftypeT.AliasforAbstractArray{T,2}.  
source

```
Base.AbstractVecOrMat– Type.

```

AbstractVecOrMat {T}

Union type ofAbstractVector{T}andAbstractMatrix{T}.  
source

```
Core.Array– Type.

```

Array {T,N}<: AbstractArray {T,N}

N-dimensional dense array with elements of typeT.  
source

```
#### 725


#### CHAPTER 47. ARRAYS 726

Core.Array– Method.

```

Array {T}(undef, dims)  
Array {T,N}(undef, dims)

Construct an uninitializedN-dimensionalArraycontaining elements of typeT.Ncan either be supplied  
explicitly, as inArray{T,N}(undef, dims), or be determined by the length or number ofdims.dimsmay  
be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rankNis  
suppliedexplicitly, thenitmustmatchthelengthornumberofdims. HereundefistheUndefInitializer.  
Examples

julia> A = Array { Float64 , 2}(undef,2, 3) # N given explicitly  
2×3 Matrix{Float64}:  
6.90198e-310 6.90198e-310 6.90198e-310  
6.90198e-310 6.90198e-310 0.0

julia> B = Array { Float64 }(undef,4) # N determined by the input  
4-element Vector{Float64}:  
2.360075077e-314  
NaN  
2.2671131793e-314  
2.299821756e-314

julia> similar(B,2, 4, 1) # use typeof(B), and the given size  
2×4×1 Array{Float64, 3}:  
[:, :, 1] =  
2.26703e-314 2.26708e-314 0.0 2.80997e-314  
0.0 2.26703e-314 2.26708e-314 0.0

source

```
Core.Array– Method.

```

Array {T}(nothing, dims)  
Array {T,N}(nothing, dims)

Construct anN-dimensionalArraycontaining elements of typeT, initialized withnothingentries. Element  
typeTmust be able to hold these values, i.e.Nothing <: T.  
Examples

julia>Array { Union {Nothing, String}}(nothing, 2)  
2-element Vector{Union{Nothing, String}}:  
nothing  
nothing

julia>Array { Union {Nothing, Int }}(nothing, 2, 3)  
2×3 Matrix{Union{Nothing, Int64}}:  
nothing nothing nothing  
nothing nothing nothing

source

```
Core.Array– Method.

```

Array {T}(missing, dims)  
Array {T,N}(missing, dims)

```

#### CHAPTER 47. ARRAYS 727

```

Construct anN-dimensionalArraycontaining elements of typeT, initialized withmissingentries. Element  
typeTmust be able to hold these values, i.e.Missing <: T.  
Examples

julia>Array { Union {Missing, String}}(missing,2)  
2-element Vector{Union{Missing, String}}:  
missing  
missing

julia>Array { Union {Missing, Int }}(missing,2, 3)  
2×3 Matrix{Union{Missing, Int64}}:  
missing missing missing  
missing missing missing

source

```
Core.UndefInitializer– Type.

```

UndefInitializer

Singleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized  
array. See alsoundef, an alias forUndefInitializer().  
Examples

julia>Array { Float64 , 1}(UndefInitializer(),3)  
3-element Array{Float64, 1}:  
2.2752528595e-314  
2.202942107e-314  
2.275252907e-314

source

```
Core.undef– Constant.

```

undef

Alias forUndefInitializer(), which constructs an instance of the singleton typeUndefInitializer,  
used in array initialization to indicate the array-constructor-caller would like an uninitialized array.  
See also:missing,similar.  
Examples

julia>Array { Float64 , 1}(undef,3)  
3-element Vector{Float64}:  
2.2752528595e-314  
2.202942107e-314  
2.275252907e-314

source

```
Base.Vector– Type.

```

Vector {T} <: AbstractVector {T}

```

#### CHAPTER 47. ARRAYS 728

```

One-dimensionaldensearraywithelementsoftypeT,oftenusedtorepresentamathematicalvector. Alias  
forArray{T,1}.  
See alsoempty,similarandzerofor creating vectors.  
source

```
Base.Vector– Method.

```

Vector {T}(undef, n)

Construct an uninitializedVector{T}of lengthn.  
Examples

julia>Vector { Float64 }(undef,3)  
3-element Array{Float64, 1}:  
6.90966e-310  
6.90966e-310  
6.90966e-310

source

```
Base.Vector– Method.

```

Vector {T}(nothing, m)

Construct aVector{T}of lengthm, initialized withnothingentries. Element typeTmust be able to hold  
these values, i.e.Nothing <: T.  
Examples

julia>Vector { Union {Nothing, String}}(nothing, 2)  
2-element Vector{Union{Nothing, String}}:  
nothing  
nothing

source

```
Base.Vector– Method.

```

Vector {T}(missing, m)

Construct aVector{T}of lengthm, initialized withmissingentries. Element typeTmust be able to hold  
these values, i.e.Missing <: T.  
Examples

julia>Vector { Union {Missing, String}}(missing,2)  
2-element Vector{Union{Missing, String}}:  
missing  
missing

source

```
Base.Matrix– Type.

```

Matrix {T} <: AbstractMatrix {T}

```

#### CHAPTER 47. ARRAYS 729

```

Two-dimensionaldensearraywithelementsoftypeT,oftenusedtorepresentamathematicalmatrix. Alias  
forArray{T,2}.  
See alsofill,zeros,undefandsimilarfor creating matrices.  
source

```
Base.Matrix– Method.

```

Matrix {T}(undef, m, n)

Construct an uninitializedMatrix{T}of sizem×n.  
Examples

julia>Matrix { Float64 }(undef,2, 3)  
2×3 Array{Float64, 2}:  
2.36365e-314 2.28473e-314 5.0e-324  
2.26704e-314 2.26711e-314 NaN

julia> similar(ans, Int32 , 2, 2)  
2×2 Matrix{Int32}:  
490537216 1277177453  
1 1936748399

source

```
Base.Matrix– Method.

```

Matrix {T}(nothing, m, n)

Construct aMatrix{T}of sizem×n, initialized withnothingentries. Element typeTmust be able to hold  
these values, i.e.Nothing <: T.  
Examples

julia>Matrix { Union {Nothing, String}}(nothing, 2, 3)  
2×3 Matrix{Union{Nothing, String}}:  
nothing nothing nothing  
nothing nothing nothing

source

```
Base.Matrix– Method.

```

Matrix {T}(missing, m, n)

Construct aMatrix{T}of sizem×n, initialized withmissingentries. Element typeTmust be able to hold  
these values, i.e.Missing <: T.  
Examples

julia>Matrix { Union {Missing, String}}(missing,2, 3)  
2×3 Matrix{Union{Missing, String}}:  
missing missing missing  
missing missing missing

source

```

#### CHAPTER 47. ARRAYS 730

Base.VecOrMat– Type.

```

VecOrMat {T}

Union type ofVector{T}andMatrix{T}which allows functions to accept either a Matrix or a Vector.  
Examples

julia>Vector { Float64 } <: VecOrMat { Float64 }  
true

julia>Matrix { Float64 } <: VecOrMat { Float64 }  
true

julia>Array { Float64 , 3} <: VecOrMat { Float64 }  
false

source

```
Core.DenseArray– Type.

```

DenseArray {T, N}<: AbstractArray {T,N}

N-dimensional dense array with elements of typeT. The elements of a dense array are stored contiguously  
in memory.  
source

```
Base.DenseVector– Type.

```

DenseVector {T}

One-dimensionalDenseArraywith elements of typeT. Alias forDenseArray{T,1}.  
source

```
Base.DenseMatrix– Type.

```

DenseMatrix {T}

Two-dimensionalDenseArraywith elements of typeT. Alias forDenseArray{T,2}.  
source

```
Base.DenseVecOrMat– Type.

```

DenseVecOrMat {T}

Union type ofDenseVector{T}andDenseMatrix{T}.  
source

```
Base.StridedArray– Type.

```

StridedArray {T, N}

```

#### CHAPTER 47. ARRAYS 731

```

A hard-codedUnionof common array types that follow thestrided array interface, with elements of type  
TandNdimensions.  
IfAis aStridedArray, then its elements are stored in memory with offsets, which may vary between  
dimensions but are constant within a dimension. For example,Acould have stride 2 in dimension 1, and  
stride 3 in dimension 2. IncrementingAalong dimensiondjumps in memory by [strides(A, d)] slots.  
Strided arrays are particularly important and useful because they can sometimes be passed directly as  
pointers to foreign language libraries like BLAS.  
source

```
Base.StridedVector– Type.

```

StridedVector {T}

One dimensionalStridedArraywith elements of typeT.  
source

```
Base.StridedMatrix– Type.

```

StridedMatrix {T}

Two dimensionalStridedArraywith elements of typeT.  
source

```
Base.StridedVecOrMat– Type.

```

StridedVecOrMat {T}

Union type ofStridedVectorandStridedMatrixwith elements of typeT.  
source

```
Base.getindex– Method.

```

getindex( type [, elements...])

Construct a 1-d array of the specified type. This is usually called with the syntaxType[]. Element values  
can be specified usingType[a,b,c,...].  
Examples

julia>Int8 [1, 2, 3]  
3-element Vector{Int8}:  
1  
2  
3

julia> getindex( Int8 , 1, 2, 3)  
3-element Vector{Int8}:  
1  
2  
3

source

```
Base.zeros– Function.


#### CHAPTER 47. ARRAYS 732

```

zeros([T= Float64 ,] dims:: Tuple )  
zeros([T= Float64 ,] dims...)

Create anArray, with element typeT, of all zeros with size specified bydims. See alsofill,ones,zero.  
Examples

julia> zeros(1)  
1-element Vector{Float64}:  
0.0

julia> zeros( Int8 , 2, 3)  
2×3 Matrix{Int8}:  
0 0 0  
0 0 0

source

```
Base.ones– Function.

```

ones([T= Float64 ,] dims:: Tuple )  
ones([T= Float64 ,] dims...)

Create anArray, with element typeT, of all ones with size specified bydims. See alsofill,zeros.  
Examples

julia> ones(1,2)  
1×2 Matrix{Float64}:  
1.0 1.0

julia> ones(ComplexF64,2, 3)  
2×3 Matrix{ComplexF64}:  
1.0+0.0im 1.0+0.0im 1.0+0.0im  
1.0+0.0im 1.0+0.0im 1.0+0.0im

source

```
Base.BitArray– Type.

```

BitArray {N} <: AbstractArray { Bool , N}

Space-efficientN-dimensional boolean array, using just one bit for each boolean value.  
BitArrays pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency overArray{Bool,  
N}and allowing some operations to work on 64 values at once.  
By default, Julia returnsBitArraysfrom broadcastingoperations that generate boolean elements (includ-  
ing dotted-comparisons like.==) as well as from the functionstruesandfalses.

Note  
Due to its packed storage format, concurrent access to the elements of aBitArraywhere at  
least one of them is a write is not thread safe.

source

```
Base.BitArray– Method.


#### CHAPTER 47. ARRAYS 733

```

BitArray (undef, dims:: Integer ...)  
BitArray {N}(undef, dims:: NTuple {N, Int })

Construct an undefBitArraywith the given dimensions. Behaves identically to theArrayconstructor.  
Seeundef.  
Examples

julia>BitArray (undef,2, 2)  
2×2 BitMatrix:  
0 0  
0 0

julia>BitArray (undef, (3, 1))  
3×1 BitMatrix:  
0  
0  
0

source

```
Base.BitArray– Method.

```

BitArray (itr)

Construct aBitArraygenerated by the given iterable object. The shape is inferred from theitrobject.  
Examples

julia>BitArray ([1 0; 0 1])  
2×2 BitMatrix:  
1 0  
0 1

julia>BitArray (x+y == 3 for x = 1:2, y = 1:3)  
2×3 BitMatrix:  
0 1 0  
1 0 0

julia>BitArray (x+y == 3 for x = 1:2 for y = 1:3)  
6-element BitVector:  
0 1 0 1 0 0

source

```
Base.trues– Function.

```

trues(dims)

Create aBitArraywith all values set totrue.  
Examples

```

#### CHAPTER 47. ARRAYS 734

```

julia> trues(2,3)  
2×3 BitMatrix:  
1 1 1  
1 1 1

source

```
Base.falses– Function.

```

falses(dims)

Create aBitArraywith all values set tofalse.  
Examples

julia> falses(2,3)  
2×3 BitMatrix:  
0 0 0  
0 0 0

source

```
Base.fill– Function.

```

fill(x, dims:: Tuple )  
fill(x, dims...)

Create an array filled with the valuex. For example,fill(1.0, (5,5))returns a 5×5 array of floats, with  
each element initialized to1.0.  
dimsmay be specified as either a tuple or a sequence of arguments. For example, the common idiom  
fill(x)creates a zero-dimensional array containing the single valuex.  
See also:fill!,zeros,ones,similar.  
Examples

julia> fill(1.0, ( 2,3))  
2×3 Matrix{Float64}:  
1.0 1.0 1.0  
1.0 1.0 1.0

julia> fill(42)  
0-dimensional Array{Int64, 0}:  
42

Ifxis an object reference, all elements will refer to the same object:

julia> A = fill(zeros(2), 2);

julia> A[1][1] = 42; # modifies both A[1][1] and A[2][1]

julia> A  
2-element Vector{Vector{Float64}}:  
[42.0, 0.0]  
[42.0, 0.0]

source

```

#### CHAPTER 47. ARRAYS 735

Base.fill!– Function.

```

fill!(A, x)

Fill arrayAwith the valuex. Ifxis an object reference, all elements will refer to the same object.fill!(A,  
Foo())will returnAfilled with the result of evaluatingFoo()once.  
Examples

julia> A = zeros(2,3)  
2×3 Matrix{Float64}:  
0.0 0.0 0.0  
0.0 0.0 0.0

julia> fill!(A,2.)  
2×3 Matrix{Float64}:  
2.0 2.0 2.0  
2.0 2.0 2.0

julia> a = [1, 1, 1]; A= fill!( Vector { Vector { Int }}(undef,3), a); a[1] = 2; A  
3-element Vector{Vector{Int64}}:  
[2, 1, 1]  
[2, 1, 1]  
[2, 1, 1]

julia> x = 0; f()= ( global x += 1; x); fill!( Vector { Int }(undef,3), f())  
3-element Vector{Int64}:  
1  
1  
1

source

```
Base.empty– Function.

```

empty(x:: Tuple )

Returns an empty tuple,().  
source  
empty(v::AbstractVector, [eltype])

Create an empty vector similar tov, optionally changing theeltype.  
See also:empty!,isempty,isassigned.  
Examples

julia> empty([1.0, 2.0, 3.0])  
Float64[]

julia> empty([1.0, 2.0, 3.0], String)  
String[]

source  
empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])

```

#### CHAPTER 47. ARRAYS 736

```

Create an emptyAbstractDictcontainer which can accept indices of typeindex_typeand values of  
typevalue_type. The second and third arguments are optional and default to the input'skeytypeand  
valtype, respectively. (If only one of the two types is specified, it is assumed to be thevalue_type, and  
theindex_typewe default tokeytype(a)).  
CustomAbstractDictsubtypes may choose which specific dictionary type is best suited to return for the  
given index and value types, by specializing on the three-argument signature. The default is to return an  
emptyDict.  
source

```
Base.similar– Function.

```

similar(array, [element_type=eltype(array)], [dims=size(array)])

Create an uninitialized mutable array with the given element type and size, based upon the given source  
array. The second and third arguments are both optional, defaulting to the given array'seltypeandsize.  
The dimensions may be specified either as a single tuple argument or as a series of integer arguments.  
Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given  
elementtypeanddimensionality. Iftheydonotspecializethismethod,thedefaultisanArray{element_type}(undef,  
dims...).  
For example,similar(1:10, 1, 4)returns an uninitializedArray{Int,2}since ranges are neither mu-  
table nor support 2 dimensions:

julia> similar(1:10, 1, 4)  
1×4 Array{Int64,2}:  
4419743872 4374413872 4419743888 0

Conversely,similar(trues(10,10), 2)returnsanuninitializedBitVectorwithtwoelementssinceBitArrays  
are both mutable and can support 1-dimensional arrays:

julia> similar(trues(10,10), 2)  
2-element BitVector:  
0  
0

SinceBitArrays can only store elements of typeBool, however, if you request a different element type it  
will create a regularArrayinstead:

julia> similar(falses(10), Float64 , 2, 4)  
2×4 Array{Float64,2}:  
2.18425e-314 2.18425e-314 2.18425e-314 2.18425e-314  
2.18425e-314 2.18425e-314 2.18425e-314 2.18425e-314

See also:undef,isassigned.  
source  
similar(storagetype, axes)

Create an uninitialized mutable array analogous to that specified bystoragetype, but withaxesspecified  
by the last argument.  
Examples :  
similar(Array{Int}, axes(A))

```

#### CHAPTER 47. ARRAYS 737

```

creates an array that"acts like" anArray{Int}(and might indeed be backed by one), but which is indexed  
identically toA. IfAhas conventional indexing, this will be identical toArray{Int}(undef, size(A)), but  
ifAhas unconventional indexing then the indices of the result will matchA.  
similar(BitArray, (axes(A, 2),))

would create a 1-dimensional logical array whose indices match those of the columns ofA.  
source

```
### 47.2 Basic functions

Base.ndims– Function.

```

ndims(A:: AbstractArray ) -> Integer

Return the number of dimensions ofA.  
See also:size,axes.  
Examples

julia> A = fill(1, ( 3,4,5));

julia> ndims(A)  
3

source

```
Base.size– Function.

```

size(A:: AbstractArray , [dim])

Return a tuple containing the dimensions ofA. Optionally you can specify a dimension to just get the length  
of that dimension.  
Note thatsizemay not be defined for arrays with non-standard indices, in which caseaxesmay be useful.  
See the manual chapter onarrays with custom indices.  
See also:length,ndims,eachindex,sizeof.  
Examples

julia> A = fill(1, ( 2,3,4));

julia> size(A)  
(2, 3, 4)

julia> size(A,2)  
3

source

```
Base.axes– Method.

```

axes(A)

```

#### CHAPTER 47. ARRAYS 738

```

Return the tuple of valid indices for arrayA.  
See also:size,keys,eachindex.  
Examples

julia> A = fill(1, ( 5,6,7));

julia> axes(A)  
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))

source

```
Base.axes– Method.

```

axes(A, d)

Return the valid range of indices for arrayAalong dimensiond.  
See alsosize, and the manual chapter onarrays with custom indices.  
Examples

julia> A = fill(1, ( 5,6,7));

julia> axes(A,2)  
Base.OneTo(6)

Usage note  
Each of the indices has to be anAbstractUnitRange{<:Integer}, but at the same time can be a type  
that uses custom indices. So, for example, if you need a subset, use generalized indexing constructs like  
begin/endorfirstindex/lastindex:

ix = axes(v,1)  
ix[2: end ] # will work for eg Vector, but may fail in general  
ix[( begin +1): end ] # works for generalized indexes

source

```
Base.length– Method.

```

length(A:: AbstractArray )

Return the number of elements in the array, defaults toprod(size(A)).  
Examples

julia> length([1, 2, 3, 4])  
4

julia> length([1 2; 3 4])  
4

source

```
Base.keys– Method.


#### CHAPTER 47. ARRAYS 739

```

keys(a:: AbstractArray )

Return an efficient array describing all valid indices foraarranged in the shape ofaitself.  
They keys of 1-dimensional arrays (vectors) are integers, whereas all other N-dimensional arrays use  
CartesianIndextodescribetheirlocations. OftenthespecialarraytypesLinearIndicesandCartesianIndices  
are used to efficiently represent these arrays of integers andCartesianIndexes, respectively.  
Note that thekeysof an array might not be the most efficient index type; for maximum performance use  
eachindexinstead.  
source

```
Base.eachindex– Function.

```

eachindex(A...)

Create an iterable object for visiting each index of anAbstractArray Ain an efficient manner. For array  
types that have opted into fast linear indexing (likeArray), this is simply the range1:length(A). For other  
arraytypes, returnaspecializedCartesianrangetoefficientlyindexintothearraywithindicesspecifiedfor  
everydimension. Forotheriterables, includingstringsanddictionaries, returnaniteratorobjectsupporting  
arbitrary index types (e.g. unevenly spaced or non-integer indices).  
If you supply more than oneAbstractArrayargument,eachindexwill create an iterable object that is fast  
for all arguments (aUnitRangeif all inputs have fast linear indexing, aCartesianIndicesotherwise). If  
the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.  
Examples

julia> A = [1 2; 3 4];

julia>for i in eachindex(A)# linear indexing  
println(i)  
end  
1  
2  
3  
4

julia>for i in eachindex(view(A,1:2, 1:1)) # Cartesian indexing  
println(i)  
end  
CartesianIndex(1, 1)  
CartesianIndex(2, 1)

source

```
Base.IndexStyle– Type.

```

IndexStyle(A)  
IndexStyle(typeof(A))

IndexStylespecifies the"native indexing style" for arrayA. When you define a newAbstractArraytype,  
youcanchoosetoimplementeitherlinearindexing(withIndexLinear)orcartesianindexing. Ifyoudecide  
to only implement linear indexing, then you must set this trait for your array type:  
Base.IndexStyle(::Type{<:MyArray}) = IndexLinear()

```

#### CHAPTER 47. ARRAYS 740

```

The default isIndexCartesian().  
Julia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into  
the preferred style. This allows users to access elements of your array using any indexing style, even when  
explicit methods have not been provided.  
If you define both styles of indexing for yourAbstractArray, this trait can be used to select the most per-  
formant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms  
depending on the most efficient access pattern. In particular,eachindexcreates an iterator whose type  
depends on the setting of this trait.  
source

```
Base.IndexLinear– Type.

```

IndexLinear()

Subtype ofIndexStyleused to describe arrays which are optimally indexed by one linear index.  
A linear indexing style uses one integer index to describe the position in the array (even if it's a multidi-  
mensional array) and column-major ordering is used to efficiently access the elements. This means that  
requestingeachindexfrom an array that isIndexLinearwill return a simple one-dimensional range, even  
if it is multidimensional.  
AcustomarraythatreportsitsIndexStyleasIndexLinearonlyneedstoimplementindexing(andindexed  
assignment) with a singleIntindex; all other indexing expressions — including multidimensional accesses  
— will be recomputed to the linear index. For example, ifAwere a2×3custom matrix with linear indexing,  
and we referencedA[1, 3], this would be recomputed to the equivalent linear index and callA[5]since  
2*1 + 3 = 5.  
See alsoIndexCartesian.  
source

```
Base.IndexCartesian– Type.

```

IndexCartesian()

Subtype ofIndexStyleused to describe arrays which are optimally indexed by a Cartesian index. This is  
the default for new customAbstractArraysubtypes.  
A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional  
array, with exactly one index per dimension. This means that requestingeachindexfrom an array that is  
IndexCartesianwill return a range ofCartesianIndices.  
AN-dimensional custom array that reports itsIndexStyleasIndexCartesianneeds to implement index-  
ing (and indexed assignment) with exactlyN Intindices; all other indexing expressions — including linear  
indexing — will be recomputed to the equivalent Cartesian location. For example, ifAwere a2×3cus-  
tom matrix with cartesian indexing, and we referencedA[5], this would be recomputed to the equivalent  
Cartesian index and callA[1, 3]since5 = 2*1 + 3.  
It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other  
way. The former operation requires division — a very costly operation — whereas the latter only uses  
multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear  
indexing with anIndexCartesianarray than it is to use Cartesian indexing with anIndexLineararray.  
See alsoIndexLinear.  
source

```

#### CHAPTER 47. ARRAYS 741

Base.conj!– Function.

```

conj!(A)

Transform an array to its complex conjugate in-place.  
See alsoconj.  
Examples

julia> A = [1+im 2-im; 2+2im 3+im]  
2×2 Matrix{Complex{Int64}}:  
1+1im 2-1im  
2+2im 3+1im

julia> conj!(A);

julia> A  
2×2 Matrix{Complex{Int64}}:  
1-1im 2+1im  
2-2im 3-1im

source

```
Base.stride– Function.

```

stride(A, k:: Integer )

Return the distance in memory (in number of elements) between adjacent elements in dimensionk.  
See also:strides.  
Examples

julia> A = fill(1, ( 3,4,5));

julia> stride(A,2)  
3

julia> stride(A,3)  
12

source

```
Base.strides– Function.

```

strides(A)

Return a tuple of the memory strides in each dimension.  
See also:stride.  
Examples

julia> A = fill(1, ( 3,4,5));

julia> strides(A)  
(1, 3, 12)

source

```

#### CHAPTER 47. ARRAYS 742

### 47.3 Broadcast and vectorization.

See also thedot syntax for vectorizing functions; for example,f.(args...) implicitly callsbroadcast(f,
args...). Rather than relying on"vectorized" methods of functions likesinto operate on arrays, you should
usesin.(a)to vectorize viabroadcast.

Base.Broadcast.broadcast– Function.

```

broadcast(f, As...)

Broadcast the functionfover the arrays, tuples, collections,Refs and/or scalarsAs.  
Broadcasting applies the functionfover the elements of the container arguments and the scalars them-  
selves inAs. Singleton and missing dimensions are expanded to match the extents of the other arguments  
byvirtuallyrepeatingthevalue. Bydefault,onlyalimitednumberoftypesareconsideredscalars,including  
Numbers,Strings,Symbols,Types,Functions and some common singletons likemissingandnothing.  
All other arguments are iterated over or indexed into elementwise.  
The resulting container type is established by the following rules:

```
- If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.
- If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a
    tuple.
- All other combinations of arguments default to returning anArray, but custom container types can
    define their own implementation and promotion-like rules to customize the result when they appear
    as arguments.

```

A special syntax exists for broadcasting: f.(args...) is equivalent tobroadcast(f, args...), and  
nestedf.(g.(args...))calls are fused into a single broadcast loop.  
Examples

julia> A = [1, 2, 3, 4, 5]  
5-element Vector{Int64}:  
1  
2  
3  
4  
5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]  
5×2 Matrix{Int64}:  
1 2  
3 4  
5 6  
7 8  
9 10

julia> broadcast(+, A, B)  
5×2 Matrix{Int64}:  
2 3  
5 6  
8 9  
11 12  
14 15

```

#### CHAPTER 47. ARRAYS 743

```

julia> parse.( Int , [ "1", "2"])  
2-element Vector{Int64}:  
1  
2

julia> abs.((1, -2))  
(1, 2)

julia> broadcast(+, 1.0, ( 0, -2.0))  
(1.0, -1.0)

julia> (+).([[0,2], [ 1,3]], Ref { Vector { Int }}([1,-1]))  
2-element Vector{Vector{Int64}}:  
[1, 1]  
[2, 2]

julia> string.(("one","two","three","four"), ": " , 1:4)  
4-element Vector{String}:  
"one: 1"  
"two: 2"  
"three: 3"  
"four: 4"

source

```
Base.Broadcast.broadcast!– Function.

```

broadcast!(f, dest, As...)

Likebroadcast,butstoretheresultofbroadcast(f, As...)inthedestarray. Notethatdestisonlyused  
tostoretheresult, anddoesnotsupplyargumentstofunlessitisalsolistedintheAs, asinbroadcast!(f,  
A, A, B)to performA[:] = broadcast(f, A, B).  
Examples

julia> A = [1.0; 0.0]; B= [0.0; 0.0];

julia> broadcast!(+, B, A, (0, -2.0));

julia> B  
2-element Vector{Float64}:  
1.0  
-2.0

julia> A  
2-element Vector{Float64}:  
1.0  
0.0

julia> broadcast!(+, A, A, (0, -2.0));

julia> A  
2-element Vector{Float64}:  
1.0  
-2.0

source

```

#### CHAPTER 47. ARRAYS 744

Base.Broadcast.@__dot__– Macro.

```

@. expr

Convert every function call or operator inexprinto a "dot call" (e.g. convertf(x)tof.(x)), and convert  
every assignment inexprto a "dot assignment" (e.g. convert+=to.+=).  
If you want to avoid adding dots for selected function calls inexpr, splice those function calls in with$.  
For example,@. sqrt(abs($sort(x)))is equivalent tosqrt.(abs.(sort(x)))(no dot forsort).  
(@.is equivalent to a call to@**dot**.)  
Examples

julia> x = 1.0:3.0; y = similar(x);

julia> @. y = x + 3 * sin(x)  
3-element Vector{Float64}:  
3.5244129544236893  
4.727892280477045  
3.4233600241796016

source

```
For specializing broadcast on custom types, see

Base.Broadcast.BroadcastStyle– Type.

```

BroadcastStyleis an abstract type and trait-function used to determine behavior of objects under broad-  
casting.BroadcastStyle(typeof(x))returns the style associated withx. To customize the broadcasting  
behavior of a type, one can declare a style by defining a type/method pair  
struct MyContainerStyle <: BroadcastStyle end  
Base.BroadcastStyle(::Type{<:MyContainer}) = MyContainerStyle()

One then writes method(s) (at leastsimilar) operating onBroadcasted{MyContainerStyle}. There are  
also several pre-defined subtypes ofBroadcastStylethat you may be able to leverage; see theInterfaces  
chapterfor more information.  
source

```
Base.Broadcast.AbstractArrayStyle– Type.

```

Broadcast.AbstractArrayStyle{N} <: BroadcastStyleis the abstract supertype for any style associ-  
ated with anAbstractArraytype. TheNparameter is the dimensionality, which can be handy for Abstrac-  
tArray types that only support specific dimensionalities:  
struct SparseMatrixStyle <: Broadcast.AbstractArrayStyle{2} end  
Base.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatrixStyle()

ForAbstractArraytypes that support arbitrary dimensionality,Ncan be set toAny:  
struct MyArrayStyle <: Broadcast.AbstractArrayStyle{Any} end  
Base.BroadcastStyle(::Type{<:MyArray}) = MyArrayStyle()

IncaseswhereyouwanttobeabletomixmultipleAbstractArrayStylesandkeeptrackofdimensionality,  
your style needs to support aValconstructor:  
struct MyArrayStyleDim{N} <: Broadcast.AbstractArrayStyle{N} end  
(::Type{<:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()

```

#### CHAPTER 47. ARRAYS 745

```

Note that if two or moreAbstractArrayStylesubtypes conflict, broadcasting machinery will fall back to  
producingArrays. If this is undesirable, you may need to define binaryBroadcastStylerules to control  
the output type.  
See alsoBroadcast.DefaultArrayStyle.  
source

```
Base.Broadcast.ArrayStyle– Type.

```

Broadcast.ArrayStyle{MyArrayType}()is aBroadcastStyleindicating that an object behaves as an  
arrayforbroadcasting. ItpresentsasimplewaytoconstructBroadcast.AbstractArrayStylesforspecific  
AbstractArraycontainer types. Broadcast styles created this way lose track of dimensionality; if keeping  
track is important for your type, you should create your own customBroadcast.AbstractArrayStyle.  
source

```
Base.Broadcast.DefaultArrayStyle– Type.

```

Broadcast.DefaultArrayStyle{N}()is aBroadcastStyleindicating that an object behaves as anN-  
dimensional array for broadcasting. Specifically,DefaultArrayStyleis used for anyAbstractArraytype  
that hasn't defined a specialized style, and in the absence of overrides from otherbroadcastarguments  
the resulting output type isArray. When there are multiple inputs tobroadcast,DefaultArrayStyle  
"loses" to any otherBroadcast.ArrayStyle.  
source

```
Base.Broadcast.broadcastable– Function.

```

Broadcast.broadcastable(x)

Return eitherxor an object likexsuch that it supportsaxes, indexing, and its type supportsndims.  
Ifxsupportsiteration,thereturnedvalueshouldhavethesameaxesandindexingbehaviorsascollect(x).  
IfxisnotanAbstractArraybutitsupportsaxes,indexing,anditstypesupportsndims,thenbroadcastable(::typeof(x))  
may be implemented to just return itself. Further, ifxdefines its ownBroadcastStyle, then it must define  
itsbroadcastablemethod to return itself for the custom style to have any effect.  
Examples

julia> Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and  
↪→ indexing  
3-element Vector{Int64}:  
1  
2  
3

julia> Broadcast.broadcastable( Int ) # Types don't support axes, indexing, or iteration but are  
↪→ commonly used as scalars  
Base.RefValue{Type{Int64}}(Int64)

julia> Broadcast.broadcastable("hello") # Strings break convention of matching iteration and act  
↪→ like a scalar instead  
Base.RefValue{String}("hello")

source

```
Base.Broadcast.combine_axes– Function.


#### CHAPTER 47. ARRAYS 746

```

combine_axes(As...) -> Tuple

Determine the result axes for broadcasting across all values inAs.

julia> Broadcast.combine_axes([1], [ 1 2; 3 4; 5 6])  
(Base.OneTo(3), Base.OneTo(2))

julia> Broadcast.combine_axes(1, 1, 1)  
()

source

```
Base.Broadcast.combine_styles– Function.

```

combine_styles(cs...) -> BroadcastStyle

Decides whichBroadcastStyleto use for any number of value arguments. UsesBroadcastStyleto get  
the style for each argument, and usesresult_styleto combine styles.  
Examples

julia> Broadcast.combine_styles([1], [ 1 2; 3 4])  
Base.Broadcast.DefaultArrayStyle{2}()

source

```
Base.Broadcast.result_style– Function.

```

result_style(s1::BroadcastStyle[, s2::BroadcastStyle])-> BroadcastStyle

Takes one or twoBroadcastStyles and combines them usingBroadcastStyleto determine a common  
BroadcastStyle.  
Examples

julia> Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(),  
↪→ Broadcast.DefaultArrayStyle{3}())  
Base.Broadcast.DefaultArrayStyle{3}()

julia> Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())  
Base.Broadcast.DefaultArrayStyle{1}()

source

```
### 47.4 Indexing and assignment

Base.getindex– Method.

```

getindex(A, inds...)

ReturnasubsetofarrayAasspecifiedbyinds,whereeachindmaybe,forexample,anInt,anAbstractRange,  
or aVector. See the manual section onarray indexingfor details.  
Examples

```

#### CHAPTER 47. ARRAYS 747

```

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> getindex(A,1)  
1

julia> getindex(A, [2, 1])  
2-element Vector{Int64}:  
3  
1

julia> getindex(A,2:4)  
3-element Vector{Int64}:  
3  
2  
4

source

```
Base.setindex!– Method.

```

setindex!(A, X, inds...)  
A[inds...] = X

Store values from arrayXwithin some subset ofAas specified byinds. The syntaxA[inds...] = Xis  
equivalent to(setindex!(A, X, inds...); X).  
Examples

julia> A = zeros(2,2);

julia> setindex!(A, [10, 20], [ 1, 2]);

julia> A[[3, 4]] = [30, 40];

julia> A  
2×2 Matrix{Float64}:  
10.0 30.0  
20.0 40.0

source

```
Base.copyto!– Method.

```

copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices)-> dest

Copy the block ofsrcin the range ofRsrcto the block ofdestin the range ofRdest. The sizes of the two  
regions must match.  
source

```
Base.copy!– Function.

```

copy!(dst, src)-> dst

```

#### CHAPTER 47. ARRAYS 748

```

In-placecopyofsrcintodst, discarding any pre-existing elements indst. Ifdstandsrcare of the same  
type,dst == srcshould hold after the call. Ifdstandsrcare multidimensional arrays, they must have  
equalaxes.  
See alsocopyto!.

Julia 1.1  
This method requires at least Julia 1.1. In Julia 1.0 this method is available from theFuture  
standard library asFuture.copy!.

source

```
Base.isassigned– Function.

```

isassigned(array, i)-> Bool

Testwhetherthegivenarrayhasavalueassociatedwithindexi. Returnfalseiftheindexisoutofbounds,  
or has an undefined reference.  
Examples

julia> isassigned(rand(3, 3), 5)  
true

julia> isassigned(rand(3, 3), 3 * 3 + 1)  
false

julia> mutable struct Foo end

julia> v = similar(rand(3), Foo)  
3-element Vector{Foo}:  
#undef  
#undef  
#undef

julia> isassigned(v,1)  
false

source

```
Base.Colon– Type.

```

Colon ()

Colons (:) are used to signify indexing entire objects or dimensions at once.  
VeryfewoperationsaredefinedonColonsdirectly; insteadtheyareconvertedbyto_indicestoaninternal  
vector type (Base.Slice) to represent the collection of indices they span before being used.  
The singleton instance ofColonis also a function used to construct ranges; see:.  
source

```
Base.IteratorsMD.CartesianIndex– Type.

```

CartesianIndex (i, j, k...) -> I  
CartesianIndex ((i, j, k...)) -> I

```

#### CHAPTER 47. ARRAYS 749

```

Create a multidimensional indexI, which can be used for indexing a multidimensional arrayA. In par-  
ticular,A[I]is equivalent toA[i,j,k...]. One can freely mix integer andCartesianIndexindices; for  
example,A[Ipre, i, Ipost](whereIpreandIpostareCartesianIndexindices andiis anInt) can  
be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary  
dimensionality.  
ACartesianIndexis sometimes produced byeachindex, and always when iterating with an explicit  
CartesianIndices.  
Examples

julia> A = reshape( Vector (1:16), ( 2, 2, 2, 2))  
2×2×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 3  
2 4

[:, :, 2, 1] =  
5 7  
6 8

[:, :, 1, 2] =  
9 11  
10 12

[:, :, 2, 2] =  
13 15  
14 16

julia> A[ CartesianIndex ((1, 1, 1, 1))]  
1

julia> A[ CartesianIndex ((1, 1, 1, 2))]  
9

julia> A[ CartesianIndex ((1, 1, 2, 1))]  
5

source

```
Base.IteratorsMD.CartesianIndices– Type.

```

CartesianIndices(sz:: Dims ) -> R  
CartesianIndices((istart:[istep:]istop, jstart:[jstep:]jstop,...)) -> R

Define a regionRspanning a multidimensional rectangular range of integer indices. These are most com-  
monly encountered in the context of iteration, wherefor I in R ... endwill returnCartesianIndex  
indicesIequivalent to the nested loops  
for j = jstart:jstep:jstop  
for i = istart:istep:istop  
...  
end  
end

Consequently these can be useful for writing algorithms that work in arbitrary dimensions.  
CartesianIndices(A::AbstractArray) -> R

```

#### CHAPTER 47. ARRAYS 750

```

As a convenience, constructing aCartesianIndicesfrom an array makes a range of its indices.

Julia 1.6  
The step range methodCartesianIndices((istart:istep:istop, jstart:[jstep:]jstop,  
...))requires at least Julia 1.6.

Examples

julia> foreach(println, CartesianIndices((2, 2, 2)))  
CartesianIndex(1, 1, 1)  
CartesianIndex(2, 1, 1)  
CartesianIndex(1, 2, 1)  
CartesianIndex(2, 2, 1)  
CartesianIndex(1, 1, 2)  
CartesianIndex(2, 1, 2)  
CartesianIndex(1, 2, 2)  
CartesianIndex(2, 2, 2)

julia> CartesianIndices(fill(1, ( 2,3)))  
2×3 CartesianIndices{2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}:  
CartesianIndex(1, 1) CartesianIndex(1, 2) CartesianIndex(1, 3)  
CartesianIndex(2, 1) CartesianIndex(2, 2) CartesianIndex(2, 3)

Conversion between linear and cartesian indices  
Linear index to cartesian index conversion exploits the fact that aCartesianIndicesis anAbstractArray  
and can be indexed linearly:

julia> cartesian= CartesianIndices((1:3, 1:2))  
3×2 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:  
CartesianIndex(1, 1) CartesianIndex(1, 2)  
CartesianIndex(2, 1) CartesianIndex(2, 2)  
CartesianIndex(3, 1) CartesianIndex(3, 2)

julia> cartesian[4]  
CartesianIndex(1, 2)

julia> cartesian= CartesianIndices((1:2:5, 1:2))  
3×2 CartesianIndices{2, Tuple{StepRange{Int64, Int64}, UnitRange{Int64}}}:  
CartesianIndex(1, 1) CartesianIndex(1, 2)  
CartesianIndex(3, 1) CartesianIndex(3, 2)  
CartesianIndex(5, 1) CartesianIndex(5, 2)

julia> cartesian[2, 2]  
CartesianIndex(3, 2)

Broadcasting  
CartesianIndicessupport broadcasting arithmetic (+ and -) with aCartesianIndex.

Julia 1.1  
Broadcasting of CartesianIndices requires at least Julia 1.1.

julia> CIs = CartesianIndices((2:3, 5:6))  
2×2 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:

```

#### CHAPTER 47. ARRAYS 751

```

CartesianIndex(2, 5) CartesianIndex(2, 6)  
CartesianIndex(3, 5) CartesianIndex(3, 6)

julia> CI = CartesianIndex (3, 4)  
CartesianIndex(3, 4)

julia> CIs .+ CI  
2×2 CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:  
CartesianIndex(5, 9) CartesianIndex(5, 10)  
CartesianIndex(6, 9) CartesianIndex(6, 10)

For cartesian to linear index conversion, seeLinearIndices.  
source

```
Base.Dims– Type.

```

Dims {N}

AnNTupleofN Ints used to represent the dimensions of anAbstractArray.  
source

```
Base.LinearIndices– Type.

```

LinearIndices(A:: AbstractArray )

Return aLinearIndicesarray with the same shape andaxesasA, holding the linear index of each entry  
inA. Indexing this array with cartesian indices allows mapping them to linear indices.  
For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices  
range from 1 tolength(A). However, forAbstractVectors linear indices areaxes(A, 1), and therefore  
do not start at 1 for vectors with unconventional indexing.  
Calling this function is the"safe" way to write algorithms that exploit linear indexing.  
Examples

julia> A = fill(1, ( 5,6,7));

julia> b = LinearIndices(A);

julia> extrema(b)  
(1, 210)

LinearIndices(inds::CartesianIndices) -> R  
LinearIndices(sz::Dims) -> R  
LinearIndices((istart:istop, jstart:jstop, ...)) -> R

Return aLinearIndicesarray with the specified shape oraxes.  
Example  
The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:

julia> linear= LinearIndices((1:3, 1:2))  
3×2 LinearIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:  
1 4  
2 5

```

#### CHAPTER 47. ARRAYS 752

```

3 6

julia> linear[1,2]  
4

source

```
Base.to_indices– Function.

```

to_indices(A,I:: Tuple )

Convert the tupleIto a tuple of indices for use in indexing into arrayA.  
The returned tuple must only contain eitherInts orAbstractArrays of scalar indices that are supported  
by arrayA. It will error upon encountering a novel index type that it does not know how to process.  
For simple index types, it defers to the unexportedBase.to_index(A, i)to process each indexi. While  
this internal function is not intended to be called directly,Base.to_indexmay be extended by custom  
array or index types to provide custom indexing behaviors.  
More complicated index types may require more context about the dimension into which they index. To  
support those cases,to_indices(A, I)callsto_indices(A, axes(A), I), which then recursively walks  
through both the given tuple of indices and the dimensional indices ofAin tandem. As such, not all index  
types are guaranteed to propagate toBase.to_index.  
source

```
Base.checkbounds– Function.

```

checkbounds( Bool , A,I...)

ReturntrueifthespecifiedindicesIareinboundsforthegivenarrayA.SubtypesofAbstractArrayshould  
specialize this method if they need to provide custom bounds checking behaviors; however, in many cases  
one can rely onA's indices andcheckindex.  
See alsocheckindex.  
Examples

julia> A = rand(3, 3);

julia> checkbounds( Bool , A,2)  
true

julia> checkbounds( Bool , A,3, 4)  
false

julia> checkbounds( Bool , A,1:3)  
true

julia> checkbounds( Bool , A,1:3, 2:4)  
false

source  
checkbounds(A, I...)

Throw an error if the specified indicesIare not in bounds for the given arrayA.  
source

```

#### CHAPTER 47. ARRAYS 753

Base.checkindex– Function.

```

checkindex( Bool , inds::AbstractUnitRange, index)

Returntrueif the givenindexis within the bounds ofinds. Custom types that would like to behave as  
indices for all arrays can extend this method in order to provide a specialized bounds checking implemen-  
tation.  
See alsocheckbounds.  
Examples

julia> checkindex( Bool , 1:20, 8)  
true

julia> checkindex( Bool , 1:20, 21)  
false

source

```
Base.elsize– Function.

```

elsize( type )

Compute the memory stride in bytes between consecutive elements ofeltypestored inside the given  
type, if the array elements are stored densely with a uniform linear stride.  
source

```
### 47.5 Views (SubArrays and other view types)

A “view” is a data structure that acts like an array (it is a subtype ofAbstractArray), but the underlying data
is actually part of another array.

For example, ifxis an array andv = @view x[1:10], thenvacts like a 10-element array, but its data is
actually accessing the first 10 elements ofx. Writing to a view, e.g.v[3] = 2, writes directly to the underlying
arrayx(in this case modifyingx[3]).

Slicing operations likex[1:10]create a copy by default in Julia.@view x[1:10]changes it to make a view.
The@viewsmacro can be used on a whole block of code (e.g.@views function foo() .... endor@views
begin ... end) to change all the slicing operations in that block to use views. Sometimes making a copy of
the data is faster and sometimes using a view is faster, as described in theperformance tips.

Base.view– Function.

```

view(A, inds...)

Likegetindex, but returnsalightweight arraythat lazily references(or is effectively aview into) the parent  
arrayAat the given index or indicesindsinstead of eagerly extracting elements or constructing a copied  
subset. Callinggetindexorsetindex!on the returned value (often aSubArray) computes the indices to  
access or modify the parent array on the fly. The behavior is undefined if the shape of the parent array is  
changed afterviewis called because there is no bound check for the parent array; e.g., it may cause a  
segmentation fault.  
Some immutable parent arrays (like ranges) may choose to simply recompute a new array in some circum-  
stances instead of returning aSubArrayif doing so is efficient and provides compatible semantics.

```

#### CHAPTER 47. ARRAYS 754

```

Julia 1.6  
In Julia 1.6 or later,viewcan be called on anAbstractString, returning aSubString.

Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> b = view(A,:, 1)  
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:  
1  
3

julia> fill!(b,0)  
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:  
0  
0

julia> A # Note A has changed even though we modified b  
2×2 Matrix{Int64}:  
0 2  
0 4

julia> view(2:5, 2:3) # returns a range as type is immutable  
3:4

source

```
Base.@view– Macro.

```

@viewA[inds...]

Transform the indexing expressionA[inds...]into the equivalentviewcall.  
This can only be applied directly to a single indexing expression and is particularly helpful for expres-  
sions that include the specialbeginorendindexing syntaxes likeA[begin, 2:end-1](as those are not  
supported by the normalviewfunction).  
Note that@viewcannot be used as the target of a regular assignment (e.g.,@view(A[1, 2:end]) = ...),  
nor would the un-decoratedindexed assignment(A[1, 2:end] = ...) or broadcasted indexed assign-  
ment (A[1, 2:end] .= ...) make a copy. It can be useful, however, for updating broadcasted as-  
signments like@view(A[1, 2:end]) .+= 1because this is a simple syntax for@view(A[1, 2:end]) .=  
@view(A[1, 2:end]) + 1, and the indexing expression on the right-hand side would otherwise make a  
copy without the@view.  
See also@viewsto switch an entire block of code to use views for non-scalar indexing.

Julia 1.5  
Usingbeginin an indexing expression to refer to the first index requires at least Julia 1.5.

Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:

```

#### CHAPTER 47. ARRAYS 755

```

1 2  
3 4

julia> b = @viewA[:, 1]  
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:  
1  
3

julia> fill!(b,0)  
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:  
0  
0

julia> A  
2×2 Matrix{Int64}:  
0 2  
0 4

source

```
Base.@views– Macro.

```

@viewsexpression

Convert every array-slicing operation in the given expression (which may be abegin/endblock, loop,  
function, etc.) to return a view. Scalar indices, non-array types, and explicitgetindexcalls (as opposed to  
array[...]) are unaffected.

Note  
The@viewsmacro only affectsarray[...] expressions that appear explicitly in the given  
expression, not array slicing that occurs in functions called by that code.

Julia 1.5  
Usingbeginin an indexing expression to refer to the first index requires at least Julia 1.5.

Examples

julia> A = zeros(3, 3);

julia> @views for row in 1:3  
b = A[row,:]  
b[:] .= row  
end

julia> A  
3×3 Matrix{Float64}:  
1.0 1.0 1.0  
2.0 2.0 2.0  
3.0 3.0 3.0

source

```
Base.parent– Function.

```

parent(A)

```

#### CHAPTER 47. ARRAYS 756

```

Return the underlying"parent array”. This parent array of objects of typesSubArray,ReshapedArrayor  
LinearAlgebra.Transposeis what was passed as an argument toview,reshape,transpose, etc. during  
object creation. If the input is not a wrapped object, return the input itself. If the input is wrapped multiple  
times, only the outermost wrapper will be removed.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> V = view(A,1:2, :)  
2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:  
1 2  
3 4

julia> parent(V)  
2×2 Matrix{Int64}:  
1 2  
3 4

source

```
Base.parentindices– Function.

```

parentindices(A)

Return the indices in theparentwhich correspond to the array viewA.  
Examples

julia> A = [1 2; 3 4];

julia> V = view(A,1, :)  
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:  
1  
2

julia> parentindices(V)  
(1, Base.Slice(Base.OneTo(2)))

source

```
Base.selectdim– Function.

```

selectdim(A, d:: Integer , i)

Return a view of all the data ofAwhere the index for dimensiondequalsi.  
Equivalent toview(A,:,:,...,i,:,:,...)whereiis in positiond.  
See also:eachslice.  
Examples

```

#### CHAPTER 47. ARRAYS 757

```

julia> A = [1 2 3 4; 5 6 7 8]  
2×4 Matrix{Int64}:  
1 2 3 4  
5 6 7 8

julia> selectdim(A,2, 3)  
2-element view(::Matrix{Int64}, :, 3) with eltype Int64:  
3  
7

julia> selectdim(A,2, 3:4)  
2×2 view(::Matrix{Int64}, :, 3:4) with eltype Int64:  
3 4  
7 8

source

```
Base.reinterpret– Function.

```

reinterpret( type , A)

Changethetype-interpretationofablockofmemory. Forarrays, thisconstructsaviewofthearraywiththe  
samebinarydataasthegivenarray,butwiththespecifiedelementtype. Forexample,reinterpret(Float32,  
UInt32(7))interprets the 4 bytes corresponding toUInt32(7)as aFloat32.  
Examples

julia> reinterpret( Float32 , UInt32 (7))  
1.0f-44

julia> reinterpret( Float32 , UInt32 [1 2 3 4 5])  
1×5 reinterpret(Float32, ::Matrix{UInt32}):  
1.0f-45 3.0f-45 4.0f-45 6.0f-45 7.0f-45

source  
reinterpret(reshape, T, A::AbstractArray{S}) -> B

Change the type-interpretation ofAwhile consuming or adding a"channel dimension."  
Ifsizeof(T) = n_sizeof(S)forn>1,A's first dimension must be of sizenandBlacksA's first dimension.  
Conversely,ifsizeof(S) = n_sizeof(T)forn>1,Bgetsanewfirstdimensionofsizen. Thedimensionality  
is unchanged ifsizeof(T) == sizeof(S).

Julia 1.6  
This method requires at least Julia 1.6.

Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> reinterpret(reshape, Complex { Int }, A) # the result is a vector  
2-element reinterpret(reshape, Complex{Int64}, ::Matrix{Int64}) with eltype Complex{Int64}:

```

#### CHAPTER 47. ARRAYS 758

```

1 + 3im  
2 + 4im

julia> a = [(1,2,3), ( 4,5,6)]  
2-element Vector{Tuple{Int64, Int64, Int64}}:  
(1, 2, 3)  
(4, 5, 6)

julia> reinterpret(reshape, Int , a) # the result is a matrix  
3×2 reinterpret(reshape, Int64, ::Vector{Tuple{Int64, Int64, Int64}}) with eltype Int64:  
1 4  
2 5  
3 6

source

```
Base.reshape– Function.

```

reshape(A, dims...) -> AbstractArray  
reshape(A, dims)-> AbstractArray

Return an array with the same data asA, but with different dimension sizes or number of dimensions. The  
two arrays share the same underlying data, so that the result is mutable if and only ifAis mutable, and  
setting elements of one alters the values of the other.  
The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one  
dimension may be specified with a:, in which case its length is computed such that its product with all  
the specified dimensions is equal to the length of the original arrayA. The total number of elements must  
not change.  
Examples

julia> A = Vector (1:16)  
16-element Vector{Int64}:  
1 2 3 4 5 6 7 8 9

10  
11  
12  
13  
14  
15  
16

julia> reshape(A, (4, 4))  
4×4 Matrix{Int64}:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

```

#### CHAPTER 47. ARRAYS 759

```

julia> reshape(A,2, :)  
2×8 Matrix{Int64}:  
1 3 5 7 9 11 13 15  
2 4 6 8 10 12 14 16

julia> reshape(1:6, 2, 3)  
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:  
1 3 5  
2 4 6

source

```
Base.dropdims– Function.

```

dropdims(A; dims)

Return an array with the same data asA, but with the dimensions specified bydimsremoved.size(A,d)  
must equal 1 for everydindims, and repeated dimensions or numbers outside1:ndims(A)are forbidden.  
The result shares the same underlying data asA, such that the result is mutable if and only ifAis mutable,  
and setting elements of one alters the values of the other.  
See also:reshape,vec.  
Examples

julia> a = reshape( Vector (1:4),(2,2,1,1))  
2×2×1×1 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 3  
2 4

julia> b = dropdims(a; dims=3)  
2×2×1 Array{Int64, 3}:  
[:, :, 1] =  
1 3  
2 4

julia> b[1,1,1] = 5; a  
2×2×1×1 Array{Int64, 4}:  
[:, :, 1, 1] =  
5 3  
2 4

source

```
Base.vec– Function.

```

vec(a:: AbstractArray ) -> AbstractVector

Reshape the arrayaas a one-dimensional column vector. Returnaif it is already anAbstractVector. The  
resulting array shares the same underlying data asa, so it will only be mutable ifais mutable, in which  
case modifying one will also modify the other.  
Examples

```

#### CHAPTER 47. ARRAYS 760

```

julia> a = [1 2 3; 4 5 6]  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> vec(a)  
6-element Vector{Int64}:  
1 4 2 5 3 6

julia> vec(1:3)  
1:3

See alsoreshape,dropdims.  
source

```
Base.SubArray– Type.

```

SubArray {T,N,P,I,L} <: AbstractArray {T,N}

N-dimensional view into a parent array (of typeP) with an element typeT, restricted by a tuple of indices  
(of typeI).Lis true for types that support fast linear indexing, andfalseotherwise.  
ConstructSubArrays using theviewfunction.  
source

```
### 47.6 Concatenation and permutation.

Base.cat– Function.

```

cat(A...; dims)

Concatenate the input arrays along the specified dimensions in the iterabledims. For dimensions not in  
dims, all input arrays should have the same size, which will also be the size of the output array along  
that dimension. For dimensions indims, the size of the output array is the sum of the sizes of the input  
arrays along that dimension. Ifdimsis a single number, the different arrays are tightly stacked along that  
dimension. Ifdimsis an iterable containing several dimensions, this allows one to construct block diago-  
nal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for  
every new input array and putting zero blocks elsewhere. For example,cat(matrices...; dims=(1,2))  
builds a block diagonal matrix, i.e. a block matrix withmatrices[1],matrices[2], ... as diagonal blocks  
and matching zero blocks away from the diagonal.  
See alsohcat,vcat,hvcat,repeat.  
Examples

julia> cat([1 2; 3 4], [ pi, pi], fill(10, 2,3,1); dims=2)  
2×6×1 Array{Float64, 3}:  
[:, :, 1] =  
1.0 2.0 3.14159 10.0 10.0 10.0  
3.0 4.0 3.14159 10.0 10.0 10.0

```

#### CHAPTER 47. ARRAYS 761

```

julia> cat( true , trues(2,2), trues(4)', dims=(1,2))  
4×7 Matrix{Bool}:  
1 0 0 0 0 0 0  
0 1 1 0 0 0 0  
0 1 1 0 0 0 0  
0 0 0 1 1 1 1

source

```
Base.vcat– Function.

```

vcat(A...)

Concatenate along dimension 1.  
Examples

julia> a = [1 2 3 4 5]  
1×5 Matrix{Int64}:  
1 2 3 4 5

julia> b = [6 7 8 9 10; 11 12 13 14 15]  
2×5 Matrix{Int64}:  
6 7 8 9 10  
11 12 13 14 15

julia> vcat(a,b)  
3×5 Matrix{Int64}:  
1 2 3 4 5  
6 7 8 9 10  
11 12 13 14 15

julia> c = ([1 2 3], [ 4 5 6])  
([1 2 3], [4 5 6])

julia> vcat(c...)  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

source

```
Base.hcat– Function.

```

hcat(A...)

Concatenate along dimension 2.  
Examples

julia> a = [1; 2; 3; 4; 5]  
5-element Vector{Int64}:  
1  
2  
3  
4

```

#### CHAPTER 47. ARRAYS 762

```

5

julia> b = [6 7; 8 9; 10 11; 12 13; 14 15]  
5×2 Matrix{Int64}:  
6 7  
8 9  
10 11  
12 13  
14 15

julia> hcat(a,b)  
5×3 Matrix{Int64}:  
1 6 7  
2 8 9  
3 10 11  
4 12 13  
5 14 15

julia> c = ([1; 2; 3], [ 4; 5; 6])  
([1, 2, 3], [4, 5, 6])

julia> hcat(c...)  
3×2 Matrix{Int64}:  
1 4  
2 5  
3 6

julia> x = Matrix (undef,3, 0) # x = [] would have created an Array{Any, 1}, but need an  
↪→ Array{Any, 2}  
3×0 Matrix{Any}

julia> hcat(x, [1; 2; 3])  
3×1 Matrix{Any}:  
1  
2  
3

source

```
Base.hvcat– Function.

```

hvcat(rows:: Tuple { Vararg { Int }}, values...)

Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first  
argument specifies the number of arguments to concatenate in each block row.  
Examples

julia> a, b, c, d,e, f = 1, 2, 3, 4, 5, 6  
(1, 2, 3, 4, 5, 6)

julia> [a b c; de f]  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> hvcat((3,3), a,b,c,d,e,f)

```

#### CHAPTER 47. ARRAYS 763

```

2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> [a b; c d;e f]  
3×2 Matrix{Int64}:  
1 2  
3 4  
5 6

julia> hvcat((2,2,2), a,b,c,d,e,f)  
3×2 Matrix{Int64}:  
1 2  
3 4  
5 6

If the first argument is a single integern, then all block rows are assumed to havenblock columns.  
source

```
Base.hvncat– Function.

```

hvncat(dim:: Int , row_first, values...)  
hvncat(dims:: Tuple { Vararg { Int }}, row_first, values...)  
hvncat(shape:: Tuple { Vararg { Tuple }}, row_first, values...)

Horizontal, vertical, and n-dimensional concatenation of manyvaluesin one call.  
This function is called for block matrix syntax. The first argument either specifies the shape of the concate-  
nation, similar tohvcat, as a tuple of tuples, or the dimensions that specify the key number of elements  
along each axis, and is used to determine the output dimensions. Thedimsform is more performant, and  
is used by default when the concatenation operation has the same number of elements along each axis  
(e.g., [a b; c d;;; e f ; g h]). Theshapeform is used when the number of elements along each axis is  
unbalanced (e.g., [a b ; c]). Unbalanced syntax needs additional validation overhead. Thedimform is an  
optimization for concatenation along just one dimension.row_firstindicates howvaluesare ordered.  
The meaning of the first and second elements ofshapeare also swapped based onrow_first.  
Examples

julia> a, b, c, d,e, f = 1, 2, 3, 4, 5, 6  
(1, 2, 3, 4, 5, 6)

julia> [a b c;;; de f]  
1×3×2 Array{Int64, 3}:  
[:, :, 1] =  
1 2 3

[:, :, 2] =  
4 5 6

julia> hvncat((2,1,3), false , a,b,c,d,e,f)  
2×1×3 Array{Int64, 3}:  
[:, :, 1] =  
1  
2

[:, :, 2] =

```

#### CHAPTER 47. ARRAYS 764

```

3  
4

[:, :, 3] =  
5  
6

julia> [a b;;; c d;;;e f]  
1×2×3 Array{Int64, 3}:  
[:, :, 1] =  
1 2

[:, :, 2] =  
3 4

[:, :, 3] =  
5 6

julia> hvncat(((3, 3), ( 3, 3), ( 6,)), true , a, b, c, d,e, f)  
1×3×2 Array{Int64, 3}:  
[:, :, 1] =  
1 2 3

[:, :, 2] =  
4 5 6

Examples for construction of the arguments:  
[a b c ; d e f ;;; g h i ; j k l ;;; m n o ; p q r ;;; s t u ; v w x] => dims = (2, 3, 4)  
[a b ; c ;;; d ;;;;] ___ _ _ 2 1 1 = elements in each row (2, 1, 1) _______ _ 3 1 = elements in each column  
(3, 1) _____________ 4 = elements in each 3d slice (4,) _____________ 4 = elements in each 4d slice (4,) =>  
shape = ((2, 1, 1), (3, 1), (4,), (4,)) withrowfirst= true  
source

```
Base.vect– Function.

```

vect(X...)

Create aVectorwith element type computed from thepromote_typeofof the argument, containing the  
argument list.  
Examples

julia> a = Base.vect( UInt8 (1), 2.5, 1//2)  
3-element Vector{Float64}:  
1.0  
2.5  
0.5

source

```
Base.circshift– Function.

```

circshift(A, shifts)

```

#### CHAPTER 47. ARRAYS 765

```

Circularlyshift, i.e. rotate, thedatainanarray. Thesecondargumentisatupleorvectorgivingtheamount  
to shift in each dimension, or an integer to shift only in the first dimension.  
See also:circshift!,circcopy!,bitrotate,<<.  
Examples

julia> b = reshape( Vector (1:16), ( 4,4))  
4×4 Matrix{Int64}:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

julia> circshift(b, (0,2))  
4×4 Matrix{Int64}:  
9 13 1 5  
10 14 2 6  
11 15 3 7  
12 16 4 8

julia> circshift(b, (-1,0))  
4×4 Matrix{Int64}:  
2 6 10 14  
3 7 11 15  
4 8 12 16  
1 5 9 13

julia> a = BitArray ([ true , true , false , false , true ])  
5-element BitVector:  
1  
1  
0  
0  
1

julia> circshift(a,1)  
5-element BitVector:  
1  
1  
1  
0  
0

julia> circshift(a,-1)  
5-element BitVector:  
1  
0  
0  
1  
1

source

```
Base.circshift!– Function.

```

circshift!(dest, src, shifts)

```

#### CHAPTER 47. ARRAYS 766

```

Circularly shift, i.e. rotate, the data insrc, storing the result indest.shiftsspecifies the amount to shift  
in each dimension.  
Thedestarray must be distinct from thesrcarray (they cannot alias each other).  
See alsocircshift.  
source

```
Base.circcopy!– Function.

```

circcopy!(dest, src)

Copysrctodest, indexing each dimension modulo its length.srcanddestmust have the same size, but  
can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping  
indices, then on the domain of the overlapdestagrees withsrc.  
See also:circshift.  
Examples

julia> src = reshape( Vector (1:16), ( 4,4))  
4×4 Array{Int64,2}:  
1 5 9 13  
2 6 10 14  
3 7 11 15  
4 8 12 16

julia> dest= OffsetArray{ Int }(undef, (0:3,2:5))

julia> circcopy!(dest, src)  
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:  
8 12 16 4  
5 9 13 1  
6 10 14 2  
7 11 15 3

julia> dest[1:3,2:4] == src[1:3,2:4]  
true

source

```
Base.findall– Method.

```

findall(A)

Return a vectorIof thetrueindices or keys ofA. If there are no such elements ofA, return an empty array.  
To search for other kinds of values, pass a predicate as the first argument.  
Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
See also:findfirst,searchsorted.  
Examples

julia> A = [ true , false , false , true ]  
4-element Vector{Bool}:  
1  
0

```

#### CHAPTER 47. ARRAYS 767

```

0  
1

julia> findall(A)  
2-element Vector{Int64}:  
1  
4

julia> A = [ truefalse ; falsetrue ]  
2×2 Matrix{Bool}:  
1 0  
0 1

julia> findall(A)  
2-element Vector{CartesianIndex{2}}:  
CartesianIndex(1, 1)  
CartesianIndex(2, 2)

julia> findall(falses(3))  
Int64[]

source

```
Base.findall– Method.

```

findall(f:: Function , A)

Return a vectorIof the indices or keys ofAwheref(A[I])returnstrue. If there are no such elements of  
A, return an empty array.  
Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> x = [1, 3, 4]  
3-element Vector{Int64}:  
1  
3  
4

julia> findall(isodd, x)  
2-element Vector{Int64}:  
1  
2

julia> A = [1 2 0; 3 4 0]  
2×3 Matrix{Int64}:  
1 2 0  
3 4 0  
julia> findall(isodd, A)  
2-element Vector{CartesianIndex{2}}:  
CartesianIndex(1, 1)  
CartesianIndex(2, 1)

julia> findall(!iszero, A)  
4-element Vector{CartesianIndex{2}}:  
CartesianIndex(1, 1)

```

#### CHAPTER 47. ARRAYS 768

```

CartesianIndex(2, 1)  
CartesianIndex(1, 2)  
CartesianIndex(2, 2)

julia> d = Dict (:A => 10, :B => -1, :C => 0)  
Dict{Symbol, Int64} with 3 entries:  
:A => 10  
:B => -1  
:C => 0

julia> findall(x-> x >= 0, d)  
2-element Vector{Symbol}:  
:A  
:C

source

```
Base.findfirst– Method.

```

findfirst(A)

Return the index or key of the firsttruevalue inA. Returnnothingif no such value is found. To search for  
other kinds of values, pass a predicate as the first argument.  
Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
See also:findall,findnext,findlast,searchsortedfirst.  
Examples

julia> A = [ false , false , true , false ]  
4-element Vector{Bool}:  
0  
0  
1  
0

julia> findfirst(A)  
3

julia> findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia> A = [ falsefalse ; truefalse ]  
2×2 Matrix{Bool}:  
0 0  
1 0

julia> findfirst(A)  
CartesianIndex(2, 1)

source

```
Base.findfirst– Method.

```

findfirst(predicate:: Function , A)

Return the index or key of the first element ofAfor whichpredicatereturnstrue. Returnnothingif there  
is no such element.

```

#### CHAPTER 47. ARRAYS 769

```

Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> A = [1, 4, 2, 2]  
4-element Vector{Int64}:  
1  
4  
2  
2

julia> findfirst(iseven, A)  
2

julia> findfirst(x-> x>10, A)# returns nothing, but not printed in the REPL

julia> findfirst(isequal(4), A)  
2

julia> A = [1 4; 2 2]  
2×2 Matrix{Int64}:  
1 4  
2 2

julia> findfirst(iseven, A)  
CartesianIndex(2, 1)

source

```
Base.findlast– Method.

```

findlast(A)

Return the index or key of the lasttruevalue inA. Returnnothingif there is notruevalue inA.  
Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
See also:findfirst,findprev,findall.  
Examples

julia> A = [ true , false , true , false ]  
4-element Vector{Bool}:  
1  
0  
1  
0

julia> findlast(A)  
3

julia> A = falses(2,2);

julia> findlast(A)# returns nothing, but not printed in the REPL

julia> A = [ truefalse ; truefalse ]  
2×2 Matrix{Bool}:  
1 0

```

#### CHAPTER 47. ARRAYS 770

```

1 0

julia> findlast(A)  
CartesianIndex(2, 1)

source

```
Base.findlast– Method.

```

findlast(predicate:: Function , A)

Return the index or key of the last element ofAfor whichpredicatereturnstrue. Returnnothingif there  
is no such element.  
Indices or keys are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> A = [1, 2, 3, 4]  
4-element Vector{Int64}:  
1  
2  
3  
4

julia> findlast(isodd, A)  
3

julia> findlast(x-> x > 5, A)# returns nothing, but not printed in the REPL

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> findlast(isodd, A)  
CartesianIndex(2, 1)

source

```
Base.findnext– Method.

```

findnext(A, i)

Find the next index after or includingiof atrueelement ofA, ornothingif not found.  
Indices are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> A = [ false , false , true , false ]  
4-element Vector{Bool}:  
0  
0  
1  
0

julia> findnext(A,1)

```

#### CHAPTER 47. ARRAYS 771

```

3

julia> findnext(A,4) # returns nothing, but not printed in the REPL

julia> A = [ falsefalse ; truefalse ]  
2×2 Matrix{Bool}:  
0 0  
1 0

julia> findnext(A, CartesianIndex (1, 1))  
CartesianIndex(2, 1)

source

```
Base.findnext– Method.

```

findnext(predicate:: Function , A, i)

Find the next index after or includingiof an element ofAfor whichpredicatereturnstrue, ornothingif  
not found.  
Indices are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> A = [1, 4, 2, 2];

julia> findnext(isodd, A,1)  
1

julia> findnext(isodd, A,2) # returns nothing, but not printed in the REPL

julia> A = [1 4; 2 2];

julia> findnext(isodd, A, CartesianIndex (1, 1))  
CartesianIndex(1, 1)

source

```
Base.findprev– Method.

```

findprev(A, i)

Find the previous index before or includingiof atrueelement ofA, ornothingif not found.  
Indices are of the same type as those returned bykeys(A)andpairs(A).  
See also:findnext,findfirst,findall.  
Examples

julia> A = [ false , false , true , true ]  
4-element Vector{Bool}:  
0  
0  
1  
1

```

#### CHAPTER 47. ARRAYS 772

```

julia> findprev(A,3)  
3

julia> findprev(A,1) # returns nothing, but not printed in the REPL

julia> A = [ falsefalse ; truetrue ]  
2×2 Matrix{Bool}:  
0 0  
1 1

julia> findprev(A, CartesianIndex (2, 1))  
CartesianIndex(2, 1)

source

```
Base.findprev– Method.

```

findprev(predicate:: Function , A, i)

Find the previous index before or includingiof an element ofAfor whichpredicatereturnstrue, or  
nothingif not found.  
Indices are of the same type as those returned bykeys(A)andpairs(A).  
Examples

julia> A = [4, 6, 1, 2]  
4-element Vector{Int64}:  
4  
6  
1  
2

julia> findprev(isodd, A,1) # returns nothing, but not printed in the REPL

julia> findprev(isodd, A,3)  
3

julia> A = [4 6; 1 2]  
2×2 Matrix{Int64}:  
4 6  
1 2

julia> findprev(isodd, A, CartesianIndex (1, 2))  
CartesianIndex(2, 1)

source

```
Base.permutedims– Function.

```

permutedims(A:: AbstractArray , perm)

Permute the dimensions of arrayA.permis a vector or a tuple of lengthndims(A)specifying the permuta-  
tion.  
See alsopermutedims!,PermutedDimsArray,transpose,invperm.  
Examples

```

#### CHAPTER 47. ARRAYS 773

```

julia> A = reshape( Vector (1:8), ( 2,2,2))  
2×2×2 Array{Int64, 3}:  
[:, :, 1] =  
1 3  
2 4

[:, :, 2] =  
5 7  
6 8

julia> permutedims(A, (3, 2, 1))  
2×2×2 Array{Int64, 3}:  
[:, :, 1] =  
1 3  
5 7

[:, :, 2] =  
2 4  
6 8

julia> B = randn(5, 7, 11, 13);

julia> perm= [4,1,3,2];

julia> size(permutedims(B, perm))  
(13, 5, 11, 7)

julia> size(B)[perm]== ans  
true

source  
permutedims(m::AbstractMatrix)

Permute the dimensions of the matrixm, by flipping the elements across the diagonal of the matrix. Differs  
fromLinearAlgebra'stransposein that the operation is not recursive.  
Examples

julia> a = [1 2; 3 4];

julia> b = [5 6; 7 8];

julia> c = [9 10; 11 12];

julia> d = [13 14; 15 16];

julia> X = [[a] [b]; [c] [d]]  
2×2 Matrix{Matrix{Int64}}:  
[1 2; 3 4] [5 6; 7 8]  
[9 10; 11 12] [13 14; 15 16]

julia> permutedims(X)  
2×2 Matrix{Matrix{Int64}}:  
[1 2; 3 4] [9 10; 11 12]  
[5 6; 7 8] [13 14; 15 16]

```

#### CHAPTER 47. ARRAYS 774

```

julia> transpose(X)  
2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:  
[1 3; 2 4] [9 11; 10 12]  
[5 7; 6 8] [13 15; 14 16]

source  
permutedims(v::AbstractVector)

Reshape vectorvinto a1 × length(v)row matrix. Differs fromLinearAlgebra'stransposein that the  
operation is not recursive.  
Examples

julia> permutedims([1, 2, 3, 4])  
1×4 Matrix{Int64}:  
1 2 3 4

julia> V = [[[1 2; 3 4]]; [[5 6; 7 8]]]  
2-element Vector{Matrix{Int64}}:  
[1 2; 3 4]  
[5 6; 7 8]

julia> permutedims(V)  
1×2 Matrix{Matrix{Int64}}:  
[1 2; 3 4] [5 6; 7 8]

julia> transpose(V)  
1×2 transpose(::Vector{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:  
[1 3; 2 4] [5 7; 6 8]

source

```
Base.permutedims!– Function.

```

permutedims!(dest, src, perm)

Permute the dimensions of arraysrcand store the result in the arraydest. permis a vector spec-  
ifying a permutation of lengthndims(src). The preallocated arraydestshould havesize(dest) ==  
size(src)[perm]and is completely overwritten. No in-place permutation is supported and unexpected  
results will happen ifsrcanddesthave overlapping memory regions.  
See alsopermutedims.  
source

```
Base.PermutedDimsArrays.PermutedDimsArray– Type.

```

PermutedDimsArray(A, perm)-> B

Given an AbstractArrayA, create a viewBsuch that the dimensions appear to be permuted. Similar to  
permutedims, except that no copying occurs (Bshares storage withA).  
See alsopermutedims,invperm.  
Examples

```

#### CHAPTER 47. ARRAYS 775

```

julia> A = rand(3,5,4);

julia> B = PermutedDimsArray(A, (3,1,2));

julia> size(B)  
(4, 3, 5)

julia> B[3,1,2] == A[1,2,3]  
true

source

```
Base.promote_shape– Function.

```

promote_shape(s1, s2)

Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever  
shape has more dimensions.  
Examples

julia> a = fill(1, ( 3,4,1,1,1));

julia> b = fill(1, ( 3,4));

julia> promote_shape(a,b)  
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia> promote_shape((2,3,1,4), ( 2, 3, 1, 4, 1))  
(2, 3, 1, 4, 1)

source

```
### 47.7 Array functions

Base.accumulate– Function.

```

accumulate(op, A; dims:: Integer , [init])

Cumulative operationopalong the dimensiondimsofA(providingdimsis optional for vectors). An initial  
valueinitmay optionally be provided by a keyword argument. See alsoaccumulate!to use a preallo-  
catedoutputarray, bothforperformanceandto controltheprecisionoftheoutput (e.g. toavoidoverflow).  
For common operations there are specialized variants ofaccumulate, see:cumsum,cumprod

Julia 1.5  
accumulateon a non-array iterator requires at least Julia 1.5.

Examples

julia> accumulate(+, [ 1,2,3])  
3-element Vector{Int64}:  
1  
3  
6

```

#### CHAPTER 47. ARRAYS 776

```

julia> accumulate(*, [ 1,2,3])  
3-element Vector{Int64}:  
1  
2  
6

julia> accumulate(+, [ 1,2,3]; init=100)  
3-element Vector{Int64}:  
101  
103  
106

julia> accumulate(min, [1,2,-1]; init=0)  
3-element Vector{Int64}:  
0  
0  
-1

julia> accumulate(+, fill(1, 3, 3), dims=1)  
3×3 Matrix{Int64}:  
1 1 1  
2 2 2  
3 3 3

julia> accumulate(+, fill(1, 3, 3), dims=2)  
3×3 Matrix{Int64}:  
1 2 3  
1 2 3  
1 2 3

source

```
Base.accumulate!– Function.

```

accumulate!(op, B, A; [dims], [init])

Cumulative operationoponAalong the dimensiondims, storing the result inB. Providingdimsis optional  
for vectors. If the keyword argumentinitis given, its value is used to instantiate the accumulation. See  
alsoaccumulate.  
Examples

julia> x = [1, 0, 2, 0, 3];

julia> y = [0, 0, 0, 0, 0];

julia> accumulate!(+, y, x);

julia> y  
5-element Vector{Int64}:  
1  
1  
3  
3  
6

julia> A = [1 2; 3 4];

```

#### CHAPTER 47. ARRAYS 777

```

julia> B = [0 0; 0 0];

julia> accumulate!(-, B, A, dims=1);

julia> B  
2×2 Matrix{Int64}:  
1 2  
-2 -2

julia> accumulate!(-, B, A, dims=2);

julia> B  
2×2 Matrix{Int64}:  
1 -1  
3 -1

source

```
Base.cumprod– Function.

```

cumprod(A; dims:: Integer )

Cumulative product along the dimensiondim. See alsocumprod!to use a preallocated output array, both  
for performance and to control the precision of the output (e.g. to avoid overflow).  
Examples

julia> a = [1 2 3; 4 5 6]  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> cumprod(a, dims=1)  
2×3 Matrix{Int64}:  
1 2 3  
4 10 18

julia> cumprod(a, dims=2)  
2×3 Matrix{Int64}:  
1 2 6  
4 20 120

source  
cumprod(itr)

Cumulative product of an iterator. See alsocumprod!to use a preallocated output array, both for perfor-  
mance and to control the precision of the output (e.g. to avoid overflow).  
See alsocumprod!,accumulate,cumsum.

Julia 1.5  
cumprodon a non-array iterator requires at least Julia 1.5.

Examples

```

#### CHAPTER 47. ARRAYS 778

```

julia> cumprod(fill(1//2, 3))  
3-element Vector{Rational{Int64}}:  
1//2  
1//4  
1//8

julia> cumprod([fill(1//3, 2, 2) for i in 1:3])  
3-element Vector{Matrix{Rational{Int64}}}:  
[1//3 1//3; 1//3 1//3]  
[2//9 2//9; 2//9 2//9]  
[4//27 4//27; 4//27 4//27]

julia> cumprod((1, 2, 1))  
(1, 2, 2)

julia> cumprod(x^2 for x in 1:3)  
3-element Vector{Int64}:  
1  
4  
36

source

```
Base.cumprod!– Function.

```

cumprod!(B, A; dims:: Integer )

Cumulative product ofAalong the dimensiondims, storing the result inB. See alsocumprod.  
source  
cumprod!(y::AbstractVector, x::AbstractVector)

Cumulative product of a vectorx, storing the result iny. See alsocumprod.  
source

```
Base.cumsum– Function.

```

cumsum(A; dims:: Integer )

Cumulative sum along the dimensiondims. See alsocumsum!to use a preallocated output array, both for  
performance and to control the precision of the output (e.g. to avoid overflow).  
Examples

julia> a = [1 2 3; 4 5 6]  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> cumsum(a, dims=1)  
2×3 Matrix{Int64}:  
1 2 3  
5 7 9

julia> cumsum(a, dims=2)  
2×3 Matrix{Int64}:  
1 3 6  
4 9 15

```

#### CHAPTER 47. ARRAYS 779

```

Note  
The return array'seltypeisIntfor signed integers of less than system word size andUInt  
for unsigned integers of less than system word size. To preserveeltypeof arrays with small  
signed or unsigned integeraccumulate(+, A)should be used.  
julia> cumsum( Int8 [100, 28])  
2-element Vector{Int64}:  
100  
128

julia> accumulate(+, Int8 [100, 28])  
2-element Vector{Int8}:  
100  
-128  
In the former case, the integers are widened to system word size and therefore the result is  
Int64[100, 128]. In the latter case, no such widening happens and integer overflow results  
inInt8[100, -128].

source  
cumsum(itr)

Cumulative sum an iterator. See alsocumsum!to use a preallocated output array, both for performance  
and to control the precision of the output (e.g. to avoid overflow).

Julia 1.5  
cumsumon a non-array iterator requires at least Julia 1.5.

Examples

julia> cumsum([1, 1, 1])  
3-element Vector{Int64}:  
1  
2  
3

julia> cumsum([fill(1, 2) for i in 1:3])  
3-element Vector{Vector{Int64}}:  
[1, 1]  
[2, 2]  
[3, 3]

julia> cumsum((1, 1, 1))  
(1, 2, 3)

julia> cumsum(x^2 for x in 1:3)  
3-element Vector{Int64}:  
1  
5  
14

source

```
Base.cumsum!– Function.

```

cumsum!(B, A; dims:: Integer )

```

#### CHAPTER 47. ARRAYS 780

```

Cumulative sum ofAalong the dimensiondims, storing the result inB. See alsocumsum.  
source

```
Base.diff– Function.

```

diff(A:: AbstractVector )  
diff(A:: AbstractArray ; dims:: Integer )

Finite difference operator on a vector or a multidimensional arrayA. In the latter case the dimension to  
operate on needs to be specified with thedimskeyword argument.

Julia 1.1  
difffor arrays with dimension higher than 2 requires at least Julia 1.1.

Examples

julia> a = [2 4; 6 16]  
2×2 Matrix{Int64}:  
2 4  
6 16

julia> diff(a, dims=2)  
2×1 Matrix{Int64}:  
2  
10

julia> diff(vec(a))  
3-element Vector{Int64}:  
4  
-2  
12

source

```
Base.repeat– Function.

```

repeat(A:: AbstractArray , counts:: Integer ...)

Construct an array by repeating arrayAa given number of times in each dimension, specified bycounts.  
See also:fill,Iterators.repeated,Iterators.cycle.  
Examples

julia> repeat([1, 2, 3], 2)  
6-element Vector{Int64}:  
1 2 3 1 2 3

julia> repeat([1, 2, 3], 2, 3)  
6×3 Matrix{Int64}:  
1 1 1

```

#### CHAPTER 47. ARRAYS 781

```

2 2 2  
3 3 3  
1 1 1  
2 2 2  
3 3 3

source  
repeat(A::AbstractArray; inner=ntuple(Returns(1), ndims(A)), outer=ntuple(Returns(1), ndims(A)))

Construct an array by repeating the entries ofA. The i-th element ofinnerspecifies the number of times  
thattheindividualentriesofthei-thdimensionofAshouldberepeated. Thei-thelementofouterspecifies  
the number of times that a slice along the i-th dimension ofAshould be repeated. Ifinnerorouterare  
omitted, no repetition is performed.  
Examples

julia> repeat(1:2, inner=2)  
4-element Vector{Int64}:  
1  
1  
2  
2

julia> repeat(1:2, outer=2)  
4-element Vector{Int64}:  
1  
2  
1  
2

julia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))  
4×6 Matrix{Int64}:  
1 2 1 2 1 2  
1 2 1 2 1 2  
3 4 3 4 3 4  
3 4 3 4 3 4

source

repeat(s:: AbstractString , r :: Integer )

Repeat a stringrtimes. This can be written ass^r.  
See also^.  
Examples

julia> repeat("ha", 3)  
"hahaha"

source

repeat(c::AbstractChar, r:: Integer ) -> String

Repeat a characterrtimes. This can equivalently be accomplished by callingc^r.  
Examples

```

#### CHAPTER 47. ARRAYS 782

```

julia> repeat('A', 3)  
"AAA"

source

```
Base.rot180– Function.

```

rot180(A)

Rotate matrixA180 degrees.  
Examples

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rot180(a)  
2×2 Matrix{Int64}:  
4 3  
2 1

source  
rot180(A, k)

Rotate matrixA180 degrees an integerknumber of times. Ifkis even, this is equivalent to acopy.  
Examples

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rot180(a,1)  
2×2 Matrix{Int64}:  
4 3  
2 1

julia> rot180(a,2)  
2×2 Matrix{Int64}:  
1 2  
3 4

source

```
Base.rotl90– Function.

```

rotl90(A)

Rotate matrixAleft 90 degrees.  
Examples

```

#### CHAPTER 47. ARRAYS 783

```

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rotl90(a)  
2×2 Matrix{Int64}:  
2 4  
1 3

source  
rotl90(A, k)

Left-rotate matrixA90 degrees counterclockwise an integerknumber of times. Ifkis a multiple of four  
(including zero), this is equivalent to acopy.  
Examples

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rotl90(a,1)  
2×2 Matrix{Int64}:  
2 4  
1 3

julia> rotl90(a,2)  
2×2 Matrix{Int64}:  
4 3  
2 1

julia> rotl90(a,3)  
2×2 Matrix{Int64}:  
3 1  
4 2

julia> rotl90(a,4)  
2×2 Matrix{Int64}:  
1 2  
3 4

source

```
Base.rotr90– Function.

```

rotr90(A)

Rotate matrixAright 90 degrees.  
Examples

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2

```

#### CHAPTER 47. ARRAYS 784

```

3 4

julia> rotr90(a)  
2×2 Matrix{Int64}:  
3 1  
4 2

source  
rotr90(A, k)

Right-rotatematrixA90degreesclockwiseanintegerknumberoftimes. Ifkisamultipleoffour(including  
zero), this is equivalent to acopy.  
Examples

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rotr90(a,1)  
2×2 Matrix{Int64}:  
3 1  
4 2

julia> rotr90(a,2)  
2×2 Matrix{Int64}:  
4 3  
2 1

julia> rotr90(a,3)  
2×2 Matrix{Int64}:  
2 4  
1 3

julia> rotr90(a,4)  
2×2 Matrix{Int64}:  
1 2  
3 4

source

```
Base.mapslices– Function.

```

mapslices(f, A; dims)

Transform the given dimensions of arrayAusing functionf. fis called on each slice ofAof the form  
A[...,:,...,:,...].dimsis an integer vector specifying where the colons go in this expression. The re-  
sultsareconcatenatedalongtheremainingdimensions. Forexample,ifdimsis[1,2]andAis4-dimensional,  
fis called onA[:,:,i,j]for alliandj.  
See alsoeachcol,eachslice.  
Examples

```

#### CHAPTER 47. ARRAYS 785

```

julia> a = reshape( Vector (1:16),(2,2,2,2))  
2×2×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
1 3  
2 4

[:, :, 2, 1] =  
5 7  
6 8

[:, :, 1, 2] =  
9 11  
10 12

[:, :, 2, 2] =  
13 15  
14 16

julia> mapslices(sum, a, dims= [1,2])  
1×1×2×2 Array{Int64, 4}:  
[:, :, 1, 1] =  
10

[:, :, 2, 1] =  
26

[:, :, 1, 2] =  
42

[:, :, 2, 2] =  
58

source

```
Base.eachrow– Function.

```

eachrow(A:: AbstractVecOrMat )

Create a generator that iterates over the first dimension of vector or matrixA, returning the rows as  
AbstractVectorviews.  
See alsoeachcol,eachslice,mapslices.

Julia 1.1  
This function requires at least Julia 1.1.

Example

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> first(eachrow(a))  
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:  
1

```

#### CHAPTER 47. ARRAYS 786

```

2

julia> collect(eachrow(a))  
2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}},  
↪→ true}}:  
[1, 2]  
[3, 4]

source

```
Base.eachcol– Function.

```

eachcol(A:: AbstractVecOrMat )

CreateageneratorthatiteratesovertheseconddimensionofmatrixA,returningthecolumnsasAbstractVector  
views.  
See alsoeachrowandeachslice.

Julia 1.1  
This function requires at least Julia 1.1.

Example

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> first(eachcol(a))  
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:  
1  
3

julia> collect(eachcol(a))  
2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64},  
↪→ true}}:  
[1, 3]  
[2, 4]

source

```
Base.eachslice– Function.

```

eachslice(A:: AbstractArray ; dims)

Create a generator that iterates over dimensionsdimsofA, returning views that select all the data from  
the other dimensions inA.  
Only a single dimension indimsis currently supported. Equivalent to(view(A,:,:,...,i,:,: ...)) for  
i in axes(A, dims)), whereiis in positiondims.  
See alsoeachrow,eachcol,mapslices, andselectdim.

Julia 1.1  
This function requires at least Julia 1.1.

```

#### CHAPTER 47. ARRAYS 787

```

Example

julia> M = [1 2 3; 4 5 6; 7 8 9]  
3×3 Matrix{Int64}:  
1 2 3  
4 5 6  
7 8 9

julia> first(eachslice(M, dims=1))  
3-element view(::Matrix{Int64}, 1, :) with eltype Int64:  
1  
2  
3

julia> collect(eachslice(M, dims=2))  
3-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64},  
↪→ true}}:  
[1, 4, 7]  
[2, 5, 8]  
[3, 6, 9]

source

```
### 47.8 Combinatorics.

Base.invperm– Function.

```

invperm(v)

Return the inverse permutation ofv. IfB = A[v], thenA == B[invperm(v)].  
See alsosortperm,invpermute!,isperm,permutedims.  
Examples

julia> p = (2, 3, 1);

julia> invperm(p)  
(3, 1, 2)

julia> v = [2; 4; 3; 1];

julia> invperm(v)  
4-element Vector{Int64}:  
4  
1  
3  
2

julia> A = ['a','b','c','d'];

julia> B = A[v]  
4-element Vector{Char}:  
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)  
'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)  
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)

```

#### CHAPTER 47. ARRAYS 788

```

'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> B[invperm(v)]  
4-element Vector{Char}:  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)  
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)  
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)  
'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)

source

```
Base.isperm– Function.

```

isperm(v)-> Bool

Returntrueifvis a valid permutation.  
Examples

julia> isperm([1; 2])  
true

julia> isperm([1; 3])  
false

source

```
Base.permute!– Method.

```

permute!(v, p)

Permutevectorvin-place,accordingtopermutationp. Nocheckingisdonetoverifythatpisapermutation.  
To return a new permutation, usev[p]. Note that this is generally faster thanpermute!(v,p)for large  
vectors.  
See alsoinvpermute!.  
Examples

julia> A = [1, 1, 3, 4];

julia> perm= [2, 4, 3, 1];

julia> permute!(A, perm);

julia> A  
4-element Vector{Int64}:  
1  
4  
3  
1

source

```
Base.invpermute!– Function.

```

invpermute!(v, p)

```

#### CHAPTER 47. ARRAYS 789

```

Likepermute!, but the inverse of the given permutation is applied.  
Examples

julia> A = [1, 1, 3, 4];

julia> perm= [2, 4, 3, 1];

julia> invpermute!(A, perm);

julia> A  
4-element Vector{Int64}:  
4  
1  
3  
1

source

```
Base.reverse– Method.

```

reverse(A; dims=:)

ReverseAalong dimensiondims, which can be an integer (a single dimension), a tuple of integers (a tuple  
ofdimensions)or:(reversealongallthedimensions, thedefault). Seealsoreverse!forin-placereversal.  
Examples

julia> b = Int64 [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> reverse(b, dims=2)  
2×2 Matrix{Int64}:  
2 1  
4 3

julia> reverse(b)  
2×2 Matrix{Int64}:  
4 3  
2 1

Julia 1.6  
Prior to Julia 1.6, only single-integerdimsare supported inreverse.

source

```
Base.reverseind– Function.

```

reverseind(v, i)

Given an indexiinreverse(v), return the corresponding index invso thatv[reverseind(v,i)] ==  
reverse(v)[i]. (This can be nontrivial in cases wherevcontains non-ASCII characters.)  
Examples

```

#### CHAPTER 47. ARRAYS 790

```

julia> s = "Julia"  
"Julia"

julia> r = reverse(s)  
"ailuJ"

julia>for i in eachindex(s)  
print(r[reverseind(r, i)])  
end  
Julia

source

```
Base.reverse!– Function.

```

reverse!(v [, start=1 [, stop=length(v) ]])-> v

In-place version ofreverse.  
Examples

julia> A = Vector (1:5)  
5-element Vector{Int64}:  
1  
2  
3  
4  
5

julia> reverse!(A);

julia> A  
5-element Vector{Int64}:  
5  
4  
3  
2  
1

source  
reverse!(A; dims=:)

Likereverse, but operates in-place inA.

Julia 1.6  
Multidimensionalreverse!requires Julia 1.6.

source

```

**Chapter 48**

**Tasks**

Core.Task– Type.

```

Task (func)

Create aTask(i.e. coroutine) to execute the given functionfunc(which must be callable with no argu-  
ments). The task exits when this function returns.  
Examples

julia> a() = sum(i for i in 1:1000);

julia> b = Task (a);

In this example,bis a runnableTaskthat hasn't started yet.  
source

```
Base.@task– Macro.

```

@task

Wrap an expression in aTaskwithout executing it, and return theTask. This only creates a task, and does  
not run it.  
Examples

julia> a1()= sum(i for i in 1:1000);

julia> b = @taska1();

julia> istaskstarted(b)  
false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)  
true

source

```
#### 791


#### CHAPTER 48. TASKS 792

Base.@async– Macro.

```

@async

Wrap an expression in aTaskand add it to the local machine's scheduler queue.  
Valuescanbeinterpolatedinto@asyncvia$,whichcopiesthevaluedirectlyintotheconstructedunderlying  
closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to  
the variable's value in the current task.

Julia 1.4  
Interpolating values via$is available as of Julia 1.4.

source

```
Base.asyncmap– Function.

```

asyncmap(f, c...; ntasks=0, batch_size=nothing)

Usesmultipleconcurrenttaskstomapfoveracollection(ormultipleequallengthcollections). Formultiple  
collection arguments,fis applied elementwise.  
ntasksspecifies the number of tasks to run concurrently. Depending on the length of the collections, if  
ntasksis unspecified, up to 100 tasks will be used for concurrent mapping.  
ntaskscan also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is  
checked before processing every element and a new task started if the value ofntasks_funcis less than  
the current number of tasks.  
Ifbatch_sizeis specified, the collection is processed in batch mode.fmust then be a function that must  
accept aVectorof argument tuples and must return a vector of results. The input vector will have a length  
ofbatch_sizeor less.  
The following examples highlight execution in different tasks by returning theobjectidof the tasks in  
which the mapping function is executed.  
First, withntasksundefined, each element is processed in a different task.  
julia> tskoid() = objectid(current_task());

julia> asyncmap(x->tskoid(), 1:5)  
5-element Array{UInt64,1}:  
0x6e15e66c75c75853  
0x440f8819a1baa682  
0x9fb3eeadd0c83985  
0xebd3e35fe90d4050  
0x29efc93edce2b961

julia> length(unique(asyncmap(x->tskoid(), 1:5)))  
5

Withntasks=2all elements are processed in 2 tasks.  
julia> asyncmap(x->tskoid(), 1:5; ntasks=2)  
5-element Array{UInt64,1}:  
0x027ab1680df7ae94  
0xa23d2f80cd7cf157  
0x027ab1680df7ae94

```

#### CHAPTER 48. TASKS 793

```

0xa23d2f80cd7cf157  
0x027ab1680df7ae94

julia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))  
2

Withbatch_sizedefined, the mapping function needs to be changed to accept an array of argument  
tuples and return an array of results.mapis used in the modified mapping function to achieve this.  
julia> batch_func(input) = map(x->string("args_tuple: ", x, ", element_val: ", x[1], ", task: ",  
tskoid()), input)  
batch_func (generic function with 1 method)

julia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)  
5-element Array{String,1}:  
"args_tuple: (1,), element_val: 1, task: 9118321258196414413"  
"args_tuple: (2,), element_val: 2, task: 4904288162898683522"  
"args_tuple: (3,), element_val: 3, task: 9118321258196414413"  
"args_tuple: (4,), element_val: 4, task: 4904288162898683522"  
"args_tuple: (5,), element_val: 5, task: 9118321258196414413"

Note  
Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently,  
asyncmapis beneficial only when the mapping function involves any I/O - disk, network, remote  
worker invocation, etc.

source

```
Base.asyncmap!– Function.

```

asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)

Likeasyncmap, but stores output inresultsrather than returning a collection.  
source

```
Base.current_task– Function.

```

current_task()

Get the currently runningTask.  
source

```
Base.istaskdone– Function.

```

istaskdone(t:: Task ) -> Bool

Determine whether a task has exited.  
Examples

julia> a2()= sum(i for i in 1:1000);

julia> b = Task (a2);

julia> istaskdone(b)

```

#### CHAPTER 48. TASKS 794

```

false

julia> schedule(b);

julia> yield();

julia> istaskdone(b)  
true

source

```
Base.istaskstarted– Function.

```

istaskstarted(t:: Task ) -> Bool

Determine whether a task has started executing.  
Examples

julia> a3()= sum(i for i in 1:1000);

julia> b = Task (a3);

julia> istaskstarted(b)  
false

source

```
Base.istaskfailed– Function.

```

istaskfailed(t:: Task ) -> Bool

Determine whether a task has exited because an exception was thrown.  
Examples

julia> a4()= error("task failed");

julia> b = Task (a4);

julia> istaskfailed(b)  
false

julia> schedule(b);

julia> yield();

julia> istaskfailed(b)  
true

Julia 1.3  
This function requires at least Julia 1.3.

source

```
Base.task_local_storage– Method.


#### CHAPTER 48. TASKS 795

```

task_local_storage(key)

Look up the value of a key in the current task's task-local storage.  
source

```
Base.task_local_storage– Method.

```

task_local_storage(key, value)

Assign a value to a key in the current task's task-local storage.  
source

```
Base.task_local_storage– Method.

```

task_local_storage(body, key, value)

Call the functionbodywith a modified task-local storage, in whichvalueis assigned tokey; the previous  
value ofkey, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.  
source

```
### 48.1 Scheduling.

Base.yield– Function.

```

yield()

Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still  
runnable, and will be restarted immediately if there are no other runnable tasks.  
source  
yield(t::Task, arg = nothing)

A fast, unfair-scheduling version ofschedule(t, arg); yield()which immediately yields totbefore  
calling the scheduler.  
source

```
Base.yieldto– Function.

```

yieldto(t:: Task , arg= nothing)

Switchtothegiventask. Thefirsttimeataskisswitchedto, thetask'sfunctioniscalledwithnoarguments.  
On subsequent switches,argis returned from the task's last call toyieldto. This is a low-level call that  
only switches tasks, not considering states or scheduling in any way. Its use is discouraged.  
source

```
Base.sleep– Function.

```

sleep(seconds)

Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input  
of0.001.  
source

```

#### CHAPTER 48. TASKS 796

Base.schedule– Function.

```

schedule(t:: Task , [val]; error= false )

Add aTaskto the scheduler's queue. This causes the task to run constantly when the system is otherwise  
idle, unless the task performs a blocking operation such aswait.  
If a second argumentvalis provided, it will be passed to the task (via the return value ofyieldto) when  
it runs again. Iferroristrue, the value is raised as an exception in the woken task.  
Examples

julia> a5()= sum(i for i in 1:1000);

julia> b = Task (a5);

julia> istaskstarted(b)  
false

julia> schedule(b);

julia> yield();

julia> istaskstarted(b)  
true

julia> istaskdone(b)  
true

source

```
### 48.2 Synchronization

Base.errormonitor– Function.

```

errormonitor(t:: Task )

Print an error log tostderrif tasktfails.  
source

```
Base.@sync– Macro.

```

@sync

Wait until all lexically-enclosed uses of@async,@spawn,@spawnatand@distributedare complete. All  
exceptions thrown by enclosed async operations are collected and thrown as aCompositeException.  
source

```
Base.wait– Function.

```

wait([x])

Block the current task until some event occurs, depending on the type of the argument:

```
- Channel: Wait for a value to be appended to the channel.


#### CHAPTER 48. TASKS 797

- Condition: Wait fornotifyon a condition.
- Process: Wait for a process or process chain to exit. Theexitcodefield of a process can be used to
    determine success or failure.
- Task: Wait for aTaskto finish. If the task fails with an exception, aTaskFailedException(which
    wraps the failed task) is thrown.
- RawFD: Wait for changes on a file descriptor (see theFileWatchingpackage).

```

If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an  
explicit call toscheduleoryieldto.  
Oftenwaitis called within awhileloop to ensure a waited-for condition is met before proceeding.  
source  
wait(r::Future)

Wait for a value to become available for the specifiedFuture.  
wait(r::RemoteChannel, args...)

Wait for a value to become available on the specifiedRemoteChannel.  
Special note forThreads.Condition:  
ThecallermustbeholdingthelockthatownsaThreads.Conditionbeforecallingthismethod. Thecalling  
taskwillbeblockeduntilsomeothertaskwakesit,usuallybycallingnotifyonthesameThreads.Condition  
object. The lock will be atomically released when blocking (even if it was locked recursively), and will be  
reacquired before returning.  
source

```
Base.fetch– Method.

```

fetch(t:: Task )

WaitforaTasktofinish,thenreturnitsresultvalue. Ifthetaskfailswithanexception,aTaskFailedException  
(which wraps the failed task) is thrown.  
source

```
Base.timedwait– Function.

```

timedwait(callback:: Function , timeout:: Real ; pollint:: Real =0.1)

Waitsuntilcallbackreturnstrueortimeoutsecondshavepassed,whicheverisearlier.callbackispolled  
everypollintseconds. The minimum value fortimeoutandpollintis0.001, that is, 1 millisecond.  
Returns :ok or :timed_out  
source

```
Base.Condition– Type.

```

Condition ()

Create an edge-triggered event source that tasks can wait for. Tasks that callwaiton aConditionare  
suspendedandqueued. TasksarewokenupwhennotifyislatercalledontheCondition. Edgetriggering

```

#### CHAPTER 48. TASKS 798

```

means that only tasks waiting at the timenotifyis called can be woken up. For level-triggered notifica-  
tions, you must keep extra state to keep track of whether a notification has happened. TheChanneland  
Threads.Eventtypes do this, and can be used for level-triggered events.  
This object is NOT thread-safe. SeeThreads.Conditionfor a thread-safe version.  
source

```
Base.notify– Function.

```

notify(condition, val=nothing; all= true , error= false )

Wake up tasks waiting for a condition, passing themval. Ifallistrue(the default), all waiting tasks are  
woken, otherwise only one is. Iferroristrue, the passed value is raised as an exception in the woken  
tasks.  
Return the count of tasks woken up. Return 0 if no tasks are waiting oncondition.  
source

```
Base.Semaphore– Type.

```

Semaphore(sem_size)

Create a counting semaphore that allows at mostsem_sizeacquires to be in use at any time. Each acquire  
must be matched with a release.  
source

```
Base.acquire– Function.

```

acquire(s::Semaphore)

Wait for one of thesem_sizepermits to be available, blocking until one can be acquired.  
source

```
Base.release– Function.

```

release(s::Semaphore)

Return one permit to the pool, possibly allowing another task to acquire it and resume execution.  
source

```
Base.AbstractLock– Type.

```

AbstractLock

Abstractsupertypedescribingtypesthatimplementthesynchronizationprimitives:lock,trylock,unlock,  
andislocked.  
source

```
Base.lock– Function.

```

lock(lock)

```

#### CHAPTER 48. TASKS 799

```

Acquire thelockwhen it becomes available. If the lock is already locked by a different task/thread, wait  
for it to become available.  
Eachlockmust be matched by anunlock.  
source  
lock(f::Function, lock)

Acquire thelock, executefwith thelockheld, and release thelockwhenfreturns. If the lock is already  
locked by a different task/thread, wait for it to become available.  
When this function returns, thelockhas been released, so the caller should not attempt tounlockit.

Julia 1.7  
Using aChannelas the second argument requires Julia 1.7 or later.

source

```
Base.unlock– Function.

```

unlock(lock)

Releases ownership of thelock.  
If this is a recursive lock which has been acquired before, decrement an internal counter and return imme-  
diately.  
source

```
Base.trylock– Function.

```

trylock(lock)-> Success (Boolean)

Acquire the lock if it is available, and returntrueif successful. If the lock is already locked by a different  
task/thread, returnfalse.  
Each successfultrylockmust be matched by anunlock.  
source

```
Base.islocked– Function.

```

islocked(lock)-> Status (Boolean)

Check whether thelockis held by any task/thread. This should not be used for synchronization (see  
insteadtrylock).  
source

```
Base.ReentrantLock– Type.

```

ReentrantLock ()

Creates a re-entrant lock for synchronizingTasks. The same task can acquire the lock as many times as  
required. Eachlockmust be matched with anunlock.  
Calling'lock' will also inhibit running of finalizers on that thread until the corresponding'unlock'. Use of the  
standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock  
order or missing the try block entirely (e.g. attempting to return with the lock still held):

```

#### CHAPTER 48. TASKS 800

```

lock(l)  
try  
  
finally  
unlock(l)  
end

source

```
### 48.3 Channels.

Base.Channel– Type.

```

Channel {T= Any }(size:: Int =0)

Constructs aChannelwith an internal buffer that can hold a maximum ofsizeobjects of typeT.put!calls  
on a full channel block until an object is removed withtake!.  
Channel(0)constructs an unbuffered channel.put!blocks until a matchingtake!is called. And vice-  
versa.  
Other constructors:

```
- Channel(): default constructor, equivalent toChannel{Any}(0)
- Channel(Inf): equivalent toChannel{Any}(typemax(Int))
- Channel(sz): equivalent toChannel{Any}(sz)

```

Julia 1.3  
The default constructorChannel()and defaultsize=0were added in Julia 1.3.

source

```
Base.Channel– Method.

```

Channel {T= Any }(func:: Function , size=0; taskref=nothing, spawn= false )

Create a new task fromfunc, bind it to a new channel of typeTand sizesize, and schedule the task, all  
in a single call.  
funcmust accept the bound channel as its only argument.  
If you need a reference to the created task, pass aRef{Task}object via the keyword argumenttaskref.  
Ifspawn = true, the Task created forfuncmay be scheduled on another thread in parallel, equivalent to  
creating a task viaThreads.@spawn.  
Return aChannel.  
Examples

julia> chnl= Channel () do ch  
foreach(i-> put!(ch, i),1:4)  
end ;

julia> typeof(chnl)  
Channel{Any}

```

#### CHAPTER 48. TASKS 801

```

julia>for i in chnl  
@showi  
end ;  
i = 1  
i = 2  
i = 3  
i = 4

Referencing the created task:

julia> taskref= Ref { Task }();

julia> chnl= Channel (taskref=taskref) do ch  
println(take!(ch))  
end ;

julia> istaskdone(taskref[])  
false

julia> put!(chnl,"Hello");  
Hello

julia> istaskdone(taskref[])  
true

Julia 1.3  
Thespawn=parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier  
versions of Julia, Channel used keyword arguments to setsizeandT, but those constructors  
are deprecated.

julia> chnl= Channel { Char }(1, spawn= true ) do ch  
for c in "hello world"  
put!(ch, c)  
end  
end  
Channel{Char}(1) (1 item available)

julia> String(collect(chnl))  
"hello world"

source

```
Base.put!– Method.

```

put!(c:: Channel , v)

Append an itemvto the channelc. Blocks if the channel is full.  
For unbuffered channels, blocks until atake!is performed by a different task.

Julia 1.1  
vnow gets converted to the channel's type withconvertasput!is called.

source

```

#### CHAPTER 48. TASKS 802

Base.take!– Method.

```

take!(c:: Channel )

Remove and return a value from aChannel. Blocks until data is available.  
For unbuffered channels, blocks until aput!is performed by a different task.  
source

```
Base.isready– Method.

```

isready(c:: Channel )

Determine whether aChannelhas a value stored to it. Returns immediately, does not block.  
For unbuffered channels returnstrueif there are tasks waiting on aput!.  
source

```
Base.fetch– Method.

```

fetch(c:: Channel )

Wait for and get the first available item from the channel. Does not remove the item.fetchis unsupported  
on an unbuffered (0-size) channel.  
source

```
Base.close– Method.

```

close(c:: Channel [, excp:: Exception ])

Close a channel. An exception (optionally given byexcp), is thrown by:

```
- put!on a closed channel.
- take!andfetchon an empty, closed channel.

```

source

```
Base.bind– Method.

```

bind(chnl:: Channel , task:: Task )

Associate the lifetime ofchnlwith a task.Channel chnlis automatically closed when the task terminates.  
Any uncaught exception in the task is propagated to all waiters onchnl.  
Thechnlobject can be explicitly closed independent of task termination. Terminating tasks have no effect  
on already closedChannelobjects.  
When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple  
channels are bound to the same task, termination of the task will close all of the bound channels.  
Examples

julia> c = Channel (0);

julia> task= @asyncforeach(i->put!(c, i),1:4);

```

#### CHAPTER 48. TASKS 803

```

julia> bind(c,task);

julia>for i in c  
@showi  
end ;  
i = 1  
i = 2  
i = 3  
i = 4

julia> isopen(c)  
false

julia> c = Channel (0);

julia> task= @async(put!(c,1); error("foo"));

julia> bind(c, task);

julia> take!(c)  
1

julia> put!(c,1);  
ERROR: TaskFailedException  
Stacktrace:  
[...]  
nested task error: foo  
[...]

source

```

**Chapter 49**

**Multi-Threading**

Base.Threads.@threads– Macro.

```

Threads.@threads[schedule] for ... end

A macro to parallelize aforloop to run with multiple threads. Splits the iteration space among multiple  
tasks and runs those tasks on threads according to a scheduling policy. A barrier is placed at the end of  
the loop which waits for all tasks to finish execution.  
Thescheduleargumentcanbeusedtorequestaparticularschedulingpolicy. Theonlycurrentlysupported  
value is:static, which creates one task per thread and divides the iterations equally among them. Spec-  
ifying:staticis an error if used from inside another@threadsloop or from a thread other than 1.  
The default schedule (used when noscheduleargument is present) is subject to change.

Julia 1.5  
Thescheduleargument is available as of Julia 1.5.

Seealso:@spawn,nthreads(),threadid(),pmapinDistributed,BLAS.set_num_threadsinLinearAlgebra.  
source

```
Base.Threads.foreach– Function.

```

Threads.foreach(f, channel:: Channel ;  
schedule::Threads.AbstractSchedule=Threads.FairSchedule(),  
ntasks=Threads.nthreads())

Similar toforeach(f, channel), but iteration overchanneland calls tofare split acrossntaskstasks  
spawned byThreads.@spawn. This function will wait for all internally spawned tasks to complete before  
returning.  
Ifschedule isa FairSchedule,Threads.foreachwill attempt to spawn tasks in a manner that enables  
Julia'sschedulertomorefreelyload-balanceworkitemsacrossthreads. Thisapproachgenerallyhashigher  
per-item overhead, but may perform better thanStaticSchedulein concurrence with other multithreaded  
workloads.  
Ifschedule isa StaticSchedule,Threads.foreachwill spawn tasks in a manner that incurs lower per-  
item overhead thanFairSchedule, but is less amenable to load-balancing. This approach thus may be  
more suitable for fine-grained, uniform workloads, but may perform worse thanFairSchedulein concur-  
rence with other multithreaded workloads.

```
#### 804


#### CHAPTER 49. MULTI-THREADING 805

```

Julia 1.6  
This function requires Julia 1.6 or later.

source

```
Base.Threads.@spawn– Macro.

```

Threads.@spawnexpr

Create aTaskandscheduleit to run on any available thread. The task is allocated to a thread after it  
becomes available. To wait for the task to finish, callwaiton the result of this macro, or callfetchto wait  
and then obtain its return value.  
Valuescanbeinterpolatedinto@spawnvia$,whichcopiesthevaluedirectlyintotheconstructedunderlying  
closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to  
the variable's value in the current task.

Note  
See the manual chapter on threading for important caveats.

Julia 1.3  
This macro is available as of Julia 1.3.

Julia 1.4  
Interpolating values via$is available as of Julia 1.4.

source

```
Base.Threads.threadid– Function.

```

Threads.threadid()

Get the ID number of the current thread of execution. The master thread has ID 1.  
source

```
Base.Threads.nthreads– Function.

```

Threads.nthreads()

Get the number of threads available to the Julia process. This is the inclusive upper bound onthreadid().  
Seealso:BLAS.get_num_threadsandBLAS.set_num_threadsintheLinearAlgebrastandardlibrary, and  
nprocs()in theDistributedstandard library.  
source

```
See alsoMulti-Threading.

### 49.1 Synchronization

Base.Threads.Condition– Type.

```

Threads. Condition ([lock])

```

#### CHAPTER 49. MULTI-THREADING 806

```

A thread-safe version ofBase.Condition.  
To callwaitornotifyon aThreads.Condition, you must first calllockon it. Whenwaitis called, the  
lock is atomically released during blocking, and will be reacquired beforewaitreturns. Therefore idiomatic  
use of aThreads.Condition clooks like the following:  
lock(c)  
try  
while !thing_we_are_waiting_for  
wait(c)  
end  
finally  
unlock(c)  
end

Julia 1.2  
This functionality requires at least Julia 1.2.

source

```
Base.Event– Type.

```

Event()

Create a level-triggered event source. Tasks that callwaiton anEventare suspended and queued until  
notifyis called on theEvent. Afternotifyis called, theEventremains in a signaled state and tasks will  
no longer block when waiting for it.

Julia 1.1  
This functionality requires at least Julia 1.1.

source

```
See alsoSynchronization.

### 49.2 Atomic operations

Base.@atomic– Macro.

```

@atomicvar  
@atomicorder ex

Markvarorexas being performed atomically, ifexis a supported expression.  
@atomic a.b.x = new  
@atomic a.b.x += addend  
@atomic :release a.b.x = new  
@atomic :acquire_release a.b.x += addend

Perform the store operation expressed on the right atomically and return the new value.  
With=, this operation translates to asetproperty!(a.b, :x, new)call. With any operator also, this  
operation translates to amodifyproperty!(a.b, :x, +, addend)[2]call.

```

#### CHAPTER 49. MULTI-THREADING 807

```

@atomic a.b.x max arg2  
@atomic a.b.x + arg2  
@atomic max(a.b.x, arg2)  
@atomic :acquire_release max(a.b.x, arg2)  
@atomic :acquire_release a.b.x + arg2  
@atomic :acquire_release a.b.x max arg2

Perform the binary operation expressed on the right atomically. Store the result into the field in the first  
argument and return the values(old, new).  
This operation translates to amodifyproperty!(a.b, :x, func, arg2)call.  
See Per-field atomicssection in the manual for more details.

julia> mutable struct Atomic{T};@atomicx::T; end

julia> a = Atomic(1)  
Atomic{Int64}(1)

julia> @atomica.x # fetch field x of a, with sequential consistency  
1

julia> @atomic:sequentially_consistent a.x = 2 # set field x of a, with sequential consistency  
2

julia> @atomica.x += 1 # increment field x of a, with sequential consistency  
3

julia> @atomica.x + 1 # increment field x of a, with sequential consistency  
3 => 4

julia> @atomica.x # fetch field x of a, with sequential consistency  
4

julia> @atomicmax(a.x, 10) # change field x of a to the max value, with sequential consistency  
4 => 10

julia> @atomica.x max5 # again change field x of a to the max value, with sequential  
↪→ consistency  
10 => 10

Julia 1.7  
This functionality requires at least Julia 1.7.

source

```
Base.@atomicswap– Macro.

```

@atomicswapa.b.x = new  
@atomicswap:sequentially_consistent a.b.x = new

Storesnewintoa.b.xand returns the old value ofa.b.x.  
This operation translates to aswapproperty!(a.b, :x, new)call.  
See Per-field atomicssection in the manual for more details.

```

#### CHAPTER 49. MULTI-THREADING 808

```

julia> mutable struct Atomic{T};@atomicx::T; end

julia> a = Atomic(1)  
Atomic{Int64}(1)

julia> @atomicswapa.x = 2+2 # replace field x of a with 4, with sequential consistency  
1

julia> @atomica.x # fetch field x of a, with sequential consistency  
4

Julia 1.7  
This functionality requires at least Julia 1.7.

source

```
Base.@atomicreplace– Macro.

```

@atomicreplacea.b.x expected=> desired  
@atomicreplace:sequentially_consistent a.b.x expected=> desired  
@atomicreplace:sequentially_consistent:monotonic a.b.x expected=> desired

Performtheconditionalreplacementexpressedbythepairatomically,returningthevalues(old, success::Bool).  
Wheresuccessindicates whether the replacement was completed.  
This operation translates to areplaceproperty!(a.b, :x, expected, desired)call.  
See Per-field atomicssection in the manual for more details.

julia> mutable struct Atomic{T};@atomicx::T; end

julia> a = Atomic(1)  
Atomic{Int64}(1)

julia> @atomicreplacea.x 1 => 2 # replace field x of a with 2 if it was 1, with sequential  
↪→ consistency  
(old = 1, success = true)

julia> @atomica.x # fetch field x of a, with sequential consistency  
2

julia> @atomicreplacea.x 1 => 2 # replace field x of a with 2 if it was 1, with sequential  
↪→ consistency  
(old = 2, success = false)

julia> xchg= 2 => 0; # replace field x of a with 0 if it was 1, with sequential consistency

julia> @atomicreplacea.x xchg  
(old = 2, success = true)

julia> @atomica.x # fetch field x of a, with sequential consistency  
0

Julia 1.7  
This functionality requires at least Julia 1.7.

```

#### CHAPTER 49. MULTI-THREADING 809

```

source

Note  
ThefollowingAPIsarefairlyprimitive,andwilllikelybeexposedthroughanunsafe_*-likewrapper.

Core.Intrinsics.atomic_pointerref(pointer::Ptr{T}, order::Symbol) --> T  
Core.Intrinsics.atomic_pointerset(pointer::Ptr{T}, new::T, order::Symbol) --> pointer  
Core.Intrinsics.atomic_pointerswap(pointer::Ptr{T}, new::T, order::Symbol) --> old  
Core.Intrinsics.atomic_pointermodify(pointer::Ptr{T}, function::(old::T,arg::S)->T, arg::S, order::  
Symbol) --> old  
Core.Intrinsics.atomic_pointerreplace(pointer::Ptr{T}, expected::Any, new::T, success_order::Symbol,  
failure_order::Symbol) --> (old, cmp)

Warning  
ThefollowingAPIsaredeprecated, thoughsupportforthemislikelytoremainforseveralreleases.

```
Base.Threads.Atomic– Type.

```

Threads.Atomic{T}

Holds a reference to an object of typeT, ensuring that it is only accessed atomically, i.e. in a thread-safe  
manner.  
Only certain"simple" types can be used atomically, namely the primitive boolean, integer, and float-point  
types. These areBool,Int8...Int128,UInt8...UInt128, andFloat16...Float64.  
New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is  
initialized with zero.  
Atomic objects can be accessed using the[]notation:  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> x[] = 1  
1

julia> x[]  
1

Atomic operations use anatomic_prefix, such asatomic_add!,atomic_xchg!, etc.  
source

```
Base.Threads.atomic_cas!– Function.

```

Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T

Atomically compare-and-setx  
Atomically compares the value inxwithcmp. If equal, writenewvaltox. Otherwise, leavesxunmodified.  
Returns the old value inx. By comparing the returned value tocmp(via===) one knows whetherxwas  
modified and now holds the new valuenewval.

```

#### CHAPTER 49. MULTI-THREADING 810

```

For further details, see LLVM'scmpxchginstruction.  
This function can be used to implement transactional semantics. Before the transaction, one records the  
value inx. After the transaction, the new value is stored only ifxhas not been modified in the mean time.  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x,4, 2);

julia> x  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_cas!(x,3, 2);

julia> x  
Base.Threads.Atomic{Int64}(2)

source

```
Base.Threads.atomic_xchg!– Function.

```

Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T

Atomically exchange the value inx  
Atomically exchanges the value inxwithnewval. Returns the old value.  
For further details, see LLVM'satomicrmw xchginstruction.  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_xchg!(x,2)  
3

julia> x[]  
2

source

```
Base.Threads.atomic_add!– Function.

```

Threads.atomic_add!(x::Atomic{T}, val::T) where T<: ArithmeticTypes

Atomically addvaltox  
Performsx[] += valatomically. Returns the old value. Not defined forAtomic{Bool}.  
For further details, see LLVM'satomicrmw addinstruction.  
Examples

```

#### CHAPTER 49. MULTI-THREADING 811

```

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_add!(x,2)  
3

julia> x[]  
5

source

```
Base.Threads.atomic_sub!– Function.

```

Threads.atomic_sub!(x::Atomic{T}, val::T) where T<: ArithmeticTypes

Atomically subtractvalfromx  
Performsx[] -= valatomically. Returns the old value. Not defined forAtomic{Bool}.  
For further details, see LLVM'satomicrmw subinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_sub!(x,2)  
3

julia> x[]  
1

source

```
Base.Threads.atomic_and!– Function.

```

Threads.atomic_and!(x::Atomic{T}, val::T) where T

Atomically bitwise-andxwithval  
Performsx[] &= valatomically. Returns the old value.  
For further details, see LLVM'satomicrmw andinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_and!(x,2)  
3

julia> x[]  
2

source

```
Base.Threads.atomic_nand!– Function.


#### CHAPTER 49. MULTI-THREADING 812

```

Threads.atomic_nand!(x::Atomic{T}, val::T) where T

Atomically bitwise-nand (not-and)xwithval  
Performsx[] = ~(x[] & val)atomically. Returns the old value.  
For further details, see LLVM'satomicrmw nandinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(3)  
Base.Threads.Atomic{Int64}(3)

julia> Threads.atomic_nand!(x,2)  
3

julia> x[]  
-3

source

```
Base.Threads.atomic_or!– Function.

```

Threads.atomic_or!(x::Atomic{T}, val::T) where T

Atomically bitwise-orxwithval  
Performsx[] |= valatomically. Returns the old value.  
For further details, see LLVM'satomicrmw orinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(5)  
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_or!(x,7)  
5

julia> x[]  
7

source

```
Base.Threads.atomic_xor!– Function.

```

Threads.atomic_xor!(x::Atomic{T}, val::T) where T

Atomically bitwise-xor (exclusive-or)xwithval  
Performsx[] $= valatomically. Returns the old value.  
For further details, see LLVM'satomicrmw xorinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(5)  
Base.Threads.Atomic{Int64}(5)

```

#### CHAPTER 49. MULTI-THREADING 813

```

julia> Threads.atomic_xor!(x,7)  
5

julia> x[]  
2

source

```
Base.Threads.atomic_max!– Function.

```

Threads.atomic_max!(x::Atomic{T}, val::T) where T

Atomically store the maximum ofxandvalinx  
Performsx[] = max(x[], val)atomically. Returns the old value.  
For further details, see LLVM'satomicrmw maxinstruction.  
Examples

julia> x = Threads.Atomic{ Int }(5)  
Base.Threads.Atomic{Int64}(5)

julia> Threads.atomic_max!(x,7)  
5

julia> x[]  
7

source

```
Base.Threads.atomic_min!– Function.

```

Threads.atomic_min!(x::Atomic{T}, val::T) where T

Atomically store the minimum ofxandvalinx  
Performsx[] = min(x[], val)atomically. Returns the old value.  
For further details, see LLVM'satomicrmw mininstruction.  
Examples

julia> x = Threads.Atomic{ Int }(7)  
Base.Threads.Atomic{Int64}(7)

julia> Threads.atomic_min!(x,5)  
7

julia> x[]  
5

source

```
Base.Threads.atomic_fence– Function.

```

Threads.atomic_fence()

```

#### CHAPTER 49. MULTI-THREADING 814

```

Insert a sequential-consistency memory fence  
Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this  
is needed, i.e. where an acquire/release ordering is insufficient.  
This is likely a very expensive operation. Given that all other atomic operations in Julia already have  
acquire/release semantics, explicit fences should not be necessary in most cases.  
For further details, see LLVM'sfenceinstruction.  
source

```
### 49.3 ccall using a threadpool (Experimental).

Base.@threadcall– Macro.

```

@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)

The@threadcallmacro is called in the same way asccallbut does the work in a different thread. This  
is useful when you want to call a blocking C function without causing the mainjuliathread to become  
blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be  
increased by setting theUV_THREADPOOL_SIZEenvironment variable and restarting thejuliaprocess.  
Note that the called function should never call back into Julia.  
source

```
### 49.4 Low-level synchronization primitives

These building blocks are used to create the regular synchronization objects.

Base.Threads.SpinLock– Type.

```

SpinLock()

Create a non-reentrant, test-and-test-and-set spin lock. Recursive use will result in a deadlock. This kind  
of lock should only be used around code that takes little time to execute and does not block (e.g. perform  
I/O). In general,ReentrantLockshould be used instead.  
Eachlockmust be matched with anunlock.  
Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more  
contention than that, different synchronization approaches should be considered.  
source

```

**Chapter 50**

**Constants**

Core.nothing– Constant.

```

nothing

The singleton instance of typeNothing, used by convention when there is no value to return (as in a C  
voidfunction) or when a variable or field holds no value.  
See also:isnothing,something,missing.  
source

```
Base.PROGRAM_FILE– Constant.

```

PROGRAM_FILE

A string containing the script name passed to Julia from the command line. Note that the script name  
remains unchanged from within included files. Alternatively see@**FILE**.  
source

```
Base.ARGS– Constant.

```

ARGS

An array of the command line arguments passed to Julia, as strings.  
source

```
Base.C_NULL– Constant.

```

C_NULL

The C null pointer constant, sometimes used when calling external code.  
source

```
Base.VERSION– Constant.

```

VERSION

AVersionNumberobject describing which version of Julia is in use. For details seeVersion Number Literals.  
source

```
#### 815


#### CHAPTER 50. CONSTANTS 816

Base.DEPOT_PATH– Constant.

```

DEPOT_PATH

A stack of"depot" locations where the package manager, as well as Julia's code loading mechanisms, look  
for package registries, installed packages, named environments, repo clones, cached compiled package  
images, and configuration files. By default it includes:

```
1. ~/.juliawhere~is the user home as appropriate on the system;
2. an architecture-specific shared system directory, e.g./usr/local/share/julia;
3. an architecture-independent shared system directory, e.g./usr/share/julia.

```

SoDEPOT_PATHmight be:

[joinpath(homedir(),".julia"), "/usr/local/share/julia", "/usr/share/julia"]

The first entry is the"user depot" and should be writable by and owned by the current user. The user depot  
is where: registries are cloned, new package versions are installed, named environments are created and  
updated, package repos are cloned, newly compiled package image files are saved, log files are written,  
development packages are checked out by default, and global configuration data is saved. Later entries  
in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and  
managed by system administrators.  
DEPOT_PATHis populated based on theJULIA_DEPOT_PATHenvironment variable if set.  
DEPOT_PATH contents  
Each entry inDEPOT_PATHis a path to a directory which contains subdirectories used by Julia for various  
purposes. Here is an overview of some of the subdirectories that may exist in a depot:

```
- clones: Contains full clones of package repos. Maintained byPkg.jland used as a cache.
- compiled: Contains precompiled*.jifiles for packages. Maintained by Julia.
- dev: Default directory forPkg.develop. Maintained byPkg.jland the user.
- environments: Default package environments. For instance the global environment for a specific
    julia version. Maintained byPkg.jl.
- logs: Contains logs ofPkgandREPLoperations. Maintained byPkg.jlandJulia.
- packages: Contains packages, some of which were explicitly installed and some which are implicit
    dependencies. Maintained byPkg.jl.
- registries: Contains package registries. By default onlyGeneral. Maintained byPkg.jl.

```

See alsoJULIA_DEPOT_PATH, and Code Loading.  
source

```
Base.LOAD_PATH– Constant.

```

LOAD_PATH

An array of paths forusingandimportstatements to consider as project environments or package di-  
rectories when loading code. It is populated based on theJULIA_LOAD_PATHenvironment variable if set;  
otherwise it defaults to["@", "@v#.#", "@stdlib"]. Entries starting with@have special meanings:

```

#### CHAPTER 50. CONSTANTS 817

- @refers to the"current active environment", the initial value of which is initially determined by the
    JULIA_PROJECTenvironment variable or the--projectcommand-line option.
- @stdlibexpands to the absolute path of the current Julia installation's standard library directory.
- @namerefers to a named environment, which are stored in depots (seeJULIA_DEPOT_PATH) under the
    environmentssubdirectory. The user's named environments are stored in~/.julia/environments
    so@namewould refer to the environment in~/.julia/environments/nameif it exists and contains a
    Project.tomlfile. Ifnamecontains#characters, then they are replaced with the major, minor and
    patchcomponentsoftheJuliaversionnumber. Forexample,ifyouarerunningJulia1.2then@v#.#ex-
    pandsto@v1.2andwilllookforanenvironmentbythatname,typicallyat~/.julia/environments/v1.2.

```

The fully expanded value ofLOAD_PATHthat is searched for projects and packages can be seen by calling  
theBase.load_path()function.  
See alsoJULIA_LOAD_PATH,JULIA_PROJECT,JULIA_DEPOT_PATH, and Code Loading.  
source

```
Base.Sys.BINDIR– Constant.

```

Sys.BINDIR

A string containing the full path to the directory containing thejuliaexecutable.  
source

```
Base.Sys.CPU_THREADS– Constant.

```

Sys.CPU_THREADS

The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run  
concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of  
hyper-threading.  
See Hwloc.jl or CpuId.jl for extended information, including number of physical cores.  
source

```
Base.Sys.WORD_SIZE– Constant.

```

Sys.WORD_SIZE

Standard word size on the current machine, in bits.  
source

```
Base.Sys.KERNEL– Constant.

```

Sys.KERNEL

A symbol representing the name of the operating system, as returned byunameof the build configuration.  
source

```
Base.Sys.ARCH– Constant.

```

Sys.ARCH

A symbol representing the architecture of the build configuration.  
source

```

#### CHAPTER 50. CONSTANTS 818

Base.Sys.MACHINE– Constant.

```

Sys.MACHINE

A string containing the build triple.  
source

```
See also:

- stdin
- stdout
- stderr
- ENV
- ENDIAN_BOM
- Libc.MS_ASYNC
- Libc.MS_INVALIDATE
- Libc.MS_SYNC


**Chapter 51**

**Filesystem**

Base.Filesystem.pwd– Function.

```

pwd()-> AbstractString

Get the current working directory.  
See also:cd,tempdir.  
Examples

julia> pwd()  
"/home/JuliaUser"

julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()  
"/home/JuliaUser/Projects/julia"

source

```
Base.Filesystem.cd– Method.

```

cd(dir:: AbstractString =homedir())

Set the current working directory.  
See also:pwd,mkdir,mkpath,mktempdir.  
Examples

julia> cd("/home/JuliaUser/Projects/julia")

julia> pwd()  
"/home/JuliaUser/Projects/julia"

julia> cd()

julia> pwd()  
"/home/JuliaUser"

source

```
#### 819


#### CHAPTER 51. FILESYSTEM 820

Base.Filesystem.cd– Method.

```

cd(f:: Function , dir:: AbstractString =homedir())

Temporarily change the current working directory todir, apply functionfand finally return to the original  
directory.  
Examples

julia> pwd()  
"/home/JuliaUser"

julia> cd(readdir,"/home/JuliaUser/Projects/julia")  
34-element Array{String,1}:  
".circleci"  
".freebsdci.sh"  
".git"  
".gitattributes"  
".github"

"test"  
"ui"  
"usr"  
"usr-staging"

julia> pwd()  
"/home/JuliaUser"

source

```
Base.Filesystem.readdir– Function.

```

readdir(dir:: AbstractString =pwd();  
join:: Bool = false ,  
sort:: Bool = true ,  
) -> Vector {String}

Return the names in the directorydiror the current working directory if not given. Whenjoinis false,  
readdirreturns just the names in the directory as is; whenjoinis true, it returnsjoinpath(dir, name)  
for eachnameso that the returned strings are full paths. If you want to get absolute paths back, call  
readdirwith an absolute directory path andjoinset to true.  
By default,readdirsorts the list of names it returns. If you want to skip sorting the names and get them  
in the order that the file system lists them, you can usereaddir(dir, sort=false)to opt out of sorting.

Julia 1.4  
Thejoinandsortkeyword arguments require at least Julia 1.4.

Examples

julia> cd("/home/JuliaUser/dev/julia")

julia> readdir()  
30-element Array{String,1}:  
".appveyor.yml"  
".git"

```

#### CHAPTER 51. FILESYSTEM 821

```

".gitattributes"

"ui"  
"usr"  
"usr-staging"

julia> readdir(join= true )  
30-element Array{String,1}:  
"/home/JuliaUser/dev/julia/.appveyor.yml"  
"/home/JuliaUser/dev/julia/.git"  
"/home/JuliaUser/dev/julia/.gitattributes"

"/home/JuliaUser/dev/julia/ui"  
"/home/JuliaUser/dev/julia/usr"  
"/home/JuliaUser/dev/julia/usr-staging"

julia> readdir("base")  
145-element Array{String,1}:  
".gitignore"  
"Base.jl"  
"Enums.jl"

"version_git.sh"  
"views.jl"  
"weakkeydict.jl"

julia> readdir("base", join= true )  
145-element Array{String,1}:  
"base/.gitignore"  
"base/Base.jl"  
"base/Enums.jl"

"base/version_git.sh"  
"base/views.jl"  
"base/weakkeydict.jl"```

julia> readdir(abspath("base"), join= true )  
145-element Array{String,1}:  
"/home/JuliaUser/dev/julia/base/.gitignore"  
"/home/JuliaUser/dev/julia/base/Base.jl"  
"/home/JuliaUser/dev/julia/base/Enums.jl"

"/home/JuliaUser/dev/julia/base/version_git.sh"  
"/home/JuliaUser/dev/julia/base/views.jl"  
"/home/JuliaUser/dev/julia/base/weakkeydict.jl"

source

```
Base.Filesystem.walkdir– Function.

```

walkdir(dir; topdown= true , follow_symlinks= false , onerror=throw)

Return an iterator that walks the directory tree of a directory. The iterator returns a tuple containing  
(rootpath, dirs, files). The directory tree can be traversed top-down or bottom-up. Ifwalkdiror  
statencounters aIOErrorit will rethrow the error by default. A custom error handling function can be  
provided throughonerrorkeyword argument.onerroris called with aIOErroras argument.

```

#### CHAPTER 51. FILESYSTEM 822

```

Examples

for (root, dirs, files) in walkdir(".")  
println("Directories in $root ")  
for dir in dirs  
println(joinpath(root, dir))# path to directories  
end  
println("Files in $root ")  
for file in files  
println(joinpath(root, file))# path to files  
end  
end

julia> mkpath("my/test/dir");

julia> itr = walkdir("my");

julia> (root, dirs, files)= first(itr)  
("my", ["test"], String[])

julia> (root, dirs, files)= first(itr)  
("my/test", ["dir"], String[])

julia> (root, dirs, files)= first(itr)  
("my/test/dir", String[], String[])

source

```
Base.Filesystem.mkdir– Function.

```

mkdir(path:: AbstractString ; mode:: Unsigned = 0o777)

Make a new directory with namepathand permissionsmode. modedefaults to0o777, modified by the  
current file creation mask. This function never creates more than one directory. If the directory already  
exists,orsomeintermediatedirectoriesdonotexist,thisfunctionthrowsanerror. Seemkpathforafunction  
which creates all required intermediate directories. Returnpath.  
Examples

julia> mkdir("testingdir")  
"testingdir"

julia> cd("testingdir")

julia> pwd()  
"/home/JuliaUser/testingdir"

source

```
Base.Filesystem.mkpath– Function.

```

mkpath(path:: AbstractString ; mode:: Unsigned = 0o777)

Create all directories in the givenpath, with permissionsmode.modedefaults to0o777, modified by the  
current file creation mask. Unlikemkdir,mkpathdoes not error ifpath(or parts of it) already exists. Return  
path.  
Examples

```

#### CHAPTER 51. FILESYSTEM 823

```

julia> mkdir("testingdir")  
"testingdir"

julia> cd("testingdir")

julia> pwd()  
"/home/JuliaUser/testingdir"

julia> mkpath("my/test/dir")  
"my/test/dir"

julia> readdir()  
1-element Array{String,1}:  
"my"

julia> cd("my")

julia> readdir()  
1-element Array{String,1}:  
"test"

julia> readdir("test")  
1-element Array{String,1}:  
"dir"

source

```
Base.Filesystem.symlink– Function.

```

symlink(target:: AbstractString , link:: AbstractString ; dir_target= false )

Creates a symbolic link totargetwith the namelink.  
On Windows, symlinks must be explicitly declared as referring to a directory or not. Iftargetalready  
exists, by default the type oflinkwill be auto- detected, however iftargetdoes not exist, this function  
defaults to creating a file symlink unlessdir_targetis set totrue. Note that if the user setsdir_target  
buttargetexists and is a file, a directory symlink will still be created, but dereferencing the symlink will  
fail, just as if the user creates a file symlink (by callingsymlink()withdir_targetset tofalsebefore  
the directory is created) and tries to dereference it to a directory.  
Additionally, there are two methods of making a link on Windows; symbolic links and junction points. Junc-  
tion points are slightly more efficient, but do not support relative paths, so if a relative directory symlink  
is requested (as denoted byisabspath(target)returningfalse) a symlink will be used, else a junc-  
tion point will be used. Best practice for creating symlinks on Windows is to create them only after the  
files/directories they reference are already created.

Note  
This function raises an error under operating systems that do not support soft symbolic links,  
such as Windows XP.

Julia 1.6  
Thedir_targetkeywordargumentwasaddedinJulia1.6. Priortothis, symlinkstononexistant  
paths on windows would always be file symlinks, and relative symlinks to directories were not  
supported.

source

```

#### CHAPTER 51. FILESYSTEM 824

Base.Filesystem.readlink– Function.

```

readlink(path:: AbstractString ) -> AbstractString

Return the target location a symbolic linkpathpoints to.  
source

```
Base.Filesystem.chmod– Function.

```

chmod(path:: AbstractString , mode:: Integer ; recursive:: Bool = false )

Change the permissions mode ofpathtomode. Only integermodes (e.g.0o777) are currently supported.  
Ifrecursive=trueand the path is a directory all permissions in that directory will be recursively changed.  
Returnpath.

Note  
Prior to Julia 1.6, this did not correctly manipulate filesystem ACLs on Windows, therefore it  
would only set read-only bits on files. It now is able to manipulate ACLs.

source

```
Base.Filesystem.chown– Function.

```

chown(path:: AbstractString , owner:: Integer , group:: Integer =-1)

Change the owner and/or group ofpathtoownerand/orgroup. If the value entered forownerorgroupis  
-1the corresponding ID will not change. Only integerowners andgroups are currently supported. Return  
path.  
source

```
Base.Libc.RawFD– Type.

```

RawFD

Primitive type which wraps the native OS file descriptor.RawFDs can be passed to methods likestatto  
discover information about the underlying file, and can also be used to open streams, with theRawFD  
describing the OS file backing the stream.  
source

```
Base.stat– Function.

```

stat(file)

Returns a structure whose fields contain information about the file. The fields of the structure are:  
source

```
Base.Filesystem.lstat– Function.

```

lstat(file)

Likestat, but for symbolic links gets the info for the link itself rather than the file it refers to. This function  
must be called on a file path rather than a file object or a file descriptor.  
source

```

#### CHAPTER 51. FILESYSTEM 825

```

Name Description  
desc The path or OS file descriptor  
size The size (in bytes) of the file  
device ID of the device that contains the file  
inode The inode number of the file  
mode The protection mode of the file  
nlink The number of hard links to the file  
uid The user id of the owner of the file  
gid The group id of the file owner  
rdev If this file refers to a device, the ID of the device it refers to  
blksize The file-system preferred block size for the file  
blocks The number of such blocks allocated  
mtime Unix timestamp of when the file was last modified  
ctime Unix timestamp of when the file's metadata was changed

```
Base.Filesystem.ctime– Function.

```

ctime(file)

Equivalent tostat(file).ctime.  
source

```
Base.Filesystem.mtime– Function.

```

mtime(file)

Equivalent tostat(file).mtime.  
source

```
Base.Filesystem.filemode– Function.

```

filemode(file)

Equivalent tostat(file).mode.  
source

```
Base.filesize– Function.

```

filesize(path...)

Equivalent tostat(file).size.  
source

```
Base.Filesystem.uperm– Function.

```

uperm(file)

Get the permissions of the owner of the file as a bitfield of  
For allowed arguments, seestat.  
source

```
Base.Filesystem.gperm– Function.


#### CHAPTER 51. FILESYSTEM 826

```

Value Description  
01 Execute Permission  
02 Write Permission  
04 Read Permission

gperm(file)

Likeupermbut gets the permissions of the group owning the file.  
source

```
Base.Filesystem.operm– Function.

```

operm(file)

Likeupermbut gets the permissions for people who neither own the file nor are a member of the group  
owning the file  
source

```
Base.Filesystem.cp– Function.

```

cp(src:: AbstractString , dst:: AbstractString ; force:: Bool = false , follow_symlinks:: Bool = false )

Copy the file, link, or directory fromsrctodst.force=truewill first remove an existingdst.  
Iffollow_symlinks=false,andsrcisasymboliclink,dstwillbecreatedasasymboliclink. Iffollow_symlinks=true  
andsrcis a symbolic link,dstwill be a copy of the file or directorysrcrefers to. Returndst.  
source

```
Base.download– Function.

```

download(url:: AbstractString , [path:: AbstractString = tempname()])-> path

Download a file from the given url, saving it to the locationpath, or if not specified, a temporary path.  
Returns the path of the downloaded file.

Note  
SinceJulia1.6,thisfunctionisdeprecatedandisjustathinwrapperaroundDownloads.download.  
In new code, you should use that function directly instead of calling this.

source

```
Base.Filesystem.mv– Function.

```

mv(src:: AbstractString , dst:: AbstractString ; force:: Bool = false )

Move the file, link, or directory fromsrctodst.force=truewill first remove an existingdst. Returndst.  
Examples

julia> write("hello.txt", "world");

julia> mv("hello.txt", "goodbye.txt")  
"goodbye.txt"

```

#### CHAPTER 51. FILESYSTEM 827

```

julia> "hello.txt" in readdir()  
false

julia> readline("goodbye.txt")  
"world"

julia> write("hello.txt", "world2");

julia> mv("hello.txt", "goodbye.txt")  
ERROR: ArgumentError: 'goodbye.txt' exists. `force=true` is required to remove 'goodbye.txt'  
↪→ before moving.  
Stacktrace:  
[1] #checkfor_mv_cp_cptree#10(::Bool, ::Function, ::String, ::String, ::String) at  
↪→ ./file.jl:293  
[...]

julia> mv("hello.txt", "goodbye.txt", force= true )  
"goodbye.txt"

julia> rm("goodbye.txt");

source

```
Base.Filesystem.rm– Function.

```

rm(path:: AbstractString ; force:: Bool = false , recursive:: Bool = false )

Delete the file, link, or empty directory at the given path. Ifforce=trueis passed, a non-existing path is  
nottreatedaserror. Ifrecursive=trueispassedandthepathisadirectory, thenallcontentsareremoved  
recursively.  
Examples

julia> mkpath("my/test/dir");

julia> rm("my", recursive= true )

julia> rm("this_file_does_not_exist", force= true )

julia> rm("this_file_does_not_exist")  
ERROR: IOError: unlink("this_file_does_not_exist"): no such file or directory (ENOENT)  
Stacktrace:  
[...]

source

```
Base.Filesystem.touch– Function.

```

touch(path:: AbstractString )

Update the last-modified timestamp on a file to the current time.  
If the file does not exist a new file is created.  
Returnpath.  
Examples

```

#### CHAPTER 51. FILESYSTEM 828

```

julia> write("my_little_file", 2);

julia> mtime("my_little_file")  
1.5273815391135583e9

julia> touch("my_little_file");

julia> mtime("my_little_file")  
1.527381559163435e9

We can see themtimehas been modified bytouch.  
source

```
Base.Filesystem.tempname– Function.

```

tempname(parent=tempdir(); cleanup= true ) -> String

Generate a temporary file path. This function only returns a path; no file is created. The path is likely to  
be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to  
tempnamegenerating the same file name. The name is guaranteed to differ from all files already existing  
at the time of the call totempname.  
When called with no arguments, the temporary name will be an absolute path to a temporary name in the  
systemtemporarydirectoryasgivenbytempdir(). Ifaparentdirectoryargumentisgiven, thetemporary  
path will be in that directory instead.  
Thecleanupoption controls whether the process attempts to delete the returned path automatically when  
the process exits. Note that thetempnamefunction does not create any file or directory at the returned  
location, so there is nothing to cleanup unless you create a file or directory there. If you do andcleanis  
trueit will be deleted upon process termination.

Julia 1.4  
Theparentandcleanuparguments were added in 1.4. Prior to Julia 1.4 the pathtempname  
would never be cleaned up at process termination.

Warning  
This can lead to security holes if another process obtains the same file name and creates the  
file before you are able to. Open the file withJL_O_EXCLif this is a concern. Usingmktemp()is  
also recommended instead.

source

```
Base.Filesystem.tempdir– Function.

```

tempdir()

Gets the path of the temporary directory. On Windows,tempdir()uses the first environment variable  
found in the ordered listTMP,TEMP,USERPROFILE. On all other operating systems,tempdir()uses the first  
environment variable found in the ordered listTMPDIR,TMP,TEMP, andTEMPDIR. If none of these are found,  
the path"/tmp"is used.  
source

```
Base.Filesystem.mktemp– Method.

```

mktemp(parent=tempdir(); cleanup= true ) -> (path, io)

```

#### CHAPTER 51. FILESYSTEM 829

```

Return(path, io), wherepathis the path of a new temporary file inparentandiois an open file object  
for this path. Thecleanupoption controls whether the temporary file is automatically deleted when the  
process exits.

Julia 1.3  
Thecleanupkeyword argument was added in Julia 1.3. Relatedly, starting from 1.3, Julia will  
remove the temporary paths created bymktempwhen the Julia process exits, unlesscleanupis  
explicitly set tofalse.

source

```
Base.Filesystem.mktemp– Method.

```

mktemp(f:: Function , parent=tempdir())

Apply the functionfto the result ofmktemp(parent)and remove the temporary file upon completion.  
See also:mktempdir.  
source

```
Base.Filesystem.mktempdir– Method.

```

mktempdir(parent=tempdir(); prefix="jl_", cleanup= true ) -> path

Create a temporary directory in theparentdirectory with a name constructed from the given prefix and  
a random suffix, and return its path. Additionally, any trailingXcharacters may be replaced with random  
characters. Ifparentdoes not exist, throw an error. Thecleanupoption controls whether the temporary  
directory is automatically deleted when the process exits.

Julia 1.2  
Theprefixkeyword argument was added in Julia 1.2.

Julia 1.3  
Thecleanupkeyword argument was added in Julia 1.3. Relatedly, starting from 1.3, Julia will  
removethetemporarypathscreatedbymktempdirwhentheJuliaprocessexits,unlesscleanup  
is explicitly set tofalse.

See also:mktemp,mkdir.  
source

```
Base.Filesystem.mktempdir– Method.

```

mktempdir(f:: Function , parent=tempdir(); prefix="jl_")

Apply the functionfto the result ofmktempdir(parent; prefix)and remove the temporary directory all  
of its contents upon completion.  
See also:mktemp,mkdir.

Julia 1.2  
Theprefixkeyword argument was added in Julia 1.2.

source

```

#### CHAPTER 51. FILESYSTEM 830

Base.Filesystem.isblockdev– Function.

```

isblockdev(path)-> Bool

Returntrueifpathis a block device,falseotherwise.  
source

```
Base.Filesystem.ischardev– Function.

```

ischardev(path)-> Bool

Returntrueifpathis a character device,falseotherwise.  
source

```
Base.Filesystem.isdir– Function.

```

isdir(path)-> Bool

Returntrueifpathis a directory,falseotherwise.  
Examples

julia> isdir(homedir())  
true

julia> isdir("not/a/directory")  
false

See alsoisfileandispath.  
source

```
Base.Filesystem.isfifo– Function.

```

isfifo(path)-> Bool

Returntrueifpathis a FIFO,falseotherwise.  
source

```
Base.Filesystem.isfile– Function.

```

isfile(path)-> Bool

Returntrueifpathis a regular file,falseotherwise.  
Examples

julia> isfile(homedir())  
false

julia> f = open("test_file.txt", "w");

julia> isfile(f)  
true

julia> close(f); rm("test_file.txt")

```

#### CHAPTER 51. FILESYSTEM 831

```

See alsoisdirandispath.  
source

```
Base.Filesystem.islink– Function.

```

islink(path)-> Bool

Returntrueifpathis a symbolic link,falseotherwise.  
source

```
Base.Filesystem.ismount– Function.

```

ismount(path)-> Bool

Returntrueifpathis a mount point,falseotherwise.  
source

```
Base.Filesystem.ispath– Function.

```

ispath(path)-> Bool

Returntrueif a valid filesystem entity exists atpath, otherwise returnsfalse. This is the generalization  
ofisfile,isdiretc.  
source

```
Base.Filesystem.issetgid– Function.

```

issetgid(path)-> Bool

Returntrueifpathhas the setgid flag set,falseotherwise.  
source

```
Base.Filesystem.issetuid– Function.

```

issetuid(path)-> Bool

Returntrueifpathhas the setuid flag set,falseotherwise.  
source

```
Base.Filesystem.issocket– Function.

```

issocket(path)-> Bool

Returntrueifpathis a socket,falseotherwise.  
source

```
Base.Filesystem.issticky– Function.

```

issticky(path)-> Bool

Returntrueifpathhas the sticky bit set,falseotherwise.  
source

```

#### CHAPTER 51. FILESYSTEM 832

Base.Filesystem.homedir– Function.

```

homedir()-> String

Return the current user's home directory.

Note  
homedirdetermines the home directory vialibuv'suv_os_homedir. For details (for exam-  
ple on how to specify the home directory via environment variables), see theuv_os_homedir  
documentation.

source

```
Base.Filesystem.dirname– Function.

```

dirname(path:: AbstractString ) -> AbstractString

Get the directory part of a path. Trailing characters ('/' or '') in the path are counted as part of the path.  
Examples

julia> dirname("/home/myuser")  
"/home"

julia> dirname("/home/myuser/")  
"/home/myuser"

See alsobasename.  
source

```
Base.Filesystem.basename– Function.

```

basename(path:: AbstractString ) -> AbstractString

Get the file name part of a path.

Note  
ThisfunctiondiffersslightlyfromtheUnixbasenameprogram,wheretrailingslashesareignored,  
i.e.$ basename /foo/bar/returnsbar, whereasbasenamein Julia returns an empty string"".

Examples

julia> basename("/home/myuser/example.jl")  
"example.jl"

julia> basename("/home/myuser/")  
""

See alsodirname.  
source

```
Base.Filesystem.isabspath– Function.

```

isabspath(path:: AbstractString ) -> Bool

```

#### CHAPTER 51. FILESYSTEM 833

```

Determine whether a path is absolute (begins at the root directory).  
Examples

julia> isabspath("/home")  
true

julia> isabspath("home")  
false

source

```
Base.Filesystem.isdirpath– Function.

```

isdirpath(path:: AbstractString ) -> Bool

Determine whether a path refers to a directory (for example, ends with a path separator).  
Examples

julia> isdirpath("/home")  
false

julia> isdirpath("/home/")  
true

source

```
Base.Filesystem.joinpath– Function.

```

joinpath(parts:: AbstractString ...) -> String  
joinpath(parts:: Vector { AbstractString }) -> String  
joinpath(parts:: Tuple { AbstractString }) -> String

Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive  
specification that doesn't match the drive computed for the join of the preceding paths, then prior compo-  
nents are dropped.  
Note on Windows since there is a current directory for each drive,joinpath("c:", "foo")represents  
a path relative to the current directory on drive"c:" so this is equal to"c:foo", not "c:\foo". Furthermore,  
joinpathtreatsthisasanon-absolutepathandignoresthedrivelettercasing,hencejoinpath("C:\A","c:b")  
= "C:\A\b".  
Examples

julia> joinpath("/home/myuser", "example.jl")  
"/home/myuser/example.jl"

julia> joinpath(["/home/myuser", "example.jl"])  
"/home/myuser/example.jl"

source

```
Base.Filesystem.abspath– Function.

```

abspath(path:: AbstractString ) -> String

```

#### CHAPTER 51. FILESYSTEM 834

```

Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path  
as innormpath.  
source  
abspath(path::AbstractString, paths::AbstractString...) -> String

Convert a set of paths to an absolute path by joining them together and adding the current directory if  
necessary. Equivalent toabspath(joinpath(path, paths...)).  
source

```
Base.Filesystem.normpath– Function.

```

normpath(path:: AbstractString ) -> String

Normalize a path, removing"." and ".." entries.  
Examples

julia> normpath("/home/myuser/../example.jl")  
"/home/example.jl"

source  
normpath(path::AbstractString, paths::AbstractString...) -> String

Convert a set of paths to a normalized path by joining them together and removing"." and ".." entries.  
Equivalent tonormpath(joinpath(path, paths...)).  
source

```
Base.Filesystem.realpath– Function.

```

realpath(path:: AbstractString ) -> String

Canonicalize a path by expanding symbolic links and removing"." and ".." entries. On case-insensitive  
case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is re-  
turned.  
(This function throws an exception ifpathdoes not exist in the filesystem.)  
source

```
Base.Filesystem.relpath– Function.

```

relpath(path:: AbstractString , startpath:: AbstractString = ".") -> AbstractString

Return a relative filepath topatheither from the current directory or from an optional start directory.  
This is a path computation: the filesystem is not accessed to confirm the existence or nature ofpathor  
startpath.  
OnWindows,casesensitivityisappliedtoeverypartofthepathexceptdriveletters. Ifpathandstartpath  
refer to different drives, the absolute path ofpathis returned.  
source

```
Base.Filesystem.expanduser– Function.

```

expanduser(path:: AbstractString ) -> AbstractString

```

#### CHAPTER 51. FILESYSTEM 835

```

On Unix systems, replace a tilde character at the start of a path with the current user's home directory.  
source

```
Base.Filesystem.splitdir– Function.

```

splitdir(path:: AbstractString ) -> ( AbstractString , AbstractString )

Split a path into a tuple of the directory name and file name.  
Examples

julia> splitdir("/home/myuser")  
("/home", "myuser")

source

```
Base.Filesystem.splitdrive– Function.

```

splitdrive(path:: AbstractString ) -> ( AbstractString , AbstractString )

On Windows, split a path into the drive letter part and the path part. On Unix systems, the first component  
is always the empty string.  
source

```
Base.Filesystem.splitext– Function.

```

splitext(path:: AbstractString ) -> ( AbstractString , AbstractString )

If the last component of a path contains one or more dots, split the path into everything before the last  
dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and  
the empty string."splitext" is short for"split extension".  
Examples

julia> splitext("/home/myuser/example.jl")  
("/home/myuser/example", ".jl")

julia> splitext("/home/myuser/example.tar.gz")  
("/home/myuser/example.tar", ".gz")

julia> splitext("/home/my.user/example")  
("/home/my.user/example", "")

source

```
Base.Filesystem.splitpath– Function.

```

splitpath(path:: AbstractString ) -> Vector {String}

Split a file path into all its path components. This is the opposite ofjoinpath. Returns an array of sub-  
strings, one for each directory or file in the path, including the root directory if present.

Julia 1.1  
This function requires at least Julia 1.1.

Examples

```

#### CHAPTER 51. FILESYSTEM 836

```

julia> splitpath("/home/myuser/example.jl")  
4-element Vector{String}:  
"/"  
"home"  
"myuser"  
"example.jl"

source

```

**Chapter 52**

**I/O and Network**

### 52.1 General I/O

Base.stdout– Constant.

```

stdout

Global variable referring to the standard out stream.  
source

```
Base.stderr– Constant.

```

stderr

Global variable referring to the standard error stream.  
source

```
Base.stdin– Constant.

```

stdin

Global variable referring to the standard input stream.  
source

```
Base.open– Function.

```

open(f:: Function , args...; kwargs...)

Apply the functionfto the result ofopen(args...; kwargs...) and close the resulting file descriptor  
upon completion.  
Examples

julia> open("myfile.txt", "w") do io  
write(io,"Hello world!")  
end ;

julia> open(f->read(f, String),"myfile.txt")  
"Hello world!"

julia> rm("myfile.txt")

```
#### 837


#### CHAPTER 52. I/O AND NETWORK 838

```

source  
open(filename::AbstractString; lock = true, keywords...) -> IOStream

Open a file in a mode specified by five boolean keyword arguments:

Keyword Description Default  
read open for reading !write  
write open for writing truncate | append  
create create if non-existent !read & write | truncate | append  
truncate truncate to zero size !read & write  
append seek to end false

The default when no keywords are passed is to open files for reading only. Returns a stream for accessing  
the opened file.  
Thelockkeyword argument controls whether operations will be locked for safe multi-threaded access.

Julia 1.5  
Thelockargument is available as of Julia 1.5.

source  
open(filename::AbstractString, [mode::AbstractString]; lock = true) -> IOStream

Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The  
values ofmodecorrespond to those fromfopen(3)or Perlopen, and are equivalent to setting the following  
boolean groups:

Mode Description Keywords  
r read none  
w write, create, truncate write = true  
a write, create, append append = true  
r+ read, write read = true, write = true  
w+ read, write, create, truncate truncate = true, read = true  
a+ read, write, create, append append = true, read = true

Thelockkeyword argument controls whether operations will be locked for safe multi-threaded access.  
Examples

julia> io = open("myfile.txt", "w");

julia> write(io,"Hello world!");

julia> close(io);

julia> io = open("myfile.txt", "r");

julia> read(io, String)  
"Hello world!"

julia> write(io,"This file is read only")  
ERROR: ArgumentError: write failed, IOStream is not writeable  
[...]

```

#### CHAPTER 52. I/O AND NETWORK 839

```

julia> close(io)

julia> io = open("myfile.txt", "a");

julia> write(io,"This stream is not read only")  
28

julia> close(io)

julia> rm("myfile.txt")

Julia 1.5  
Thelockargument is available as of Julia 1.5.

source  
open(fd::OS_HANDLE) -> IO

Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call  
open(Libc.dup(fd))to avoid the ownership capture of the original handle.

Warning  
Do not call this on a handle that's already owned by some other part of the system.

source  
open(command, mode::AbstractString, stdio=devnull)

Runcommandasynchronously. Likeopen(command, stdio; read, write)except specifying the read and  
write flags via a mode string instead of keyword arguments. Possible mode strings are:

Mode Description Keywords  
r read none  
w write write = true  
r+ read, write read = true, write = true  
w+ read, write read = true, write = true

source  
open(command, stdio=devnull; write::Bool = false, read::Bool = !write)

Start runningcommandasynchronously, and return aprocess::IOobject. Ifreadis true, then reads from  
theprocesscomefromtheprocess'sstandardoutputandstdiooptionallyspecifiestheprocess'sstandard  
input stream. Ifwriteis true, then writes go to the process's standard input andstdiooptionally specifies  
the process's standard output stream. The process's standard error stream is connected to the current  
globalstderr.  
source  
open(f::Function, command, args...; kwargs...)

Similar toopen(command, args...; kwargs...), but callsf(stream)on the resulting process stream,  
then closes the input stream and waits for the process to complete. Return the value returned byfon  
success. Throw an error if the process failed, or if the process attempts to print anything to stdout.  
source

```

#### CHAPTER 52. I/O AND NETWORK 840

Base.IOStream– Type.

```

IOStream

A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned byopen.  
source

```
Base.IOBuffer– Type.

```

IOBuffer ([data:: AbstractVector { UInt8 }]; keywords...) -> IOBuffer

Create an in-memory I/O stream, which may optionally operate on a pre-existing array.  
It may take optional keyword arguments:

```
- read,write,append: restricts operations to the buffer; seeopenfor details.
- truncate: truncates the buffer size to zero length.
- maxsize: specifies a size beyond which the buffer may not be grown.
- sizehint: suggests a capacity of the buffer (datamust implementsizehint!(data, size)).

```

Whendatais not given, the buffer will be both readable and writable by default.  
Examples

julia> io = IOBuffer ();

julia> write(io,"JuliaLang is a GitHub organization.", " It has many members.")  
56

julia> String(take!(io))  
"JuliaLang is a GitHub organization. It has many members."

julia> io = IOBuffer (b"JuliaLang is a GitHub organization.")  
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35,  
↪→ maxsize=Inf, ptr=1, mark=-1)

julia> read(io, String)  
"JuliaLang is a GitHub organization."

julia> write(io,"This isn't writable.")  
ERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable

julia> io = IOBuffer ( UInt8 [], read= true , write= true , maxsize=34)  
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0,  
↪→ maxsize=34, ptr=1, mark=-1)

julia> write(io,"JuliaLang is a GitHub organization.")  
34

julia> String(take!(io))  
"JuliaLang is a GitHub organization"

julia> length(read( IOBuffer (b"data", read= true , truncate= false )))  
4

julia> length(read( IOBuffer (b"data", read= true , truncate= true )))  
0

```

#### CHAPTER 52. I/O AND NETWORK 841

```

source  
IOBuffer(string::String)

Create a read-onlyIOBufferon the data underlying the given string.  
Examples

julia> io = IOBuffer ("Haho");

julia> String(take!(io))  
"Haho"

julia> String(take!(io))  
"Haho"

source

```
Base.take!– Method.

```

take!(b:: IOBuffer )

Obtain the contents of anIOBufferas an array. Afterwards, theIOBufferis reset to its initial state.  
Examples

julia> io = IOBuffer ();

julia> write(io,"JuliaLang is a GitHub organization.", " It has many members.")  
56

julia> String(take!(io))  
"JuliaLang is a GitHub organization. It has many members."

source

```
Base.fdio– Function.

```

fdio([name:: AbstractString , ]fd:: Integer [, own:: Bool = false ]) -> IOStream

Create anIOStreamobject from an integer file descriptor. Ifownistrue, closing this object will close the  
underlying descriptor. By default, anIOStreamis closed when it is garbage collected.nameallows you to  
associate the descriptor with a named file.  
source

```
Base.flush– Function.

```

flush(stream)

Commit all currently buffered writes to the given stream.  
source

```
Base.close– Function.

```

close(stream)

```

#### CHAPTER 52. I/O AND NETWORK 842

```

Close an I/O stream. Performs aflushfirst.  
source

```
Base.write– Function.

```

write(io:: IO , x)  
write(filename:: AbstractString , x)

Write the canonical binary representation of a value to the given I/O stream or file. Return the number of  
bytes written into the stream. See alsoprintto write a text representation (with an encoding that may  
depend uponio).  
The endianness of the written value depends on the endianness of the host system. Convert to/from a  
fixed endianness when writing/reading (e.g. usinghtolandltoh) to get results that are consistent across  
platforms.  
You can write multiple values with the samewritecall. i.e. the following are equivalent:  
write(io, x, y...)  
write(io, x) + write(io, y...)

Examples  
Consistent serialization:

julia> fname= tempname();# random temporary filename

julia> open(fname,"w") do f

# Make sure we write 64bit integer in little-endian byte order

write(f,htol( Int64 (42)))  
end  
8

julia> open(fname,"r") do f

# Convert back to host byte order and host integer type

Int (ltoh(read(f, Int64 )))  
end  
42

Merging write calls:

julia> io = IOBuffer ();

julia> write(io,"JuliaLang is a GitHub organization.", " It has many members.")  
56

julia> String(take!(io))  
"JuliaLang is a GitHub organization. It has many members."

julia> write(io,"Sometimes those members") + write(io," write documentation.")  
44

julia> String(take!(io))  
"Sometimes those members write documentation."

User-defined plain-data types withoutwritemethods can be written when wrapped in aRef:

```

#### CHAPTER 52. I/O AND NETWORK 843

```

julia> struct MyStruct; x:: Float64 ; end

julia> io = IOBuffer ()  
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0,  
↪→ maxsize=Inf, ptr=1, mark=-1)

julia> write(io, Ref (MyStruct(42.0)))  
8

julia> seekstart(io); read!(io, Ref (MyStruct(NaN)))  
Base.RefValue{MyStruct}(MyStruct(42.0))

source

```
Base.read– Function.

```

read(io:: IO , T)

Read a single value of typeTfromio, in canonical binary representation.  
Note that Julia does not convert the endianness for you. Usentohorltohfor this purpose.  
read(io::IO, String)

Read the entirety ofio, as aString(see alsoreadchomp).  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization");

julia> read(io, Char )  
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)

julia> io = IOBuffer ("JuliaLang is a GitHub organization");

julia> read(io, String)  
"JuliaLang is a GitHub organization"

source  
read(filename::AbstractString, args...)

Open a file and read its contents. argsis passed toread: this is equivalent toopen(io->read(io,  
args...), filename).  
read(filename::AbstractString, String)

Read the entire contents of a file as a string.  
source  
read(s::IO, nb=typemax(Int))

Read at mostnbbytes froms, returning aVector{UInt8}of the bytes read.  
source  
read(s::IOStream, nb::Integer; all=true)

```

#### CHAPTER 52. I/O AND NETWORK 844

```

Read at mostnbbytes froms, returning aVector{UInt8}of the bytes read.  
Ifallistrue(the default), this function will block repeatedly trying to read all requested bytes, until an  
error or end-of-file occurs. Ifallisfalse, at most onereadcall is performed, and the amount of data  
returned is device-dependent. Note that not all stream types support thealloption.  
source  
read(command::Cmd)

Runcommandand return the resulting output as an array of bytes.  
source  
read(command::Cmd, String)

Runcommandand return the resulting output as aString.  
source

```
Base.read!– Function.

```

read!(stream:: IO , array:: AbstractArray )  
read!(filename:: AbstractString , array:: AbstractArray )

Read binary data from an I/O stream or file, filling inarray.  
source

```
Base.readbytes!– Function.

```

readbytes!(stream:: IO , b :: AbstractVector { UInt8 }, nb=length(b))

Read at mostnbbytes fromstreamintob, returning the number of bytes read. The size ofbwill be  
increased if needed (i.e. ifnbis greater thanlength(b)and enough bytes could be read), but it will never  
be decreased.  
source  
readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)

Read at mostnbbytes fromstreamintob, returning the number of bytes read. The size ofbwill be  
increased if needed (i.e. ifnbis greater thanlength(b)and enough bytes could be read), but it will never  
be decreased.  
Ifallistrue(the default), this function will block repeatedly trying to read all requested bytes, until an  
error or end-of-file occurs. Ifallisfalse, at most onereadcall is performed, and the amount of data  
returned is device-dependent. Note that not all stream types support thealloption.  
source

```
Base.unsafe_read– Function.

```

unsafe_read(io:: IO , ref, nbytes:: UInt )

Copynbytesfrom theIOstream object intoref(converted to a pointer).  
It is recommended that subtypesT<:IOoverride the following method signature to provide more efficient  
implementations:unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)  
source

```

#### CHAPTER 52. I/O AND NETWORK 845

Base.unsafe_write– Function.

```

unsafe_write(io:: IO , ref, nbytes:: UInt )

Copynbytesfromref(converted to a pointer) into theIOobject.  
It is recommended that subtypesT<:IOoverride the following method signature to provide more efficient  
implementations:unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)  
source

```
Base.readeach– Function.

```

readeach(io:: IO , T)

Return an iterable object yieldingread(io, T).  
See alsoskipchars,eachline,readuntil.

Julia 1.6  
readeachrequires Julia 1.6 or later.

Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization. \n It has many members. \n ");

julia>for c in readeach(io, Char )  
c == '\n'&& break  
print(c)  
end  
JuliaLang is a GitHub organization.

source

```
Base.peek– Function.

```

peek(stream[, T= UInt8 ])

Read and return a value of typeTfrom a stream without advancing the current position in the stream.  
Examples

julia> b = IOBuffer ("julia");

julia> peek(b)  
0x6a

julia> position(b)  
0

julia> peek(b, Char )  
'j': ASCII/Unicode U+006A (category Ll: Letter, lowercase)

Julia 1.5  
The method which accepts a type requires Julia 1.5 or later.

source

```

#### CHAPTER 52. I/O AND NETWORK 846

Base.position– Function.

```

position(s)

Get the current position of a stream.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> seek(io,5);

julia> position(io)  
5

julia> skip(io,10);

julia> position(io)  
15

julia> seekend(io);

julia> position(io)  
35

source

```
Base.seek– Function.

```

seek(s, pos)

Seek a stream to the given position.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> seek(io,5);

julia> read(io, Char )  
'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)

source

```
Base.seekstart– Function.

```

seekstart(s)

Seek a stream to its beginning.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> seek(io,5);

julia> read(io, Char )

```

#### CHAPTER 52. I/O AND NETWORK 847

```

'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)

julia> seekstart(io);

julia> read(io, Char )  
'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)

source

```
Base.seekend– Function.

```

seekend(s)

Seek a stream to its end.  
source

```
Base.skip– Function.

```

skip(s, offset)

Seek a stream relative to the current position.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> seek(io,5);

julia> skip(io,10);

julia> read(io, Char )  
'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)

source

```
Base.mark– Function.

```

mark(s)

Add a mark at the current position of streams. Return the marked position.  
See alsounmark,reset,ismarked.  
source

```
Base.unmark– Function.

```

unmark(s)

Remove a mark from streams. Returntrueif the stream was marked,falseotherwise.  
See alsomark,reset,ismarked.  
source

```
Base.reset– Function.

```

reset(s)

```

#### CHAPTER 52. I/O AND NETWORK 848

```

Reset a streamsto a previously marked position, and remove the mark. Return the previously marked  
position. Throw an error if the stream is not marked.  
See alsomark,unmark,ismarked.  
source

```
Base.ismarked– Function.

```

ismarked(s)

Returntrueif streamsis marked.  
See alsomark,unmark,reset.  
source

```
Base.eof– Function.

```

eof(stream)-> Bool

Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to  
wait for more data if necessary, and then returnfalse. Therefore it is always safe to read one byte after  
seeingeofreturnfalse.eofwill returnfalseas long as buffered data is still available, even if the remote  
end of a connection is closed.  
source

```
Base.isreadonly– Function.

```

isreadonly(io)-> Bool

Determine whether a stream is read-only.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization");

julia> isreadonly(io)  
true

julia> io = IOBuffer ();

julia> isreadonly(io)  
false

source

```
Base.iswritable– Function.

```

iswritable(io)-> Bool

Returntrueif the specified IO object is writable (if that can be determined).  
Examples

julia> open("myfile.txt", "w") do io  
print(io,"Hello world!");  
iswritable(io)

```

#### CHAPTER 52. I/O AND NETWORK 849

```

end  
true

julia> open("myfile.txt", "r") do io  
iswritable(io)  
end  
false

julia> rm("myfile.txt")

source

```
Base.isreadable– Function.

```

isreadable(io)-> Bool

Returntrueif the specified IO object is readable (if that can be determined).  
Examples

julia> open("myfile.txt", "w") do io  
print(io,"Hello world!");  
isreadable(io)  
end  
false

julia> open("myfile.txt", "r") do io  
isreadable(io)  
end  
true

julia> rm("myfile.txt")

source

```
Base.isopen– Function.

```

isopen(object)-> Bool

Determine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it  
will never produce a new event. However, since a closed stream may still have data to read in its buffer,  
useeofto check for the ability to read data. Use theFileWatchingpackage to be notified when a stream  
might be writable or readable.  
Examples

julia> io = open("my_file.txt", "w+");

julia> isopen(io)  
true

julia> close(io)

julia> isopen(io)  
false

source

```

#### CHAPTER 52. I/O AND NETWORK 850

Base.fd– Function.

```

fd(stream)

Return the file descriptor backing the stream or file. Note that this function only applies to synchronous  
File's andIOStream's not to any of the asynchronous streams.  
source

```
Base.redirect_stdio– Function.

```

redirect_stdio(;stdin=stdin, stderr=stderr, stdout=stdout)

Redirect a subset of the streamsstdin,stderr,stdout. Each argument must be anIOStream,TTY,Pipe,  
socket, ordevnull.

Julia 1.7  
redirect_stdiorequires Julia 1.7 or later.

source  
redirect_stdio(f; stdin=nothing, stderr=nothing, stdout=nothing)

Redirect a subset of the streamsstdin,stderr,stdout, callf()and restore each stream.  
Possible values for each stream are:

```
- nothingindicating the stream should not be redirected.
- path::AbstractStringredirecting the stream to the file atpath.
- ioanIOStream,TTY,Pipe, socket, ordevnull.

```

Examples

julia> redirect_stdio(stdout="stdout.txt", stderr="stderr.txt") do  
print("hello stdout")  
print(stderr,"hello stderr")  
end

julia> read("stdout.txt", String)  
"hello stdout"

julia> read("stderr.txt", String)  
"hello stderr"

Edge cases  
It is possible to pass the same argument tostdoutandstderr:

julia> redirect_stdio(stdout="log.txt", stderr="log.txt", stdin=devnull) do  
...  
end

However it is not supported to pass two distinct descriptors of the same file.

```

#### CHAPTER 52. I/O AND NETWORK 851

```

julia> io1 = open("same/path", "w")

julia> io2 = open("same/path", "w")

julia> redirect_stdio(f, stdout=io1, stderr=io2)# not suppored

Also thestdinargument may not be the same descriptor asstdoutorstderr.

julia> io = open(...)

julia> redirect_stdio(f, stdout=io, stdin=io) # not supported

Julia 1.7  
redirect_stdiorequires Julia 1.7 or later.

source

```
Base.redirect_stdout– Function.

```

redirect_stdout([stream])-> stream

Create a pipe to which all C and Julia levelstdoutoutput will be redirected. Return a stream representing  
the pipe ends. Data written tostdoutmay now be read from therdend of the pipe.

Note  
streammust be a compatible objects, such as anIOStream,TTY,Pipe, socket, ordevnull.

See alsoredirect_stdio.  
source

```
Base.redirect_stdout– Method.

```

redirect_stdout(f:: Function , stream)

Run the functionfwhile redirectingstdouttostream. Upon completion,stdoutis restored to its prior  
setting.  
source

```
Base.redirect_stderr– Function.

```

redirect_stderr([stream])-> stream

Likeredirect_stdout, but forstderr.

Note  
streammust be a compatible objects, such as anIOStream,TTY,Pipe, socket, ordevnull.

See alsoredirect_stdio.  
source

```
Base.redirect_stderr– Method.

```

redirect_stderr(f:: Function , stream)

```

#### CHAPTER 52. I/O AND NETWORK 852

```

Run the functionfwhile redirectingstderrtostream. Upon completion,stderris restored to its prior  
setting.  
source

```
Base.redirect_stdin– Function.

```

redirect_stdin([stream])-> stream

Likeredirect_stdout, but forstdin. Note that the direction of the stream is reversed.

Note  
streammust be a compatible objects, such as anIOStream,TTY,Pipe, socket, ordevnull.

See alsoredirect_stdio.  
source

```
Base.redirect_stdin– Method.

```

redirect_stdin(f:: Function , stream)

Run the functionfwhile redirectingstdintostream. Upon completion,stdinis restored to its prior  
setting.  
source

```
Base.readchomp– Function.

```

readchomp(x)

Read the entirety ofxas a string and remove a single trailing newline if there is one. Equivalent to  
chomp(read(x, String)).  
Examples

julia> open("my_file.txt", "w") do io  
write(io,"JuliaLang is a GitHub organization. \n It has many members. \n ");  
end ;

julia> readchomp("my_file.txt")  
"JuliaLang is a GitHub organization.\nIt has many members."

julia> rm("my_file.txt");

source

```
Base.truncate– Function.

```

truncate(file, n)

Resize the file or buffer given by the first argument to exactlynbytes, filling previously unallocated space  
with '\0' if the file or buffer is grown.  
Examples

```

#### CHAPTER 52. I/O AND NETWORK 853

```

julia> io = IOBuffer ();

julia> write(io,"JuliaLang is a GitHub organization.")  
35

julia> truncate(io,15)  
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15,  
↪→ maxsize=Inf, ptr=16, mark=-1)

julia> String(take!(io))  
"JuliaLang is a "

julia> io = IOBuffer ();

julia> write(io,"JuliaLang is a GitHub organization.");

julia> truncate(io,40);

julia> String(take!(io))  
"JuliaLang is a GitHub organization.\0\0\0\0\0"

source

```
Base.skipchars– Function.

```

skipchars(predicate, io:: IO ; linecomment=nothing)

Advance the streamiosuch that the next-read character will be the first remaining for whichpredicate  
returnsfalse. If the keyword argumentlinecommentis specified, all characters from that character until  
the start of the next line are ignored.  
Examples

julia> buf = IOBuffer (" text")  
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8,  
↪→ maxsize=Inf, ptr=1, mark=-1)

julia> skipchars(isspace, buf)  
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8,  
↪→ maxsize=Inf, ptr=5, mark=-1)

julia> String(readavailable(buf))  
"text"

source

```
Base.countlines– Function.

```

countlines(io:: IO ; eol::AbstractChar= '\n')

Readiountil the end of the stream/file and count the number of lines. To specify a file pass the filename as  
the first argument. EOL markers other than'\n'are supported by passing them as the second argument.  
The last non-empty line ofiois counted even if it does not end with the EOL, matching the length returned  
byeachlineandreadlines.  
To count lines of aString,countlines(IOBuffer(str))can be used.  
Examples

```

#### CHAPTER 52. I/O AND NETWORK 854

```

julia> io = IOBuffer ("JuliaLang is a GitHub organization. \n ");

julia> countlines(io)  
1

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> countlines(io)  
1

julia> eof(io)# counting lines moves the file pointer  
true

julia> io = IOBuffer ("JuliaLang is a GitHub organization.");

julia> countlines(io, eol= '.')  
1

source

```
Base.PipeBuffer– Function.

```

PipeBuffer(data:: Vector { UInt8 }= UInt8 []; maxsize:: Integer = typemax( Int ))

AnIOBufferthat allows reading and performs writes by appending. Seeking and truncating are not sup-  
ported. SeeIOBufferfor the available constructors. Ifdatais given, creates aPipeBufferto operate on  
a data vector, optionally specifying a size beyond which the underlyingArraymay not be grown.  
source

```
Base.readavailable– Function.

```

readavailable(stream)

Read available buffered data from a stream. Actual I/O is performed only if no data has already been  
buffered. The result is aVector{UInt8}.

Warning  
The amount of data returned is implementation-dependent; for example it can depend on the  
internal choice of buffer size. Other functions such asreadshould generally be used instead.

source

```
Base.IOContext– Type.

```

IOContext

IOContextprovides a mechanism for passing output configuration settings amongshowmethods.  
In short, it is an immutable dictionary that is a subclass ofIO. It supports standard dictionary operations  
such asgetindex, and can also be used as an I/O stream.  
source

```
Base.IOContext– Method.

```

IOContext(io:: IO , KV :: Pair ...)

```

#### CHAPTER 52. I/O AND NETWORK 855

```

Create anIOContextthat wraps a given stream, adding the specifiedkey=>valuepairs to the properties  
of that stream (note thatiocan itself be anIOContext).

```
- use(key => value) in ioto see if this particular combination is in the properties set
- useget(io, key, default)to retrieve the most recent value for a particular key

```

The following properties are in common use:

```
- :compact: Boolean specifying that values should be printed more compactly, e.g. that numbers
    should be printed with fewer digits. This is set when printing array elements. :compactoutput
    should not contain line breaks.
- :limit: Boolean specifying that containers should be truncated, e.g. showing...in place of most
    elements.
- :displaysize: ATuple{Int,Int}giving the size in rows and columns to use for text output. This
    can be used to override the display size for called functions, but to get the size of the screen use the
    displaysizefunction.
- :typeinfo: aTypecharacterizing the information already printed concerning the type of the object
    about to be displayed. This is mainly useful when displaying a collection of objects of the same
    type, so that redundant type information can be avoided (e.g. [Float16(0)]can be shown as
    "Float16[0.0]" instead of"Float16[Float16(0.0)]" : while displaying the elements of the array, the
    :typeinfoproperty will be set toFloat16).
- :color: Boolean specifying whether ANSI color/escape codes are supported/expected. By default,
    this is determined by whetheriois a compatible terminal and by any--colorcommand-line flag
    whenjuliawas launched.

```

Examples

julia> io = IOBuffer ();

julia> printstyled(IOContext(io,:color=> true ), "string", color=:red)

julia> String(take!(io))  
"\e[31mstring\e[39m"

julia> printstyled(io,"string", color=:red)

julia> String(take!(io))  
"string"

julia> print(IOContext(stdout,:compact=> false ), 1.12341234)  
1.12341234  
julia> print(IOContext(stdout,:compact=> true ), 1.12341234)  
1.12341

julia>function f(io:: IO )  
if get(io,:short, false )  
print(io,"short")  
else  
print(io,"loooooong")  
end  
end  
f (generic function with 1 method)

```

#### CHAPTER 52. I/O AND NETWORK 856

```

julia> f(stdout)  
loooooong  
julia> f(IOContext(stdout,:short=> true ))  
short

source

```
Base.IOContext– Method.

```

IOContext(io:: IO , context::IOContext)

Create anIOContextthat wraps an alternateIObut inherits the properties ofcontext.  
source

```
### 52.2 Text I/O

Base.show– Method.

```

show([io:: IO = stdout], x)

Writeatextrepresentationofavaluextotheoutputstreamio. NewtypesTshouldoverloadshow(io::IO,  
x::T). The representation used byshowgenerally includes Julia-specific formatting and type information,  
and should be parseable Julia code when possible.  
reprreturns the output ofshowas a string.  
Tocustomizehuman-readabletextoutputforobjectsoftypeT,defineshow(io::IO, ::MIME"text/plain",  
::T)instead. Checking the:compactIOContextproperty ofioin such methods is recommended, since  
some containers show their elements by calling this method with:compact => true.  
See alsoprint, which writes un-decorated representations.  
Examples

julia> show("Hello World!")  
"Hello World!"  
julia> print("Hello World!")  
Hello World!

source

```
Base.summary– Function.

```

summary(io:: IO , x)  
str = summary(x)

Print to a streamio, or return a stringstr, giving a brief description of a value. By default returns  
string(typeof(x)), e.g.Int64.  
For arrays, returns a string of size and type info, e.g.10-element Array{Int64,1}.  
Examples

julia> summary(1)  
"Int64"

julia> summary(zeros(2))  
"2-element Vector{Float64}"

```

#### CHAPTER 52. I/O AND NETWORK 857

```

source

```
Base.print– Function.

```

print([io:: IO ], xs...)

Write toio(or to the default output streamstdoutifiois not given) a canonical (un-decorated) text  
representation. The representation used byprintincludes minimal formatting and tries to avoid Julia-  
specific details.  
printfalls back to callingshow, so most types should just defineshow. Defineprintif your type has a  
separate"plain"representation. Forexample,showdisplaysstringswithquotes, andprintdisplaysstrings  
without quotes.  
See alsoprintln,string,printstyled.  
Examples

julia> print("Hello World!")  
Hello World!  
julia> io = IOBuffer ();

julia> print(io,"Hello", ' ' , :World!)

julia> String(take!(io))  
"Hello World!"

source

```
Base.println– Function.

```

println([io:: IO ], xs...)

Print (usingprint)xsfollowed by a newline. Ifiois not supplied, prints tostdout.  
See alsoprintstyledto add colors etc.  
Examples

julia> println("Hello, world")  
Hello, world

julia> io = IOBuffer ();

julia> println(io,"Hello", ',', " world.")

julia> String(take!(io))  
"Hello, world.\n"

source

```
Base.printstyled– Function.

```

printstyled([io], xs...; bold:: Bool = false , underline:: Bool = false , blink:: Bool = false ,  
↪→ reverse:: Bool = false , hidden:: Bool = false , color:: Union { Symbol , Int }=:normal)

```

#### CHAPTER 52. I/O AND NETWORK 858

```

Printxsin a color specified as a symbol or integer, optionally in bold.  
Keywordcolormay take any of the values:normal,:default,:bold,:black,:blink,:blue,:cyan,  
:green,:hidden,:light_black,:light_blue,:light_cyan,:light_green,:light_magenta,:light_red,  
:light_yellow,:magenta,:nothing,:red,:reverse,:underline,:white, or:yellowor an integer be-  
tween 0 and 255 inclusive. Note that not all terminals support 256 colors.  
Keywordsbold=true,underline=true,blink=trueare self-explanatory. Keywordreverse=trueprints  
with foreground and background colors exchanged, andhidden=trueshould be invisibe in the terminal  
but can still be copied. These properties can be used in any combination.  
See alsoprint,println,show.

Julia 1.7  
Keywords exceptcolorandboldwere added in Julia 1.7.

source

```
Base.sprint– Function.

```

sprint(f:: Function , args...; context=nothing, sizehint=0)

Call the given function with an I/O stream and the supplied extra arguments. Everything written to this  
I/O stream is returned as a string.contextcan be anIOContextwhose properties will be used, aPair  
specifying a property and its value, or a tuple ofPairspecifying multiple properties and their values.  
sizehintsuggests the capacity of the buffer (in bytes).  
Theoptionalkeywordargumentcontextcanbesettoa:key=>valuepair, atupleof:key=>valuepairs, or  
anIOorIOContextobject whose attributes are used for the I/O stream passed tof. The optionalsizehint  
is a suggested size (in bytes) to allocate for the buffer used to write the string.

Julia 1.7  
Passing a tuple to keywordcontextrequires Julia 1.7 or later.

Examples

julia> sprint(show,66.66666; context=:compact=> true )  
"66.6667"

julia> sprint(showerror, BoundsError ([1], 100))  
"BoundsError: attempt to access 1-element Vector{Int64} at index [100]"

source

```
Base.showerror– Function.

```

showerror(io,e)

Show a descriptive representation of an exception objecte. This method is used to display the exception  
after a call tothrow.  
Examples

julia> struct MyException<: Exception  
msg::String  
end

```

#### CHAPTER 52. I/O AND NETWORK 859

```

julia>function Base.showerror(io:: IO , err::MyException)  
print(io,"MyException: ")  
print(io, err.msg)  
end

julia> err = MyException("test exception")  
MyException("test exception")

julia> sprint(showerror, err)  
"MyException: test exception"

julia> throw(MyException("test exception"))  
ERROR: MyException: test exception

source

```
Base.dump– Function.

```

dump(x; maxdepth=8)

Show every part of the representation of a value. The depth of the output is truncated atmaxdepth.  
Examples

julia> struct MyStruct  
x  
y  
end

julia> x = MyStruct(1, ( 2,3));

julia> dump(x)  
MyStruct  
x: Int64 1  
y: Tuple{Int64, Int64}  
1: Int64 2  
2: Int64 3

julia> dump(x; maxdepth= 1)  
MyStruct  
x: Int64 1  
y: Tuple{Int64, Int64}

source

```
Base.Meta.@dump– Macro.

```

@dumpexpr

Show every part of the representation of the given expression. Equivalent todump(:(expr)).  
source

```
Base.readline– Function.

```

readline(io:: IO =stdin; keep:: Bool = false )  
readline(filename:: AbstractString ; keep:: Bool = false )

```

#### CHAPTER 52. I/O AND NETWORK 860

```

Read a single line of text from the given I/O stream or file (defaults tostdin). When reading from a file,  
the text is assumed to be encoded in UTF-8. Lines in the input end with'\n'or"\r\n"or the end of an  
input stream. Whenkeepis false (as it is by default), these trailing newline characters are removed from  
the line before it is returned. Whenkeepis true, they are returned as part of the line.  
Examples

julia> open("my_file.txt", "w") do io  
write(io,"JuliaLang is a GitHub organization. \n It has many members. \n ");  
end  
57

julia> readline("my_file.txt")  
"JuliaLang is a GitHub organization."

julia> readline("my_file.txt", keep= true )  
"JuliaLang is a GitHub organization.\n"

julia> rm("my_file.txt")

source

```
Base.readuntil– Function.

```

readuntil(stream:: IO , delim; keep:: Bool = false )  
readuntil(filename:: AbstractString , delim; keep:: Bool = false )

Read a string from an I/O stream or a file, up to the given delimiter. The delimiter can be aUInt8,  
AbstractChar, string, or vector. Keyword argumentkeepcontrols whether the delimiter is included in  
the result. The text is assumed to be encoded in UTF-8.  
Examples

julia> open("my_file.txt", "w") do io  
write(io,"JuliaLang is a GitHub organization. \n It has many members. \n ");  
end  
57

julia> readuntil("my_file.txt", 'L')  
"Julia"

julia> readuntil("my_file.txt", '.', keep= true )  
"JuliaLang is a GitHub organization."

julia> rm("my_file.txt")

source

```
Base.readlines– Function.

```

readlines(io:: IO =stdin; keep:: Bool = false )  
readlines(filename:: AbstractString ; keep:: Bool = false )

Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result  
of readingreadlinerepeatedly with the same arguments and saving the resulting lines as a vector of  
strings.  
Examples

```

#### CHAPTER 52. I/O AND NETWORK 861

```

julia> open("my_file.txt", "w") do io  
write(io,"JuliaLang is a GitHub organization. \n It has many members. \n ");  
end  
57

julia> readlines("my_file.txt")  
2-element Vector{String}:  
"JuliaLang is a GitHub organization."  
"It has many members."

julia> readlines("my_file.txt", keep= true )  
2-element Vector{String}:  
"JuliaLang is a GitHub organization.\n"  
"It has many members.\n"

julia> rm("my_file.txt")

source

```
Base.eachline– Function.

```

eachline(io:: IO =stdin; keep:: Bool = false )  
eachline(filename:: AbstractString ; keep:: Bool = false )

Create an iterableEachLineobject that will yield each line from an I/O stream or a file. Iteration calls  
readlineon the stream argument repeatedly withkeeppassed through, determining whether trailing  
end-of-line characters are retained. When called with a file name, the file is opened once at the beginning  
of iteration and closed at the end. If iteration is interrupted, the file will be closed when theEachLine  
object is garbage collected.  
To iterate over each line of aString,eachline(IOBuffer(str))can be used.  
Examples

julia> open("my_file.txt", "w") do io  
write(io,"JuliaLang is a GitHub organization. \n It has many members. \n ");  
end ;

julia>for line in eachline("my_file.txt")  
print(line)  
end  
JuliaLang is a GitHub organization. It has many members.

julia> rm("my_file.txt");

source

```
Base.displaysize– Function.

```

displaysize([io:: IO ]) -> (lines, columns)

Return the nominal size of the screen that may be used for rendering output to thisIOobject. If no input  
is provided, the environment variablesLINESandCOLUMNSare read. If those are not set, a default size of  
(24, 80)is returned.  
Examples

```

#### CHAPTER 52. I/O AND NETWORK 862

```

julia> withenv("LINES"=> 30, "COLUMNS"=> 100) do  
displaysize()  
end  
(30, 100)

To get your TTY size,

julia> displaysize(stdout)  
(34, 147)

source

```
### 52.3 Multimedia I/O.

Just as text output is performed byprintand user-defined types can indicate their textual representation
by overloadingshow, Julia provides a standardized mechanism for rich multimedia output (such as images,
formatted text, or even audio and video), consisting of three parts:

- A functiondisplay(x)to request the richest available multimedia display of a Julia objectx(with a
    plain-text fallback).
- Overloadingshowallows one to indicate arbitrary multimedia representations (keyed by standard MIME
    types) of user-defined types.
- Multimedia-capabledisplaybackendsmayberegisteredbysubclassingagenericAbstractDisplaytype
    and pushing them onto a stack of display backends viapushdisplay.

The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external
modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).

Base.Multimedia.AbstractDisplay– Type.

```

AbstractDisplay

Abstract supertype for rich display output devices.TextDisplayis a subtype of this.  
source

```
Base.Multimedia.display– Function.

```

display(x)  
display(d::AbstractDisplay, x)  
display(mime, x)  
display(d::AbstractDisplay, mime, x)

AbstractDisplayxusing the topmost applicable display in the display stack, typically using the richest  
supportedmultimediaoutputforx, withplain-textstdoutoutputasafallback. Thedisplay(d, x)variant  
attempts to displayxon the given displaydonly, throwing aMethodErrorifdcannot display objects of  
this type.  
In general, you cannot assume thatdisplayoutput goes tostdout(unlikeprint(x)orshow(x)). For  
example,display(x)may open up a separate window with an image.display(x)means"showxin the  
best way you can for the current output device(s)." If you want REPL-like text output that is guaranteed to  
go tostdout, useshow(stdout, "text/plain", x)instead.

```

#### CHAPTER 52. I/O AND NETWORK 863

```

Therearealsotwovariantswithamimeargument(aMIMEtypestring,suchas"image/png"),whichattempt  
to displayxusing the requested MIME type only, throwing aMethodErrorif this type is not supported by  
either the display(s) or byx. With these variants, one can also supply the"raw" data in the requested  
MIME type by passingx::AbstractString(for MIME types with text-based storage, such as text/html or  
application/postscript) orx::Vector{UInt8}(for binary MIME types).  
To customize how instances of a type are displayed, overloadshowrather thandisplay, as explained in  
the manual section oncustom pretty-printing.  
source

```
Base.Multimedia.redisplay– Function.

```

redisplay(x)  
redisplay(d::AbstractDisplay, x)  
redisplay(mime, x)  
redisplay(d::AbstractDisplay, mime, x)

By default, theredisplayfunctions simply calldisplay. However, some display backends may override  
redisplayto modify an existing display ofx(if any). Usingredisplayis also a hint to the backend that  
xmay be redisplayed several times, and the backend may choose to defer the display until (for example)  
the next interactive prompt.  
source

```
Base.Multimedia.displayable– Function.

```

displayable(mime)-> Bool  
displayable(d::AbstractDisplay, mime)-> Bool

Returnsabooleanvalueindicatingwhetherthegivenmimetype(string)isdisplayablebyanyofthedisplays  
in the current display stack, or specifically by the displaydin the second variant.  
source

```
Base.show– Method.

```

show(io:: IO , mime, x)

Thedisplayfunctions ultimately callshowin order to write an objectxas a givenmimetype to a given I/O  
streamio(usually a memory buffer), if possible. In order to provide a rich multimedia representation of a  
user-defined typeT, it is only necessary to define a newshowmethod forT, via:show(io, ::MIME"mime",  
x::T) = ..., wheremimeis a MIME-type string and the function body callswrite(or similar) to write that  
representation ofxtoio. (Note that theMIME""notation only supports literal strings; to constructMIME  
types in a more flexible manner useMIME{Symbol("")}.)  
Forexample, ifyoudefineaMyImagetypeandknowhowtowriteittoaPNGfile, youcoulddefineafunction  
show(io, ::MIME"image/png", x::MyImage) = ...to allow your images to be displayed on any PNG-  
capableAbstractDisplay(such as IJulia). As usual, be sure toimport Base.showin order to add new  
methods to the built-in Julia functionshow.  
Technically, theMIME"mime"macro defines a singleton type for the givenmimestring, which allows us to  
exploit Julia's dispatch mechanisms in determining how to display objects of any given type.  
The default MIME type isMIME"text/plain". There is a fallback definition fortext/plainoutput that calls  
showwith 2 arguments, so it is not always necessary to add a method for that case. If a type benefits from  
custom human-readable output though,show(::IO, ::MIME"text/plain", ::T)should be defined. For

```

#### CHAPTER 52. I/O AND NETWORK 864

```

example, theDaytype uses1 dayas the output for thetext/plainMIME type, andDay(1)as the output  
of 2-argumentshow.  
Container types generally implement 3-argumentshowby callingshow(io, MIME"text/plain"(), x)for  
elementsx, with:compact => trueset in anIOContextpassed as the first argument.  
source

```
Base.Multimedia.showable– Function.

```

showable(mime, x)

Returns a boolean value indicating whether or not the objectxcan be written as the givenmimetype.  
(By default, this is determined automatically by the existence of the correspondingshowmethod for  
typeof(x). Some types provide customshowablemethods; for example, if the available MIME formats  
depend on the value ofx.)  
Examples

julia> showable( MIME ("text/plain"), rand(5))  
true

julia> showable("image/png", rand(5))  
false

source

```
Base.repr– Method.

```

repr(mime, x; context=nothing)

Returns anAbstractStringorVector{UInt8}containing the representation ofxin the requestedmime  
type, as written byshow(io, mime, x)(throwing aMethodErrorif no appropriateshowis available).  
AnAbstractStringis returned for MIME types with textual representations (such as"text/html"or  
"application/postscript"),whereasbinarydataisreturnedasVector{UInt8}. (Thefunctionistextmime(mime)  
returns whether or not Julia treats a givenmimetype as text.)  
The optional keyword argumentcontextcan be set to:key=>valuepair or anIOorIOContextobject  
whose attributes are used for the I/O stream passed toshow.  
As a special case, ifxis anAbstractString(for textual MIME types) or aVector{UInt8}(for binary MIME  
types), thereprfunction assumes thatxis already in the requestedmimeformat and simply returnsx.  
This special case does not apply to the"text/plain"MIME type. This is useful so that raw data can be  
passed todisplay(m::MIME, x).  
In particular,repr("text/plain", x)is typically a"pretty-printed" version ofxdesigned for human con-  
sumption. See alsorepr(x)to instead return a string corresponding toshow(x)that may be closer to how  
the value ofxwould be entered in Julia.  
Examples

julia> A = [1 2; 3 4];

julia> repr("text/plain", A)  
"2×2 Matrix{Int64}:\n 1 2\n 3 4"

source

```

#### CHAPTER 52. I/O AND NETWORK 865

Base.Multimedia.MIME– Type.

```

MIME

A type representing a standard internet data format."MIME" stands for"Multipurpose Internet Mail Exten-  
sions", since the standard was originally used to describe multimedia attachments to email messages.  
AMIMEobject can be passed as the second argument toshowto request output in that format.  
Examples

julia> show(stdout, MIME ("text/plain"), "hi")  
"hi"

source

```
Base.Multimedia.@MIME_str– Macro.

```

@MIME_str

A convenience macro for writingMIMEtypes, typically used when adding methods toshow. For example  
the syntaxshow(io::IO, ::MIME"text/html", x::MyType) = ...could be used to define how to write  
an HTML representation ofMyType.  
source

```
As mentioned above, one can also define new display backends. For example, a module that can display
PNG images in a window can register this capability with Julia, so that callingdisplay(x)on types with PNG
representations will automatically display the image using the module's window.

Inordertodefineanewdisplaybackend,oneshouldfirstcreateasubtypeDoftheabstractclassAbstractDisplay.
Then, foreachMIMEtype(mimestring)thatcanbedisplayedonD,oneshoulddefineafunctiondisplay(d::D,
::MIME"mime", x) = ...thatdisplaysxasthatMIMEtype,usuallybycallingshow(io, mime, x)orrepr(io,
mime, x). AMethodErrorshould be thrown ifxcannot be displayed as that MIME type; this is automatic if one
callsshoworrepr. Finally, one should define a functiondisplay(d::D, x)that queriesshowable(mime, x)
forthemimetypessupportedbyDanddisplaysthe"best"one; aMethodErrorshouldbethrownifnosupported
MIME types are found forx. Similarly, some subtypes may wish to overrideredisplay(d::D, ...). (Again,
one shouldimport Base.displayto add new methods todisplay.) The return values of these functions are
up to the implementation (since in some cases it may be useful to return a display"handle" of some type). The
display functions forDcan then be called directly, but they can also be invoked automatically fromdisplay(x)
simply by pushing a new display onto the display-backend stack with:

Base.Multimedia.pushdisplay– Function.

```

pushdisplay(d::AbstractDisplay)

Pushes a new displaydon top of the global display-backend stack. Callingdisplay(x)ordisplay(mime,  
x)will displayxon the topmost compatible backend in the stack (i.e., the topmost backend that does not  
throw aMethodError).  
source

```
Base.Multimedia.popdisplay– Function.

```

popdisplay()  
popdisplay(d::AbstractDisplay)

```

#### CHAPTER 52. I/O AND NETWORK 866

```

Pop the topmost backend off of the display-backend stack, or the topmost copy ofdin the second variant.  
source

```
Base.Multimedia.TextDisplay– Type.

```

TextDisplay (io:: IO )

Returns aTextDisplay <: AbstractDisplay, which displays any object as the text/plain MIME type (by  
default), writing the text representation to the given I/O stream. (This is how objects are printed in the  
Julia REPL.)  
source

```
Base.Multimedia.istextmime– Function.

```

istextmime(m:: MIME )

Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set  
of types known to be text data (possibly Unicode).  
Examples

julia> istextmime( MIME ("text/plain"))  
true

julia> istextmime( MIME ("image/png"))  
false

source

```
### 52.4 Network I/O

Base.bytesavailable– Function.

```

bytesavailable(io)

Return the number of bytes available for reading before a read from this stream or buffer will block.  
Examples

julia> io = IOBuffer ("JuliaLang is a GitHub organization");

julia> bytesavailable(io)  
34

source

```
Base.ntoh– Function.

```

ntoh(x)

Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.  
source

```
Base.hton– Function.


#### CHAPTER 52. I/O AND NETWORK 867

```

hton(x)

Convert the endianness of a value from that used by the Host to Network byte order (big-endian).  
source

```
Base.ltoh– Function.

```

ltoh(x)

Convert the endianness of a value from Little-endian to that used by the Host.  
source

```
Base.htol– Function.

```

htol(x)

Convert the endianness of a value from that used by the Host to Little-endian.  
source

```
Base.ENDIAN_BOM– Constant.

```

ENDIAN_BOM

The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines  
will contain the value0x04030201. Big-endian machines will contain the value0x01020304.  
source

```

**Chapter 53**

**Punctuation**

Extended documentation for mathematical symbols & functions ishere.

#### 868


#### CHAPTER 53. PUNCTUATION 869

```

sym-  
bol

meaning

@ the at-sign marks amacroinvocation; optionally followed by an argument list  
! an exclamation mark is a prefix operator for logical negation ("not")  
a! function names that end with an exclamation mark modify one or more of their arguments by  
convention

# the number sign (or hash or pound) character begins single line comments

#= when followed by an equals sign, it begins a multi-line comment (these are nestable)  
=# end a multi-line comment by immediately preceding the number sign with an equals sign  
$ the dollar sign is used forstring and expressioninterpolation  
% the percent symbol is the remainder operator  
^ the caret is the exponentiation operator  
& single ampersand is bitwise and  
&& double ampersands is short-circuiting boolean and  
| single pipe character is bitwise or  
|| double pipe characters is short-circuiting boolean or  
⊻ the unicode xor character is bitwise exclusive or  
~ the tilde is an operator for bitwise not  
' a trailing apostrophe is theadjoint(that is, the complex transpose) operator Aᴴ

-   the asterisk is used for multiplication, including matrix multiplication andstring concatenation  
    / forward slash divides the argument on its left by the one on its right  
    \ backslash operator divides the argument on its right by the one on its left, commonly used to  
    solve matrix equations  
    () parentheses with no arguments constructs an emptyTuple  
    (a,...)parentheses with comma-separated arguments constructs a tuple containing its arguments  
    (a=1,...)parentheses with comma-separated assignments constructs aNamedTuple  
    (x;y) parentheses can also be used to group one or more semicolon separated expressions  
    a[] array indexing(callinggetindexorsetindex!)  
    [,] vector literal constructor(callingvect)  
    [;] vertical concatenation(callingvcatorhvcat)  
    [ ] with space-separated expressions,horizontal concatenation(callinghcatorhvcat)  
    T{ } curly braces following a type list that type's parameters  
    {} curly braces can also be used to group multiplewhereexpressions in function declarations  
    ; semicolons separate statements, begin a list of keyword arguments in function declarations or  
    calls, or are used to separate array literals for vertical concatenation  
    , commas separate function arguments or tuple or array components  
    ? the question mark delimits the ternary conditional operator (used like:conditional? if_true  
    : if_false)  
    " " the single double-quote character delimitsStringliterals  
    """  
    """

three double-quote characters delimits string literals that may contain"and ignore leading  
indentation  
' ' the single-quote character delimitsChar(that is, character) literals  
the backtick character delimitsexternal process(Cmd) literals  
A... triple periods are a postfix operator that"splat" their arguments' contents into many arguments  
of a function call or declare a varargs function that"slurps" up many arguments into a single  
tuple  
a.b single periods access named fields in objects/modules (callinggetpropertyorsetproperty!)  
f.() periods may also prefix parentheses (likef.(...)) or infix operators (like.+) to perform the  
function element-wise (callingbroadcast)  
a:b colons (:) used as a binary infix operator construct a range fromatob(inclusive) with fixed step  
size 1  
a:s:b colons (:) used as a ternary infix operator construct a range fromatob(inclusive) with step size  
s  
: when used by themselves,Colons represent all indices within a dimension, frequently combined  
with indexing  
:: double-colons represent a type annotation ortypeassert, depending on context, frequently  
used when declaring function arguments  
:( ) quoted expression  
:a Symbola  
<: subtype operator

> : supertype operator (reverse of subtype operator)  
> = single equals sign isassignment  
> == double equals sign is value equality comparison  
> === triple equals sign is programmatically identical equality comparison  
> => right arrow using an equals sign defines aPairtypically used to populatedictionaries  
> -> right arrow using a hyphen defines ananonymous functionon a single line  
> ‘ >‘  
> ∘ function composition operator (typed with \circ{tab}) combines two functions as though they  
> are a single largerfunction

```

**Chapter 54**

**Sorting and Related Functions**

Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default,
Julia picks reasonable algorithms and sorts in standard ascending order:

```

julia> sort([2,3,1])  
3-element Vector{Int64}:  
1  
2  
3

```
You can easily sort in reverse order as well:

```

julia> sort([2,3,1], rev= true )  
3-element Vector{Int64}:  
3  
2  
1

```
To sort an array in-place, use the"bang" version of the sort function:

```

julia> a = [2,3,1];

julia> sort!(a);

julia> a  
3-element Vector{Int64}:  
1  
2  
3

```
Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array
into sorted order:

```

julia> v = randn(5)  
5-element Array{Float64,1}:  
0.297288  
0.382396  
-0.597634

```
#### 870


#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 871

```

-0.0104452  
-0.839027

julia> p = sortperm(v)  
5-element Array{Int64,1}:  
5  
3  
4  
1  
2

julia> v[p]  
5-element Array{Float64,1}:  
-0.839027  
-0.597634  
-0.0104452  
0.297288  
0.382396

```
Arrays can easily be sorted according to an arbitrary transformation of their values:

```

julia> sort(v, by=abs)  
5-element Array{Float64,1}:  
-0.0104452  
0.297288  
0.382396  
-0.597634  
-0.839027

```
Or in reverse order by a transformation:

```

julia> sort(v, by=abs, rev= true )  
5-element Array{Float64,1}:  
-0.839027  
-0.597634  
0.382396  
0.297288  
-0.0104452

```
If needed, the sorting algorithm can be chosen:

```

julia> sort(v, alg=InsertionSort)  
5-element Array{Float64,1}:  
-0.839027  
-0.597634  
-0.0104452  
0.297288  
0.382396

```
All the sorting and order related functions rely on a"less than" relation defining a total order on the values
to be manipulated. Theislessfunction is invoked by default, but the relation can be specified via thelt
keyword.


#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 872

### 54.1 Sorting Functions

Base.sort!– Function.

```

sort!(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev:: Bool = false ,  
↪→ order::Ordering=Forward)

Sort the vectorvin place. QuickSortis used by default for numeric arrays whileMergeSortis used  
for other arrays. You can specify an algorithm to use via thealgkeyword (seeSorting Algorithmsfor  
available algorithms). Thebykeyword lets you provide a function that will be applied to each element  
before comparison; theltkeyword allows providing a custom"less than" function (note that for every  
xandy, only one oflt(x,y)andlt(y,x)can returntrue); userev=trueto reverse the sorting order.  
Theseoptionsareindependentandcanbeusedtogetherinallpossiblecombinations: ifbothbyandltare  
specified, theltfunction is applied to the result of thebyfunction;rev=truereverses whatever ordering  
specified via thebyandltkeywords.  
Examples

julia> v = [3, 1, 2]; sort!(v); v  
3-element Vector{Int64}:  
1  
2  
3

julia> v = [3, 1, 2]; sort!(v, rev= true ); v  
3-element Vector{Int64}:  
3  
2  
1

julia> v = [(1, "c"), ( 3, "a"), ( 2, "b")]; sort!(v, by= x -> x[1]); v  
3-element Vector{Tuple{Int64, String}}:  
(1, "c")  
(2, "b")  
(3, "a")

julia> v = [(1, "c"), ( 3, "a"), ( 2, "b")]; sort!(v, by= x -> x[2]); v  
3-element Vector{Tuple{Int64, String}}:  
(3, "a")  
(2, "b")  
(1, "c")

source  
sort!(A; dims::Integer, alg::Algorithm=defalg(A), lt=isless, by=identity, rev::Bool=false, order  
::Ordering=Forward)

Sort the multidimensional arrayAalong dimensiondims. Seesort!for a description of possible keyword  
arguments.  
To sort slices of an array, refer tosortslices.

Julia 1.1  
This function requires at least Julia 1.1.

Examples

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 873

```

julia> A = [4 3; 1 2]  
2×2 Matrix{Int64}:  
4 3  
1 2

julia> sort!(A, dims= 1); A  
2×2 Matrix{Int64}:  
1 2  
4 3

julia> sort!(A, dims= 2); A  
2×2 Matrix{Int64}:  
1 2  
3 4

source

```
Base.sort– Function.

```

sort(v; alg::Algorithm=defalg(v), lt=isless, by=identity, rev:: Bool = false ,  
↪→ order::Ordering=Forward)

Variant ofsort!that returns a sorted copy ofvleavingvitself unmodified.  
Examples

julia> v = [3, 1, 2];

julia> sort(v)  
3-element Vector{Int64}:  
1  
2  
3

julia> v  
3-element Vector{Int64}:  
3  
1  
2

source  
sort(A; dims::Integer, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false,  
order::Ordering=Forward)

SortamultidimensionalarrayAalongthegivendimension. Seesort!foradescriptionofpossiblekeyword  
arguments.  
To sort slices of an array, refer tosortslices.  
Examples

julia> A = [4 3; 1 2]  
2×2 Matrix{Int64}:  
4 3  
1 2

julia> sort(A, dims= 1)

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 874

```

2×2 Matrix{Int64}:  
1 2  
4 3

julia> sort(A, dims= 2)  
2×2 Matrix{Int64}:  
3 4  
1 2

source

```
Base.sortperm– Function.

```

sortperm(v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev:: Bool = false ,  
↪→ order::Ordering=Forward)

Return a permutation vectorIthat putsv[I]in sorted order. The order is specified using the same key-  
words assort!. The permutation is guaranteed to be stable even if the sorting algorithm is unstable,  
meaning that indices of equal elements appear in ascending order.  
See alsosortperm!,partialsortperm,invperm,indexin.  
Examples

julia> v = [3, 1, 2];

julia> p = sortperm(v)  
3-element Vector{Int64}:  
2  
3  
1

julia> v[p]  
3-element Vector{Int64}:  
1  
2  
3

source

```
Base.Sort.InsertionSort– Constant.

```

InsertionSort

Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collec-  
tion one element at a time, inserting each element into its correct, sorted position in the output list.  
Characteristics:

```
- stable: preserves the ordering of elements which compare equal (e.g."a" and "A" in a sort of letters
    which ignores case).
- in-place in memory.
- quadratic performance in the number of elements to be sorted: it is well-suited to small collections
    but should not be used for large ones.

```

source

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 875

Base.Sort.MergeSort– Constant.

```

MergeSort

Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection  
into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire  
collection has been recombined in sorted form.  
Characteristics:

```
- stable: preserves the ordering of elements which compare equal (e.g."a" and "A" in a sort of letters
    which ignores case).
- not in-place in memory.
- divide-and-conquer sort strategy.

```

source

```
Base.Sort.QuickSort– Constant.

```

QuickSort

Indicate that a sorting function should use the quick sort algorithm, which is not stable.  
Characteristics:

```
- not stable: does not preserve the ordering of elements which compare equal (e.g."a" and "A" in a
    sort of letters which ignores case).
- in-place in memory.
- divide-and-conquer: sort strategy similar toMergeSort.
- good performance for large collections.

```

source

```
Base.Sort.PartialQuickSort– Type.

```

PartialQuickSort {T <: Union { Integer , OrdinalRange }}

Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the  
smallestkelements sorted from smallest to largest, finding them and sorting them usingQuickSort.  
Characteristics:

```
- not stable: does not preserve the ordering of elements which compare equal (e.g."a" and "A" in a
    sort of letters which ignores case).
- in-place in memory.
- divide-and-conquer: sort strategy similar toMergeSort.

```

source

```
Base.Sort.sortperm!– Function.

```

sortperm!(ix, v; alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev:: Bool = false ,  
↪→ order::Ordering=Forward, initialized:: Bool = false )

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 876

```

Likesortperm, but accepts a preallocated index vectorix. Ifinitializedisfalse(the default),ixis  
initialized to contain the values1:length(v).  
Examples

julia> v = [3, 1, 2]; p= zeros( Int , 3);

julia> sortperm!(p, v); p  
3-element Vector{Int64}:  
2  
3  
1

julia> v[p]  
3-element Vector{Int64}:  
1  
2  
3

source

```
Base.sortslices– Function.

```

sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev:: Bool = false ,  
↪→ order::Ordering=Forward)

Sort slices of an arrayA. The required keyword argumentdimsmust be either an integer or a tuple of  
integers. It specifies the dimension(s) over which the slices are sorted.  
E.g., ifAis a matrix,dims=1will sort rows,dims=2will sort columns. Note that the default comparison  
function on one dimensional slices sorts lexicographically.  
For the remaining keyword arguments, see the documentation ofsort!.  
Examples

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows  
3×3 Matrix{Int64}:  
-1 6 4  
7 3 5  
9 -2 8

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt =(x,y)->isless(x[2],y[2]))  
3×3 Matrix{Int64}:  
9 -2 8  
7 3 5  
-1 6 4

julia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev= true )  
3×3 Matrix{Int64}:  
9 -2 8  
7 3 5  
-1 6 4

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns  
3×3 Matrix{Int64}:  
3 5 7  
-1 -4 6

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 877

```

-2 8 9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort,  
↪→ lt=(x,y)->isless(x[2],y[2]))  
3×3 Matrix{Int64}:  
5 3 7  
-4 -1 6  
8 -2 9

julia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev= true )  
3×3 Matrix{Int64}:  
7 5 3  
6 -4 -1  
9 8 -2

Higher dimensions  
sortslicesextends naturally to higher dimensions. E.g., ifAis a a 2x2x2 array,sortslices(A, dims=3)  
will sort slices within the 3rd dimension, passing the 2x2 slicesA[:, :, 1]andA[:, :, 2]to the com-  
parison function. Note that while there is no default order on higher-dimensional slices, you may use the  
byorltkeyword argument to specify such an order.  
Ifdimsis a tuple, the order of the dimensions indimsis relevant and specifies the linear order of the slices.  
E.g., ifAis three dimensional anddimsis(1, 2), the orderings of the first two dimensions are re-arranged  
such that the slices (of the remaining third dimension) are sorted. Ifdimsis(2, 1)instead, the same  
slices will be taken, but the result order will be row-major instead.  
Higher dimensional examples  
julia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))  
2×2×2 Array{Any, 3}:  
[:, :, 1] =  
4 3  
2 1

[:, :, 2] =  
'A' 'B'  
'C' 'D'

julia> sortslices(A, dims=(1,2))  
2×2×2 Array{Any, 3}:  
[:, :, 1] =  
1 3  
2 4

[:, :, 2] =  
'D' 'B'  
'C' 'A'

julia> sortslices(A, dims=(2,1))  
2×2×2 Array{Any, 3}:  
[:, :, 1] =  
1 2  
3 4

[:, :, 2] =  
'D' 'C'

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 878

```

'B' 'A'

julia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])  
1×1×5 Array{Int64, 3}:  
[:, :, 1] =  
1

[:, :, 2] =  
2

[:, :, 3] =  
3

[:, :, 4] =  
4

[:, :, 5] =  
5

source

```
### 54.2 Order-Related Functions.

Base.issorted– Function.

```

issorted(v, lt=isless, by=identity, rev:: Bool = false , order::Ordering=Forward)

Test whether a vector is in sorted order. Thelt,byandrevkeywords modify what order is considered to  
be sorted just as they do forsort.  
Examples

julia> issorted([1, 2, 3])  
true

julia> issorted([(1, "b"), ( 2, "a")], by= x -> x[1])  
true

julia> issorted([(1, "b"), ( 2, "a")], by= x -> x[2])  
false

julia> issorted([(1, "b"), ( 2, "a")], by= x -> x[2], rev= true )  
true

source

```
Base.Sort.searchsorted– Function.

```

searchsorted(a, x; by=, lt =, rev= false )

Return the range of indices ofawhich compare as equal tox(using binary search) according to the order  
specified by theby,ltandrevkeywords, assuming thatais already sorted in that order. Return an empty  
range located at the insertion point ifadoes not contain values equal tox.  
See also:insorted,searchsortedfirst,sort,findall.  
Examples

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 879

```

julia> searchsorted([1, 2, 4, 5, 5, 7], 4) # single match  
3:3

julia> searchsorted([1, 2, 4, 5, 5, 7], 5) # multiple matches  
4:5

julia> searchsorted([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle  
3:2

julia> searchsorted([1, 2, 4, 5, 5, 7], 9) # no match, insert at end  
7:6

julia> searchsorted([1, 2, 4, 5, 5, 7], 0) # no match, insert at start  
1:0

source

```
Base.Sort.searchsortedfirst– Function.

```

searchsortedfirst(a, x; by=, lt =, rev= false )

Return the index of the first value inagreater than or equal tox, according to the specified order. Return  
length(a) + 1ifxis greater than all values ina.ais assumed to be sorted.  
See also:searchsortedlast,searchsorted,findfirst.  
Examples

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 4) # single match  
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 5) # multiple matches  
4

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle  
3

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 9) # no match, insert at end  
7

julia> searchsortedfirst([1, 2, 4, 5, 5, 7], 0) # no match, insert at start  
1

source

```
Base.Sort.searchsortedlast– Function.

```

searchsortedlast(a, x; by=, lt =, rev= false )

Return the index of the last value inaless than or equal tox, according to the specified order. Return 0 if  
xis less than all values ina.ais assumed to be sorted.  
Examples

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 4) # single match  
3

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 880

```

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 5) # multiple matches  
5

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 3) # no match, insert in the middle  
2

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 9) # no match, insert at end  
6

julia> searchsortedlast([1, 2, 4, 5, 5, 7], 0) # no match, insert at start  
0

source

```
Base.Sort.insorted– Function.

```

insorted(a, x; by=, lt =, rev= false ) -> Bool

Determine whether an item is in the given sorted collection, in the sense that it is==to one of the values of  
the collection according to the order specified by theby,ltandrevkeywords, assuming thatais already  
sorted in that order, seesortfor the keywords.  
See alsoin.  
Examples

julia> insorted(4, [ 1, 2, 4, 5, 5, 7]) # single match  
true

julia> insorted(5, [ 1, 2, 4, 5, 5, 7]) # multiple matches  
true

julia> insorted(3, [ 1, 2, 4, 5, 5, 7]) # no match  
false

julia> insorted(9, [ 1, 2, 4, 5, 5, 7]) # no match  
false

julia> insorted(0, [ 1, 2, 4, 5, 5, 7]) # no match  
false

Julia 1.6  
insortedwas added in Julia 1.6.

source

```
Base.Sort.partialsort!– Function.

```

partialsort!(v, k; by=, lt =, rev= false )

Partially sort the vectorvin place, according to the order specified byby,ltandrevso that the value at  
indexk(or range of adjacent values ifkis a range) occurs at the position where it would appear if the array  
were fully sorted via a non-stable algorithm. Ifkis a single index, that value is returned; ifkis a range, an  
array of values at those indices is returned. Note thatpartialsort!does not fully sort the input array.  
Examples

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 881

```

julia> a = [1, 2, 4, 3, 4]  
5-element Vector{Int64}:  
1  
2  
4  
3  
4

julia> partialsort!(a,4)  
4

julia> a  
5-element Vector{Int64}:  
1  
2  
3  
4  
4

julia> a = [1, 2, 4, 3, 4]  
5-element Vector{Int64}:  
1  
2  
4  
3  
4

julia> partialsort!(a,4, rev= true )  
2

julia> a  
5-element Vector{Int64}:  
4  
4  
3  
2  
1

source

```
Base.Sort.partialsort– Function.

```

partialsort(v, k, by=, lt =, rev= false )

Variant ofpartialsort!which copiesvbefore partially sorting it, thereby returning the same thing as  
partialsort!but leavingvunmodified.  
source

```
Base.Sort.partialsortperm– Function.

```

partialsortperm(v, k; by=, lt =, rev= false )

Return a partial permutationIof the vectorv, so thatv[I]returns values of a fully sorted version ofvat  
indexk. Ifkis a range, a vector of indices is returned; ifkis an integer, a single index is returned. The  
order is specified using the same keywords assort!. The permutation is stable, meaning that indices of  
equal elements appear in ascending order.

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 882

```

Note that this function is equivalent to, but more efficient than, callingsortperm(...)[k].  
Examples

julia> v = [3, 1, 2, 1];

julia> v[partialsortperm(v,1)]  
1

julia> p = partialsortperm(v,1:3)  
3-element view(::Vector{Int64}, 1:3) with eltype Int64:  
2  
4  
3

julia> v[p]  
3-element Vector{Int64}:  
1  
1  
2

source

```
Base.Sort.partialsortperm!– Function.

```

partialsortperm!(ix, v, k; by=, lt =, rev= false , initialized= false )

Likepartialsortperm, but accepts a preallocated index vectorixthe same size asv, which is used to  
store (a permutation of) the indices ofv.  
If the index vectorixis initialized with the indices ofv(or a permutation thereof),initializedshould be  
set totrue.  
Ifinitializedisfalse(the default), thenixis initialized to contain the indices ofv.  
Ifinitializedistrue, butixdoes not contain (a permutation of) the indices ofv, the behavior of  
partialsortperm!is undefined.  
(Typically, the indices ofvwill be1:length(v), although ifvhas an alternative array type with non-one-  
based indices, such as anOffsetArray,ixmust also be anOffsetArraywith the same indices, and must  
contain as values (a permutation of) these same indices.)  
Upon return,ixis guaranteed to have the indiceskin their sorted positions, such that

partialsortperm!(ix, v, k);  
v[ix[k]]== partialsort(v, k)

The return value is thekth element ofixifkis an integer, or view intoixifkis a range.  
Examples

julia> v = [3, 1, 2, 1];

julia> ix = Vector { Int }(undef,4);

julia> partialsortperm!(ix, v,1)  
2

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 883

```

julia> ix = [1:4;];

julia> partialsortperm!(ix, v,2:3, initialized= true )  
2-element view(::Vector{Int64}, 2:3) with eltype Int64:  
4  
3

source

```
### 54.3 Sorting Algorithms.

There are currently four sorting algorithms available in base Julia:

- InsertionSort
- QuickSort
- PartialQuickSort(k)
- MergeSort

InsertionSortis an O(n^2) stable sorting algorithm. It is efficient for very smalln, and is used internally by
QuickSort.

QuickSortis an O(n log n) sorting algorithm which is in-place, very fast, but not stable – i.e. elements which
are considered equal will not remain in the same order in which they originally appeared in the array to be
sorted.QuickSortis the default algorithm for numeric values, including integers and floats.

PartialQuickSort(k)is similar toQuickSort, but the output array is only sorted up to indexkifkis an
integer, or in the range ofkifkis anOrdinalRange. For example:

```

x = rand(1:500, 100)  
k = 50  
k2 = 50:100  
s = sort(x; alg=QuickSort)  
ps = sort(x; alg= PartialQuickSort (k))  
qs = sort(x; alg= PartialQuickSort (k2))  
map(issorted, (s, ps, qs)) # => (true, false, false)  
map(x->issorted(x[1:k]), (s, ps, qs)) # => (true, true, false)  
map(x->issorted(x[k2]), (s, ps, qs)) # => (true, false, true)  
s[1:k] == ps[1:k] # => true  
s[k2]== qs[k2] # => true

```
MergeSortis an O(n log n) stable sorting algorithm but is not in-place – it requires a temporary array of half
the size of the input array – and is typically not quite as fast asQuickSort. It is the default algorithm for
non-numeric data.

The default sorting algorithms are chosen on the basis that they are fast and stable, or appear to be so. For
numeric types indeed,QuickSortis selected as it is faster and indistinguishable in this case from a stable sort
(unlessthearrayrecordsitsmutationsinsomeway). Thestabilitypropertycomesatanon-negligiblecost, soif
youdon'tneedit, youmaywanttoexplicitlyspecifyyourpreferredalgorithm, e.g.sort!(v, alg=QuickSort).

The mechanism by which Julia picks default sorting algorithms is implemented via theBase.Sort.defalg
function. It allows a particular algorithm to be registered as the default in all sorting functions for specific
arrays. For example, here are the two default methods fromsort.jl:


#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 884

```

defalg(v:: AbstractArray ) = MergeSort  
defalg(v:: AbstractArray {<: Number }) = QuickSort

```
As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable
sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.

### 54.4 Alternate orderings

Bydefault,sortandrelatedfunctionsuseislesstocomparetwoelementsinordertodeterminewhichshould
come first. TheBase.Order.Orderingabstract type provides a mechanism for defining alternate orderings
on the same set of elements. Instances ofOrderingdefine atotal orderon a set of elements, so that for any
elementsa,b,cthe following hold:

- Exactly one of the following is true:ais less thanb,bis less thana, oraandbare equal (according to
    isequal).
- The relation is transitive - ifais less thanbandbis less thancthenais less thanc.

TheBase.Order.ltfunction works as a generalization ofislessto test whetherais less thanbaccording to
a given order.

Base.Order.Ordering– Type.

```

Base.Order.Ordering

Abstract type which represents a total order on some set of elements.  
UseBase.Order.ltto compare two elements according to the ordering.  
source

```
Base.Order.lt– Function.

```

lt(o::Ordering, a, b)

Test whetherais less thanbaccording to the orderingo.  
source

```
Base.Order.ord– Function.

```

ord(lt, by, rev:: Union { Bool , Nothing}, order::Ordering=Forward)

Construct anOrderingobject from the same arguments used bysort!. Elements are first transformed by  
the functionby(which may beidentity) and are then compared according to either the functionltor an  
existing orderingorder.ltshould beislessor a function which obeys similar rules. Finally, the resulting  
order is reversed ifrev=true.  
PassinganltotherthanislessalongwithanorderotherthanBase.Order.ForwardorBase.Order.Reverse  
is not permitted, otherwise all options are independent and can be used together in all possible combina-  
tions.  
source

```
Base.Order.Forward– Constant.

```

Base.Order.Forward

```

#### CHAPTER 54. SORTING AND RELATED FUNCTIONS 885

```

Default ordering according toisless.  
source

```
Base.Order.ReverseOrdering– Type.

```

ReverseOrdering(fwd::Ordering=Forward)

A wrapper which reverses an ordering.  
For a givenOrdering o, the following holds for alla,b:  
lt(ReverseOrdering(o), a, b) == lt(o, b, a)

source

```
Base.Order.Reverse– Constant.

```

Base.Order.Reverse

Reverse ordering according toisless.  
source

```
Base.Order.By– Type.

```

By(by, order::Ordering=Forward)

Orderingwhich appliesorderto elements after they have been transformed by the functionby.  
source

```
Base.Order.Lt– Type.

```

Lt(lt)

Orderingwhich callslt(a, b)to compare elements.ltshould obey the same rules as implementations  
ofisless.  
source

```
Base.Order.Perm– Type.

```

Perm(order::Ordering, data:: AbstractVector )

Orderingon the indices ofdatawhereiis less thanjifdata[i]is less thandata[j]according toorder.  
In the case thatdata[i]anddata[j]are equal,iandjare compared by numeric value.  
source

```

**Chapter 55**

**Iteration utilities**

Base.Iterators.Stateful– Type.

```

Stateful(itr)

There are several different ways to think about this iterator wrapper:

```
1. It provides a mutable wrapper around an iterator and its iteration state.
2. It turns an iterator-like abstraction into aChannel-like abstraction.
3. It's an iterator that mutates to become its own rest iterator whenever an item is produced.

```

Statefulprovides the regular iterator interface. Like other mutable iterators (e.g.Channel), if iteration is  
stoppedearly(e.g. byabreakinaforloop), iterationcanberesumedfromthesamespotbycontinuingto  
iterate over the same iterator object (in contrast, an immutable iterator would restart from the beginning).  
Examples

julia> a = Iterators.Stateful("abcdef");

julia> isempty(a)  
false

julia> popfirst!(a)  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(Iterators.take(a,3))  
3-element Vector{Char}:  
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)  
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)  
'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)

julia> collect(a)  
2-element Vector{Char}:  
'e': ASCII/Unicode U+0065 (category Ll: Letter, lowercase)  
'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)

julia> Iterators.reset!(a); popfirst!(a)  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> Iterators.reset!(a,"hello"); popfirst!(a)  
'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)

```
#### 886


#### CHAPTER 55. ITERATION UTILITIES 887

```

julia> a = Iterators.Stateful([1,1,1,2,3,4]);

julia>for x in a; x== 1 || break ; end

julia> peek(a)  
3

julia> sum(a)# Sum the remaining elements  
7

source

```
Base.Iterators.zip– Function.

```

zip(iters...)

Run multiple iterators at the same time, until any of them is exhausted. The value type of thezipiterator  
is a tuple of values of its subiterators.

Note  
ziporders the calls to its subiterators in such a way that stateful iterators will not advance  
when another iterator finishes in the current iteration.

See also:enumerate,splat.  
Examples

julia> a = 1:5  
1:5

julia> b = ["e","d","b","c","a"]  
5-element Vector{String}:  
"e"  
"d"  
"b"  
"c"  
"a"

julia> c = zip(a,b)  
zip(1:5, ["e", "d", "b", "c", "a"])

julia> length(c)  
5

julia> first(c)  
(1, "e")

source

```
Base.Iterators.enumerate– Function.

```

enumerate(iter)

An iterator that yields(i, x)whereiis a counter starting at 1, andxis theith value from the given  
iterator. It's useful when you need not only the valuesxover which you are iterating, but also the number  
of iterations so far. Note thatimay not be valid for indexingiter; it 's also possible thatx != iter[i],

```

#### CHAPTER 55. ITERATION UTILITIES 888

```

ifiterhas indices that do not start at 1. See thepairs(IndexLinear(), iter)method if you want to  
ensure thatiis an index.  
Examples

julia> a = ["a", "b", "c"];

julia>for (index, value) in enumerate(a)  
println(" $index$value ")  
end  
1 a  
2 b  
3 c

source

```
Base.Iterators.rest– Function.

```

rest(iter, state)

An iterator that yields the same elements asiter, but starting at the givenstate.  
See also:Iterators.drop,Iterators.peel,Base.rest.  
Examples

julia> collect(Iterators.rest([1,2,3,4], 2))  
3-element Vector{Int64}:  
2  
3  
4

source

```
Base.Iterators.countfrom– Function.

```

countfrom(start=1, step=1)

An iterator that counts forever, starting atstartand incrementing bystep.  
Examples

julia>for v in Iterators.countfrom(5, 2)  
v > 10 && break  
println(v)  
end  
5  
7  
9

source

```
Base.Iterators.take– Function.

```

take(iter, n)

```

#### CHAPTER 55. ITERATION UTILITIES 889

```

An iterator that generates at most the firstnelements ofiter.  
See also:drop,peel,first,take!.  
Examples

julia> a = 1:2:11  
1:2:11

julia> collect(a)  
6-element Vector{Int64}:  
1  
3  
5  
7  
9  
11

julia> collect(Iterators.take(a,3))  
3-element Vector{Int64}:  
1  
3  
5

source

```
Base.Iterators.takewhile– Function.

```

takewhile(pred, iter)

An iterator that generates element fromiteras long as predicatepredis true, afterwards, drops every  
element.

Julia 1.4  
This function requires at least Julia 1.4.

Examples

julia> s = collect(1:5)  
5-element Vector{Int64}:  
1  
2  
3  
4  
5

julia> collect(Iterators.takewhile(<(3),s))  
2-element Vector{Int64}:  
1  
2

source

```
Base.Iterators.drop– Function.

```

drop(iter, n)

```

#### CHAPTER 55. ITERATION UTILITIES 890

```

An iterator that generates all but the firstnelements ofiter.  
Examples

julia> a = 1:2:11  
1:2:11

julia> collect(a)  
6-element Vector{Int64}:  
1  
3  
5  
7  
9  
11

julia> collect(Iterators.drop(a,4))  
2-element Vector{Int64}:  
9  
11

source

```
Base.Iterators.dropwhile– Function.

```

dropwhile(pred, iter)

An iterator that drops element fromiteras long as predicatepredis true, afterwards, returns every  
element.

Julia 1.4  
This function requires at least Julia 1.4.

Examples

julia> s = collect(1:5)  
5-element Vector{Int64}:  
1  
2  
3  
4  
5

julia> collect(Iterators.dropwhile(<(3),s))  
3-element Vector{Int64}:  
3  
4  
5

source

```
Base.Iterators.cycle– Function.

```

cycle(iter)

```

#### CHAPTER 55. ITERATION UTILITIES 891

```

An iterator that cycles throughiterforever. Ifiteris empty, so iscycle(iter).  
See also:Iterators.repeated,repeat.  
Examples

julia>for (i, v) in enumerate(Iterators.cycle("hello"))  
print(v)  
i > 10 && break  
end  
hellohelloh

source

```
Base.Iterators.repeated– Function.

```

repeated(x[, n:: Int ])

An iterator that generates the valuexforever. Ifnis specified, generatesxthat many times (equivalent  
totake(repeated(x), n)).  
See also:Iterators.cycle,repeat.  
Examples

julia> a = Iterators.repeated([1 2], 4);

julia> collect(a)  
4-element Vector{Matrix{Int64}}:  
[1 2]  
[1 2]  
[1 2]  
[1 2]

source

```
Base.Iterators.product– Function.

```

product(iters...)

Return an iterator over the product of several iterators. Each generated element is a tuple whoseith  
element comes from theith argument iterator. The first iterator changes the fastest.  
See also:zip,Iterators.flatten.  
Examples

julia> collect(Iterators.product(1:2, 3:5))  
2×3 Matrix{Tuple{Int64, Int64}}:  
(1, 3) (1, 4) (1, 5)  
(2, 3) (2, 4) (2, 5)

julia> ans == [(x,y) for x in 1:2, y in 3:5] # collects a generator involving Iterators.product  
true

source

```
Base.Iterators.flatten– Function.


#### CHAPTER 55. ITERATION UTILITIES 892

```

flatten(iter)

Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put  
differently, the elements of the argument iterator are concatenated.  
Examples

julia> collect(Iterators.flatten((1:2, 8:9)))  
4-element Vector{Int64}:  
1  
2  
8  
9

julia> [(x,y) for x in 0:1 for y in 'a':'c'] # collects generators involving Iterators.flatten  
6-element Vector{Tuple{Int64, Char}}:  
(0, 'a')  
(0, 'b')  
(0, 'c')  
(1, 'a')  
(1, 'b')  
(1, 'c')

source

```
Base.Iterators.partition– Function.

```

partition(collection, n)

Iterate over a collectionnelements at a time.  
Examples

julia> collect(Iterators.partition([1,2,3,4,5], 2))  
3-element Vector{SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}}:  
[1, 2]  
[3, 4]  
[5]

source

```
Base.Iterators.map– Function.

```

Iterators.map(f, iterators...)

Createalazymapping. Thisisanothersyntaxforwriting(f(args...) for args in zip(iterators...)).

Julia 1.6  
This function requires at least Julia 1.6.

Examples

julia> collect(Iterators.map(x-> x^2, 1:3))  
3-element Vector{Int64}:  
1  
4  
9

```

#### CHAPTER 55. ITERATION UTILITIES 893

```

source

```
Base.Iterators.filter– Function.

```

Iterators.filter(flt, itr)

Given a predicate functionfltand an iterable objectitr, return an iterable object which upon iteration  
yields the elementsxofitrthat satisfyflt(x). The order of the original iterator is preserved.  
This function is lazy; that is, it is guaranteed to return in(1)time and use(1)additional space, andflt  
will not be called by an invocation offilter. Calls tofltwill be made when iterating over the returned  
iterable object. These calls are not cached and repeated calls will be made when reiterating.  
SeeBase.filterfor an eager implementation of filtering for arrays.  
Examples

julia> f = Iterators.filter(isodd, [1, 2, 3, 4, 5])  
Base.Iterators.Filter{typeof(isodd), Vector{Int64}}(isodd, [1, 2, 3, 4, 5])

julia> foreach(println, f)  
1  
3  
5

julia> [x for x in [1, 2, 3, 4, 5] if isodd(x)] # collects a generator over Iterators.filter  
3-element Vector{Int64}:  
1  
3  
5

source

```
Base.Iterators.accumulate– Function.

```

Iterators.accumulate(f, itr; [init])

Given a 2-argument functionfand an iteratoritr, return a new iterator that successively appliesfto the  
previous value and the next element ofitr.  
This is effectively a lazy version ofBase.accumulate.

Julia 1.5  
Keyword argumentinitis added in Julia 1.5.

Examples

julia> f = Iterators.accumulate(+, [ 1,2,3,4]);

julia> foreach(println, f)  
1  
3  
6  
10

julia> f = Iterators.accumulate(+, [ 1,2,3]; init= 100);

```

#### CHAPTER 55. ITERATION UTILITIES 894

```

julia> foreach(println, f)  
101  
103  
106

source

```
Base.Iterators.reverse– Function.

```

Iterators.reverse(itr)

Given an iteratoritr, thenreverse(itr)is an iterator over the same collection but in the reverse order.  
Thisiteratoris"lazy"inthatitdoesnotmakeacopyofthecollectioninordertoreverseit;seeBase.reverse  
for an eager implementation.  
NotalliteratortypesTsupportreverse-orderiteration. IfTdoesn't,theniteratingoverIterators.reverse(itr::T)  
will throw aMethodErrorbecause of the missingiteratemethods forIterators.Reverse{T}. (To imple-  
ment these methods, the original iteratoritr::Tcan be obtained fromr = Iterators.reverse(itr)by  
r.itr.)  
Examples

julia> foreach(println, Iterators.reverse(1:5))  
5  
4  
3  
2  
1

source

```
Base.Iterators.only– Function.

```

only(x)

Returns the one and only element of collectionx, and throws anArgumentErrorif the collection has zero  
or multiple elements.  
See alsofirst,last.

Julia 1.4  
This method requires at least Julia 1.4.

source

```
Base.Iterators.peel– Function.

```

peel(iter)

Returns the first element and an iterator over the remaining elements.  
If the iterator is empty returnnothing(likeiterate).

Julia 1.7  
Prior versions throw a BoundsError if the iterator is empty.

```

#### CHAPTER 55. ITERATION UTILITIES 895

```

See also:Iterators.drop,Iterators.take.  
Examples

julia> (a, rest)= Iterators.peel("abc");

julia> a  
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia> collect(rest)  
2-element Vector{Char}:  
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)  
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)

source

```

**Chapter 56**

**C Interface**

Base.@ccall– Macro.

```

@ccalllibrary.function_name(argvalue1::argtype1,...)::returntype  
@ccallfunction_name(argvalue1::argtype1,...)::returntype  
@ccall$function_pointer(argvalue1::argtype1,...)::returntype

Call a function in a C-exported shared library, specified bylibrary.function_name, wherelibraryis a  
string constant or literal. The library may be omitted, in which case thefunction_nameis resolved in the  
current process. Alternatively,@ccallmay also be used to call a function pointer$function_pointer,  
such as one returned bydlsym.  
Eachargvalueto@ccallis converted to the correspondingargtype, by automatic insertion of calls to  
unsafe_convert(argtype, cconvert(argtype, argvalue)). (Seealsothedocumentationforunsafe_convert  
andcconvertforfurtherdetails.) Inmostcases,thissimplyresultsinacalltoconvert(argtype, argvalue).  
Examples  
@ccall strlen(s::Cstring)::Csize_t

This calls the C standard library function:  
size_t strlen(char *)

with a Julia variable nameds. See alsoccall.  
Varargs are supported with the following convention:  
@ccall printf("%s = %d"::Cstring ; "foo"::Cstring, foo::Cint)::Cint

The semicolon is used to separate required arguments (of which there must be at least one) from variadic  
arguments.  
Example using an external library:

# C signature of g_uri_escape_string:

# char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean

allow_utf8);

const glib = "libglib-2.0"  
@ccall glib.g_uri_escape_string(my_uri::Cstring, ":/"::Cstring, true::Cint)::Cstring

Thestringliteralcouldalsobeuseddirectlybeforethefunctionname,ifdesired"libglib-2.0".g_uri_escape_string(...  
source

```
#### 896


#### CHAPTER 56. C INTERFACE 897

ccall– Keyword.

```

ccall ((function_name, library), returntype, (argtype1,...), argvalue1,...)  
ccall (function_name, returntype, (argtype1,...), argvalue1,...)  
ccall (function_pointer, returntype, (argtype1,...), argvalue1,...)

Call a function in a C-exported shared library, specified by the tuple(function_name, library), where  
eachcomponentiseitherastringorsymbol. Insteadofspecifyingalibrary,onecanalsouseafunction_name  
symbol or string, which is resolved in the current process. Alternatively,ccallmay also be used to call a  
function pointerfunction_pointer, such as one returned bydlsym.  
Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression.  
Eachargvalueto theccallwill be converted to the correspondingargtype, by automatic insertion  
of calls tounsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation  
forunsafe_convertandcconvertfor further details.) In most cases, this simply results in a call to  
convert(argtype, argvalue).  
source

```
Core.Intrinsics.cglobal– Function.

```

cglobal((symbol, library) [, type =Cvoid])

Obtain a pointer to a global variable in a C-exported shared library, specified exactly as inccall. Returns  
aPtr{Type}, defaulting toPtr{Cvoid}if noTypeargument is supplied. The values can be read or written  
byunsafe_loadorunsafe_store!, respectively.  
source

```
Base.@cfunction– Macro.

```

@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr {Cvoid}  
@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction

Generate a C-callable function pointer from the Julia functioncallablefor the given type signature. To  
pass the return value to accall, use the argument typePtr{Cvoid}in the signature.  
Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression  
(although it can include a splat expression). And that these arguments will be evaluated in global scope  
during compile-time (not deferred until runtime). Adding a'$' in front of the function argument changes  
this to instead create a runtime closure over the local variablecallable(this is not supported on all  
architectures).  
See manual section on ccall and cfunction usage.  
Examples

julia>function foo(x:: Int , y :: Int )  
return x + y  
end

julia> @cfunction(foo, Int , ( Int , Int ))  
Ptr{Cvoid} @0x000000001b82fcd0

source

```
Base.CFunction– Type.


#### CHAPTER 56. C INTERFACE 898

```

CFunction struct

Garbage-collection handle for the return value from@cfunctionwhen the first argument is annotated  
with '$'. Like allcfunctionhandles, it should be passed toccallas aPtr{Cvoid}, and will be converted  
automatically at the call site to the appropriate type.  
See@cfunction.  
source

```
Base.unsafe_convert– Function.

```

unsafe_convert(T, x)

Convertxto a C argument of typeTwhere the inputxmust be the return value ofcconvert(T, ...).  
In cases whereconvertwould need to take a Julia object and turn it into aPtr, this function should be  
used to define and perform that conversion.  
Be careful to ensure that a Julia reference toxexists as long as the result of this function will be used.  
Accordingly, the argumentxto this function should never be an expression, only a variable name or field  
reference. For example,x=a.b.cis acceptable, butx=[a,b,c]is not.  
Theunsafeprefix on this function indicates that using the result of this function after thexargument to  
this function is no longer accessible to the program may cause undefined behavior, including program  
corruption or segfaults, at any later time.  
See alsocconvert  
source

```
Base.cconvert– Function.

```

cconvert(T,x)

Convertxto a value to be passed to C code as typeT, typically by callingconvert(T, x).  
In cases wherexcannot be safely converted toT, unlikeconvert,cconvertmay return an object of a  
type different fromT, which however is suitable forunsafe_convertto handle. The result of this function  
should be kept valid (for the GC) until the result ofunsafe_convertis not needed anymore. This can be  
used to allocate memory that will be accessed by theccall. If multiple objects need to be allocated, a  
tuple of the objects can be used as return value.  
Neitherconvertnorcconvertshould take a Julia object and turn it into aPtr.  
source

```
Base.unsafe_load– Function.

```

unsafe_load(p:: Ptr {T}, i:: Integer =1)

Load a value of typeTfrom the address of theith element (1-indexed) starting atp. This is equivalent to  
the C expressionp[i-1].  
Theunsafeprefix on this function indicates that no validation is performed on the pointerpto ensure that  
it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as  
C.  
source

```
Base.unsafe_store!– Function.


#### CHAPTER 56. C INTERFACE 899

```

unsafe_store!(p:: Ptr {T}, x, i:: Integer =1)

Store a value of typeTto the address of theith element (1-indexed) starting atp. This is equivalent to  
the C expressionp[i-1] = x.  
Theunsafeprefix on this function indicates that no validation is performed on the pointerpto ensure that  
it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.  
source

```
Base.unsafe_copyto!– Method.

```

unsafe_copyto!(dest:: Ptr {T}, src:: Ptr {T}, N)

CopyNelements from a source pointer to a destination, with no checking. The size of an element is  
determined by the type of the pointers.  
Theunsafeprefix on this function indicates that no validation is performed on the pointersdestandsrc  
to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner  
as C.  
source

```
Base.unsafe_copyto!– Method.

```

unsafe_copyto!(dest:: Array , do , src:: Array , so, N)

CopyNelements from a source array to a destination, starting at offsetsoin the source anddoin the  
destination (1-indexed).  
Theunsafeprefix on this function indicates that no validation is performed to ensure that N is inbounds  
on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.  
source

```
Base.copyto!– Function.

```

copyto!(dest, do , src, so, N)

CopyNelements from collectionsrcstarting at offsetso, to arraydeststarting at offsetdo. Returndest.  
source  
copyto!(dest::AbstractArray, src) -> dest

Copy all elements from collectionsrcto arraydest, whose length must be greater than or equal to the  
lengthnofsrc. The firstnelements ofdestare overwritten, the other elements are left untouched.  
See alsocopy!,copy.  
Examples

julia> x = [1., 0., 3., 0., 5.];

julia> y = zeros(7);

julia> copyto!(y, x);

julia> y  
7-element Vector{Float64}:

```

#### CHAPTER 56. C INTERFACE 900

```

1.0  
0.0  
3.0  
0.0  
5.0  
0.0  
0.0

source

copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices)-> dest

Copy the block ofsrcin the range ofRsrcto the block ofdestin the range ofRdest. The sizes of the two  
regions must match.  
source  
copyto!(dest::AbstractMatrix, src::UniformScaling)

Copies aUniformScalingonto a matrix.

Julia 1.1  
In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support  
for a rectangular matrix.

```
Base.pointer– Function.

```

pointer(array [, index])

Get the native address of an array or string, optionally at a given locationindex.  
This function is"unsafe". Be careful to ensure that a Julia reference toarrayexists as long as this pointer  
will be used. TheGC.@preservemacro should be used to protect thearrayargument from garbage  
collection within a given block of code.  
CallingRef(array[, index])is generally preferable to this function as it guarantees validity.  
source

```
Base.unsafe_wrap– Method.

```

unsafe_wrap( Array , pointer:: Ptr {T}, dims; own= false )

Wrap a JuliaArrayobject around the data at the address given bypointer, without making a copy. The  
pointer element typeTdetermines the array element type.dimsis either an integer (for a 1d array) or a  
tuple of the array dimensions.ownoptionally specifies whether Julia should take ownership of the memory,  
callingfreeon the pointer when the array is no longer referenced.  
This function is labeled"unsafe" because it will crash ifpointeris not a valid memory address to data of  
the requested length.  
source

```
Base.pointer_from_objref– Function.

```

pointer_from_objref(x)

```

#### CHAPTER 56. C INTERFACE 901

```

Get the memory address of a Julia object as aPtr. The existence of the resultingPtrwill not protect the  
object from garbage collection, so you must ensure that the object remains referenced for the whole time  
that thePtrwill be used.  
This function may not be called on immutable objects, since they do not have stable memory addresses.  
See alsounsafe_pointer_to_objref.  
source

```
Base.unsafe_pointer_to_objref– Function.

```

unsafe_pointer_to_objref(p:: Ptr )

Convert aPtrto an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If  
this is not the case, undefined behavior results, hence this function is considered"unsafe" and should be  
used with care.  
See alsopointer_from_objref.  
source

```
Base.disable_sigint– Function.

```

disable_sigint(f:: Function )

Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may  
call julia code that is not interrupt safe. Intended to be called usingdoblock syntax as follows:  
disable_sigint() do

# interrupt-unsafe code

...  
end

This is not needed on worker threads (Threads.threadid() != 1) since theInterruptExceptionwill  
only be delivered to the master thread. External functions that do not call julia code or julia runtime  
automatically disable sigint during their execution.  
source

```
Base.reenable_sigint– Function.

```

reenable_sigint(f:: Function )

Re-enableCtrl-Chandlerduringexecutionofafunction. Temporarilyreversestheeffectofdisable_sigint.  
source

```
Base.exit_on_sigint– Function.

```

exit_on_sigint(on:: Bool )

Setexit_on_sigintflagofthejuliaruntime. Iffalse,Ctrl-C(SIGINT)iscapturableasInterruptException  
intryblock. This is the default behavior in REPL, any code run via-eand-Eand in Julia script run with  
-ioption.  
Iftrue,InterruptExceptionis not thrown by Ctrl-C. Running code upon such event requiresatexit. This  
is the default behavior in Julia script run without-ioption.

```

#### CHAPTER 56. C INTERFACE 902

```

Julia 1.5  
Functionexit_on_sigintrequires at least Julia 1.5.

source

```
Base.systemerror– Function.

```

systemerror(sysfunc[, errno:: Cint =Libc.errno()])  
systemerror(sysfunc, iftrue:: Bool )

Raises aSystemErrorforerrnowith the descriptive stringsysfuncififtrueistrue  
source

```
Base.windowserror– Function.

```

windowserror(sysfunc[, code:: UInt32 =Libc.GetLastError()])  
windowserror(sysfunc, iftrue:: Bool )

Likesystemerror, but for Windows API functions that useGetLastErrorto return an error code instead  
of settingerrno.  
source

```
Core.Ptr– Type.

```

Ptr {T}

A memory address referring to data of typeT. However, there is no guarantee that the memory is actually  
valid, or that it actually represents data of the specified type.  
source

```
Core.Ref– Type.

```

Ref {T}

An object that safely references data of typeT. This type is guaranteed to point to valid, Julia-allocated  
memory of the correct type. The underlying data is protected from freeing by the garbage collector as  
long as theRefitself is referenced.  
In Julia,Refobjects are dereferenced (loaded or stored) with[].  
Creation of aRefto a valuexof typeTis usually writtenRef(x). Additionally, for creating interior pointers  
tocontainers(suchasArrayorPtr), itcanbewrittenRef(a, i)forcreatingareferencetothei-thelement  
ofa.  
Ref{T}()creates a reference to a value of typeTwithout initialization. For a bitstypeT, the value will be  
whatever currently resides in the memory allocated. For a non-bitstypeT, the reference will be undefined  
and attempting to dereference it will result in an error,"UndefRefError: access to undefined reference".  
TocheckifaRefisanundefinedreference,useisassigned(ref::RefValue). Forexample,isassigned(Ref{T}())  
isfalseifTis not a bitstype. IfTis a bitstype,isassigned(Ref{T}())will always be true.  
When passed as accallargument (either as aPtrorReftype), aRefobject will be converted to a native  
pointer to the data it references. For mostT, or when converted to aPtr{Cvoid}, this is a pointer to the  
object data. WhenTis anisbitstype, this value may be safely mutated, otherwise mutation is strictly  
undefined behavior.

```

#### CHAPTER 56. C INTERFACE 903

```

As a special case, settingT = Anywill instead cause the creation of a pointer to the reference itself when  
converted to aPtr{Any}(ajl_value_t const* const*if T is immutable, else ajl_value_t *const *).  
When converted to aPtr{Cvoid}, it will still return a pointer to the data region as for any otherT.  
AC_NULLinstance ofPtrcan be passed to accall Refargument to initialize it.  
Use in broadcasting  
Refis sometimes used in broadcasting in order to treat the referenced values as a scalar.  
Examples

julia>Ref (5)  
Base.RefValue{Int64}(5)

julia> isa.( Ref ([1,2,3]), [ Array , Dict , Int ]) # Treat reference values as scalar during  
↪→ broadcasting  
3-element BitVector:  
1  
0  
0

julia>Ref { Function }() # Undefined reference to a non-bitstype, Function  
Base.RefValue{Function}(#undef)

julia>try  
Ref { Function }()[]# Dereferencing an undefined reference will result in an error  
catch e  
println(e)  
end  
UndefRefError()

julia>Ref { Int64 }()[];# A reference to a bitstype refers to an undetermined value if not given

julia> isassigned( Ref { Int64 }())# A reference to a bitstype is always assigned  
true

julia>Ref { Int64 }(0)[] == 0 # Explicitly give a value for a bitstype reference  
true

source

```
Base.isassigned– Method.

```

isassigned(ref::RefValue)-> Bool

Test whether the givenRefis associated with a value. This is always true for aRefof a bitstype object.  
Returnfalseif the reference is undefined.  
Examples

julia> ref = Ref { Function }()  
Base.RefValue{Function}(#undef)

julia> isassigned(ref)  
false

julia> ref[]= (foobar(x)= x)

```

#### CHAPTER 56. C INTERFACE 904

```

foobar (generic function with 1 method)

julia> isassigned(ref)  
true

julia> isassigned( Ref { Int }())  
true

source

```
Base.Cchar– Type.

```

Cchar

Equivalent to the nativecharc-type.  
source

```
Base.Cuchar– Type.

```

Cuchar

Equivalent to the nativeunsigned charc-type (UInt8).  
source

```
Base.Cshort– Type.

```

Cshort

Equivalent to the nativesigned shortc-type (Int16).  
source

```
Base.Cstring– Type.

```

Cstring

A C-style string composed of the native character typeCchars.Cstrings are NUL-terminated. For C-style  
strings composed of the native wide character type, seeCwstring. For more information about string  
interopability with C, see themanual.  
source

```
Base.Cushort– Type.

```

Cushort

Equivalent to the nativeunsigned shortc-type (UInt16).  
source

```
Base.Cint– Type.

```

Cint

Equivalent to the nativesigned intc-type (Int32).  
source

```

#### CHAPTER 56. C INTERFACE 905

Base.Cuint– Type.

```

Cuint

Equivalent to the nativeunsigned intc-type (UInt32).  
source

```
Base.Clong– Type.

```

Clong

Equivalent to the nativesigned longc-type.  
source

```
Base.Culong– Type.

```

Culong

Equivalent to the nativeunsigned longc-type.  
source

```
Base.Clonglong– Type.

```

Clonglong

Equivalent to the nativesigned long longc-type (Int64).  
source

```
Base.Culonglong– Type.

```

Culonglong

Equivalent to the nativeunsigned long longc-type (UInt64).  
source

```
Base.Cintmax_t– Type.

```

Cintmax_t

Equivalent to the nativeintmax_tc-type (Int64).  
source

```
Base.Cuintmax_t– Type.

```

Cuintmax_t

Equivalent to the nativeuintmax_tc-type (UInt64).  
source

```
Base.Csize_t– Type.

```

Csize_t

```

#### CHAPTER 56. C INTERFACE 906

```

Equivalent to the nativesize_tc-type (UInt).  
source

```
Base.Cssize_t– Type.

```

Cssize_t

Equivalent to the nativessize_tc-type.  
source

```
Base.Cptrdiff_t– Type.

```

Cptrdiff_t

Equivalent to the nativeptrdiff_tc-type (Int).  
source

```
Base.Cwchar_t– Type.

```

Cwchar_t

Equivalent to the nativewchar_tc-type (Int32).  
source

```
Base.Cwstring– Type.

```

Cwstring

A C-style string composed of the native wide character typeCwchar_ts.Cwstrings are NUL-terminated.  
For C-style strings composed of the native character type, seeCstring. For more information about string  
interopability with C, see themanual.  
source

```
Base.Cfloat– Type.

```

Cfloat

Equivalent to the nativefloatc-type (Float32).  
source

```
Base.Cdouble– Type.

```

Cdouble

Equivalent to the nativedoublec-type (Float64).  
source

```

**Chapter 57**

**LLVM Interface**

Core.Intrinsics.llvmcall– Function.

```

llvmcall(fun_ir::String, returntype, Tuple {argtype1,...}, argvalue1,...)  
llvmcall((mod_ir::String, entry_fn::String), returntype, Tuple {argtype1,...}, argvalue1,...)  
llvmcall((mod_bc:: Vector { UInt8 }, entry_fn::String), returntype, Tuple {argtype1,...}, argvalue1,  
↪→ ...)

Call the LLVM code provided in the first argument. There are several ways to specify this first argument:

```
- as a literal string, representing function-level IR (similar to an LLVMdefineblock), with arguments
    are available as consecutive unnamed SSA variables (%0, %1, etc.);
- as a 2-element tuple, containing a string of module IR and a string representing the name of the
    entry-point function to call;
- as a 2-element tuple, but with the module provided as anVector{UINt8}with bitcode.

```

Notethatcontrarytoccall, theargumenttypesmustbespecifiedasatupletype, andnotatupleoftypes.  
All types, as well as the LLVM code, should be specified as literals, and not as variables or expressions (it  
may be necessary to use@evalto generate these literals).  
Seetest/llvmcall.jlfor usage examples.  
source

```
#### 907


**Chapter 58**

**C Standard Library**

Base.Libc.malloc– Function.

```

malloc(size:: Integer ) -> Ptr {Cvoid}

Callmallocfrom the C standard library.  
source

```
Base.Libc.calloc– Function.

```

calloc(num:: Integer , size:: Integer ) -> Ptr {Cvoid}

Callcallocfrom the C standard library.  
source

```
Base.Libc.realloc– Function.

```

realloc(addr:: Ptr , size:: Integer ) -> Ptr {Cvoid}

Callreallocfrom the C standard library.  
See warning in the documentation forfreeregarding only using this on memory originally obtained from  
malloc.  
source

```
Base.Libc.free– Function.

```

free(addr:: Ptr )

Callfreefrom the C standard library. Only use this on memory obtained frommalloc, not on pointers  
retrieved from other C libraries.Ptrobjects obtained from C libraries should be freed by the free functions  
defined in that library, to avoid assertion failures if multiplelibclibraries exist on the system.  
source

```
Base.Libc.errno– Function.

```

errno([code])

```
#### 908


#### CHAPTER 58. C STANDARD LIBRARY 909

```

Get the value of the C library'serrno. If an argument is specified, it is used to set the value oferrno.  
The value oferrnois only valid immediately after accallto a C library routine that sets it. Specifically,  
you cannot callerrnoat the next prompt in a REPL, because lots of code is executed between prompts.  
source

```
Base.Libc.strerror– Function.

```

strerror(n=errno())

Convert a system call error code to a descriptive string  
source

```
Base.Libc.GetLastError– Function.

```

GetLastError()

Call the Win32GetLastErrorfunction [only available on Windows].  
source

```
Base.Libc.FormatMessage– Function.

```

FormatMessage(n=GetLastError())

Convert a Win32 system call error code to a descriptive string [only available on Windows].  
source

```
Base.Libc.time– Method.

```

time(t::TmStruct)

Converts aTmStructstruct to a number of seconds since the epoch.  
source

```
Base.Libc.strftime– Function.

```

strftime([format], time)

Convert time, given as a number of seconds since the epoch or aTmStruct, to a formatted string using  
the given format. Supported formats are the same as those in the standard C library.  
source

```
Base.Libc.strptime– Function.

```

strptime([format], timestr)

Parse a formatted time string into aTmStructgiving the seconds, minute, hour, date, etc. Supported  
formats are the same as those in the standard C library. On some platforms, timezones will not be parsed  
correctly. If the result of this function will be passed totimeto convert it to seconds since the epoch, the  
isdstfield should be filled in manually. Setting it to-1will tell the C library to use the current system  
settings to determine the timezone.  
source

```
Base.Libc.TmStruct– Type.


#### CHAPTER 58. C STANDARD LIBRARY 910

```

TmStruct([seconds])

Convert a number of seconds since the epoch to broken-down format, with fieldssec,min,hour,mday,  
month,year,wday,yday, andisdst.  
source

```
Base.Libc.flush_cstdio– Function.

```

flush_cstdio()

Flushes the Cstdoutandstderrstreams (which may have been written to by external C code).  
source

```
Base.Libc.systemsleep– Function.

```

systemsleep(s:: Real )

Suspends execution forsseconds. This function does not yield to Julia's scheduler and therefore blocks  
the Julia thread that it is running on for the duration of the sleep time.  
See alsosleep.  
source

```

**Chapter 59**

**StackTraces**

Base.StackTraces.StackFrame– Type.

```

StackFrame

Stack information representing execution context, with the following fields:

```
- func::Symbol
    The name of the function containing the execution context.
- linfo::Union{Core.MethodInstance, CodeInfo, Nothing}
    The MethodInstance containing the execution context (if it could be found).
- file::Symbol
    The path to the file containing the execution context.
- line::Int
    The line number in the file containing the execution context.
- from_c::Bool
    True if the code is from C.
- inlined::Bool
    True if the code is from an inlined frame.
- pointer::UInt64
    Representation of the pointer to the execution context as returned bybacktrace.

```

source

```
Base.StackTraces.StackTrace– Type.

```

StackTrace

An alias forVector{StackFrame}provided for convenience; returned by calls tostacktrace.  
source

```
Base.StackTraces.stacktrace– Function.

```

stacktrace([trace:: Vector { Ptr {Cvoid}},] [c_funcs:: Bool = false ]) -> StackTrace

Returns a stack trace in the form of a vector ofStackFrames. (By default stacktrace doesn't return C func-  
tions, but this can be enabled.) When called without specifying a trace,stacktracefirst callsbacktrace.  
source

```
#### 911


#### CHAPTER 59. STACKTRACES 912

The following methods and types inBase.StackTracesare not exported and need to be called e.g. as
StackTraces.lookup(ptr).

Base.StackTraces.lookup– Function.

```

lookup(pointer:: Ptr {Cvoid})-> Vector {StackFrame}

Given a pointer to an execution context (usually generated by a call tobacktrace), looks up stack frame  
context information. Returns an array of frame information for all functions inlined at that point, innermost  
function first.  
source

```
Base.StackTraces.remove_frames!– Function.

```

remove_frames!(stack::StackTrace, name:: Symbol )

TakesaStackTrace(avectorofStackFrames)andafunctionname(aSymbol)andremovestheStackFrame  
specified by the function name from theStackTrace(also removing all frames above the specified func-  
tion). Primarily used to removeStackTracesfunctions from theStackTraceprior to returning it.  
source  
remove_frames!(stack::StackTrace, m::Module)

Returns theStackTracewith allStackFrames from the providedModuleremoved.  
source

```

**Chapter 60**

**SIMD Support**

TypeVecElement{T}is intended for building libraries of SIMD operations. Practical use of it requires using
llvmcall. The type is defined as:

```

struct VecElement{T}  
value::T  
end

```
It has a special compilation rule: a homogeneous tuple ofVecElement{T}maps to an LLVMvectortype when
Tis a primitive bits type.

At-O3, the compiler might automatically vectorize operations on such tuples. For example, the following
program, when compiled withjulia -O3generates two SIMD addition instructions (addps) on x86 systems:

```

const m128= NTuple {4,VecElement{ Float32 }}

function add(a::m128, b::m128)  
(VecElement(a[1].value+b[1].value),  
VecElement(a[2].value+b[2].value),  
VecElement(a[3].value+b[3].value),  
VecElement(a[4].value+b[4].value))  
end

triple(c::m128)= add(add(c,c),c)

code_native(triple,(m128,))

```
However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that
usellvmcall.

#### 913


**Part III**

**Standard Library**

#### 914


**Chapter 61**

**Artifacts**

Starting with Julia 1.6, the artifacts support has moved fromPkg.jlto Julia itself. Until proper documentation
canbeaddedhere,youcanlearnmoreaboutartifactsinthePkg.jlmanualathttps://julialang.github.io/Pkg.jl/v1/ar-
tifacts/.

```

Julia 1.6  
Julia'sartifactsAPIrequiresatleastJulia1.6. InJuliaversions1.3to1.5,youcanusePkg.Artifacts  
instead.

```
Artifacts.artifact_meta– Function.

```

artifact_meta(name::String, artifacts_toml::String;  
platform::AbstractPlatform= HostPlatform(),  
pkg_uuid:: Union {Base.UUID,Nothing}=nothing)

Get metadata about a given artifact (identified by name) stored within the given(Julia)Artifacts.toml  
file. If the artifact is platform-specific, useplatformto choose the most appropriate mapping. If none is  
found, returnnothing.

Julia 1.3  
This function requires at least Julia 1.3.

```
Artifacts.artifact_hash– Function.

```

artifact_hash(name::String, artifacts_toml::String;  
platform::AbstractPlatform= HostPlatform())

Thin wrapper aroundartifact_meta()to return the hash of the specified, platform- collapsed artifact.  
Returnsnothingif no mapping can be found.

Julia 1.3  
This function requires at least Julia 1.3.

```
Artifacts.find_artifacts_toml– Function.

```

find_artifacts_toml(path::String)

Given the path to a.jlfile, (such as the one returned by__source__.filein a macro context), find  
the(Julia)Artifacts.tomlthat is contained within the containing project (if it exists), otherwise return  
nothing.

```
#### 915


#### CHAPTER 61. ARTIFACTS 916

```

Julia 1.3  
This function requires at least Julia 1.3.

```
Artifacts.@artifact_str– Macro.

```

macro artifact_str(name)

Returntheon-diskpathtoanartifact. Automaticallylookstheartifactupbynameintheproject's(Julia)Artifacts.toml  
file. Throws an error on if the requested artifact is not present. If run in the REPL, searches for the toml  
file starting in the current directory, seefind_artifacts_toml()for more.  
If the artifact is marked"lazy" and the package hasusing LazyArtifactsdefined, the artifact will be  
downloaded on-demand withPkgthe first time this macro tries to compute the path. The files will then be  
left installed locally for later.  
Ifnamecontains a forward or backward slash, all elements after the first slash will be taken to be path  
names indexing into the artifact, allowing for an easy one-liner to access a single file/directory within an  
artifact. Example:  
ffmpeg_path = @artifact"FFMPEG/bin/ffmpeg"

Julia 1.3  
This macro requires at least Julia 1.3.

Julia 1.6  
Slash-indexing requires at least Julia 1.6.

```

**Chapter 62**

**Base64**

Base64.Base64– Module.

```

Base64

Functionality for base-64 encoded strings and IO.

```
Base64.Base64EncodePipe– Type.

```

Base64EncodePipe (ostream)

Return a new write-only I/O stream, which converts any bytes written to it into base64-encoded ASCII bytes  
writtentoostream. CallingcloseontheBase64EncodePipestreamisnecessarytocompletetheencoding  
(but does not closeostream).  
Examples

julia> io = IOBuffer ();

julia> iob64_encode= Base64EncodePipe (io);

julia> write(iob64_encode,"Hello!")  
6

julia> close(iob64_encode);

julia> str = String(take!(io))  
"SGVsbG8h"

julia> String(base64decode(str))  
"Hello!"

```
Base64.base64encode– Function.

```

base64encode(writefunc, args...; context=nothing)  
base64encode(args...; context=nothing)

Givenawrite-likefunctionwritefunc,whichtakesanI/Ostreamasitsfirstargument,base64encode(writefunc,  
args...)callswritefunctowriteargs...toabase64-encodedstring,andreturnsthestring.base64encode(args...)  
is equivalent tobase64encode(write, args...): it converts its arguments into bytes using the standard  
writefunctions and returns the base64-encoded string.

```
#### 917


#### CHAPTER 62. BASE64 918

```

The optional keyword argumentcontextcan be set to:key=>valuepair or anIOorIOContextobject  
whose attributes are used for the I/O stream passed towritefuncorwrite.  
See alsobase64decode.

```
Base64.Base64DecodePipe– Type.

```

Base64DecodePipe (istream)

Return a new read-only I/O stream, which decodes base64-encoded data read fromistream.  
Examples

julia> io = IOBuffer ();

julia> iob64_decode= Base64DecodePipe (io);

julia> write(io,"SGVsbG8h")  
8

julia> seekstart(io);

julia> String(read(iob64_decode))  
"Hello!"

```
Base64.base64decode– Function.

```

base64decode(string)

Decode the base64-encodedstringand returns aVector{UInt8}of the decoded bytes.  
See alsobase64encode.  
Examples

julia> b = base64decode("SGVsbG8h")  
6-element Vector{UInt8}:  
0x48  
0x65  
0x6c  
0x6c  
0x6f  
0x21

julia> String(b)  
"Hello!"

```
Base64.stringmime– Function.

```

stringmime(mime, x; context=nothing)

Returns anAbstractStringcontaining the representation ofxin the requestedmimetype. This is similar  
torepr(mime, x)except that binary data is base64-encoded as an ASCII string.  
The optional keyword argumentcontextcan be set to:key=>valuepair or anIOorIOContextobject  
whose attributes are used for the I/O stream passed toshow.

```

**Chapter 63**

**CRC32c**

CRC32c.crc32c– Function.

```

crc32c(data, crc:: UInt32 =0x00000000)

Compute the CRC-32c checksum of the givendata, which can be anArray{UInt8}, a contiguous subarray  
thereof, or aString. Optionally, you can pass a startingcrcinteger to be mixed in with the check-  
sum. Thecrcparameter can be used to compute a checksum on data divided into chunks: performing  
crc32c(data2, crc32c(data1))is equivalent to the checksum of[data1; data2]. (Technically, a little-  
endian checksum is computed.)  
There is also a methodcrc32c(io, nb, crc)to checksumnbbytes from a streamio, orcrc32c(io,  
crc)to checksum all the remaining bytes. Hence you can doopen(crc32c, filename)to checksum an  
entire file, orcrc32c(seekstart(buf))to checksum anIOBufferwithout callingtake!.  
For aString, note that the result is specific to the UTF-8 encoding (a different checksum would be ob-  
tained from a different Unicode encoding). To checksum ana::Arrayof some other bitstype, you can do  
crc32c(reinterpret(UInt8,a)), but note that the result may be endian-dependent.

```
CRC32c.crc32c– Method.

```

crc32c(io:: IO , [nb:: Integer ,] crc:: UInt32 =0x00000000)

ReaduptonbbytesfromioandreturntheCRC-32cchecksum, optionallymixedwithastartingcrcinteger.  
Ifnbis not supplied, theniowill be read until the end of the stream.

```
#### 919


**Chapter 64**

**Dates**

TheDatesmodule provides two types for working with dates:DateandDateTime, representing day and
millisecond precision, respectively; both are subtypes of the abstractTimeType. The motivation for distinct
types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the
complexities of greater precision don't have to be dealt with. For example, since theDatetype only resolves
to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones,
daylight savings/summer time, and leap seconds are unnecessary and avoided.

BothDateandDateTimeare basically immutableInt64wrappers. The singleinstantfield of either type
is actually aUTInstant{P}type, which represents a continuously increasing machine timeline based on the
UT second^1. TheDateTimetype is not aware of time zones (naive, in Python parlance), analogous to a
LocalDateTime in Java 8. Additional time zone functionality can be added through theTimeZones.jl package,
which compiles theIANA time zone database. BothDateandDateTimeare based on theISO 8601standard,
which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about
BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus
no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so0000-12-31is the day
before0001-01-01, and year-0001(yes, negative one for the year) is 2 BC/BCE, year-0002is 3 BC/BCE, etc.

### 64.1 Constructors.

DateandDateTimetypes can be constructed by integer orPeriodtypes, by parsing, or through adjusters
(more on those later):

```

julia>DateTime (2013)  
2013-01-01T00:00:00

julia>DateTime (2013,7)  
2013-07-01T00:00:00

julia>DateTime (2013,7,1)  
2013-07-01T00:00:00

```
(^1) The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one
based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These
are radically different! Think about it, a"UT second", as defined relative to the rotation of the earth, may have a different absolute length
depending on the day! Anyway, the fact thatDateandDateTimeare based on UT seconds is a simplifying, yet honest assumption so
that things like leap seconds and all their complexity can be avoided. This basis of time is formally calledUT or UT1. Basing types on the
UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when
working with calendar dates.

#### 920


#### CHAPTER 64. DATES 921

```

julia>DateTime (2013,7,1,12)  
2013-07-01T12:00:00

julia>DateTime (2013,7,1,12,30)  
2013-07-01T12:30:00

julia>DateTime (2013,7,1,12,30,59)  
2013-07-01T12:30:59

julia>DateTime (2013,7,1,12,30,59,1)  
2013-07-01T12:30:59.001

julia>Date (2013)  
2013-01-01

julia>Date (2013,7)  
2013-07-01

julia>Date (2013,7,1)  
2013-07-01

julia>Date (Dates.Year(2013),Dates.Month(7),Dates.Day(1))  
2013-07-01

julia>Date (Dates.Month(7),Dates.Year(2013))  
2013-07-01

```
DateorDateTimeparsing is accomplished by the use of format strings. Format strings work by the notion
of defining delimited or fixed-width"slots" that contain a period to parse and passing the text to parse and
format string to aDateorDateTimeconstructor, of the formDate("2015-01-01",dateformat"y-m-d")or
DateTime("20150101",dateformat"yyyymmdd").

Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent
periods; so"y-m-d"letstheparserknowthatbetweenthefirstandsecondslotsinadatestringlike"2014-07-
16", it should find the-character. They,m, anddcharacters let the parser know which periods to parse in
each slot.

As in the case of constructors above such asDate(2013), delimitedDateFormats allow for missing parts
of dates and times so long as the preceding parts are given. The other parts are given the usual default
values. For example,Date("1981-03", dateformat"y-m-d")returns1981-03-01, whilstDate("31/12",
dateformat"d/m/y")gives0001-12-31. (Note that the default year is 1 AD/CE.) Consequently, an empty
string will always return0001-01-01forDates, and0001-01-01T00:00:00.000forDateTimes.

Fixed-width slots are specified by repeating the period character the number of times corresponding to the
width with no delimiter between characters. Sodateformat"yyyymmdd"would correspond to a date string like
"20140716". The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition
"yyyymm"from one period character to the next.

Support for text-form month parsing is also supported through theuandUcharacters, for abbreviated and
full-length month names, respectively. By default, only English month names are supported, soucorre-
sponds to"Jan", "Feb ", "Mar", etc. AndUcorresponds to"January", "February", "March ", etc. Similar to other
name=>value mapping functionsdaynameandmonthname, custom locales can be loaded by passing in the
locale=>Dict{String,Int}mapping to theMONTHTOVALUEABBRandMONTHTOVALUEdicts for abbreviated and
full-name month names, respectively.

Theaboveexamplesusedthedateformat""stringmacro. ThismacrocreatesaDateFormatobjectoncewhen
the macro is expanded and uses the sameDateFormatobject even if a code snippet is run multiple times.


#### CHAPTER 64. DATES 922

```

julia>for i = 1:10^5  
Date ("2015-01-01", dateformat"y-m-d")  
end

```
Or you can create the DateFormat object explicitly:

```

julia> df = DateFormat("y-m-d");

julia> dt = Date ("2015-01-01",df)  
2015-01-01

julia> dt2 = Date ("2015-01-02",df)  
2015-01-02

```
Alternatively, use broadcasting:

```

julia> years= ["2015", "2016"];

julia>Date .(years, DateFormat("yyyy"))  
2-element Vector{Date}:  
2015-01-01  
2016-01-01

```
For convenience, you may pass the format string directly (e.g.,Date("2015-01-01","y-m-d")), although this
form incurs performance costs if you are parsing the same format repeatedly, as it internally creates a new
DateFormatobject each time.

As well as via the constructors, aDateorDateTimecan be constructed from strings using theparseand
tryparsefunctions,butwithanoptionalthirdargumentoftypeDateFormatspecifyingtheformat;forexample,
parse(Date, "06.23.2013", dateformat"m.d.y"),ortryparse(DateTime, "1999-12-31T23:59:59")which
uses the default format. The notable difference between the functions is that withtryparse, an error is not
thrown if the string is in an invalid format; insteadnothingis returned. Note however that as with the con-
structors above, empty date and time parts assume default values and consequently an empty string ("") is
valid for anyDateFormat, giving for example aDateof0001-01-01. Code relying onparseortryparsefor
DateandDateTimeparsing should therefore also check whether parsed strings are empty before using the
result.

A full suite of parsing and formatting tests and examples is available instdlib/Dates/test/io.jl.

### 64.2 Durations/Comparisons

Finding the length of time between twoDateorDateTimeis straightforward given their underlying representa-
tion asUTInstant{Day}andUTInstant{Millisecond}, respectively. The difference betweenDateis returned
in the number ofDay, andDateTimein the number ofMillisecond. Similarly, comparingTimeTypeis a simple
matter of comparing the underlying machine instants (which in turn compares the internalInt64values).

```

julia> dt = Date (2012,2,29)  
2012-02-29

julia> dt2 = Date (2000,2,1)  
2000-02-01

```

#### CHAPTER 64. DATES 923

```

julia> dump(dt)  
Date  
instant: Dates.UTInstant{Day}  
periods: Day  
value: Int64 734562

julia> dump(dt2)  
Date  
instant: Dates.UTInstant{Day}  
periods: Day  
value: Int64 730151

julia> dt > dt2  
true

julia> dt != dt2  
true

julia> dt + dt2  
ERROR: MethodError: no method matching +(::Date, ::Date)  
[...]

julia> dt * dt2  
ERROR: MethodError: no method matching *(::Date, ::Date)  
[...]

julia> dt / dt2  
ERROR: MethodError: no method matching /(::Date, ::Date)

julia> dt - dt2  
4411 days

julia> dt2 - dt  
-4411 days

julia> dt = DateTime (2012,2,29)  
2012-02-29T00:00:00

julia> dt2 = DateTime (2000,2,1)  
2000-02-01T00:00:00

julia> dt - dt2  
381110400000 milliseconds

```
### 64.3 Accessor Functions

Because theDateandDateTimetypes are stored as singleInt64values, date parts or fields can be retrieved
through accessor functions. The lowercase accessors return the field as an integer:

```

julia> t = Date (2014, 1, 31)  
2014-01-31

julia> Dates.year(t)  
2014

```

#### CHAPTER 64. DATES 924

```

julia> Dates.month(t)  
1

julia> Dates.week(t)  
5

julia> Dates.day(t)  
31

```
While propercase return the same value in the correspondingPeriodtype:

```

julia> Dates.Year(t)  
2014 years

julia> Dates.Day(t)  
31 days

```
Compound methods are provided because it is more efficient to access multiple fields at the same time than
individually:

```

julia> Dates.yearmonth(t)  
(2014, 1)

julia> Dates.monthday(t)  
(1, 31)

julia> Dates.yearmonthday(t)  
(2014, 1, 31)

```
One may also access the underlyingUTInstantor integer value:

```

julia> dump(t)  
Date  
instant: Dates.UTInstant{Day}  
periods: Day  
value: Int64 735264

julia> t.instant  
Dates.UTInstant{Day}(Day(735264))

julia> Dates.value(t)  
735264

```
### 64.4 Query Functions.

Query functions provide calendrical information about aTimeType. They include information about the day of
the week:

```

julia> t = Date (2014, 1, 31)  
2014-01-31

julia> Dates.dayofweek(t)

```

#### CHAPTER 64. DATES 925

```

5

julia> Dates.dayname(t)  
"Friday"

julia> Dates.dayofweekofmonth(t)# 5th Friday of January  
5

```
Month of the year:

```

julia> Dates.monthname(t)  
"January"

julia> Dates.daysinmonth(t)  
31

```
As well as information about theTimeType's year and quarter:

```

julia> Dates.isleapyear(t)  
false

julia> Dates.dayofyear(t)  
31

julia> Dates.quarterofyear(t)  
1

julia> Dates.dayofquarter(t)  
31

```
Thedaynameandmonthnamemethods can also take an optionallocalekeyword that can be used to return
the name of the day or month of the year for other languages/locales. There are also versions of these func-
tions returning the abbreviated names, namelydayabbrandmonthabbr. First the mapping is loaded into the
LOCALESvariable:

```

julia> french_months= ["janvier", "février", "mars", "avril", "mai", "juin",  
"juillet", "août", "septembre", "octobre", "novembre", "décembre"];

julia> french_monts_abbrev= ["janv","févr","mars","avril","mai","juin",  
"juil","août","sept","oct","nov","déc"];

julia> french_days= ["lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"];

julia> Dates.LOCALES["french"] = Dates.DateLocale(french_months, french_monts_abbrev, french_days,  
↪→ [""]);

```
The above mentioned functions can then be used to perform the queries:

```

julia> Dates.dayname(t;locale="french")  
"vendredi"

julia> Dates.monthname(t;locale="french")

```

#### CHAPTER 64. DATES 926

```

"janvier"

julia> Dates.monthabbr(t;locale="french")  
"janv"

```
Since the abbreviated versions of the days are not loaded, trying to use the functiondayabbrwill error.

```

julia> Dates.dayabbr(t;locale="french")  
ERROR: BoundsError: attempt to access 1-element Vector{String} at index [5]  
Stacktrace:  
[...]

```
### 64.5 TimeType-Period Arithmetic

It's good practice when using any language/date framework to be familiar with how date-period arithmetic is
handled as there are sometricky issuesto deal with (though much less so for day-precision types).

TheDatesmodule approach tries to follow the simple principle of trying to change as little as possible when
doingPeriodarithmetic. This approach is also often known as calendrical arithmetic or what you would prob-
ably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this?
Let 's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will sayMarch
3 (assumes 31 days). PHP saysMarch 2(assumes 30 days). The fact is, there is no right answer. In theDates
module, it gives the result of February 28th. How does it figure that out? Consider the classic 7-7-7 gambling
game in casinos.

Now just imagine that instead of 7-7-7, the slots are Year-Month-Day, or in our example, 2014-01-31. When
you ask to add 1 month to this date, the month slot is incremented, so now we have 2014-02-31. Then the day
number is checked if it is greater than the last valid day of the new month; if it is (as in the case above), the day
number is adjusted down to the last valid day (28). What are the ramifications with this approach? Go ahead
and add another month to our date,2014-02-28 + Month(1) == 2014-03-28. What? Were you expecting
the last day of March? Nope, sorry, remember the 7-7-7 slots. As few slots as possible are going to change, so
we first increment the month slot by 1, 2014-03-28, and boom, we're done because that's a valid date. On the
other hand, if we were to add 2 months to our original date, 2014-01-31, then we end up with 2014-03-31, as
expected. The other ramification of this approach is a loss in associativity when a specific ordering is forced
(i.e. adding things in different orders results in different outcomes). For example:

```

julia> ( Date (2014,1,29)+Dates.Day(1)) + Dates.Month(1)  
2014-02-28

julia> ( Date (2014,1,29)+Dates.Month(1)) + Dates.Day(1)  
2014-03-01

```
What's going on there? In the first line, we're adding 1 day to January 29th, which results in 2014-01-30; then
we add 1 month, so we get 2014-02-30, which then adjusts down to 2014-02-28. In the second example, we
add 1 month first, where we get 2014-02-29, which adjusts down to 2014-02-28, and then add 1 day, which
results in 2014-03-01. One design principle that helps in this case is that, in the presence of multiple Periods,
the operations will be ordered by the Periods' types, not their value or positional order; this meansYearwill
always be added first, thenMonth, thenWeek, etc. Hence the following does result in associativity and Just
Works:

```

julia>Date (2014,1,29) + Dates.Day(1) + Dates.Month(1)  
2014-03-01

```

#### CHAPTER 64. DATES 927

```

julia>Date (2014,1,29) + Dates.Month(1) + Dates.Day(1)  
2014-03-01

```
Tricky? Perhaps. What is an innocentDatesuser to do? The bottom line is to be aware that explicitly forcing
a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, ev-
erything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period
arithmetic when dealing with time in UT (avoiding the"joys" of dealing with daylight savings, leap seconds,
etc.).

As a bonus, all period arithmetic objects work directly with ranges:

```

julia> dr = Date (2014,1,29):Day(1): Date (2014,2,3)  
Date("2014-01-29"):Day(1):Date("2014-02-03")

julia> collect(dr)  
6-element Vector{Date}:  
2014-01-29  
2014-01-30  
2014-01-31  
2014-02-01  
2014-02-02  
2014-02-03

julia> dr = Date (2014,1,29):Dates.Month(1): Date (2014,07,29)  
Date("2014-01-29"):Month(1):Date("2014-07-29")

julia> collect(dr)  
7-element Vector{Date}:  
2014-01-29  
2014-02-28  
2014-03-29  
2014-04-29  
2014-05-29  
2014-06-29  
2014-07-29

```
### 64.6 Adjuster Functions.

Asconvenientasdate-periodarithmeticis,oftenthekindsofcalculationsneededondatestakeonacalendrical
or temporal nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules
such as"Memorial Day = Last Monday of May", or "Thanksgiving = 4th Thursday of November". These kinds
of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday,
or the first and third Wednesdays, etc.

TheDatesmodule provides the adjuster API through several convenient methods that aid in simply and suc-
cinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks,
months, quarters, and years. They each take a singleTimeTypeas input and return or adjust to the first or last
of the desired period relative to the input.

```

julia> Dates.firstdayofweek( Date (2014,7,16)) # Adjusts the input to the Monday of the input's week  
2014-07-14

julia> Dates.lastdayofmonth( Date (2014,7,16)) # Adjusts to the last day of the input's month

```

#### CHAPTER 64. DATES 928

```

2014-07-31

julia> Dates.lastdayofquarter( Date (2014,7,16)) # Adjusts to the last day of the input's quarter  
2014-09-30

```
The next two higher-order methods,tonext, andtoprev, generalize working with temporal expressions by
taking aDateFunctionas first argument, along with a startingTimeType. ADateFunctionis just a function,
usually anonymous, that takes a singleTimeTypeas input and returns aBool,trueindicating a satisfied
adjustment criterion. For example:

```

julia> istuesday= x->Dates.dayofweek(x)== Dates.Tuesday;# Returns true if the day of the week of  
↪→ x is Tuesday

julia> Dates.tonext(istuesday, Date (2014,7,13)) # 2014-07-13 is a Sunday  
2014-07-15

julia> Dates.tonext( Date (2014,7,13), Dates.Tuesday)# Convenience method provided for day of the  
↪→ week adjustments  
2014-07-15

```
This is useful with the do-block syntax for more complex temporal expressions:

```

julia> Dates.tonext( Date (2014,7,13)) do x

# Return true on the 4th Thursday of November (Thanksgiving)

Dates.dayofweek(x)== Dates.Thursday&&  
Dates.dayofweekofmonth(x)== 4 &&  
Dates.month(x)== Dates.November  
end  
2014-11-27

```
TheBase.filtermethod can be used to obtain all valid dates/moments in a specified range:

```

# Pittsburgh street cleaning; Every 2nd Tuesday from April to November

# Date range from January 1st, 2014 to January 1st, 2015

julia> dr = Dates. Date (2014):Day(1):Dates. Date (2015);

julia> filter(dr) do x  
Dates.dayofweek(x)== Dates.Tue &&  
Dates.April<= Dates.month(x)<= Dates.Nov &&  
Dates.dayofweekofmonth(x)== 2  
end  
8-element Vector{Date}:  
2014-04-08  
2014-05-13  
2014-06-10  
2014-07-08  
2014-08-12  
2014-09-09  
2014-10-14  
2014-11-11

```
Additional examples and tests are available instdlib/Dates/test/adjusters.jl.


#### CHAPTER 64. DATES 929

### 64.7 Period Types.

Periods are a human view of discrete, sometimes irregular durations of time. Consider 1 month; it could
represent, in days, a value of 28, 29, 30, or 31 depending on the year and month context. Or a year could
represent 365 or 366 days in the case of a leap year. Periodtypes are simpleInt64wrappers and are
constructed by wrapping anyInt64convertible type, i.e.Year(1)orMonth(3.0). Arithmetic betweenPeriod
of the same type behave like integers, and limitedPeriod-Realarithmetic is available. You can extract the
underlying integer withDates.value.

```

julia> y1 = Dates.Year(1)  
1 year

julia> y2 = Dates.Year(2)  
2 years

julia> y3 = Dates.Year(10)  
10 years

julia> y1 + y2  
3 years

julia> div(y3,y2)  
5

julia> y3 - y2  
8 years

julia> y3 % y2  
0 years

julia> div(y3,3) # mirrors integer division  
3 years

julia> Dates.value(Dates.Millisecond(10))  
10

```
### 64.8 Rounding

DateandDateTimevalues can be rounded to a specified resolution (e.g., 1 month or 15 minutes) withfloor,
ceil, orround:

```

julia> floor( Date (1985, 8, 16), Dates.Month)  
1985-08-01

julia> ceil( DateTime (2013, 2, 13, 0, 31, 20), Dates.Minute(15))  
2013-02-13T00:45:00

julia> round( DateTime (2016, 8, 6, 20, 15), Dates.Day)  
2016-08-07T00:00:00

```
Unlike the numericroundmethod, which breaks ties toward the even number by default, theTimeTyperound
method uses theRoundNearestTiesUprounding mode. (It's difficult to guess what breaking ties to nearest
"even"TimeTypewould entail.) Further details on the availableRoundingModes can be found in theAPI refer-
ence.


#### CHAPTER 64. DATES 930

Rounding should generally behave as expected, but there are a few cases in which the expected behaviour is
not obvious.

### Rounding Epoch

In many cases, the resolution specified for rounding (e.g.,Dates.Second(30)) divides evenly into the next
largest period (in this case,Dates.Minute(1)). But rounding behaviour in cases in which this is not true may
lead to confusion. What is the expected result of rounding aDateTimeto the nearest 10 hours?

```

julia> round( DateTime (2016, 7, 17, 11, 55), Dates.Hour(10))  
2016-07-17T12:00:00

```
Thatmayseemconfusing,giventhatthehour(12)isnotdivisibleby10. Thereasonthat2016-07-17T12:00:00
was chosen is that it is 17,676,660 hours after0000-01-01T00:00:00, and 17,676,660 is divisible by 10.

As JuliaDateandDateTimevalues are represented according to the ISO 8601 standard,0000-01-01T00:00:00
was chosen as base (or"rounding epoch") from which to begin the count of days (and milliseconds) used in
roundingcalculations. (NotethatthisdiffersslightlyfromJulia'sinternalrepresentationofDatesusingRataDie
notation; but since the ISO 8601 standard is most visible to the end user,0000-01-01T00:00:00was chosen
as the rounding epoch instead of the0000-12-31T00:00:00used internally to minimize confusion.)

The only exception to the use of0000-01-01T00:00:00as the rounding epoch is when rounding to weeks.
Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601).
For this reason, we use0000-01-03T00:00:00(the first day of the first week of year 0000, as defined by ISO
8601) as the base when rounding to a number of weeks.

Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we
roundtothenearestP(2),wherePisaPeriodtype? Insomecases(specifically,whenP <: Dates.TimePeriod)
the answer is clear:

```

julia> round( DateTime (2016, 7, 17, 8, 55, 30), Dates.Hour(2))  
2016-07-17T08:00:00

julia> round( DateTime (2016, 7, 17, 8, 55, 30), Dates.Minute(2))  
2016-07-17T08:56:00

```
This seems obvious, because two of each of these periods still divides evenly into the next larger order period.
But in the case of two months (which still divides evenly into one year), the answer may be surprising:

```

julia> round( DateTime (2016, 7, 17, 8, 55, 30), Dates.Month(2))  
2016-07-01T00:00:00

```
Why round to the first day in July, even though it is month 7 (an odd number)? The key is that months are
1-indexed (the first month is assigned 1), unlike hours, minutes, seconds, and milliseconds (the first of which
are assigned 0).

This means that rounding aDateTimeto an even multiple of seconds, minutes, hours, or years (because the
ISO 8601 specification includes a year zero) will result in aDateTimewith an even value in that field, while
roundingaDateTimetoanevenmultipleofmonthswillresultinthemonthsfieldhavinganoddvalue. Because
both months and years may contain an irregular number of days, whether rounding to an even number of days
will result in an even value in the days field is uncertain.

See theAPI referencefor additional information on methods exported from theDatesmodule.


**Chapter 65**

**API reference**

### 65.1 Dates and Time Types.

Dates.Period– Type.

```

Period  
Year  
Quarter  
Month  
Week  
Day  
Hour  
Minute  
Second  
Millisecond  
Microsecond  
Nanosecond

Periodtypes represent discrete, human representations of time.

```
Dates.CompoundPeriod– Type.

```

CompoundPeriod

ACompoundPeriodis useful for expressing time periods that are not a fixed multiple of smaller periods. For  
example,"a year and a day" is not a fixed number of days, but can be expressed using aCompoundPeriod.  
In fact, aCompoundPeriodis automatically generated by addition of different period types, e.g.Year(1)

-   Day(1)produces aCompoundPeriodresult.

```
Dates.Instant– Type.

```

Instant

Instanttypes represent integer-based, machine representations of time as continuous timelines starting  
from an epoch.

```
Dates.UTInstant– Type.

```

UTInstant{T}

TheUTInstantrepresents a machine timeline based on UT time (1 day = one revolution of the earth). The  
Tis aPeriodparameter that indicates the resolution or precision of the instant.

```
#### 931


#### CHAPTER 65. API REFERENCE 932

Dates.TimeType– Type.

```

TimeType

TimeTypetypeswrapInstantmachineinstancestoprovidehumanrepresentationsofthemachineinstant.  
Time,DateTimeandDateare subtypes ofTimeType.

```
Dates.DateTime– Type.

```

DateTime

DateTimewraps aUTInstant{Millisecond}and interprets it according to the proleptic Gregorian calen-  
dar.

```
Dates.Date– Type.

```

Date

Datewraps aUTInstant{Day}and interprets it according to the proleptic Gregorian calendar.

```
Dates.Time– Type.

```

Time

Timewraps aNanosecondand represents a specific moment in a 24-hour day.

```
Dates.TimeZone– Type.

```

TimeZone

Geographic zone generally based on longitude determining what the time is at a certain location. Some  
time zones observe daylight savings (eg EST -> EDT). For implementations and more support, see the  
TimeZones.jlpackage

```
Dates.UTC– Type.

```

UTC

UTC, or Coordinated Universal Time, is theTimeZonefrom which all others are measured. It is associated  
with the time at 0° longitude. It is not adjusted for daylight savings.

```
### 65.2 Dates Functions

Dates.DateTime– Method.

```

DateTime (y, [m, d, h, mi, s, ms])-> DateTime

Construct aDateTimetype by parts. Arguments must be convertible toInt64.

```
Dates.DateTime– Method.

```

DateTime (periods::Period...) -> DateTime

Construct aDateTimetype byPeriodtype parts. Arguments may be in any order. DateTime parts not  
provided will default to the value ofDates.default(period).

```
Dates.DateTime– Method.


#### CHAPTER 65. API REFERENCE 933

```

DateTime (f:: Function , y[, m, d, h, mi, s]; step=Day(1), limit=10000) -> DateTime

Create aDateTimethrough the adjuster API. The starting point will be constructed from the providedy,  
m, d...arguments, and will be adjusted untilf::Functionreturnstrue. The step size in adjusting can  
be provided manually through thestepkeyword.limitprovides a limit to the max number of iterations  
the adjustment API will pursue before throwing an error (in the case thatf::Functionis never satisfied).  
Examples

julia>DateTime (dt -> Dates.second(dt)== 40, 2010, 10, 20, 10; step= Dates.Second(1))  
2010-10-20T10:00:40

julia>DateTime (dt -> Dates.hour(dt)== 20, 2010, 10, 20, 10; step= Dates.Hour(1), limit= 5)  
ERROR: ArgumentError: Adjustment limit reached: 5 iterations  
Stacktrace:  
[...]

```
Dates.DateTime– Method.

```

DateTime (dt:: Date ) -> DateTime

Convert aDateto aDateTime. The hour, minute, second, and millisecond parts of the newDateTimeare  
assumed to be zero.

```
Dates.DateTime– Method.

```

DateTime (dt:: AbstractString , format:: AbstractString ; locale="english") -> DateTime

Construct aDateTimeby parsing thedtdate time string following the pattern given in theformatstring  
(seeDateFormatfor syntax).

Note  
This method creates aDateFormatobject each time it is called. It is recommended that you  
create aDateFormatobject instead and use that as the second argument to avoid performance  
loss when using the same format repeatedly.

Example

julia>DateTime ("2020-01-01", "yyyy-mm-dd")  
2020-01-01T00:00:00

julia> a = ("2020-01-01", "2020-01-02");

julia> [ DateTime (d, dateformat"yyyy-mm-dd") for d ∈ a] # preferred  
2-element Vector{DateTime}:  
2020-01-01T00:00:00  
2020-01-02T00:00:00

```
Dates.format– Method.

```

format(dt::TimeType, format:: AbstractString ; locale="english") -> AbstractString

Construct a string by using aTimeTypeobject and applying the providedformat. The following character  
codes can be used to construct theformatstring:

```

#### CHAPTER 65. API REFERENCE 934

```

Code Examples Comment  
y 6 Numeric year with a fixed width  
Y 1996 Numeric year with a minimum width  
m 1, 12 Numeric month with a minimum width  
u Jan Month name shortened to 3-chars according to thelocale  
U January Full month name according to thelocalekeyword  
d 1, 31 Day of the month with a minimum width  
H 0, 23 Hour (24-hour clock) with a minimum width  
M 0, 59 Minute with a minimum width  
S 0, 59 Second with a minimum width  
s 000, 500 Millisecond with a minimum width of 3  
e Mon, Tue Abbreviated days of the week  
E Monday Full day of week name

The number of sequential code characters indicate the width of the code. A format ofyyyy-mmspecifies  
that the codeyshould have a width of four whilema width of two. Codes that yield numeric digits have  
an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros  
when it is shorter than the specified width and truncates the value when longer. Minimum-width mode  
works the same as fixed-width except that it does not truncate values longer than the width.  
When creating aformatyou can use any non-code characters as a separator. For example to generate  
the string"1996-01-15T00:00:00" you could useformat: "yyyy-mm-ddTHH:MM:SS". Note that if you need  
to use a code character as a literal you can use the escape character backslash. The string"1996y01m"  
can be produced with the format"yyyy\ymm\m".

```
Dates.DateFormat– Type.

```

DateFormat(format:: AbstractString , locale="english") -> DateFormat

Construct a date formatting object that can be used for parsing date strings or formatting a date object as  
a string. The following character codes can be used to construct theformatstring:

Code Matches Comment  
y 1996, 96 Returns year of 1996, 0096  
Y 1996, 96 Returns year of 1996, 0096. Equivalent toy  
m 1, 01 Matches 1 or 2-digit months  
u Jan Matches abbreviated months according to thelocalekeyword  
U January Matches full month names according to thelocalekeyword  
d 1, 01 Matches 1 or 2-digit days  
H 00 Matches hours (24-hour clock)  
I 00 For outputting hours with 12-hour clock  
M 00 Matches minutes  
S 00 Matches seconds  
s .500 Matches milliseconds  
e Mon, Tues Matches abbreviated days of the week  
E Monday Matches full name days of the week  
p AM Matches AM/PM (case-insensitive)  
yyyymmdd 19960101 Matches fixed-width year, month, and day

Characters not listed above are normally treated as delimiters between date and time slots. For example  
adtstring of"1996-01-15T00:00:00.0" would have aformatstring like"y-m-dTH:M:S.s". If you need to

```

#### CHAPTER 65. API REFERENCE 935

```

use a code character as a delimiter you can escape it using backslash. The date"1995y01m" would have  
the format"y\ym\m".  
Notethat12:00AMcorresponds00:00(midnight),and12:00PMcorrespondsto12:00(noon). Whenparsing  
atimewithapspecifier, anyhour(eitherHorI)isinterpretedasasa12-hourclock, sotheIcodeismainly  
useful for output.  
Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try  
thedateformat""string macro. Using this macro creates the DateFormat object once at macro expansion  
time and reuses it later. There are also severalpre-defined formatters, listed later.  
SeeDateTimeandformatfor how to use a DateFormat object to parse and write Date strings respectively.

```
Dates.@dateformat_str– Macro.

```

dateformat"Y-m-d H:M:S"

Create aDateFormatobject. Similar toDateFormat("Y-m-d H:M:S")but creates the DateFormat object  
once during macro expansion.  
SeeDateFormatfor details about format specifiers.

```
Dates.DateTime– Method.

```

DateTime (dt:: AbstractString , df ::DateFormat=ISODateTimeFormat)-> DateTime

Construct aDateTimeby parsing thedtdate time string following the pattern given in theDateFormat  
object, or dateformat"yyyy-mm-ddTHH:MM:SS.s" if omitted.  
SimilartoDateTime(::AbstractString, ::AbstractString)butmoreefficientwhenrepeatedlyparsing  
similarly formatted date time strings with a pre-createdDateFormatobject.

```
Dates.Date– Method.

```

Date (y, [m, d])-> Date

Construct aDatetype by parts. Arguments must be convertible toInt64.

```
Dates.Date– Method.

```

Date (period::Period...) -> Date

Construct aDatetype byPeriodtype parts. Arguments may be in any order.Dateparts not provided will  
default to the value ofDates.default(period).

```
Dates.Date– Method.

```

Date (f:: Function , y[, m, d]; step=Day(1), limit=10000) -> Date

Create aDatethrough the adjuster API. The starting point will be constructed from the providedy, m, d  
arguments, andwillbeadjusteduntilf::Functionreturnstrue. Thestepsizeinadjustingcanbeprovided  
manuallythroughthestepkeyword.limitprovidesalimittothemaxnumberofiterationstheadjustment  
API will pursue before throwing an error (given thatf::Functionis never satisfied).  
Examples

```

#### CHAPTER 65. API REFERENCE 936

```

julia>Date (date-> Dates.week(date)== 20, 2010, 01, 01)  
2010-05-17

julia>Date (date-> Dates.year(date)== 2010, 2000, 01, 01)  
2010-01-01

julia>Date (date-> Dates.month(date)== 10, 2000, 01, 01; limit= 5)  
ERROR: ArgumentError: Adjustment limit reached: 5 iterations  
Stacktrace:  
[...]

```
Dates.Date– Method.

```

Date (dt:: DateTime ) -> Date

Convert aDateTimeto aDate. The hour, minute, second, and millisecond parts of theDateTimeare  
truncated, so only the year, month and day parts are used in construction.

```
Dates.Date– Method.

```

Date (d:: AbstractString , format:: AbstractString ; locale="english") -> Date

ConstructaDatebyparsingtheddatestringfollowingthepatterngivenintheformatstring(seeDateFormat  
for syntax).

Note  
This method creates aDateFormatobject each time it is called. It is recommended that you  
create aDateFormatobject instead and use that as the second argument to avoid performance  
loss when using the same format repeatedly.

Example

julia>Date ("2020-01-01", "yyyy-mm-dd")  
2020-01-01

julia> a = ("2020-01-01", "2020-01-02");

julia> [ Date (d, dateformat"yyyy-mm-dd") for d ∈ a] # preferred  
2-element Vector{Date}:  
2020-01-01  
2020-01-02

```
Dates.Date– Method.

```

Date (d:: AbstractString , df ::DateFormat=ISODateFormat)-> Date

Construct aDateby parsing theddate string following the pattern given in theDateFormatobject, or  
dateformat"yyyy-mm-dd" if omitted.  
SimilartoDate(::AbstractString, ::AbstractString)butmoreefficientwhenrepeatedlyparsingsim-  
ilarly formatted date strings with a pre-createdDateFormatobject.

```
Dates.Time– Method.

```

Time(h, [mi, s, ms, us, ns])-> Time

```

#### CHAPTER 65. API REFERENCE 937

```

Construct aTimetype by parts. Arguments must be convertible toInt64.

```
Dates.Time– Method.

```

Time(period::TimePeriod...) -> Time

Construct aTimetype byPeriodtype parts. Arguments may be in any order.Timeparts not provided will  
default to the value ofDates.default(period).

```
Dates.Time– Method.

```

Time(f:: Function , h, mi=0; step::Period=Second(1), limit:: Int =10000)  
Time(f:: Function , h, mi, s; step::Period=Millisecond(1), limit:: Int =10000)  
Time(f:: Function , h, mi, s, ms; step::Period=Microsecond(1), limit:: Int =10000)  
Time(f:: Function , h, mi, s, ms, us; step::Period=Nanosecond(1), limit:: Int =10000)

Create aTimethrough the adjuster API. The starting point will be constructed from the providedh, mi, s,  
ms, usarguments, and will be adjusted untilf::Functionreturnstrue. The step size in adjusting can be  
provided manually through thestepkeyword.limitprovides a limit to the max number of iterations the  
adjustment API will pursue before throwing an error (in the case thatf::Functionis never satisfied). Note  
that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute,  
and second arguments are provided, the default step will beMillisecond(1)instead ofSecond(1).  
Examples

julia> Dates.Time(t-> Dates.minute(t)== 30, 20)  
20:30:00

julia> Dates.Time(t-> Dates.minute(t)== 0, 20)  
20:00:00

julia> Dates.Time(t-> Dates.hour(t)== 10, 3; limit= 5)  
ERROR: ArgumentError: Adjustment limit reached: 5 iterations  
Stacktrace:  
[...]

```
Dates.Time– Method.

```

Time(dt:: DateTime ) -> Time

Convert aDateTimeto aTime. The hour, minute, second, and millisecond parts of theDateTimeare used  
to create the newTime. Microsecond and nanoseconds are zero by default.

```
Dates.Time– Method.

```

Time(t:: AbstractString , format:: AbstractString ; locale="english") -> Time

ConstructaTimebyparsingthettimestringfollowingthepatterngivenintheformatstring(seeDateFormat  
for syntax).

Note  
This method creates aDateFormatobject each time it is called. It is recommended that you  
create aDateFormatobject instead and use that as the second argument to avoid performance  
loss when using the same format repeatedly.

Example

```

#### CHAPTER 65. API REFERENCE 938

```

julia> Time("12:34pm", "HH:MMp")  
12:34:00

julia> a = ("12:34pm", "2:34am");

julia> [Time(d, dateformat"HH:MMp") for d ∈ a] # preferred  
2-element Vector{Time}:  
12:34:00  
02:34:00

```
Dates.Time– Method.

```

Time(t:: AbstractString , df ::DateFormat=ISOTimeFormat)-> Time

Construct aTimeby parsing thetdate time string following the pattern given in theDateFormatobject,  
or dateformat"HH:MM:SS.s" if omitted.  
SimilartoTime(::AbstractString, ::AbstractString)butmoreefficientwhenrepeatedlyparsingsim-  
ilarly formatted time strings with a pre-createdDateFormatobject.

```
Dates.now– Method.

```

now()-> DateTime

Return aDateTimecorresponding to the user's system time including the system timezone locale.

```
Dates.now– Method.

```

now(:: Type {UTC})-> DateTime

Return aDateTimecorresponding to the user's system time as UTC/GMT.

```
Base.eps– Method.

```

eps(:: Type { DateTime }) -> Millisecond  
eps(:: Type { Date }) -> Day  
eps(:: Type {Time})-> Nanosecond  
eps(::TimeType)-> Period

Return the smallest unit value supported by theTimeType.  
Examples

julia> eps( DateTime )  
1 millisecond

julia> eps( Date )  
1 day

julia> eps(Time)  
1 nanosecond

```
### Accessor Functions

Dates.year– Function.

```

year(dt::TimeType)-> Int64

```

#### CHAPTER 65. API REFERENCE 939

```

The year of aDateorDateTimeas anInt64.

```
Dates.month– Function.

```

month(dt::TimeType)-> Int64

The month of aDateorDateTimeas anInt64.

```
Dates.week– Function.

```

week(dt::TimeType)-> Int64

Return theISO week dateof aDateorDateTimeas anInt64. Note that the first week of a year is the week  
that contains the first Thursday of the year, which can result in dates prior to January 4th being in the last  
week of the previous year. For example,week(Date(2005, 1, 1))is the 53rd week of 2004.  
Examples

julia> Dates.week( Date (1989, 6, 22))  
25

julia> Dates.week( Date (2005, 1, 1))  
53

julia> Dates.week( Date (2004, 12, 31))  
53

```
Dates.day– Function.

```

day(dt::TimeType)-> Int64

The day of month of aDateorDateTimeas anInt64.

```
Dates.hour– Function.

```

hour(dt:: DateTime ) -> Int64

The hour of day of aDateTimeas anInt64.  
hour(t::Time) -> Int64

The hour of aTimeas anInt64.

```
Dates.minute– Function.

```

minute(dt:: DateTime ) -> Int64

The minute of aDateTimeas anInt64.  
minute(t::Time) -> Int64

The minute of aTimeas anInt64.

```
Dates.second– Function.

```

second(dt:: DateTime ) -> Int64

The second of aDateTimeas anInt64.

```

#### CHAPTER 65. API REFERENCE 940

```

second(t::Time) -> Int64

The second of aTimeas anInt64.

```
Dates.millisecond– Function.

```

millisecond(dt:: DateTime ) -> Int64

The millisecond of aDateTimeas anInt64.  
millisecond(t::Time) -> Int64

The millisecond of aTimeas anInt64.

```
Dates.microsecond– Function.

```

microsecond(t::Time)-> Int64

The microsecond of aTimeas anInt64.

```
Dates.nanosecond– Function.

```

nanosecond(t::Time)-> Int64

The nanosecond of aTimeas anInt64.

```
Dates.Year– Method.

```

Year(v)

Construct aYearobject with the givenvvalue. Input must be losslessly convertible to anInt64.

```
Dates.Month– Method.

```

Month(v)

Construct aMonthobject with the givenvvalue. Input must be losslessly convertible to anInt64.

```
Dates.Week– Method.

```

Week(v)

Construct aWeekobject with the givenvvalue. Input must be losslessly convertible to anInt64.

```
Dates.Day– Method.

```

Day(v)

Construct aDayobject with the givenvvalue. Input must be losslessly convertible to anInt64.

```
Dates.Hour– Method.

```

Hour(dt:: DateTime ) -> Hour

The hour part of a DateTime as aHour.

```
Dates.Minute– Method.

```

Minute(dt:: DateTime ) -> Minute

```

#### CHAPTER 65. API REFERENCE 941

```

The minute part of a DateTime as aMinute.

```
Dates.Second– Method.

```

Second(dt:: DateTime ) -> Second

The second part of a DateTime as aSecond.

```
Dates.Millisecond– Method.

```

Millisecond(dt:: DateTime ) -> Millisecond

The millisecond part of a DateTime as aMillisecond.

```
Dates.Microsecond– Method.

```

Microsecond(dt::Time)-> Microsecond

The microsecond part of a Time as aMicrosecond.

```
Dates.Nanosecond– Method.

```

Nanosecond(dt::Time)-> Nanosecond

The nanosecond part of a Time as aNanosecond.

```
Dates.yearmonth– Function.

```

yearmonth(dt::TimeType)-> ( Int64 , Int64 )

Simultaneously return the year and month parts of aDateorDateTime.

```
Dates.monthday– Function.

```

monthday(dt::TimeType)-> ( Int64 , Int64 )

Simultaneously return the month and day parts of aDateorDateTime.

```
Dates.yearmonthday– Function.

```

yearmonthday(dt::TimeType)-> ( Int64 , Int64 , Int64 )

Simultaneously return the year, month and day parts of aDateorDateTime.

```
### Query Functions

Dates.dayname– Function.

```

dayname(dt::TimeType; locale="english") -> String  
dayname(day:: Integer ; locale="english") -> String

ReturnthefulldaynamecorrespondingtothedayoftheweekoftheDateorDateTimeinthegivenlocale.  
Also acceptsInteger.  
Examples

```

#### CHAPTER 65. API REFERENCE 942

```

julia> Dates.dayname( Date ("2000-01-01"))  
"Saturday"

julia> Dates.dayname(4)  
"Thursday"

```
Dates.dayabbr– Function.

```

dayabbr(dt::TimeType; locale="english") -> String  
dayabbr(day:: Integer ; locale="english") -> String

Return the abbreviated name corresponding to the day of the week of theDateorDateTimein the given  
locale. Also acceptsInteger.  
Examples

julia> Dates.dayabbr( Date ("2000-01-01"))  
"Sat"

julia> Dates.dayabbr(3)  
"Wed"

```
Dates.dayofweek– Function.

```

dayofweek(dt::TimeType)-> Int64

Return the day of the week as anInt64with1 = Monday, 2 = Tuesday, etc..  
Examples

julia> Dates.dayofweek( Date ("2000-01-01"))  
6

```
Dates.dayofmonth– Function.

```

dayofmonth(dt::TimeType)-> Int64

The day of month of aDateorDateTimeas anInt64.

```
Dates.dayofweekofmonth– Function.

```

dayofweekofmonth(dt::TimeType)-> Int

Forthedayofweekofdt, returnwhichnumberitisindt'smonth. SoifthedayoftheweekofdtisMonday,  
then1 = First Monday of the month, 2 = Second Monday of the month, etc.In the range 1:5.  
Examples

julia> Dates.dayofweekofmonth( Date ("2000-02-01"))  
1

julia> Dates.dayofweekofmonth( Date ("2000-02-08"))  
2

julia> Dates.dayofweekofmonth( Date ("2000-02-15"))  
3

```

#### CHAPTER 65. API REFERENCE 943

Dates.daysofweekinmonth– Function.

```

daysofweekinmonth(dt::TimeType)-> Int

For the day of week ofdt, return the total number of that day of the week indt's month. Returns  
4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including  
dayofweekofmonth(dt) == daysofweekinmonth(dt)in the adjuster function.  
Examples

julia> Dates.daysofweekinmonth( Date ("2005-01-01"))  
5

julia> Dates.daysofweekinmonth( Date ("2005-01-04"))  
4

```
Dates.monthname– Function.

```

monthname(dt::TimeType; locale="english") -> String  
monthname(month:: Integer , locale="english") -> String

Return the full name of the month of theDateorDateTimeorIntegerin the givenlocale.  
Examples

julia> Dates.monthname( Date ("2005-01-04"))  
"January"

julia> Dates.monthname(2)  
"February"

```
Dates.monthabbr– Function.

```

monthabbr(dt::TimeType; locale="english") -> String  
monthabbr(month:: Integer , locale="english") -> String

Return the abbreviated month name of theDateorDateTimeorIntegerin the givenlocale.  
Examples

julia> Dates.monthabbr( Date ("2005-01-04"))  
"Jan"

julia> monthabbr(2)  
"Feb"

```
Dates.daysinmonth– Function.

```

daysinmonth(dt::TimeType)-> Int

Return the number of days in the month ofdt. Value will be 28, 29, 30, or 31.  
Examples

```

#### CHAPTER 65. API REFERENCE 944

```

julia> Dates.daysinmonth( Date ("2000-01"))  
31

julia> Dates.daysinmonth( Date ("2001-02"))  
28

julia> Dates.daysinmonth( Date ("2000-02"))  
29

```
Dates.isleapyear– Function.

```

isleapyear(dt::TimeType)-> Bool

Returntrueif the year ofdtis a leap year.  
Examples

julia> Dates.isleapyear( Date ("2004"))  
true

julia> Dates.isleapyear( Date ("2005"))  
false

```
Dates.dayofyear– Function.

```

dayofyear(dt::TimeType)-> Int

Return the day of the year fordtwith January 1st being day 1.

```
Dates.daysinyear– Function.

```

daysinyear(dt::TimeType)-> Int

Return 366 if the year ofdtis a leap year, otherwise return 365.  
Examples

julia> Dates.daysinyear(1999)  
365

julia> Dates.daysinyear(2000)  
366

```
Dates.quarterofyear– Function.

```

quarterofyear(dt::TimeType)-> Int

Return the quarter thatdtresides in. Range of value is 1:4.

```
Dates.dayofquarter– Function.

```

dayofquarter(dt::TimeType)-> Int

Return the day of the current quarter ofdt. Range of value is 1:92.

```

#### CHAPTER 65. API REFERENCE 945

### Adjuster Functions

Base.trunc– Method.

```

trunc(dt::TimeType,:: Type {Period})-> TimeType

Truncates the value ofdtaccording to the providedPeriodtype.  
Examples

julia> trunc(Dates. DateTime ("1996-01-01T12:30:00"), Dates.Day)  
1996-01-01T00:00:00

```
Dates.firstdayofweek– Function.

```

firstdayofweek(dt::TimeType)-> TimeType

Adjustsdtto the Monday of its week.  
Examples

julia> Dates.firstdayofweek( DateTime ("1996-01-05T12:30:00"))  
1996-01-01T00:00:00

```
Dates.lastdayofweek– Function.

```

lastdayofweek(dt::TimeType)-> TimeType

Adjustsdtto the Sunday of its week.  
Examples

julia> Dates.lastdayofweek( DateTime ("1996-01-05T12:30:00"))  
1996-01-07T00:00:00

```
Dates.firstdayofmonth– Function.

```

firstdayofmonth(dt::TimeType)-> TimeType

Adjustsdtto the first day of its month.  
Examples

julia> Dates.firstdayofmonth( DateTime ("1996-05-20"))  
1996-05-01T00:00:00

```
Dates.lastdayofmonth– Function.

```

lastdayofmonth(dt::TimeType)-> TimeType

Adjustsdtto the last day of its month.  
Examples

julia> Dates.lastdayofmonth( DateTime ("1996-05-20"))  
1996-05-31T00:00:00

```
Dates.firstdayofyear– Function.


#### CHAPTER 65. API REFERENCE 946

```

firstdayofyear(dt::TimeType)-> TimeType

Adjustsdtto the first day of its year.  
Examples

julia> Dates.firstdayofyear( DateTime ("1996-05-20"))  
1996-01-01T00:00:00

```
Dates.lastdayofyear– Function.

```

lastdayofyear(dt::TimeType)-> TimeType

Adjustsdtto the last day of its year.  
Examples

julia> Dates.lastdayofyear( DateTime ("1996-05-20"))  
1996-12-31T00:00:00

```
Dates.firstdayofquarter– Function.

```

firstdayofquarter(dt::TimeType)-> TimeType

Adjustsdtto the first day of its quarter.  
Examples

julia> Dates.firstdayofquarter( DateTime ("1996-05-20"))  
1996-04-01T00:00:00

julia> Dates.firstdayofquarter( DateTime ("1996-08-20"))  
1996-07-01T00:00:00

```
Dates.lastdayofquarter– Function.

```

lastdayofquarter(dt::TimeType)-> TimeType

Adjustsdtto the last day of its quarter.  
Examples

julia> Dates.lastdayofquarter( DateTime ("1996-05-20"))  
1996-06-30T00:00:00

julia> Dates.lastdayofquarter( DateTime ("1996-08-20"))  
1996-09-30T00:00:00

```
Dates.tonext– Method.

```

tonext(dt::TimeType, dow:: Int ; same:: Bool = false ) -> TimeType

Adjustsdtto the next day of week corresponding todowwith1 = Monday, 2 = Tuesday, etc. Setting  
same=trueallows the currentdtto be considered as the nextdow, allowing for no adjustment to occur.

```
Dates.toprev– Method.


#### CHAPTER 65. API REFERENCE 947

```

toprev(dt::TimeType, dow:: Int ; same:: Bool = false ) -> TimeType

Adjustsdtto the previous day of week corresponding todowwith1 = Monday, 2 = Tuesday, etc. Set-  
tingsame=trueallows the currentdtto be considered as the previousdow, allowing for no adjustment to  
occur.

```
Dates.tofirst– Function.

```

tofirst(dt::TimeType, dow:: Int ; of =Month)-> TimeType

Adjustsdtto the firstdowof its month. Alternatively,of=Yearwill adjust to the firstdowof the year.

```
Dates.tolast– Function.

```

tolast(dt::TimeType, dow:: Int ; of =Month)-> TimeType

Adjustsdtto the lastdowof its month. Alternatively,of=Yearwill adjust to the lastdowof the year.

```
Dates.tonext– Method.

```

tonext(func:: Function , dt ::TimeType; step=Day(1), limit=10000, same= false ) -> TimeType

Adjustsdtby iterating at mostlimititerations bystepincrements untilfuncreturnstrue. funcmust  
take a singleTimeTypeargument and return aBool.sameallowsdtto be considered in satisfyingfunc.

```
Dates.toprev– Method.

```

toprev(func:: Function , dt ::TimeType; step=Day(-1), limit=10000, same= false ) -> TimeType

Adjustsdtby iterating at mostlimititerations bystepincrements untilfuncreturnstrue. funcmust  
take a singleTimeTypeargument and return aBool.sameallowsdtto be considered in satisfyingfunc.

```
### Periods

Dates.Period– Method.

```

Year(v)  
Quarter(v)  
Month(v)  
Week(v)  
Day(v)  
Hour(v)  
Minute(v)  
Second(v)  
Millisecond(v)  
Microsecond(v)  
Nanosecond(v)

Construct aPeriodtype with the givenvvalue. Input must be losslessly convertible to anInt64.

```
Dates.CompoundPeriod– Method.

```

CompoundPeriod(periods)-> CompoundPeriod

Construct aCompoundPeriodfrom aVectorofPeriods. AllPeriods of the same type will be added to-  
gether.  
Examples

```

#### CHAPTER 65. API REFERENCE 948

```

julia> Dates.CompoundPeriod(Dates.Hour(12), Dates.Hour(13))  
25 hours

julia> Dates.CompoundPeriod(Dates.Hour(-1), Dates.Minute(1))  
-1 hour, 1 minute

julia> Dates.CompoundPeriod(Dates.Month(1), Dates.Week(-2))  
1 month, -2 weeks

julia> Dates.CompoundPeriod(Dates.Minute( 50000 ))  
50000 minutes

```
Dates.value– Function.

```

Dates.value(x::Period)-> Int64

For a given period, return the value associated with that period. For example,value(Millisecond(10))  
returns 10 as an integer.

```
Dates.default– Function.

```

default(p::Period)-> Period

Returns a sensible"default" value for the input Period by returningT(1)for Year, Month, and Day, and  
T(0)for Hour, Minute, Second, and Millisecond.

```
Dates.periods– Function.

```

Dates.periods(::CompoundPeriod)-> Vector {Period}

Return theVectorofPeriods that comprise the givenCompoundPeriod.

Julia 1.7  
This function requires Julia 1.7 or later.

```
### Rounding Functions

DateandDateTimevalues can be rounded to a specified resolution (e.g., 1 month or 15 minutes) withfloor,
ceil, orround.

Base.floor– Method.

```

floor(dt::TimeType, p::Period)-> TimeType

Return the nearestDateorDateTimeless than or equal todtat resolutionp.  
For convenience,pmay be a type instead of a value:floor(dt, Dates.Hour)is a shortcut forfloor(dt,  
Dates.Hour(1)).

julia> floor( Date (1985, 8, 16), Dates.Month)  
1985-08-01

julia> floor( DateTime (2013, 2, 13, 0, 31, 20), Dates.Minute(15))  
2013-02-13T00:30:00

julia> floor( DateTime (2016, 8, 6, 12, 0, 0), Dates.Day)  
2016-08-06T00:00:00

```

#### CHAPTER 65. API REFERENCE 949

Base.ceil– Method.

```

ceil(dt::TimeType, p::Period)-> TimeType

Return the nearestDateorDateTimegreater than or equal todtat resolutionp.  
For convenience,pmay be a type instead of a value:ceil(dt, Dates.Hour)is a shortcut forceil(dt,  
Dates.Hour(1)).

julia> ceil( Date (1985, 8, 16), Dates.Month)  
1985-09-01

julia> ceil( DateTime (2013, 2, 13, 0, 31, 20), Dates.Minute(15))  
2013-02-13T00:45:00

julia> ceil( DateTime (2016, 8, 6, 12, 0, 0), Dates.Day)  
2016-08-07T00:00:00

```
Base.round– Method.

```

round(dt::TimeType, p::Period, [r:: RoundingMode ]) -> TimeType

Return theDateorDateTimenearest todtat resolutionp. By default (RoundNearestTiesUp), ties (e.g.,  
rounding 9:30 to the nearest hour) will be rounded up.  
For convenience,pmay be a type instead of a value:round(dt, Dates.Hour)is a shortcut forround(dt,  
Dates.Hour(1)).

julia> round( Date (1985, 8, 16), Dates.Month)  
1985-08-01

julia> round( DateTime (2013, 2, 13, 0, 31, 20), Dates.Minute(15))  
2013-02-13T00:30:00

julia> round( DateTime (2016, 8, 6, 12, 0, 0), Dates.Day)  
2016-08-07T00:00:00

Valid rounding modes forround(::TimeType, ::Period, ::RoundingMode)areRoundNearestTiesUp  
(default),RoundDown(floor), andRoundUp(ceil).

```
MostPeriodvalues can also be rounded to a specified resolution:

Base.floor– Method.

```

floor(x::Period, precision::T) where T<: Union {TimePeriod, Week, Day}-> T

Roundxdown to the nearest multiple ofprecision. Ifxandprecisionare different subtypes ofPeriod,  
the return value will have the same type asprecision.  
For convenience,precisionmay be a type instead of a value:floor(x, Dates.Hour)is a shortcut for  
floor(x, Dates.Hour(1)).

julia> floor(Dates.Day(16), Dates.Week)  
2 weeks

julia> floor(Dates.Minute(44), Dates.Minute(15))  
30 minutes

```

#### CHAPTER 65. API REFERENCE 950

```

julia> floor(Dates.Hour(36), Dates.Day)  
1 day

Rounding to aprecisionofMonths orYears is not supported, as thesePeriods are of inconsistent length.

```
Base.ceil– Method.

```

ceil(x::Period, precision::T) where T<: Union {TimePeriod, Week, Day}-> T

Roundxup to the nearest multiple ofprecision. Ifxandprecisionare different subtypes ofPeriod, the  
return value will have the same type asprecision.  
For convenience,precisionmay be a type instead of a value:ceil(x, Dates.Hour)is a shortcut for  
ceil(x, Dates.Hour(1)).

julia> ceil(Dates.Day(16), Dates.Week)  
3 weeks

julia> ceil(Dates.Minute(44), Dates.Minute(15))  
45 minutes

julia> ceil(Dates.Hour(36), Dates.Day)  
2 days

Rounding to aprecisionofMonths orYears is not supported, as thesePeriods are of inconsistent length.

```
Base.round– Method.

```

round(x::Period, precision::T, [r:: RoundingMode ]) where T<: Union {TimePeriod, Week, Day}-> T

Roundxto the nearest multiple ofprecision. Ifxandprecisionare different subtypes ofPeriod, the  
return value will have the same type asprecision. By default (RoundNearestTiesUp), ties (e.g., rounding  
90 minutes to the nearest hour) will be rounded up.  
For convenience,precisionmay be a type instead of a value:round(x, Dates.Hour)is a shortcut for  
round(x, Dates.Hour(1)).

julia> round(Dates.Day(16), Dates.Week)  
2 weeks

julia> round(Dates.Minute(44), Dates.Minute(15))  
45 minutes

julia> round(Dates.Hour(36), Dates.Day)  
2 days

Valid rounding modes forround(::Period, ::T, ::RoundingMode)areRoundNearestTiesUp(default),  
RoundDown(floor), andRoundUp(ceil).  
Rounding to aprecisionofMonths orYears is not supported, as thesePeriods are of inconsistent length.

```
The following functions are not exported:

Dates.floorceil– Function.

```

floorceil(dt::TimeType, p::Period)-> (TimeType, TimeType)

```

#### CHAPTER 65. API REFERENCE 951

```

Simultaneously return thefloorandceilof aDateorDateTimeat resolutionp. More efficient than calling  
bothfloorandceilindividually.  
floorceil(x::Period, precision::T) where T <: Union{TimePeriod, Week, Day} -> (T, T)

Simultaneously return thefloorandceilofPeriodat resolutionp. More efficient than calling bothfloor  
andceilindividually.

```
Dates.epochdays2date– Function.

```

epochdays2date(days)-> Date

Take the number of days since the rounding epoch (0000-01-01T00:00:00) and return the corresponding  
Date.

```
Dates.epochms2datetime– Function.

```

epochms2datetime(milliseconds)-> DateTime

Take the number of milliseconds since the rounding epoch (0000-01-01T00:00:00) and return the corre-  
spondingDateTime.

```
Dates.date2epochdays– Function.

```

date2epochdays(dt:: Date ) -> Int64

Take the givenDateand return the number of days since the rounding epoch (0000-01-01T00:00:00) as  
anInt64.

```
Dates.datetime2epochms– Function.

```

datetime2epochms(dt:: DateTime ) -> Int64

Take the givenDateTimeand return the number of milliseconds since the rounding epoch (0000-01-  
01T00:00:00) as anInt64.

```
### Conversion Functions

Dates.today– Function.

```

today()-> Date

Return the date portion ofnow().

```
Dates.unix2datetime– Function.

```

unix2datetime(x)-> DateTime

Take the number of seconds since unix epoch1970-01-01T00:00:00and convert to the corresponding  
DateTime.

```
Dates.datetime2unix– Function.

```

datetime2unix(dt:: DateTime ) -> Float64

Take the givenDateTimeand return the number of seconds since the unix epoch1970-01-01T00:00:00  
as aFloat64.

```

#### CHAPTER 65. API REFERENCE 952

Dates.julian2datetime– Function.

```

julian2datetime(julian_days)-> DateTime

Take the number of Julian calendar days since epoch-4713-11-24T12:00:00and return the corresponding  
DateTime.

```
Dates.datetime2julian– Function.

```

datetime2julian(dt:: DateTime ) -> Float64

Take the givenDateTimeand return the number of Julian calendar days since the julian epoch-4713-11-  
24T12:00:00as aFloat64.

```
Dates.rata2datetime– Function.

```

rata2datetime(days)-> DateTime

TakethenumberofRataDiedayssinceepoch0000-12-31T00:00:00andreturnthecorrespondingDateTime.

```
Dates.datetime2rata– Function.

```

datetime2rata(dt::TimeType)-> Int64

Return the number of Rata Die days since epoch from the givenDateorDateTime.

```
### Constants

Days of the Week:

```

Variable Abbr. Value (Int)  
Monday Mon 1  
Tuesday Tue 2  
Wednesday Wed 3  
Thursday Thu 4  
Friday Fri 5  
Saturday Sat 6  
Sunday Sun 7

```
Months of the Year:

**Common Date Formatters**

Dates.ISODateTimeFormat– Constant.

```

Dates.ISODateTimeFormat

Describes the ISO8601 formatting for a date and time. This is the default value forDates.formatof a  
DateTime.  
Example

julia> Dates.format( DateTime (2018, 8, 8, 12, 0, 43, 1), ISODateTimeFormat)  
"2018-08-08T12:00:43.001"

```
Dates.ISODateFormat– Constant.


#### CHAPTER 65. API REFERENCE 953

```

Variable Abbr. Value (Int)  
January Jan 1  
February Feb 2  
March Mar 3  
April Apr 4  
May May 5  
June Jun 6  
July Jul 7  
August Aug 8  
September Sep 9  
October Oct 10  
November Nov 11  
December Dec 12

Dates.ISODateFormat

Describes the ISO8601 formatting for a date. This is the default value forDates.formatof aDate.  
Example

julia> Dates.format( Date (2018, 8, 8), ISODateFormat)  
"2018-08-08"

```
Dates.ISOTimeFormat– Constant.

```

Dates.ISOTimeFormat

Describes the ISO8601 formatting for a time. This is the default value forDates.formatof aTime.  
Example

julia> Dates.format(Time(12, 0, 43, 1), ISOTimeFormat)  
"12:00:43.001"

```
Dates.RFC1123Format– Constant.

```

Dates.RFC1123Format

Describes the RFC1123 formatting for a date and time.  
Example

julia> Dates.format( DateTime (2018, 8, 8, 12, 0, 43, 1), RFC1123Format)  
"Wed, 08 Aug 2018 12:00:43"

```

**Chapter 66**

**Delimited Files**

DelimitedFiles.readdlm– Method.

```

readdlm(source, delim::AbstractChar, T:: Type , eol::AbstractChar; header= false , skipstart=0,  
↪→ skipblanks= true , use_mmap, quotes= true , dims, comments= false , comment_char='#')

Read a matrix from the source where each line (separated byeol) gives one row, with elements separated  
by the given delimiter. The source can be a text file, stream or byte array. Memory mapped files can be  
used by passing the byte array representation of the mapped segment as source.  
IfTis a numeric type, the result is an array of that type, with any non-numeric elements asNaNfor floating-  
point types, or zero. Other useful values ofTincludeString,AbstractString, andAny.  
Ifheaderistrue, the first row of data will be read as header and the tuple(data_cells, header_cells)  
is returned instead of onlydata_cells.  
Specifyingskipstartwill ignore the corresponding number of initial lines from the input.  
Ifskipblanksistrue, blank lines in the input will be ignored.  
Ifuse_mmapistrue, the file specified bysourceis memory mapped for potential speedups if the file is  
large. Default isfalse'. On a Windows filesystem,use_mmapshould not be set totrue‘ unless the  
file is only read once and is also not written to. Some edge cases exist where an OS is Unix-like but the  
filesystem is Windows-like.  
Ifquotesistrue, columns enclosed within double-quote (") characters are allowed to contain new lines  
and column delimiters. Double-quote characters within a quoted field must be escaped with another  
double-quote. Specifyingdimsas a tuple of the expected rows and columns (including header, if any)  
may speed up reading of large files. Ifcommentsistrue, lines beginning withcomment_charand text  
followingcomment_charin any line are ignored.  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y])  
end

```
#### 954


#### CHAPTER 66. DELIMITED FILES 955

```

julia> readdlm("delim_file.txt", '\t', Int , '\n')  
4×2 Matrix{Int64}:  
1 5  
2 6  
3 7  
4 8

julia> rm("delim_file.txt")

```
DelimitedFiles.readdlm– Method.

```

readdlm(source, delim::AbstractChar, eol::AbstractChar; options...)

If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a  
heterogeneous array of numbers and strings is returned.

```
DelimitedFiles.readdlm– Method.

```

readdlm(source, delim::AbstractChar, T:: Type ; options...)

The end of line delimiter is taken as\n.  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y],',')  
end ;

julia> readdlm("delim_file.txt", ',', Float64 )  
4×2 Matrix{Float64}:  
1.0 1.1  
2.0 2.2  
3.0 3.3  
4.0 4.4

julia> rm("delim_file.txt")

```
DelimitedFiles.readdlm– Method.

```

readdlm(source, delim::AbstractChar; options...)

The end of line delimiter is taken as\n. If all data is numeric, the result will be a numeric array. If some  
elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [1.1; 2.2; 3.3; 4.4];

```

#### CHAPTER 66. DELIMITED FILES 956

```

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y],',')  
end ;

julia> readdlm("delim_file.txt", ',')  
4×2 Matrix{Float64}:  
1.0 1.1  
2.0 2.2  
3.0 3.3  
4.0 4.4

julia> z = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x z],',')  
end ;

julia> readdlm("delim_file.txt", ',')  
4×2 Matrix{Any}:  
1 "a"  
2 "b"  
3 "c"  
4 "d"

julia> rm("delim_file.txt")

```
DelimitedFiles.readdlm– Method.

```

readdlm(source, T:: Type ; options...)

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken  
as\n.  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y])  
end ;

julia> readdlm("delim_file.txt", Int64 )  
4×2 Matrix{Int64}:  
1 5  
2 6  
3 7  
4 8

julia> readdlm("delim_file.txt", Float64 )  
4×2 Matrix{Float64}:  
1.0 5.0  
2.0 6.0

```

#### CHAPTER 66. DELIMITED FILES 957

```

3.0 7.0  
4.0 8.0

julia> rm("delim_file.txt")

```
DelimitedFiles.readdlm– Method.

```

readdlm(source; options...)

The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken  
as\n. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as  
numbers, a heterogeneous array of numbers and strings is returned.  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = ["a"; "b"; "c"; "d"];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y])  
end ;

julia> readdlm("delim_file.txt")  
4×2 Matrix{Any}:  
1 "a"  
2 "b"  
3 "c"  
4 "d"

julia> rm("delim_file.txt")

```
DelimitedFiles.writedlm– Function.

```

writedlm(f, A, delim='\t'; opts)

WriteA(a vector, matrix, or an iterable collection of iterable rows) as text tof(either a filename string or  
anIOstream) using the given delimiterdelim(which defaults to tab, but can be any printable Julia object,  
typically aCharorAbstractString).  
For example, two vectorsxandyof the same length can be written as two columns of tab-delimited text  
tofby eitherwritedlm(f, [x y])or bywritedlm(f, zip(x, y)).  
Examples

julia>using DelimitedFiles

julia> x = [1; 2; 3; 4];

julia> y = [5; 6; 7; 8];

julia> open("delim_file.txt", "w") do io  
writedlm(io, [x y])  
end

```

#### CHAPTER 66. DELIMITED FILES 958

```

julia> readdlm("delim_file.txt", '\t', Int , '\n')  
4×2 Matrix{Int64}:  
1 5  
2 6  
3 7  
4 8

julia> rm("delim_file.txt")

```

**Chapter 67**

**Distributed Computing**

Distributed.addprocs– Function.

```

addprocs(manager:: ClusterManager ; kwargs...) -> List of process identifiers

Launches worker processes via the specified cluster manager.  
For example, Beowulf clusters are supported via a custom cluster manager implemented in the package  
ClusterManagers.jl.  
The number of seconds a newly launched worker waits for connection establishment from the master can  
bespecifiedviavariableJULIA_WORKER_TIMEOUTintheworkerprocess'senvironment. Relevantonlywhen  
using TCP/IP as transport.  
To launch workers without blocking the REPL, or the containing function if launching workers programmat-  
ically, executeaddprocsin its own task.  
Examples

# On busy clusters, call `addprocs` asynchronously

t = @asyncaddprocs(...)

# Utilize workers as and when they come online

if nprocs()> 1 # Ensure at least one new worker is available  
.... # perform distributed execution  
end

# Retrieve newly launched worker IDs, or any error messages

if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block  
if nworkers()== N  
new_pids= fetch(t)  
else  
fetch(t)  
end  
end

addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process  
identifiers

Add processes on remote machines via SSH. Seeexenameto set the path to thejuliainstallation on  
remote machines.  
machinesis a vector of machine specifications. Workers are started for each specification.

```
#### 959


#### CHAPTER 67. DISTRIBUTED COMPUTING 960

```

A machine specification is either a stringmachine_specor a tuple -(machine_spec, count).  
machine_specisastringoftheform[user@]host[:port] [bind_addr[:port]].userdefaultstocurrent  
user,portto the standard ssh port. If[bind_addr[:port]]is specified, other workers will connect to this  
worker at the specifiedbind_addrandport.  
countis the number of workers to be launched on the specified host. If specified as:autoit will launch as  
many workers as the number of CPU threads on the specific host.  
Keyword arguments:

```
- tunnel: iftruethen SSH tunneling will be used to connect to the worker from the master process.
    Default isfalse.
- multiplex: iftruethen SSH multiplexing is used for SSH tunneling. Default isfalse.
- ssh: the name or path of the SSH client executable used to start the workers. Default is"ssh".
- sshflags: specifies additional ssh options, e.g.sshflags=`-i /home/foo/bar.pem`
- max_parallel: specifiesthemaximumnumberofworkersconnectedtoinparallelatahost. Defaults
    to 10.
- shell: specifies the type of shell to which ssh connects on the workers.
    **-** shell=:posix: a POSIX-compatible Unix/Linux shell (bash, sh, etc.). The default.
    **-** shell=:wincmd: Microsoft Windowscmd.exe.
- dir: specifies the working directory on the workers. Defaults to the host's current directory (as found
    bypwd())
- enable_threaded_blas: iftruethen BLAS will run on multiple threads in added processes. Default
    isfalse.
- exename: nameofthejuliaexecutable. Defaultsto"$(Sys.BINDIR)/julia"or"$(Sys.BINDIR)/julia-debug"
    as the case may be.
- exeflags: additional flags passed to the worker processes.
- topology: Specifies how the workers connect to each other. Sending a message between uncon-
    nected workers results in an error.
       **-** topology=:all_to_all: All processes are connected to each other. The default.
       **-** topology=:master_worker: Only the driver process, i.e.pid1 connects to the workers. The
          workers do not connect to each other.
       **-** topology=:custom: Thelaunchmethod of the cluster manager specifies the connection topol-
          ogy via fieldsidentandconnect_identsinWorkerConfig. A worker with a cluster manager
          identityidentwill connect to all workers specified inconnect_idents.
- lazy: Applicable only withtopology=:all_to_all. Iftrue, worker-worker connections are setup
    lazily, i.e. they are setup at the first instance of a remote call between workers. Default is true.
- env: provide an array of string pairs such asenv=["JULIA_DEPOT_PATH"=>"/depot"]to request that
    environment variables are set on the remote machine. By default only the environment variable
    JULIA_WORKER_TIMEOUTis passed automatically from the local to the remote environment.
- cmdline_cookie: pass the authentication cookie via the--workercommandline option. The (more
    secure) default behaviour of passing the cookie via ssh stdio may hang with Windows workers that
    use older (pre-ConPTY) Julia or Windows versions, in which casecmdline_cookie=trueoffers a work-
    around.

```

Julia 1.6  
The keyword argumentsssh,shell,envandcmdline_cookiewere added in Julia 1.6.

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 961

```

Environment variables:  
If the master process fails to establish a connection with a newly launched worker within 60.0 seconds,  
the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment  
variableJULIA_WORKER_TIMEOUT.ThevalueofJULIA_WORKER_TIMEOUTonthemasterprocessspecifiesthe  
number of seconds a newly launched worker waits for connection establishment.  
addprocs(; kwargs...) -> List of process identifiers

Equivalent toaddprocs(Sys.CPU_THREADS; kwargs...)  
Note that workers do not run a.julia/config/startup.jlstartup script, nor do they synchronize their  
global state (such as global variables, new method definitions, and loaded modules) with any of the other  
running processes.  
addprocs(np::Integer; restrict=true, kwargs...) -> List of process identifiers

Launches workers using the in-builtLocalManagerwhich only launches workers on the local host. This can  
be used to take advantage of multiple cores.addprocs(4)will add 4 processes on the local machine. If  
restrictistrue, binding is restricted to127.0.0.1. Keyword argsdir,exename,exeflags,topology,  
lazyandenable_threaded_blashave the same effect as documented foraddprocs(machines).

```
Distributed.nprocs– Function.

```

nprocs()

Get the number of available processes.  
Examples

julia> nprocs()  
3

julia> workers()  
2-element Array{Int64,1}:  
2  
3

```
Distributed.nworkers– Function.

```

nworkers()

Get the number of available worker processes. This is one less thannprocs(). Equal tonprocs()if  
nprocs() == 1.  
Examples

$ julia -p 2

julia> nprocs()  
3

julia> nworkers()  
2

```
Distributed.procs– Method.

```

procs()

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 962

```

Return a list of all process identifiers, including pid 1 (which is not included byworkers()).  
Examples

$ julia -p 2

julia> procs()  
3-element Array{Int64,1}:  
1  
2  
3

```
Distributed.procs– Method.

```

procs(pid:: Integer )

Return a list of all process identifiers on the same physical node. Specifically all workers bound to the same  
ip-address aspidare returned.

```
Distributed.workers– Function.

```

workers()

Return a list of all worker process identifiers.  
Examples

$ julia -p 2

julia> workers()  
2-element Array{Int64,1}:  
2  
3

```
Distributed.rmprocs– Function.

```

rmprocs(pids...; waitfor=typemax( Int ))

Remove the specified workers. Note that only process 1 can add or remove workers.  
Argumentwaitforspecifies how long to wait for the workers to shut down:

```
- If unspecified,rmprocswill wait until all requestedpidsare removed.
- AnErrorExceptionis raised if all workers cannot be terminated before the requestedwaitforsec-
    onds.
- With awaitforvalue of 0, the call returns immediately with the workers scheduled for removal in a
    different task. The scheduledTaskobject is returned. The user should callwaiton the task before
    invoking any other parallel calls.

```

Examples

$ julia -p 5

julia> t = rmprocs(2, 3, waitfor=0)  
Task (runnable) @0x0000000107c718d0

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 963

```

julia> wait(t)

julia> workers()  
3-element Array{Int64,1}:  
4  
5  
6

```
Distributed.interrupt– Function.

```

interrupt(pids:: Integer ...)

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the  
local machine. If no arguments are given, all workers are interrupted.  
interrupt(pids::AbstractVector=workers())

Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the  
local machine. If no arguments are given, all workers are interrupted.

```
Distributed.myid– Function.

```

myid()

Get the id of the current process.  
Examples

julia> myid()  
1

julia> remotecall_fetch(()-> myid(),4)  
4

```
Distributed.pmap– Function.

```

pmap(f, [::AbstractWorkerPool], c...; distributed= true , batch_size=1, on_error=nothing,  
↪→ retry_delays=[], retry_check=nothing) -> collection

Transform collectioncby applyingfto each element using available workers and tasks.  
For multiple collection arguments, applyfelementwise.  
Note thatfmust be made available to all worker processes; seeCode Availability and Loading Packages  
for details.  
If a worker pool is not specified, all available workers, i.e., the default worker pool is used.  
By default,pmapdistributes the computation over all specified workers. To use only the local process and  
distribute over tasks, specifydistributed=false. This is equivalent to usingasyncmap. For example,  
pmap(f, c; distributed=false)is equivalent toasyncmap(f,c; ntasks=()->nworkers())  
pmapcan also use a mix of processes and tasks via thebatch_sizeargument. For batch sizes greater than  
1, the collection is processed in multiple batches, each of lengthbatch_sizeor less. A batch is sent as a  
single request to a free worker, where a localasyncmapprocesses elements from the batch using multiple  
concurrent tasks.

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 964

```

Any error stopspmapfrom processing the remainder of the collection. To override this behavior you can  
specify an error handling function via argumenton_errorwhich takes in a single argument, i.e., the ex-  
ception. The function can stop the processing by rethrowing the error, or, to continue, return any value  
which is then returned inline with the results to the caller.  
Consider the following two examples. The first one returns the exception object inline, the second a 0 in  
place of any exception:

julia> pmap(x->iseven(x)? error("foo") : x, 1:4; on_error=identity)  
4-element Array{Any,1}:  
1  
ErrorException("foo")  
3  
ErrorException("foo")

julia> pmap(x->iseven(x)? error("foo") : x, 1:4; on_error=ex->0)  
4-element Array{Int64,1}:  
1  
0  
3  
0

Errorscanalsobehandledbyretryingfailedcomputations. Keywordargumentsretry_delaysandretry_check  
arepassedthroughtoretryaskeywordargumentsdelaysandcheckrespectively. Ifbatchingisspecified,  
and an entire batch fails, all items in the batch are retried.  
Note that if bothon_errorandretry_delaysare specified, theon_errorhook is called before retrying.  
Ifon_errordoes not throw (or rethrow) an exception, the element will not be retried.  
Example: On errors, retryfon an element a maximum of 3 times without any delay between retries.

pmap(f, c; retry_delays= zeros(3))

Example: Retryfonly if the exception is not of typeInexactError, with exponentially increasing delays  
up to 3 times. Return aNaNin place for allInexactErroroccurrences.

pmap(f, c; on_error= e->(isa(e, InexactError )? NaN : rethrow()), retry_delays=  
↪→ ExponentialBackOff(n= 3))

```
Distributed.RemoteException– Type.

```

RemoteException (captured)

Exceptions on remote computations are captured and rethrown locally. ARemoteExceptionwraps the  
pidof the worker and a captured exception. ACapturedExceptioncaptures the remote exception and a  
serializable form of the call stack when the exception was raised.

```
Distributed.Future– Type.

```

Future(w:: Int , rrid::RRID, v:: Union {Some, Nothing}=nothing)

AFutureis a placeholder for a single computation of unknown termination status and time. For multiple  
potential computations, seeRemoteChannel. Seeremoteref_idfor identifying anAbstractRemoteRef.

```
Distributed.RemoteChannel– Type.

```

RemoteChannel(pid:: Integer =myid())

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 965

```

Make a reference to aChannel{Any}(1)on processpid. The defaultpidis the current process.  
RemoteChannel(f::Function, pid::Integer=myid())

Create references to remote channels of a specific size and type.fis a function that when executed on  
pidmust return an implementation of anAbstractChannel.  
For example,RemoteChannel(()->Channel{Int}(10), pid), will return a reference to a channel of type  
Intand size 10 onpid.  
The defaultpidis the current process.

```
Base.fetch– Method.

```

fetch(x::Future)

Wait for and get the value of aFuture. The fetched value is cached locally. Further calls tofetchon the  
same reference return the cached value. If the remote value is an exception, throws aRemoteException  
which captures the remote exception and backtrace.

```
Base.fetch– Method.

```

fetch(c::RemoteChannel)

Wait for and get a value from aRemoteChannel. Exceptions raised are the same as for aFuture. Does not  
remove the item fetched.

```
Distributed.remotecall– Method.

```

remotecall(f, id:: Integer , args...; kwargs...) -> Future

Call a functionfasynchronously on the given arguments on the specified process. Return aFuture.  
Keyword arguments, if any, are passed through tof.

```
Distributed.remotecall_wait– Method.

```

remotecall_wait(f, id:: Integer , args...; kwargs...)

Perform a fasterwait(remotecall(...))in one message on theWorkerspecified by worker idid. Key-  
word arguments, if any, are passed through tof.  
See alsowaitandremotecall.

```
Distributed.remotecall_fetch– Method.

```

remotecall_fetch(f, id:: Integer , args...; kwargs...)

Performfetch(remotecall(...))in one message. Keyword arguments, if any, are passed through tof.  
Any remote exceptions are captured in aRemoteExceptionand thrown.  
See alsofetchandremotecall.  
Examples

$ julia -p 2

julia> remotecall_fetch(sqrt,2, 4)  
2.0

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 966

```

julia> remotecall_fetch(sqrt,2, -4)  
ERROR: On worker 2:  
DomainError with -4.0:  
sqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).  
...

```
Distributed.remote_do– Method.

```

remote_do(f, id:: Integer , args...; kwargs...) -> nothing

Executesfon workeridasynchronously. Unlikeremotecall, it does not store the result of computation,  
nor is there a way to wait for its completion.  
A successful invocation indicates that the request has been accepted for execution on the remote node.  
While consecutiveremotecalls to the same worker are serialized in the order they are invoked, the order  
of executions on the remote worker is undetermined. For example,remote_do(f1, 2); remotecall(f2,  
2); remote_do(f3, 2)will serialize the call tof1, followed byf2andf3in that order. However, it is not  
guaranteed thatf1is executed beforef3on worker 2.  
Any exceptions thrown byfare printed tostderron the remote worker.  
Keyword arguments, if any, are passed through tof.

```
Base.put!– Method.

```

put!(rr::RemoteChannel, args...)

Store a set of values to theRemoteChannel. If the channel is full, blocks until space is available. Return  
the first argument.

```
Base.put!– Method.

```

put!(rr::Future, v)

Store a value to aFuturerr.Futures are write-once remote references. Aput!on an already setFuture  
throws anException. All asynchronous remote calls returnFutures and set the value to the return value  
of the call upon completion.

```
Base.take!– Method.

```

take!(rr::RemoteChannel, args...)

Fetch value(s) from aRemoteChannelrr, removing the value(s) in the process.

```
Base.isready– Method.

```

isready(rr::RemoteChannel, args...)

Determine whether aRemoteChannelhas a value stored to it. Note that this function can cause race  
conditions, since by the time you receive its result it may no longer be true. However, it can be safely used  
on aFuturesince they are assigned only once.

```
Base.isready– Method.

```

isready(rr::Future)

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 967

```

Determine whether aFuturehas a value stored to it.  
If the argumentFutureis owned by a different node, this call will block to wait for the answer. It is  
recommended to wait forrrin a separate task instead or to use a localChannelas a proxy:

p = 1  
f = Future(p)  
errormonitor(@asyncput!(f, remotecall_fetch(long_computation, p)))  
isready(f) # will not block

```
Distributed.AbstractWorkerPool– Type.

```

AbstractWorkerPool

Supertype for worker pools such asWorkerPoolandCachingPool. AnAbstractWorkerPoolshould imple-  
ment:

```
- push!- add a new worker to the overall pool (available + busy)
- put!- put back a worker to the available pool
- take!- take a worker from the available pool (to be used for remote function execution)
- length- number of workers available in the overall pool
- isready- return false if atake!on the pool would block, else true

```

The default implementations of the above (on aAbstractWorkerPool) require fields

```
- channel::Channel{Int}
- workers::Set{Int}

```

wherechannelcontains free worker pids andworkersis the set of all workers associated with this pool.

```
Distributed.WorkerPool– Type.

```

WorkerPool(workers:: Vector { Int })

Create aWorkerPoolfrom a vector of worker ids.  
Examples

$ julia -p 3

julia> WorkerPool([2, 3])  
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:2), Set([2, 3]),  
↪→ RemoteChannel{Channel{Any}}(1, 1, 6))

```
Distributed.CachingPool– Type.

```

CachingPool(workers:: Vector { Int })

An implementation of anAbstractWorkerPool.remote,remotecall_fetch,pmap(and other remote calls  
which execute functions remotely) benefit from caching the serialized/deserialized functions on the worker  
nodes, especially closures (which may capture large amounts of data).  
The remote cache is maintained for the lifetime of the returnedCachingPoolobject. To clear the cache  
earlier, useclear!(pool).  
For global variables, only the bindings are captured in a closure, not the data.letblocks can be used to  
capture global data.  
Examples

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 968

```

const foo = rand(10^8);  
wp = CachingPool(workers())  
let foo = foo  
pmap(i-> sum(foo)+ i, wp,1:100);  
end

The above would transferfooonly once to each worker.

```
Distributed.default_worker_pool– Function.

```

default_worker_pool()

WorkerPoolcontaining idleworkers- used byremote(f)andpmap(by default).  
Examples

$ julia -p 3

julia> default_worker_pool()  
WorkerPool(Channel{Int64}(sz_max:9223372036854775807,sz_curr:3), Set([4, 2, 3]),  
↪→ RemoteChannel{Channel{Any}}(1, 1, 4))

```
Distributed.clear!– Method.

```

clear!(pool::CachingPool)-> pool

Removes all cached functions from all participating workers.

```
Distributed.remote– Function.

```

remote([p::AbstractWorkerPool], f)-> Function

Return an anonymous function that executes functionfon an available worker (drawn fromWorkerPoolp  
if provided) usingremotecall_fetch.

```
Distributed.remotecall– Method.

```

remotecall(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future

WorkerPoolvariantofremotecall(f, pid, ....). Waitforandtakeafreeworkerfrompoolandperform  
aremotecallon it.  
Examples

$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall(maximum, wp, A)  
Future(2, 1, 6, nothing)

In this example, the task ran on pid 2, called from pid 1.

```
Distributed.remotecall_wait– Method.

```

remotecall_wait(f, pool::AbstractWorkerPool, args...; kwargs...) -> Future

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 969

```

WorkerPoolvariant ofremotecall_wait(f, pid, ....). Wait for and take a free worker frompooland  
perform aremotecall_waiton it.  
Examples

$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> f = remotecall_wait(maximum, wp, A)  
Future(3, 1, 9, nothing)

julia> fetch(f)  
0.9995177101692958

```
Distributed.remotecall_fetch– Method.

```

remotecall_fetch(f, pool::AbstractWorkerPool, args...; kwargs...) -> result

WorkerPoolvariant ofremotecall_fetch(f, pid, ....). Waits for and takes a free worker frompool  
and performs aremotecall_fetchon it.  
Examples

$ julia -p 3

julia> wp = WorkerPool([2, 3]);

julia> A = rand(3000);

julia> remotecall_fetch(maximum, wp, A)  
0.9995177101692958

```
Distributed.remote_do– Method.

```

remote_do(f, pool::AbstractWorkerPool, args...; kwargs...) -> nothing

WorkerPoolvariant ofremote_do(f, pid, ....). Wait for and take a free worker frompooland perform  
aremote_doon it.

```
Distributed.@spawnat– Macro.

```

@spawnatp expr

Createaclosurearoundanexpressionandruntheclosureasynchronouslyonprocessp. ReturnaFutureto  
the result. Ifpis the quoted literal symbol:any, then the system will pick a processor to use automatically.  
Examples

julia> addprocs(3);

julia> f = @spawnat2 myid()  
Future(2, 1, 3, nothing)

julia> fetch(f)

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 970

```

2

julia> f = @spawnat:any myid()  
Future(3, 1, 7, nothing)

julia> fetch(f)  
3

Julia 1.3  
The:anyargument is available as of Julia 1.3.

```
Distributed.@fetch– Macro.

```

@fetchexpr

Equivalent tofetch(@spawnat :any expr). Seefetchand@spawnat.  
Examples

julia> addprocs(3);

julia> @fetchmyid()  
2

julia> @fetchmyid()  
3

julia> @fetchmyid()  
4

julia> @fetchmyid()  
2

```
Distributed.@fetchfrom– Macro.

```

@fetchfrom

Equivalent tofetch(@spawnat p expr). Seefetchand@spawnat.  
Examples

julia> addprocs(3);

julia> @fetchfrom2 myid()  
2

julia> @fetchfrom4 myid()  
4

```
Distributed.@distributed– Macro.

```

@distributed

A distributed memory, parallel for loop of the form :  
@distributed [reducer] for var = range  
body  
end

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 971

```

The specified range is partitioned and locally executed across all workers. In case an optional reducer  
function is specified,@distributedperforms local reductions on each worker with a final reduction on the  
calling process.  
Note that without a reducer function,@distributedexecutes asynchronously, i.e. it spawns indepen-  
dent tasks on all available workers and returns immediately without waiting for completion. To wait for  
completion, prefix the call with@sync, like :  
@sync @distributed for var = range  
body  
end

```
Distributed.@everywhere– Macro.

```

@everywhere[procs()] expr

Execute an expression underMainon allprocs. Errors on any of the processes are collected into a  
CompositeExceptionand thrown. For example:  
@everywhere bar = 1

will defineMain.baron all current processes. Any processes added later (say withaddprocs()) will not  
have the expression defined.  
Unlike@spawnat,@everywheredoes not capture any local variables. Instead, local variables can be broad-  
cast using interpolation:  
foo = 1  
@everywhere bar = $foo

The optional argumentprocsallows specifying a subset of all processes to have execute the expression.  
Similar to callingremotecall_eval(Main, procs, expr), but with two extra features:

```
- `using` and `import` statements run on the calling process first, to ensure
    packages are precompiled.
- The current source file path used by `include` is propagated to other processes.

Distributed.clear!– Method.

```

clear!(syms, pids=workers(); mod=Main)

Clears global bindings in modules by initializing them tonothing. symsshould be of typeSymbolor a  
collection ofSymbols .pidsandmodidentify the processes and the module in which global variables are  
to be reinitialized. Only those names found to be defined undermodare cleared.  
An exception is raised if a global constant is requested to be cleared.

```
Distributed.remoteref_id– Function.

```

remoteref_id(r::AbstractRemoteRef)-> RRID

Futures andRemoteChannels are identified by fields:

```
- where- refers to the node where the underlying object/storage referred to by the reference actually
    exists.
- whence-referstothenodetheremotereferencewascreatedfrom. Notethatthisisdifferentfromthe
    node where the underlying object referred to actually exists. For example callingRemoteChannel(2)
    from the master process would result in awherevalue of 2 and awhencevalue of 1.


#### CHAPTER 67. DISTRIBUTED COMPUTING 972

- idis unique across all references created from the worker specified bywhence.

```

Taken together,whenceandiduniquely identify a reference across all workers.  
remoteref_idis a low-level API which returns aRRIDobject that wrapswhenceandidvalues of a remote  
reference.

```
Distributed.channel_from_id– Function.

```

channel_from_id(id)-> c

A low-level API which returns the backingAbstractChannelfor anidreturned byremoteref_id. The call  
is valid only on the node where the backing channel exists.

```
Distributed.worker_id_from_socket– Function.

```

worker_id_from_socket(s)-> pid

A low-level API which, given aIOconnection or aWorker, returns thepidof the worker it is connected to.  
This is useful when writing customserializemethods for a type, which optimizes the data written out  
depending on the receiving process id.

```
Distributed.cluster_cookie– Method.

```

cluster_cookie()-> cookie

Return the cluster cookie.

```
Distributed.cluster_cookie– Method.

```

cluster_cookie(cookie)-> cookie

Set the passed cookie as the cluster cookie, then returns it.

```
### 67.1 Cluster Manager Interface.

This interface provides a mechanism to launch and manage Julia workers on different cluster environments.
TherearetwotypesofmanagerspresentinBase:LocalManager, forlaunchingadditionalworkersonthesame
host, andSSHManager, for launching on remote hosts viassh. TCP/IP sockets are used to connect and transport
messages between processes. It is possible for Cluster Managers to provide a different transport.

Distributed.ClusterManager– Type.

```

ClusterManager

Supertype for cluster managers, which control workers processes as a cluster. Cluster managers imple-  
ment how workers can be added, removed and communicated with.SSHManagerandLocalManagerare  
subtypes of this.

```
Distributed.WorkerConfig– Type.

```

WorkerConfig

Type used byClusterManagers to control workers added to their clusters. Some fields are used by all  
cluster managers to access a host:

```
- io– the connection used to access the worker (a subtype ofIOorNothing)


#### CHAPTER 67. DISTRIBUTED COMPUTING 973

- host– the host address (either aStringorNothing)
- port– the port on the host used to connect to the worker (either anIntorNothing)

```

Some are used by the cluster manager to add workers to an already-initialized host:

```
- count– the number of workers to be launched on the host
- exename– the path to the Julia executable on the host, defaults to"$(Sys.BINDIR)/julia"or
    "$(Sys.BINDIR)/julia-debug"
- exeflags– flags to use when lauching Julia remotely

```

Theuserdatafield is used to store information for each worker by external managers.  
Some fields are used bySSHManagerand similar managers:

```
- tunnel–true(usetunneling),false(donotusetunneling),ornothing(usedefaultforthemanager)
- multiplex–true(use SSH multiplexing for tunneling) orfalse
- forward– the forwarding option used for-Loption of ssh
- bind_addr– the address on the remote host to bind to
- sshflags– flags to use in establishing the SSH connection
- max_parallel– the maximum number of workers to connect to in parallel on the host

```

Some fields are used by bothLocalManagers andSSHManagers:

```
- connect_at– determines whether this is a worker-to-worker or driver-to-worker setup call
- process–theprocesswhichwillbeconnected(usuallythemanagerwillassignthisduringaddprocs)
- ospid– the process ID according to the host OS, used to interrupt worker processes
- environ– private dictionary used to store temporary information by Local/SSH managers
- ident– worker as identified by theClusterManager
- connect_idents– list of worker ids the worker must connect to if using a custom topology
- enable_threaded_blas–true,false, ornothing, whether to use threaded BLAS or not on the
    workers

Distributed.launch– Function.

```

launch(manager:: ClusterManager , params:: Dict , launched:: Array , launch_ntfy:: Condition )

Implemented by cluster managers. For every Julia worker launched by this function, it should append  
aWorkerConfigentry tolaunchedand notifylaunch_ntfy. The function MUST exit once all workers,  
requested bymanagerhave been launched.paramsis a dictionary of all keyword argumentsaddprocs  
was called with.

```
Distributed.manage– Function.

```

manage(manager:: ClusterManager , id :: Integer , config:: WorkerConfig. op:: Symbol )

Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with  
appropriateopvalues:

```
- with:register/:deregisterwhen a worker is added / removed from the Julia worker pool.


#### CHAPTER 67. DISTRIBUTED COMPUTING 974

- with:interruptwheninterrupt(workers)is called. TheClusterManagershould signal the ap-
    propriate worker with an interrupt signal.
- with:finalizefor cleanup purposes.

Base.kill– Method.

```

kill(manager:: ClusterManager , pid:: Int , config:: WorkerConfig )

Implemented by cluster managers. It is called on the master process, byrmprocs. It should cause the re-  
mote worker specified bypidto exit.kill(manager::ClusterManager.....)executes a remoteexit()  
onpid.

```
Sockets.connect– Method.

```

connect(manager:: ClusterManager , pid:: Int , config:: WorkerConfig ) -> (instrm:: IO , outstrm:: IO )

Implemented by cluster managers using custom transports. It should establish a logical connection to  
worker with idpid, specified byconfigand return a pair ofIOobjects. Messages frompidto current  
process will be read offinstrm, while messages to be sent topidwill be written tooutstrm. The custom  
transport implementation must ensure that messages are delivered and received completely and in order.  
connect(manager::ClusterManager.....)sets up TCP/IP socket connections in-between workers.

```
Distributed.init_worker– Function.

```

init_worker(cookie:: AbstractString , manager:: ClusterManager =DefaultClusterManager())

Called by cluster managers implementing custom transports. It initializes a newly launched process as a  
worker. Command line argument--worker[=]has the effect of initializing a process as a worker  
using TCP/IP sockets for transport.cookieis acluster_cookie.

```
Distributed.start_worker– Function.

```

start_worker([out:: IO =stdout], cookie:: AbstractString =readline(stdin); close_stdin:: Bool = true ,  
↪→ stderr_to_stdout:: Bool = true )

start_workeris an internal function which is the default entry point for worker processes connecting via  
TCP/IP. It sets up the process as a Julia cluster worker.  
host:port information is written to streamout(defaults to stdout).  
The function readsthe cookie from stdin if required, and listens on a freeport (or if specified, the port in the  
--bind-tocommand line option) and schedules tasks to process incoming TCP connections and requests.  
It also (optionally) closes stdin and redirects stderr to stdout.  
It does not return.

```
Distributed.process_messages– Function.

```

process_messages(r_stream:: IO , w_stream:: IO , incoming:: Bool = true )

Called by cluster managers using custom transports. It should be called when the custom transport imple-  
mentation receives the first message from a remote worker. The custom transport must manage a logical  
connection to the remote worker and provide twoIOobjects, one for incoming messages and the other for  
messages addressed to the remote worker. Ifincomingistrue, the remote peer initiated the connection.  
Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to  
perform the authentication handshake.  
See alsocluster_cookie.

```

#### CHAPTER 67. DISTRIBUTED COMPUTING 975

Distributed.default_addprocs_params– Function.

```

default_addprocs_params(mgr:: ClusterManager ) -> Dict { Symbol , Any }

Implemented by cluster managers. The default keyword parameters passed when callingaddprocs(mgr).  
The minimal set of options is available by callingdefault_addprocs_params()

```

**Chapter 68**

**Downloads**

Downloads.download– Function.

```

download(url, [ output= tempfile() ];  
[ method= "GET", ]  
[ headers= , ]  
[ timeout= , ]  
[ progress= , ]  
[ verbose= false , ]  
[ downloader= , ]  
) -> output

url :: AbstractString  
output :: Union { AbstractString , AbstractCmd, IO }  
method :: AbstractString  
headers :: Union { AbstractVector , AbstractDict}  
timeout :: Real  
progress :: (total:: Integer , now:: Integer ) --> Any  
verbose :: Bool  
downloader:: Downloader

Download a file from the given url, saving it tooutputor if not specified, a temporary path. Theoutput  
can also be anIOhandle, in which case the body of the response is streamed to that handle and the handle  
is returned. Ifoutputis a command, the command is run and output is sent to it on stdin.  
If thedownloaderkeyword argument is provided, it must be aDownloaderobject. Resources and connec-  
tions will be shared between downloads performed by the sameDownloaderand cleaned up automatically  
whentheobjectisgarbagecollectedortherehavebeennodownloadsperformedwithitforagraceperiod.  
SeeDownloaderfor more info about configuration and usage.  
If theheaderskeyword argument is provided, it must be a vector or dictionary whose elements are all  
pairs of strings. These pairs are passed as headers when downloading URLs with protocols that supports  
them, such as HTTP/S.  
Thetimeoutkeyword argument specifies a timeout for the download in seconds, with a resolution of  
milliseconds. By default no timeout is set, but this can also be explicitly requested by passing a timeout  
value ofInf.  
If theprogresskeyword argument is provided, it must be a callback funtion which will be called whenever  
there are updates about the size and status of the ongoing download. The callback must take two integer  
arguments:totalandnowwhich are the total size of the download in bytes, and the number of bytes  
which have been downloaded so far. Note thattotalstarts out as zero and remains zero until the server

```
#### 976


#### CHAPTER 68. DOWNLOADS 977

```

gives an indiation of the total size of the download (e.g. with aContent-Lengthheader), which may never  
happen. So a well-behaved progress callback should handle a total size of zero gracefully.  
If theverboseoption is set to true,libcurl, which is used to implement the download functionality will  
print debugging information tostderr.

```
Downloads.request– Function.

```

request(url;  
[ input= , ]  
[ output= , ]  
[ method= input? "PUT": output? "GET": "HEAD", ]  
[ headers= , ]  
[ timeout= , ]  
[ progress= , ]  
[ verbose= false , ]  
[ throw= true , ]  
[ downloader= , ]  
) -> Union {Response, RequestError}

url :: AbstractString  
input :: Union { AbstractString , AbstractCmd, IO }  
output :: Union { AbstractString , AbstractCmd, IO }  
method :: AbstractString  
headers :: Union { AbstractVector , AbstractDict}  
timeout :: Real  
progress :: (dl_total, dl_now, ul_total, ul_now)--> Any  
verbose :: Bool  
throw :: Bool  
downloader:: Downloader

Make a request to the given url, returning aResponseobject capturing the status, headers and other  
information about the response. The body of the reponse is written tooutputif specified and discarded  
otherwise. For HTTP/S requests, if aninputstream is given, aPUTrequest is made; otherwise if anoutput  
stream is given, aGETrequest is made; if neither is given aHEADrequest is made. For other protocols,  
appropriate default methods are used based on what combination of input and output are requested. The  
following options differ from thedownloadfunction:

```
- inputallows providing a request body; if provided default toPUTrequest
- progressis a callback taking four integers for upload and download progress
- throwcontrols whether to throw or return aRequestErroron request error

```

Note that unlikedownloadwhich throws an error if the requested URL could not be downloaded (indicated  
bynon-2xxstatuscode),requestreturnsaResponseobjectnomatterwhatthestatuscodeoftheresponse  
is. If there is an error with getting a response at all, then aRequestErroris thrown or returned.

```
Downloads.Response– Type.

```

struct Response  
proto :: String  
url :: String  
status :: Int  
message:: String  
headers:: Vector { Pair {String,String}}  
end

```

#### CHAPTER 68. DOWNLOADS 978

```

Responseis a type capturing the properties of a successful response to a request as an object. It has the  
following fields:

```
- proto: the protocol that was used to get the response
- url: the URL that was ultimately requested after following redirects
- status: the status code of the response, indicating success, failure, etc.
- message: a textual message describing the nature of the response
- headers: any headers that were returned with the response

```

The meaning and availability of some of these responses depends on the protocol used for the request.  
For many protocols, including HTTP/S and S/FTP, a 2xx status code indicates a successful response. For  
responses in protocols that do not support headers, the headers vector will be empty. HTTP/2 does not  
include a status message, only a status code, so the message will be empty.

```
Downloads.RequestError– Type.

```

struct RequestError<: ErrorException  
url :: String  
code :: Int  
message :: String  
response:: Response  
end

RequestErroris a type capturing the properties of a failed response to a request as an exception object:

```
- url: the original URL that was requested without any redirects
- code: the libcurl error code; 0 if a protocol-only error occurred
- message: the libcurl error message indicating what went wrong
- response: response object capturing what response info is available

```

ThesameRequestErrortypeisthrownbydownloadiftherequestwassuccessfulbuttherewasaprotocol-  
level error indicated by a status code that is not in the 2xx range, in which casecodewill be zero and the  
messagefield will be the empty string. TherequestAPI only throws aRequestErrorif the libcurl error  
codeis non-zero, in which case the includedresponseobject is likely to have astatusof zero and an  
empty message. There are, however, situations where a curl-level error is thrown due to a protocol error,  
in which case both the inner and outer code and message may be of interest.

```
Downloads.Downloader– Type.

```

Downloader(; [ grace:: Real = 30 ])

Downloaderobjects are used to perform individualdownloadoperations. Connections, name lookups and  
other resources are shared within aDownloader. These connections and resources are cleaned up after  
a configurable grace period (default: 30 seconds) since anything was downloaded with it, or when it is  
garbage collected, whichever comes first. If the grace period is set to zero, all resources will be cleaned  
up immediately as soon as there are no more ongoing downloads in progress. If the grace period is set to  
Infthen resources are not cleaned up untilDownloaderis garbage collected.

```

**Chapter 69**

**File Events**

FileWatching.poll_fd– Function.

```

poll_fd(fd, timeout_s:: Real =-1; readable= false , writable= false )

Monitor a file descriptorfdfor changes in the read or write availability, and with a timeout given by  
timeout_sseconds.  
The keyword arguments determine which of read and/or write status should be monitored; at least one of  
them must be set totrue.  
The returned value is an object with boolean fieldsreadable,writable, andtimedout, giving the result  
of the polling.

```
FileWatching.poll_file– Function.

```

poll_file(path:: AbstractString , interval_s:: Real =5.007, timeout_s:: Real =-1) ->  
↪→ (previous:: StatStruct , current)

Monitorafileforchangesbypollingeveryinterval_ssecondsuntilachangeoccursortimeout_sseconds  
have elapsed. Theinterval_sshould be a long period; the default is 5.007 seconds.  
Returns a pair of status objects(previous, current)when a change is detected. Thepreviousstatus  
is always aStatStruct, but it may have all of the fields zeroed (indicating the file didn't previously exist,  
or wasn't previously accessible).  
Thecurrentstatus object may be aStatStruct, anEOFError(indicating the timeout elapsed), or some  
otherExceptionsubtype (if thestatoperation failed - for example, if the path does not exist).  
Todeterminewhenafilewasmodified,comparecurrent isa StatStruct && mtime(prev) != mtime(current)  
todetectnotificationofchanges. However,usingwatch_fileforthisoperationispreferred,sinceitismore  
reliable and efficient, although in some situations it may not be available.

```
FileWatching.watch_file– Function.

```

watch_file(path:: AbstractString , timeout_s:: Real =-1)

Watch file or directorypathfor changes until a change occurs ortimeout_sseconds have elapsed.  
The returned value is an object with boolean fieldschanged,renamed, andtimedout, giving the result of  
watching the file.  
Thisbehaviorofthisfunctionvariesslightlyacrossplatforms. Seehttps://nodejs.org/api/fs.html#fs_caveats  
for more detailed information.

```
#### 979


#### CHAPTER 69. FILE EVENTS 980

FileWatching.watch_folder– Function.

```

watch_folder(path:: AbstractString , timeout_s:: Real =-1)

Watches a file or directorypathfor changes until a change has occurred ortimeout_sseconds have  
elapsed.  
This will continuing tracking changes forpathin the background untilunwatch_folderis called on the  
samepath.  
The returned value is an pair where the first field is the name of the changed file (if available) and the  
second field is an object with boolean fieldschanged,renamed, andtimedout, giving the event.  
Thisbehaviorofthisfunctionvariesslightlyacrossplatforms. Seehttps://nodejs.org/api/fs.html#fs_caveats  
for more detailed information.

```
FileWatching.unwatch_folder– Function.

```

unwatch_folder(path:: AbstractString )

Stop background tracking of changes forpath. It is not recommended to do this while another task is  
waiting forwatch_folderto return on the same path, as the result may be unpredictable.

```

**Chapter 70**

**Future**

TheFuturemodule implements future behavior of already existing functions, which will replace the current
version in a future release of Julia.

Future.copy!– Function.

```

Future.copy!(dst, src)-> dst

Copysrcintodst.

Julia 1.1  
ThisfunctionhasmovedtoBasewithJulia1.1,considerusingcopy!(dst, src)instead.Future.copy!  
will be deprecated in the future.

```
Future.randjump– Function.

```

randjump(r:: MersenneTwister , steps:: Integer ) -> MersenneTwister

CreateaninitializedMersenneTwisterobject, whosestateismovedforward(withoutgeneratingnumbers)  
fromrbystepssteps. One such step corresponds to the generation of twoFloat64numbers. For each  
different value ofsteps, a large polynomial has to be generated internally. One is already pre-computed  
forsteps=big(10)^20.

```
#### 981


**Chapter 71**

**Interactive Utilities**

This module is intended for interactive work. It is loaded automaticaly ininteractive mode.

Base.Docs.apropos– Function.

```

apropos([io:: IO =stdout], pattern:: Union { AbstractString , Regex })

Search available docstrings for entries containingpattern.  
Whenpatternis a string, case is ignored. Results are printed toio.

```
InteractiveUtils.varinfo– Function.

```

varinfo(m:: Module =Main, pattern:: Regex =r""; all:: Bool = false , imported:: Bool = false ,  
↪→ sortby:: Symbol = :name)

Return a markdown table giving information about exported global variables in a module, optionally re-  
stricted to those matchingpattern.  
The memory consumption estimate is an approximate lower bound on the size of the internal structure of  
the object.

```
- all: alsolistnon-exportedobjectsdefinedinthemodule,deprecatedobjects,andcompiler-generated
    objects.
- imported: also list objects explicitly imported from other modules.
- recursive: recursively include objects in sub-modules, observing the same settings in each.
- sortby: the column to sort results by. Options are:name(default),:size, and:summary.

InteractiveUtils.versioninfo– Function.

```

versioninfo(io:: IO =stdout; verbose:: Bool = false )

PrintinformationabouttheversionofJuliainuse. Theoutputiscontrolledwithbooleankeywordarguments:

```
- verbose: print all additional information

```

See also:VERSION.

```
InteractiveUtils.methodswith– Function.

```

methodswith(typ[, module or function ]; supertypes:: Bool = false ])

```
#### 982


#### CHAPTER 71. INTERACTIVE UTILITIES 983

```

Return an array of methods with an argument of typetyp.  
The optional second argument restricts the search to a particular module or function (the default is all  
top-level modules).  
If keywordsupertypesistrue, also return arguments with a parent type oftyp, excluding typeAny.

```
InteractiveUtils.subtypes– Function.

```

subtypes(T:: DataType )

Return a list of immediate subtypes of DataTypeT. Note that all currently loaded subtypes are included,  
including those not visible in the current module.  
See alsosupertype,supertypes,methodswith.  
Examples

julia> subtypes( Integer )  
3-element Vector{Any}:  
Bool  
Signed  
Unsigned

```
InteractiveUtils.supertypes– Function.

```

supertypes(T:: Type )

Returnatuple(T, ..., Any)ofTandallitssupertypes,asdeterminedbysuccessivecallstothesupertype  
function, listed in order of<:and terminated byAny.  
See alsosubtypes.  
Examples

julia> supertypes( Int )  
(Int64, Signed, Integer, Real, Number, Any)

```
InteractiveUtils.edit– Method.

```

edit(path:: AbstractString , line:: Integer =0)

Edit a file or directory optionally providing a line number to edit the file at. Return to thejuliaprompt  
when you quit the editor. The editor can be changed by settingJULIA_EDITOR,VISUALorEDITORas an  
environment variable.  
See alsodefine_editor.

```
InteractiveUtils.edit– Method.

```

edit( function , [types])  
edit( module )

Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For  
modules, open the main source file. The module needs to be loaded withusingorimportfirst.

Julia 1.1  
editon modules requires at least Julia 1.1.

```

#### CHAPTER 71. INTERACTIVE UTILITIES 984

```

To ensure that the file can be opened at the given line, you may need to calldefine_editorfirst.

```
InteractiveUtils.@edit– Macro.

```

@edit

Evaluates the arguments to the function or macro call, determines their types, and calls theeditfunction  
on the resulting expression.  
See also:@less,@which.

```
InteractiveUtils.define_editor– Function.

```

define_editor(fn, pattern; wait= false )

Define a new editor matchingpatternthat can be used to open a file (possibly at a given line number)  
usingfn.  
Thefnargument is a function that determines how to open a file with the given editor. It should take three  
arguments, as follows:

```
- cmd- a base command object for the editor
- path- the path to the source file to open
- line- the line number to open the editor at

```

Editors which cannot open to a specific line with a command may ignore thelineargument. Thefn  
callback must return either an appropriateCmdobject to open a file ornothingto indicate that they cannot  
edit this file. Usenothingto indicate that this editor is not appropriate for the current environment and  
another editor should be attempted. It is possible to add more general editing hooks that need not spawn  
external commands by pushing a callback directly to the vectorEDITOR_CALLBACKS.  
Thepatternargument is a string, regular expression, or an array of strings and regular expressions. For  
thefnto be called, one of the patterns must match the value ofEDITOR,VISUALorJULIA_EDITOR. For  
strings, the string must equal thebasenameof the first word of the editor command, with its extension,  
if any, removed. E.g."vi" doesn't match"vim -g " but matches"/usr/bin/vi -m"; it also matchesvi.exe.  
Ifpatternis a regex it is matched against all of the editor command as a shell-escaped string. An array  
pattern matches if any of its items match. If multiple editors match, the one added most recently is used.  
By default julia does not wait for the editor to close, running it in the background. However, if the editor  
is terminal based, you will probably want to setwait=trueand julia will wait for the editor to close before  
resuming.  
If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is  
invoked:  
(cmd, path, line) -> `$cmd $path`

Note that many editors are already defined. All of the following commands should already work:

```
- emacs
- emacsclient
- vim
- nvim
- nano


#### CHAPTER 71. INTERACTIVE UTILITIES 985

- micro
- kak
- textmate
- mate
- kate
- subl
- atom
- notepad++
- Visual Studio Code
- open
- pycharm
- bbedit

```

Example:  
The following defines the usage of terminal-basedemacs:  
define_editor(  
r"\bemacs\b.*\s(-nw|--no-window-system)\b", wait=true) do cmd, path, line  
`$cmd +$line $path`  
end

Julia 1.4  
define_editorwas introduced in Julia 1.4.

```
InteractiveUtils.less– Method.

```

less(file:: AbstractString , [line:: Integer ])

Show a file using the default pager, optionally providing a starting line number. Returns to thejulia  
prompt when you quit the pager.

```
InteractiveUtils.less– Method.

```

less( function , [types])

Show the definition of a function using the default pager, optionally specifying a tuple of types to indicate  
which method to see.

```
InteractiveUtils.@less– Macro.

```

@less

Evaluates the arguments to the function or macro call, determines their types, and calls thelessfunction  
on the resulting expression.  
See also:@edit,@which,@code_lowered.

```
InteractiveUtils.@which– Macro.

```

@which

```

#### CHAPTER 71. INTERACTIVE UTILITIES 986

```

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns theMethod  
objectforthemethodthatwouldbecalledforthosearguments. Appliedtoavariable, itreturnsthemodule  
in which the variable was bound. It calls out to thewhichfunction.  
See also:@less,@edit.

```
InteractiveUtils.@functionloc– Macro.

```

@functionloc

Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple  
(filename,line)giving the location for the method that would be called for those arguments. It calls out  
to thefunctionlocfunction.

```
InteractiveUtils.@code_lowered– Macro.

```

@code_lowered

Evaluates the arguments to the function or macro call, determines their types, and callscode_loweredon  
the resulting expression.

```
InteractiveUtils.@code_typed– Macro.

```

@code_typed

Evaluates the arguments to the function or macro call, determines their types, and callscode_typedon  
the resulting expression. Use the optional argumentoptimizewith  
@code_typed optimize=true foo(x)

to control whether additional optimizations, such as inlining, are also applied.

```
InteractiveUtils.code_warntype– Function.

```

code_warntype([io:: IO ], f, types; debuginfo=:default)

Prints lowered and type-inferred ASTs for the methods matching the given generic function and type sig-  
nature toiowhich defaults tostdout. The ASTs are annotated in such a way as to cause"non-leaf" types  
to be emphasized (if color is available, displayed in red). This serves as a warning of potential type insta-  
bility. Not all non-leaf types are particularly problematic for performance, so the results need to be used  
judiciously. In particular, unions containing eithermissingornothingare displayed in yellow, since these  
are often intentional.  
Keyword argumentdebuginfomay be one of:sourceor:none(default), to specify the verbosity of code  
comments.  
See@code_warntypefor more information.

```
InteractiveUtils.@code_warntype– Macro.

```

@code_warntype

Evaluates the arguments to the function or macro call, determines their types, and callscode_warntype  
on the resulting expression.

```
InteractiveUtils.code_llvm– Function.

```

code_llvm([io=stdout,], f, types; raw= false , dump_module= false , optimize= true ,  
↪→ debuginfo=:default)

```

#### CHAPTER 71. INTERACTIVE UTILITIES 987

```

Prints the LLVM bitcodes generated for running the method matching the given generic function and type  
signature toio.  
If theoptimizekeyword is unset, the code will be shown before LLVM optimizations. All metadata and  
dbg.* calls are removed from the printed bitcode. For the full IR, set therawkeyword to true. To dump the  
entire module that encapsulates the function (with declarations), set thedump_modulekeyword to true.  
Keyword argumentdebuginfomay be one of source (default) or none, to specify the verbosity of code  
comments.

```
InteractiveUtils.@code_llvm– Macro.

```

@code_llvm

Evaluates the arguments to the function or macro call, determines their types, and callscode_llvmon  
the resulting expression. Set the optional keyword argumentsraw,dump_module,debuginfo,optimizeby  
putting them and their value before the function call, like this:  
@code_llvm raw=true dump_module=true debuginfo=:default f(x)  
@code_llvm optimize=false f(x)

optimizecontrols whether additional optimizations, such as inlining, are also applied. rawmakes all  
metadata and dbg.* calls visible.debuginfomay be one of:source(default) or:none, to specify the  
verbosity of code comments.dump_moduleprints the entire module that encapsulates the function.

```
InteractiveUtils.code_native– Function.

```

code_native([io=stdout,], f, types; syntax=:att, debuginfo=:default, binary= false )

Prints the native assembly instructions generated for running the method matching the given generic  
function and type signature toio. Switch assembly syntax usingsyntaxsymbol parameter set to:attfor  
AT&T syntax or:intelfor Intel syntax. Keyword argumentdebuginfomay be one of source (default) or  
none, to specify the verbosity of code comments. Ifbinaryistrue, it also prints the binary machine code  
for each instruction precedented by an abbreviated address.

```
InteractiveUtils.@code_native– Macro.

```

@code_native

Evaluates the arguments to the function or macro call, determines their types, and callscode_nativeon  
the resulting expression.  
Set the optional keyword argumentdebuginfoby putting it before the function call, like this:  
@code_native debuginfo=:default f(x)

debuginfomay be one of:source(default) or:none, to specify the verbosity of code comments.

```
InteractiveUtils.clipboard– Function.

```

clipboard(x)

Send a printed form ofxto the operating system clipboard ("copy").  
clipboard() -> AbstractString

Return a string with the contents of the operating system clipboard ("paste").

```

**Chapter 72**

**Lazy Artifacts**

In order for a package to download artifacts lazily,LazyArtifactsmust be explicitly listed as a dependency
of that package.

For further information on artifacts, seeArtifacts.

#### 988


**Chapter 73**

**LibGit2**

The LibGit2 module provides bindings tolibgit2, a portable C library that implements core functionality for the
Git version control system. These bindings are currently used to power Julia's package manager. It is expected
that this module will eventually be moved into a separate package.

### Functionality

Some of this documentation assumes some prior knowledge of the libgit2 API. For more information on some
of the objects and methods referenced here, consult the upstreamlibgit2 API reference.

LibGit2.Buffer– Type.

```

LibGit2.Buffer

A data buffer for exporting data from libgit2. Matches thegit_bufstruct.  
When fetching data from LibGit2, a typical usage would look like:

buf_ref= Ref (Buffer())  
@check ccall (..., ( Ptr {Buffer},), buf_ref)

# operation on buf_ref

free(buf_ref)

In particular, note thatLibGit2.freeshould be called afterward on theRefobject.

```
LibGit2.CheckoutOptions– Type.

```

LibGit2.CheckoutOptions

Matches thegit_checkout_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- checkout_strategy: determine how to handle conflicts and whether to force the checkout/recreate
    missing files.
- disable_filters: if nonzero, do not apply filters like CLRF (to convert file newlines between UNIX
    and DOS).
- dir_mode: read/write/access mode for any directories involved in the checkout. Default is 0755.
- file_mode: read/write/access mode for any files involved in the checkout. Default is 0755 or 0644 ,
    depending on the blob.

#### 989


#### CHAPTER 73. LIBGIT2 990

- file_open_flags: bitflags used to open any files during the checkout.
- notify_flags: Flags for what sort of conflicts the user should be notified about.
- notify_cb: An optional callback function to notify the user if a checkout conflict occurs. If this
    function returns a non-zero value, the checkout will be cancelled.
- notify_payload: Payload for the notify callback function.
- progress_cb: An optional callback function to display checkout progress.
- progress_payload: Payload for the progress callback.
- paths: If not empty, describes which paths to search during the checkout. If empty, the checkout
    will occur over all files in the repository.
- baseline: Expected content of theworkdir, captured in a (pointer to a)GitTree. Defaults to the
    state of the tree at HEAD.
- baseline_index: Expected content of theworkdir, captured in a (pointer to a)GitIndex. Defaults
    to the state of the index at HEAD.
- target_directory: If not empty, checkout to this directory instead of theworkdir.
- ancestor_label: In case of conflicts, the name of the common ancestor side.
- our_label: In case of conflicts, the name of"our" side.
- their_label: In case of conflicts, the name of"their" side.
- perfdata_cb: An optional callback function to display performance data.
- perfdata_payload: Payload for the performance callback.

LibGit2.CloneOptions– Type.

```

LibGit2.CloneOptions

Matches thegit_clone_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- checkout_opts: The options for performing the checkout of the remote as part of the clone.
- fetch_opts: The options for performing the pre-checkout fetch of the remote as part of the clone.
- bare: If 0 , clone the full remote repository. If non-zero, perform a bare clone, in which there is no
    local copy of the source files in the repository and thegitdirandworkdirare the same.
- localclone: Flag whether to clone a local object database or do a fetch. The default is to let git
    decide. It will not use the git-aware transport for a local clone, but will use it for URLs which begin
    withfile://.
- checkout_branch: The name of the branch to checkout. If an empty string, the default branch of the
    remote will be checked out.
- repository_cb: An optional callback which will be used to create the new repository into which the
    clone is made.
- repository_cb_payload: The payload for the repository callback.
- remote_cb: An optional callback used to create theGitRemotebefore making the clone from it.
- remote_cb_payload: The payload for the remote callback.

LibGit2.DescribeOptions– Type.


#### CHAPTER 73. LIBGIT2 991

```

LibGit2.DescribeOptions

Matches thegit_describe_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- max_candidates_tags: consider this many most recent tags inrefs/tagsto describe a commit.
    Defaults to 10 (so that the 10 most recent tags would be examined to see if they describe a commit).
- describe_strategy: whether to consider all entries inrefs/tags(equivalent togit-describe --
    tags) or all entries inrefs/(equivalent togit-describe --all). The default is to only show an-
    notated tags. IfConsts.DESCRIBE_TAGSis passed, all tags, annotated or not, will be considered. If
    Consts.DESCRIBE_ALLis passed, any ref inrefs/will be considered.
- pattern: only consider tags which matchpattern. Supports glob expansion.
- only_follow_first_parent: when finding the distance from a matching reference to the described
    object, only consider the distance from the first parent.
- show_commit_oid_as_fallback: if no matching reference can be found which describes a commit,
    show the commit'sGitHashinstead of throwing an error (the default behavior).

LibGit2.DescribeFormatOptions– Type.

```

LibGit2.DescribeFormatOptions

Matches thegit_describe_format_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- abbreviated_size: lower bound on the size of the abbreviatedGitHashto use, defaulting to 7.
- always_use_long_format: set to 1 to use the long format for strings even if a short format can be
    used.
- dirty_suffix: if set, this will be appended to the end of the description string if theworkdiris dirty.

LibGit2.DiffDelta– Type.

```

LibGit2.DiffDelta

Description of changes to one entry. Matches thegit_diff_deltastruct.  
The fields represent:

```
- status: One ofConsts.DELTA_STATUS, indicating whether the file has been added/modified/deleted.
- flags: Flags for the delta and the objects on each side. Determines whether to treat the file(s) as
    binary/text, whether they exist on each side of the diff, and whether the object ids are known to be
    correct.
- similarity: Used to indicate if a file has been renamed or copied.
- nfiles: The number of files in the delta (for instance, if the delta was run on a submodule commit
    id, it may contain more than one file).
- old_file: ADiffFilecontaining information about the file(s) before the changes.
- new_file: ADiffFilecontaining information about the file(s) after the changes.


#### CHAPTER 73. LIBGIT2 992

LibGit2.DiffFile– Type.

```

LibGit2.DiffFile

Description of one side of a delta. Matches thegit_diff_filestruct.  
The fields represent:

```
- id: theGitHashof the item in the diff. If the item is empty on this side of the diff (for instance, if the
    diff is of the removal of a file), this will beGitHash(0).
- path: aNULLterminated path to the item relative to the working directory of the repository.
- size: the size of the item in bytes.
- flags: a combination of thegit_diff_flag_tflags. Theith bit of this integer sets theith flag.
- mode: thestatmode for the item.
- id_abbrev: only present in LibGit2 versions newer than or equal to0.25.0. The length of theid
    field when converted usingstring. Usually equal toOID_HEXSZ(40).

LibGit2.DiffOptionsStruct– Type.

```

LibGit2.DiffOptionsStruct

Matches thegit_diff_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- flags: flags controlling which files will appear in the diff. Defaults toDIFF_NORMAL.
- ignore_submodules: whethertolookatfilesinsubmodulesornot. DefaultstoSUBMODULE_IGNORE_UNSPECIFIED,
    which means the submodule's configuration will control whether it appears in the diff or not.
- pathspec: path to files to include in the diff. Default is to use all files in the repository.
- notify_cb: optional callback which will notify the user of changes to the diff as file deltas are added
    to it.
- progress_cb: optional callback which will display diff progress. Only relevant on libgit2 versions at
    least as new as 0.24.0.
- payload: the payload to pass tonotify_cbandprogress_cb.
- context_lines: the number of unchanged lines used to define the edges of a hunk. This is also the
    number of lines which will be shown before/after a hunk to provide context. Default is 3.
- interhunk_lines: the maximum number of unchanged lines between two separate hunks allowed
    before the hunks will be combined. Default is 0.
- id_abbrev: sets the length of the abbreviatedGitHashto print. Default is 7.
- max_size: the maximum file size of a blob. Above this size, it will be treated as a binary blob. The
    default is 512 MB.
- old_prefix: the virtual file directory in which to place old files on one side of the diff. Default is"a".
- new_prefix: the virtual file directory in which to place new files on one side of the diff. Default is
    "b".

LibGit2.FetchHead– Type.

```

LibGit2.FetchHead

```

#### CHAPTER 73. LIBGIT2 993

```

Contains the information about HEAD during a fetch, including the name and URL of the branch fetched  
from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.  
The fields represent:

```
- name: Thenameinthelocalreferencedatabaseofthefetchhead,forexample,"refs/heads/master".
- url: The URL of the fetch head.
- oid: TheGitHashof the tip of the fetch head.
- ismerge: Booleanflagindicatingwhetherthechangesattheremotehavebeenmergedintothelocal
    copy yet or not. Iftrue, the local copy is up to date with the remote fetch head.

LibGit2.FetchOptions– Type.

```

LibGit2.FetchOptions

Matches thegit_fetch_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- callbacks: remote callbacks to use during the fetch.
- prune: whether to perform a prune after the fetch or not. The default is to use the setting from the
    GitConfig.
- update_fetchhead: whether to update theFetchHeadafter the fetch. The default is to perform the
    update, which is the normal git behavior.
- download_tags: whether to download tags present at the remote or not. The default is to request
    the tags for objects which are being downloaded anyway from the server.
- proxy_opts: options for connecting to the remote through a proxy. SeeProxyOptions. Only present
    on libgit2 versions newer than or equal to 0.25.0.
- custom_headers: any extra headers needed for the fetch. Only present on libgit2 versions newer
    than or equal to 0.24.0.

LibGit2.GitAnnotated– Type.

```

GitAnnotated(repo::GitRepo, commit_id::GitHash)  
GitAnnotated(repo::GitRepo, ref::GitReference)  
GitAnnotated(repo::GitRepo, fh::FetchHead)  
GitAnnotated(repo::GitRepo, committish:: AbstractString )

An annotated git commit carries with it information about how it was looked up and why, so that rebase or  
mergeoperationshavemoreinformationaboutthecontextofthecommit. Conflictfilescontaininformation  
about the source/target branches in the merge which are conflicting, for instance. An annotated commit  
can refer to the tip of a remote branch, for instance when aFetchHeadis passed, or to a branch head  
described usingGitReference.

```
LibGit2.GitBlame– Type.

```

GitBlame(repo::GitRepo, path:: AbstractString ; options::BlameOptions=BlameOptions())

ConstructaGitBlameobjectforthefileatpath, usingchangeinformationgleanedfromthehistoryofrepo.  
TheGitBlameobject records who changed which chunks of the file when, and how.optionscontrols how  
to separate the contents of the file and which commits to probe - seeBlameOptionsfor more information.

```

#### CHAPTER 73. LIBGIT2 994

LibGit2.GitBlob– Type.

```

GitBlob(repo::GitRepo, hash::AbstractGitHash)  
GitBlob(repo::GitRepo, spec:: AbstractString )

Return aGitBlobobject fromrepospecified byhash/spec.

```
- hashis a full (GitHash) or partial (GitShortHash) hash.
- specis a textual specification: seethe git docsfor a full list.

LibGit2.GitCommit– Type.

```

GitCommit(repo::GitRepo, hash::AbstractGitHash)  
GitCommit(repo::GitRepo, spec:: AbstractString )

Return aGitCommitobject fromrepospecified byhash/spec.

```
- hashis a full (GitHash) or partial (GitShortHash) hash.
- specis a textual specification: seethe git docsfor a full list.

LibGit2.GitHash– Type.

```

GitHash

A git object identifier, based on the sha-1 hash. It is a 20 byte string (40 hex digits) used to identify a  
GitObjectin a repository.

```
LibGit2.GitObject– Type.

```

GitObject(repo::GitRepo, hash::AbstractGitHash)  
GitObject(repo::GitRepo, spec:: AbstractString )

Return the specified object (GitCommit,GitBlob,GitTreeorGitTag) fromrepospecified byhash/spec.

```
- hashis a full (GitHash) or partial (GitShortHash) hash.
- specis a textual specification: seethe git docsfor a full list.

LibGit2.GitRemote– Type.

```

GitRemote(repo::GitRepo, rmt_name:: AbstractString , rmt_url:: AbstractString ) -> GitRemote

Look up a remote git repository using its name and URL. Uses the default fetch refspec.  
Examples

repo= LibGit2.init(repo_path)  
remote= LibGit2.GitRemote(repo,"upstream", repo_url)

GitRemote(repo::GitRepo, rmt_name::AbstractString, rmt_url::AbstractString, fetch_spec::  
AbstractString) -> GitRemote

Look up a remote git repository using the repository's name and URL, as well as specifications for how to  
fetch from the remote (e.g. which remote branch to fetch from).  
Examples

```

#### CHAPTER 73. LIBGIT2 995

```

repo= LibGit2.init(repo_path)  
refspec= "+refs/heads/mybranch:refs/remotes/origin/mybranch"  
remote= LibGit2.GitRemote(repo,"upstream", repo_url, refspec)

```
LibGit2.GitRemoteAnon– Function.

```

GitRemoteAnon(repo::GitRepo, url:: AbstractString ) -> GitRemote

Look up a remote git repository using only its URL, not its name.  
Examples

repo= LibGit2.init(repo_path)  
remote= LibGit2.GitRemoteAnon(repo, repo_url)

```
LibGit2.GitRepo– Type.

```

LibGit2.GitRepo(path:: AbstractString )

Open a git repository atpath.

```
LibGit2.GitRepoExt– Function.

```

LibGit2.GitRepoExt(path:: AbstractString , flags:: Cuint = Cuint (Consts.REPOSITORY_OPEN_DEFAULT))

Open a git repository atpathwith extended controls (for instance, if the current user must be a member  
of a special access group to readpath).

```
LibGit2.GitRevWalker– Type.

```

GitRevWalker(repo::GitRepo)

AGitRevWalkerwalks through the revisions (i.e. commits) of a git repositoryrepo. It is a collection of  
the commits in the repository, and supports iteration and calls toLibGit2.mapandLibGit2.count(for  
instance,LibGit2.countcould be used to determine what percentage of commits in a repository were  
made by a certain author).

cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker  
LibGit2.count((oid,repo)->(oid== commit_oid1), walker, oid=commit_oid1,  
↪→ by=LibGit2.Consts.SORT_TIME)  
end

Here,LibGit2.countfinds the number of commits along the walk with a certainGitHash. Since the  
GitHashis unique to a commit,cntwill be 1.

```
LibGit2.GitShortHash– Type.

```

GitShortHash(hash::GitHash, len:: Integer )

A shortened git object identifier, which can be used to identify a git object when it is unique, consisting of  
the initiallenhexadecimal digits ofhash(the remaining digits are ignored).

```
LibGit2.GitSignature– Type.

```

LibGit2.GitSignature

This is a Julia wrapper around a pointer to agit_signatureobject.

```

#### CHAPTER 73. LIBGIT2 996

LibGit2.GitStatus– Type.

```

LibGit2.GitStatus(repo::GitRepo; status_opts=StatusOptions())

Collect information about the status of each file in the git repositoryrepo(e.g. is the file modified, staged,  
etc.).status_optscan be used to set various options, for instance whether or not to look at untracked  
files or whether to include submodules or not. SeeStatusOptionsfor more information.

```
LibGit2.GitTag– Type.

```

GitTag(repo::GitRepo, hash::AbstractGitHash)  
GitTag(repo::GitRepo, spec:: AbstractString )

Return aGitTagobject fromrepospecified byhash/spec.

```
- hashis a full (GitHash) or partial (GitShortHash) hash.
- specis a textual specification: seethe git docsfor a full list.

LibGit2.GitTree– Type.

```

GitTree(repo::GitRepo, hash::AbstractGitHash)  
GitTree(repo::GitRepo, spec:: AbstractString )

Return aGitTreeobject fromrepospecified byhash/spec.

```
- hashis a full (GitHash) or partial (GitShortHash) hash.
- specis a textual specification: seethe git docsfor a full list.

LibGit2.IndexEntry– Type.

```

LibGit2.IndexEntry

In-memory representation of a file entry in the index. Matches thegit_index_entrystruct.

```
LibGit2.IndexTime– Type.

```

LibGit2.IndexTime

Matches thegit_index_timestruct.

```
LibGit2.BlameOptions– Type.

```

LibGit2.BlameOptions

Matches thegit_blame_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- flags: one ofConsts.BLAME_NORMALorConsts.BLAME_FIRST_PARENT(the other blame flags are not
    yet implemented by libgit2).
- min_match_characters: the minimum number of alphanumeric characters which much change in
    a commit in order for the change to be associated with that commit. The default is 20. Only takes
    effect if one of theConsts.BLAME_*_COPIESflags are used, which libgit2 does not implement yet.


#### CHAPTER 73. LIBGIT2 997

- newest_commit: theGitHashof the newest commit from which to look at changes.
- oldest_commit: theGitHashof the oldest commit from which to look at changes.
- min_line: the first line of the file from which to starting blaming. The default is 1.
- max_line: the last line of the file to which to blame. The default is 0 , meaning the last line of the file.

LibGit2.MergeOptions– Type.

```

LibGit2.MergeOptions

Matches thegit_merge_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- flags: anenumfor flags describing merge behavior. Defined ingit_merge_flag_t. The correspond-
    ing Julia enum isGIT_MERGEand has values:
       **-** MERGE_FIND_RENAMES: detect if a file has been renamed between the common ancestor and the
          "ours" or "theirs" side of the merge. Allows merges where a file has been renamed.
       **-** MERGE_FAIL_ON_CONFLICT: exit immediately if a conflict is found rather than trying to resolve it.
       **-** MERGE_SKIP_REUC: do not write the REUC extension on the index resulting from the merge.
       **-** MERGE_NO_RECURSIVE: if the commits being merged have multiple merge bases, use the first
          one, rather than trying to recursively merge the bases.
- rename_threshold: how similar two files must to consider one a rename of the other. This is an
    integer that sets the percentage similarity. The default is 50.
- target_limit: the maximum number of files to compare with to look for renames. The default is
    200.
- metric: optional custom function to use to determine the similarity between two files for rename
    detection.
- recursion_limit: the upper limit on the number of merges of common ancestors to perform to try
    to build a new virtual merge base for the merge. The default is no limit. This field is only present on
    libgit2 versions newer than 0.24.0.
- default_driver: the merge driver to use if both sides have changed. This field is only present on
    libgit2 versions newer than 0.25.0.
- file_favor: how to handle conflicting file contents for thetextdriver.
    **-** MERGE_FILE_FAVOR_NORMAL: if both sides of the merge have changes to a section, make a note
       of the conflict in the index whichgit checkoutwill use to create a merge file, which the user
       can then reference to resolve the conflicts. This is the default.
    **-** MERGE_FILE_FAVOR_OURS: if both sides of the merge have changes to a section, use the version
       in the "ours" side of the merge in the index.
    **-** MERGE_FILE_FAVOR_THEIRS:ifbothsidesofthemergehavechangestoasection,usetheversion
       in the "theirs" side of the merge in the index.
    **-** MERGE_FILE_FAVOR_UNION: if both sides of the merge have changes to a section, include each
       unique line from both sides in the file which is put into the index.
- file_flags: guidelines for merging files.

LibGit2.ProxyOptions– Type.

```

LibGit2.ProxyOptions

```

#### CHAPTER 73. LIBGIT2 998

```

Options for connecting through a proxy.  
Matches thegit_proxy_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- proxytype: anenumfor the type of proxy to use. Defined ingit_proxy_t. The corresponding Julia
    enum isGIT_PROXYand has values:
       **-** PROXY_NONE: do not attempt the connection through a proxy.
       **-** PROXY_AUTO: attempt to figure out the proxy configuration from the git configuration.
       **-** PROXY_SPECIFIED: connect using the URL given in theurlfield of this struct.
    Default is to auto-detect the proxy type.
- url: the URL of the proxy.
- credential_cb: a pointer to a callback function which will be called if the remote requires authenti-
    cation to connect.
- certificate_cb: a pointer to a callback function which will be called if certificate verification fails.
    This lets the user decide whether or not to keep connecting. If the function returns 1 , connecting will
    be allowed. If it returns 0 , the connection will not be allowed. A negative value can be used to return
    errors.
- payload: the payload to be provided to the two callback functions.

```

Examples

julia> fo = LibGit2.FetchOptions(  
proxy_opts= LibGit2.ProxyOptions(url= Cstring ("https://my_proxy_url.com")))

julia> fetch(remote,"master", options=fo)

```
LibGit2.PushOptions– Type.

```

LibGit2.PushOptions

Matches thegit_push_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- parallelism: if a pack file must be created, this variable sets the number of worker threads which
    will be spawned by the packbuilder. If 0 , the packbuilder will auto-set the number of threads to use.
    The default is 1.
- callbacks: the callbacks (e.g. for authentication with the remote) to use for the push.
- proxy_opts: only relevant if the LibGit2 version is greater than or equal to0.25.0. Sets options for
    using a proxy to communicate with a remote. SeeProxyOptionsfor more information.
- custom_headers: only relevant if the LibGit2 version is greater than or equal to0.24.0. Extra head-
    ers needed for the push operation.

LibGit2.RebaseOperation– Type.

```

LibGit2.RebaseOperation

```

#### CHAPTER 73. LIBGIT2 999

```

Describesasingleinstruction/operationtobeperformedduringtherebase. Matchesthegit_rebase_operation  
struct.  
The fields represent:

```
- optype: the type of rebase operation currently being performed. The options are:
    **-** REBASE_OPERATION_PICK: cherry-pick the commit in question.
    **-** REBASE_OPERATION_REWORD: cherry-pick the commit in question, but rewrite its message using
       the prompt.
    **-** REBASE_OPERATION_EDIT: cherry-pick the commit in question, but allow the user to edit the
       commit's contents and its message.
    **-** REBASE_OPERATION_SQUASH: squash the commit in question into the previous commit. The com-
       mit messages of the two commits will be merged.
    **-** REBASE_OPERATION_FIXUP: squash the commit in question into the previous commit. Only the
       commit message of the previous commit will be used.
    **-** REBASE_OPERATION_EXEC: do not cherry-pick a commit. Run a command and continue if the
       command exits successfully.
- id: theGitHashof the commit being worked on during this rebase step.
- exec: in caseREBASE_OPERATION_EXECis used, the command to run during this step (for instance,
    running the test suite after each commit).

LibGit2.RebaseOptions– Type.

```

LibGit2.RebaseOptions

Matches thegit_rebase_optionsstruct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- quiet: inform other git clients helping with/working on the rebase that the rebase should be done
    "quietly". Used for interoperability. The default is 1.
- inmemory: start an in-memory rebase. Callers working on the rebase can go through its steps and
    commit any changes, but cannot rewind HEAD or update the repository. Theworkdirwill not be
    modified. Only present on libgit2 versions newer than or equal to 0.24.0.
- rewrite_notes_ref: nameofthereferencetonotestousetorewritethecommitnotesastherebase
    is finished.
- merge_opts: merge options controlling how the trees will be merged at each rebase step. Only
    present on libgit2 versions newer than or equal to 0.24.0.
- checkout_opts: checkout options for writing files when initializing the rebase, stepping through it,
    and aborting it. SeeCheckoutOptionsfor more information.

LibGit2.RemoteCallbacks– Type.

```

LibGit2.RemoteCallbacks

Callback settings. Matches thegit_remote_callbacksstruct.

```
LibGit2.SignatureStruct– Type.

```

LibGit2.SignatureStruct

```

#### CHAPTER 73. LIBGIT2 1000

```

An action signature (e.g. for committers, taggers, etc). Matches thegit_signaturestruct.  
The fields represent:

```
- name: The full name of the committer or author of the commit.
- email: The email at which the committer/author can be contacted.
- when: aTimeStructindicating when the commit was authored/committed into the repository.

LibGit2.StatusEntry– Type.

```

LibGit2.StatusEntry

Providing the differences between the file as it exists in HEAD and the index, and providing the differences  
between the index and the working directory. Matches thegit_status_entrystruct.  
The fields represent:

```
- status: contains the status flags for the file, indicating if it is current, or has been changed in some
    way in the index or work tree.
- head_to_index: a pointer to aDiffDeltawhich encapsulates the difference(s) between the file as
    it exists in HEAD and in the index.
- index_to_workdir: a pointer to aDiffDeltawhich encapsulates the difference(s) between the file
    as it exists in the index and in theworkdir.

LibGit2.StatusOptions– Type.

```

LibGit2.StatusOptions

Options to control howgit_status_foreach_ext()will issue callbacks. Matches thegit_status_opt_t  
struct.  
The fields represent:

```
- version: version of the struct in use, in case this changes later. For now, always 1.
- show: aflagforwhichfilestoexamineandinwhichorder. ThedefaultisConsts.STATUS_SHOW_INDEX_AND_WORKDIR.
- flags: flags for controlling any callbacks used in a status call.
- pathspec: an array of paths to use for path-matching. The behavior of the path-matching will vary
    depending on the values ofshowandflags.
- Thebaselineis the tree to be used for comparison to the working directory and index; defaults to
    HEAD.

LibGit2.StrArrayStruct– Type.

```

LibGit2.StrArrayStruct

A LibGit2 representation of an array of strings. Matches thegit_strarraystruct.  
When fetching data from LibGit2, a typical usage would look like:

sa_ref= Ref (StrArrayStruct())  
@check ccall (..., ( Ptr {StrArrayStruct},), sa_ref)  
res = convert( Vector {String}, sa_ref[])  
free(sa_ref)

```

#### CHAPTER 73. LIBGIT2 1001

```

In particular, note thatLibGit2.freeshould be called afterward on theRefobject.  
Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conver-  
sion:

strs= String[...]  
@check ccall (..., ( Ptr {StrArrayStruct},), strs)

Note that no call tofreeis required as the data is allocated by Julia.

```
LibGit2.TimeStruct– Type.

```

LibGit2.TimeStruct

Time in a signature. Matches thegit_timestruct.

```
LibGit2.add!– Function.

```

add!(repo::GitRepo, files:: AbstractString ...; flags:: Cuint = Consts.INDEX_ADD_DEFAULT)  
add!(idx::GitIndex, files:: AbstractString ...; flags:: Cuint = Consts.INDEX_ADD_DEFAULT)

Add all the files with paths specified byfilesto the indexidx(or the index of therepo). If the file already  
exists, the index entry will be updated. If the file does not exist already, it will be newly added into the  
index. filesmay contain glob patterns which will be expanded and any matching files will be added  
(unlessINDEX_ADD_DISABLE_PATHSPEC_MATCHis set, see below). If a file has been ignored (in.gitignore  
or in the config), it will not be added, unless it is already being tracked in the index, in which case it will  
be updated. The keyword argumentflagsis a set of bit-flags which control the behavior with respect to  
ignored files:

```
- Consts.INDEX_ADD_DEFAULT- default, described above.
- Consts.INDEX_ADD_FORCE- disregard the existing ignore rules and force addition of the file to the
    index even if it is already ignored.
- Consts.INDEX_ADD_CHECK_PATHSPEC- cannot be used at the same time asINDEX_ADD_FORCE. Check
    that each file infileswhich exists on disk is not in the ignore list. If one of the files is ignored, the
    function will returnEINVALIDSPEC.
- Consts.INDEX_ADD_DISABLE_PATHSPEC_MATCH- turn off glob matching, and only add files to the
    index which exactly match the paths specified infiles.

LibGit2.add_fetch!– Function.

```

add_fetch!(repo::GitRepo, rmt::GitRemote, fetch_spec::String)

Add a fetch refspec for the specifiedrmt. This refspec will contain information about which branch(es) to  
fetch from.  
Examples

julia> LibGit2.add_fetch!(repo, remote,"upstream");

julia> LibGit2.fetch_refspecs(remote)  
String["+refs/heads/_:refs/remotes/upstream/_"]

```
LibGit2.add_push!– Function.

```

add_push!(repo::GitRepo, rmt::GitRemote, push_spec::String)

```

#### CHAPTER 73. LIBGIT2 1002

```

Add a push refspec for the specifiedrmt. This refspec will contain information about which branch(es) to  
push to.  
Examples

julia> LibGit2.add_push!(repo, remote,"refs/heads/master");

julia> remote= LibGit2.get(LibGit2.GitRemote, repo, branch);

julia> LibGit2.push_refspecs(remote)  
String["refs/heads/master"]

Note  
You may need tocloseand reopen theGitRemotein question after updating its push refspecs  
in order for the change to take effect and for calls topushto work.

```
LibGit2.addblob!– Function.

```

LibGit2.addblob!(repo::GitRepo, path:: AbstractString )

Read the file atpathand adds it to the object database ofrepoas a loose blob. Return theGitHashof the  
resulting blob.  
Examples

hash_str= string(commit_oid)  
blob_file= joinpath(repo_path,".git", "objects", hash_str[1:2], hash_str[3: end ])  
id = LibGit2.addblob!(repo, blob_file)

```
LibGit2.author– Function.

```

author(c::GitCommit)

Return theSignatureof the author of the commitc. The author is the person who made changes to the  
relevant file(s). See alsocommitter.

```
LibGit2.authors– Function.

```

authors(repo::GitRepo)-> Vector {Signature}

Return all authors of commits to thereporepository.  
Examples

repo= LibGit2.GitRepo(repo_path)  
repo_file= open(joinpath(repo_path, test_file),"a")

println(repo_file, commit_msg)  
flush(repo_file)  
LibGit2.add!(repo, test_file)  
sig = LibGit2.Signature("TEST", "TEST@TEST.COM", round(time(),0), 0)  
commit_oid1= LibGit2.commit(repo,"commit1"; author=sig, committer=sig)  
println(repo_file, randstring(10))  
flush(repo_file)  
LibGit2.add!(repo, test_file)  
commit_oid2= LibGit2.commit(repo,"commit2"; author=sig, committer=sig)

# will be a Vector of [sig, sig]

auths= LibGit2.authors(repo)

```

#### CHAPTER 73. LIBGIT2 1003

LibGit2.branch– Function.

```

branch(repo::GitRepo)

Equivalent togit branch. Create a new branch from the current HEAD.

```
LibGit2.branch!– Function.

```

branch!(repo::GitRepo, branch_name:: AbstractString , commit:: AbstractString =""; kwargs...)

Checkout a new git branch in thereporepository.commitis theGitHash, in string form, which will be the  
start of the new branch. Ifcommitis an empty string, the current HEAD will be used.  
The keyword arguments are:

```
- track::AbstractString="": the name of the remote branch this new branch should track, if any. If
    empty (the default), no remote branch will be tracked.
- force::Bool=false: iftrue, branch creation will be forced.
- set_head::Bool=true: iftrue, after the branch creation finishes the branch head will be set as the
    HEAD ofrepo.

```

Equivalent togit checkout [-b|-B] <branch_name> [] [--track ].  
Examples

repo= LibGit2.GitRepo(repo_path)  
LibGit2.branch!(repo,"new_branch", set_head= false )

```
LibGit2.checkout!– Function.

```

checkout!(repo::GitRepo, commit:: AbstractString =""; force:: Bool = true )

Equivalent togit checkout [-f] --detach . Checkout the git commitcommit(aGitHashin  
string form) inrepo. Ifforceistrue, force the checkout and discard any current changes. Note that this  
detaches the current HEAD.  
Examples

repo= LibGit2.init(repo_path)  
open(joinpath(LibGit2.path(repo),"file1"), "w") do f  
write(f,"111  
")  
end  
LibGit2.add!(repo,"file1")  
commit_oid= LibGit2.commit(repo,"add file1")  
open(joinpath(LibGit2.path(repo),"file1"), "w") do f  
write(f,"112  
")  
end

# would fail without the force=true

# since there are modifications to the file

LibGit2.checkout!(repo, string(commit_oid), force= true )

```
LibGit2.clone– Function.

```

clone(repo_url:: AbstractString , repo_path:: AbstractString , clone_opts::CloneOptions)

```

#### CHAPTER 73. LIBGIT2 1004

```

Clone the remote repository atrepo_url(which can be a remote URL or a path on the local filesystem)  
torepo_path(which must be a path on the local filesystem). Options for the clone, such as whether to  
perform a bare clone or not, are set byCloneOptions.  
Examples

repo_url= "https://github.com/JuliaLang/Example.jl"  
repo= LibGit2.clone(repo_url,"/home/me/projects/Example")

clone(repo_url::AbstractString, repo_path::AbstractString; kwargs...)

Clone a remote repository located atrepo_urlto the local filesystem locationrepo_path.  
The keyword arguments are:

```
- branch::AbstractString="": which branch of the remote to clone, if not the default repository
    branch (usuallymaster).
- isbare::Bool=false: iftrue, clone the remote as a bare repository, which will makerepo_path
    itself the git directory instead ofrepo_path/.git. This means that a working tree cannot be checked
    out. Plays the role of the git CLI argument--bare.
- remote_cb::Ptr{Cvoid}=C_NULL: a callback which will be used to create the remote before it is
    cloned. IfC_NULL(the default), no attempt will be made to create the remote - it will be assumed to
    already exist.
- credentials::Creds=nothing: provides credentials and/or settings when authenticating against a
    private repository.
- callbacks::Callbacks=Callbacks(): user provided callbacks and payloads.

```

Equivalent togit clone [-b ] [--bare] <repo_url> <repo_path>.  
Examples

repo_url= "https://github.com/JuliaLang/Example.jl"  
repo1= LibGit2.clone(repo_url,"test_path")  
repo2= LibGit2.clone(repo_url,"test_path", isbare= true )  
julia_url= "https://github.com/JuliaLang/julia"  
julia_repo= LibGit2.clone(julia_url,"julia_path", branch="release-0.6")

```
LibGit2.commit– Function.

```

commit(repo::GitRepo, msg:: AbstractString ; kwargs...) -> GitHash

Wrapperaroundgit_commit_create. Createacommitintherepositoryrepo.msgisthecommitmessage.  
Return the OID of the new commit.  
The keyword arguments are:

```
- refname::AbstractString=Consts.HEAD_FILE: if not NULL, the name of the reference to update to
    point to the new commit. For example,"HEAD"will update the HEAD of the current branch. If the
    reference does not yet exist, it will be created.
- author::Signature = Signature(repo)is aSignaturecontaining information about the person
    who authored the commit.
- committer::Signature = Signature(repo)is aSignaturecontaining information about the per-
    son who committed the commit to the repository. Not necessarily the same asauthor, for instance
    ifauthoremailed a patch tocommitterwho committed it.


#### CHAPTER 73. LIBGIT2 1005

- tree_id::GitHash = GitHash()is a git tree to use to create the commit, showing its ancestry and
    relationship with any other history.treemust belong torepo.
- parent_ids::Vector{GitHash}=GitHash[]isalistofcommitsbyGitHashtouseasparentcommits
    for the new one, and may be empty. A commit might have multiple parents if it is a merge commit,
    for example.

```

LibGit2.commit(rb::GitRebase, sig::GitSignature)

Commit the current patch to the rebaserb, usingsigas the committer. Is silent if the commit has already  
been applied.

```
LibGit2.committer– Function.

```

committer(c::GitCommit)

Return theSignatureof the committer of the commitc. The committer is the person who committed the  
changes originally authored by theauthor, but need not be the same as theauthor, for example, if the  
authoremailed a patch to acommitterwho committed it.

```
LibGit2.count– Function.

```

LibGit2.count(f:: Function , walker::GitRevWalker; oid::GitHash=GitHash(),  
↪→ by:: Cint =Consts.SORT_NONE, rev:: Bool = false )

Using theGitRevWalkerwalkerto "walk" over every commit in the repository's history, find the number  
of commits which returntruewhenfis applied to them. The keyword arguments are: *oid: TheGitHash  
of the commit to begin the walk from. The default is to usepush_head!and therefore the HEAD commit  
and all its ancestors. *by: The sorting method. The default is not to sort. Other options are to sort by  
topology (LibGit2.Consts.SORT_TOPOLOGICAL), to sort forwards in time (LibGit2.Consts.SORT_TIME,  
most ancient first) or to sort backwards in time (LibGit2.Consts.SORT_REVERSE, most recent first). *rev:  
Whether to reverse the sorted order (for instance, if topological sorting is used).  
Examples

cnt = LibGit2.with(LibGit2.GitRevWalker(repo)) do walker  
LibGit2.count((oid, repo)->(oid== commit_oid1), walker, oid=commit_oid1,  
↪→ by=LibGit2.Consts.SORT_TIME)  
end

LibGit2.countfinds the number of commits along the walk with a certainGitHash commit_oid1, starting  
the walk from that commit and moving forwards in time from it. Since theGitHashis unique to a commit,  
cntwill be 1.

```
LibGit2.counthunks– Function.

```

counthunks(blame::GitBlame)

Return the number of distinct"hunks" with a file. A hunk may contain multiple lines. A hunk is usually a  
piece of a file that was added/changed/removed together, for example, a function added to a source file  
or an inner loop that was optimized out of that function later.

```
LibGit2.create_branch– Function.

```

LibGit2.create_branch(repo::GitRepo, bname:: AbstractString , commit_obj::GitCommit;  
↪→ force:: Bool = false )

```

#### CHAPTER 73. LIBGIT2 1006

```

Create a new branch in the repositoryrepowith namebname, which points to commitcommit_obj(which  
has to be part ofrepo). Ifforceistrue, overwrite an existing branch namedbnameif it exists. Ifforceis  
falseand a branch already exists namedbname, this function will throw an error.

```
LibGit2.credentials_callback– Function.

```

credential_callback(...) -> Cint

A LibGit2 credential callback function which provides different credential acquisition functionality w.r.t. a  
connection protocol. Thepayload_ptris required to contain aLibGit2.CredentialPayloadobject which  
will keep track of state and settings.  
Theallowed_typescontains a bitmask ofLibGit2.Consts.GIT_CREDTYPEvalues specifying which au-  
thentication methods should be attempted.  
Credential authentication is done in the following order (if supported):

```
- SSH agent
- SSH private/public key pair
- Username/password plain text

```

If a user is presented with a credential prompt they can abort the prompt by typing^D(pressing the control  
key together with thedkey).  
Note : Duetothespecificsofthelibgit2authenticationprocedure,whenauthenticationfails,thisfunction  
is called again without any indication whether authentication was successful or not. To avoid an infinite  
loop from repeatedly using the same faulty credentials, we will keep track of state using the payload.  
For addition details see the LibGit2 guide onauthenticating against a server.

```
LibGit2.credentials_cb– Function.

```

C function pointer forcredentials_callback

```
LibGit2.default_signature– Function.

```

Return signature object. Free it after use.

```
LibGit2.delete_branch– Function.

```

LibGit2.delete_branch(branch::GitReference)

Delete the branch pointed to bybranch.

```
LibGit2.diff_files– Function.

```

diff_files(repo::GitRepo, branch1:: AbstractString , branch2:: AbstractString ; kwarg...) ->  
↪→ Vector { AbstractString }

Show which files have changed in the git repositoryrepobetween branchesbranch1andbranch2.  
The keyword argument is:

```
- filter::Set{Consts.DELTA_STATUS}=Set([Consts.DELTA_ADDED, Consts.DELTA_MODIFIED, Consts.DELTA_DELETED])),
    and it sets options for the diff. The default is to show files added, modified, or deleted.

```

Return only the names of the files which have changed, not their contents.  
Examples

```

#### CHAPTER 73. LIBGIT2 1007

```

LibGit2.branch!(repo,"branch/a")  
LibGit2.branch!(repo,"branch/b")

# add a file to repo

open(joinpath(LibGit2.path(repo),"file"),"w") do f  
write(f,"hello repo  
")  
end  
LibGit2.add!(repo,"file")  
LibGit2.commit(repo,"add file")

# returns ["file"]

filt= Set ([LibGit2.Consts.DELTA_ADDED])  
files= LibGit2.diff_files(repo,"branch/a", "branch/b", filter=filt)

# returns [] because existing files weren't modified

filt= Set ([LibGit2.Consts.DELTA_MODIFIED])  
files= LibGit2.diff_files(repo,"branch/a", "branch/b", filter=filt)

Equivalent togit diff --name-only --diff-filter=

```
LibGit2.entryid– Function.

```

entryid(te::GitTreeEntry)

Return theGitHashof the object to whichterefers.

```
LibGit2.entrytype– Function.

```

entrytype(te::GitTreeEntry)

Return the type of the object to whichterefers. The result will be one of the types whichobjtypereturns,  
e.g. aGitTreeorGitBlob.

```
LibGit2.fetch– Function.

```

fetch(rmt::GitRemote, refspecs; options::FetchOptions=FetchOptions(), msg="")

Fetch from the specifiedrmtremote git repository, usingrefspecsto determine which remote branch(es)  
to fetch. The keyword arguments are:

```
- options: determines the options for the fetch, e.g. whether to prune afterwards. SeeFetchOptions
    for more information.
- msg: a message to insert into the reflogs.

```

fetch(repo::GitRepo; kwargs...)

Fetches updates from an upstream of the repositoryrepo.  
The keyword arguments are:

```
- remote::AbstractString="origin": which remote, specified by name, ofrepoto fetch from. If this
    is empty, the URL will be used to construct an anonymous remote.
- remoteurl::AbstractString="": the URL ofremote. If not specified, will be assumed based on the
    given name ofremote.
- refspecs=AbstractString[]: determines properties of the fetch.
- credentials=nothing: provides credentials and/or settings when authenticating against a private
    remote.


#### CHAPTER 73. LIBGIT2 1008

- callbacks=Callbacks(): user provided callbacks and payloads.

```

Equivalent togit fetch [|] [].

```
LibGit2.fetchheads– Function.

```

fetchheads(repo::GitRepo)-> Vector {FetchHead}

Return the list of all the fetch heads forrepo, each represented as aFetchHead, including their names,  
URLs, and merge statuses.  
Examples

julia> fetch_heads= LibGit2.fetchheads(repo);

julia> fetch_heads[1].name  
"refs/heads/master"

julia> fetch_heads[1].ismerge  
true

julia> fetch_heads[2].name  
"refs/heads/test_branch"

julia> fetch_heads[2].ismerge  
false

```
LibGit2.fetch_refspecs– Function.

```

fetch_refspecs(rmt::GitRemote)-> Vector {String}

Get the fetch refspecs for the specifiedrmt. These refspecs contain information about which branch(es)  
to fetch from.  
Examples

julia> remote= LibGit2.get(LibGit2.GitRemote, repo,"upstream");

julia> LibGit2.add_fetch!(repo, remote,"upstream");

julia> LibGit2.fetch_refspecs(remote)  
String["+refs/heads/_:refs/remotes/upstream/_"]

```
LibGit2.fetchhead_foreach_cb– Function.

```

C function pointer forfetchhead_foreach_callback

```
LibGit2.merge_base– Function.

```

merge_base(repo::GitRepo, one:: AbstractString , two:: AbstractString ) -> GitHash

Find a merge base (a common ancestor) between the commitsoneandtwo.oneandtwomay both be in  
string form. Return theGitHashof the merge base.

```
LibGit2.merge!– Method.

```

merge!(repo::GitRepo; kwargs...) -> Bool

```

#### CHAPTER 73. LIBGIT2 1009

```

Performagitmergeontherepositoryrepo,mergingcommitswithdiverginghistoryintothecurrentbranch.  
Returntrueif the merge succeeded,falseif not.  
The keyword arguments are:

```
- committish::AbstractString="": Merge the named commit(s) incommittish.
- branch::AbstractString="": Merge the branchbranchand all its commits since it diverged from
    the current branch.
- fastforward::Bool=false: Iffastforwardistrue, only merge if the merge is a fast-forward (the
    current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and
    returnfalse. This is equivalent to the git CLI option--ff-only.
- merge_opts::MergeOptions=MergeOptions():merge_optsspecifies options for the merge, such as
    merge strategy in case of conflicts.
- checkout_opts::CheckoutOptions=CheckoutOptions():checkout_optsspecifies options for the
    checkout step.

```

Equivalent togit merge [--ff-only] [ | ].

Note  
If you specify abranch, this must be done in reference format, since the string will be turned  
into aGitReference. For example, if you wanted to merge branchbranch_a, you would call  
merge!(repo, branch="refs/heads/branch_a").

```
LibGit2.merge!– Method.

```

merge!(repo::GitRepo, anns:: Vector {GitAnnotated}; kwargs...) -> Bool

Merge changes from the annotated commits (captured asGitAnnotatedobjects)annsinto the HEAD of  
the repositoryrepo. The keyword arguments are:

```
- merge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including
    whether fastforwarding is allowed. SeeMergeOptionsfor more information.
- checkout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the check-
    out. SeeCheckoutOptionsfor more information.

```

annsmay refer to remote or local branch heads. Returntrueif the merge is successful, otherwise return  
false(for instance, if no merge is possible because the branches have no common ancestor).  
Examples

upst_ann= LibGit2.GitAnnotated(repo,"branch/a")

# merge the branch in

LibGit2.merge!(repo, [upst_ann])

```
LibGit2.merge!– Method.

```

merge!(repo::GitRepo, anns:: Vector {GitAnnotated}, fastforward:: Bool ; kwargs...) -> Bool

Merge changes from the annotated commits (captured asGitAnnotatedobjects)annsinto the HEAD of  
the repositoryrepo. Iffastforwardistrue, only a fastforward merge is allowed. In this case, if conflicts  
occur, the merge will fail. Otherwise, iffastforwardisfalse, the merge may produce a conflict file which  
the user will need to resolve.  
The keyword arguments are:

```

#### CHAPTER 73. LIBGIT2 1010

- merge_opts::MergeOptions = MergeOptions(): options for how to perform the merge, including
    whether fastforwarding is allowed. SeeMergeOptionsfor more information.
- checkout_opts::CheckoutOptions = CheckoutOptions(): options for how to perform the check-
    out. SeeCheckoutOptionsfor more information.

```

annsmay refer to remote or local branch heads. Returntrueif the merge is successful, otherwise return  
false(for instance, if no merge is possible because the branches have no common ancestor).  
Examples

upst_ann_1= LibGit2.GitAnnotated(repo,"branch/a")

# merge the branch in, fastforward

LibGit2.merge!(repo, [upst_ann_1], true )

# merge conflicts!

upst_ann_2= LibGit2.GitAnnotated(repo,"branch/b")

# merge the branch in, try to fastforward

LibGit2.merge!(repo, [upst_ann_2], true ) # will return false  
LibGit2.merge!(repo, [upst_ann_2], false ) # will return true

```
LibGit2.ffmerge!– Function.

```

ffmerge!(repo::GitRepo, ann::GitAnnotated)

Fastforward merge changes into current HEAD. This is only possible if the commit referred to byannis  
descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of  
the local branch tip).

```
LibGit2.fullname– Function.

```

LibGit2.fullname(ref::GitReference)

Return the name of the reference pointed to by the symbolic referenceref. Ifrefis not a symbolic  
reference, return an empty string.

```
LibGit2.features– Function.

```

features()

Return a list of git features the current version of libgit2 supports, such as threading or using HTTPS or  
SSH.

```
LibGit2.filename– Function.

```

filename(te::GitTreeEntry)

Return the filename of the object on disk to whichterefers.

```
LibGit2.filemode– Function.

```

filemode(te::GitTreeEntry)-> Cint

Return the UNIX filemode of the object on disk to whichterefers as an integer.

```
LibGit2.gitdir– Function.


#### CHAPTER 73. LIBGIT2 1011

```

LibGit2.gitdir(repo::GitRepo)

Return the location of the"git" files ofrepo:

```
- for normal repositories, this is the location of the.gitfolder.
- for bare repositories, this is the location of the repository itself.

```

See alsoworkdir,path.

```
LibGit2.git_url– Function.

```

LibGit2.git_url(; kwargs...) -> String

Create a string based upon the URL components provided. When theschemekeyword is not provided the  
URL produced will use the alternativescp-like syntax.  
Keywords

```
- scheme::AbstractString="": the URL scheme which identifies the protocol to be used. For HTTP
    use "http", SSH use"ssh", etc. Whenschemeis not provided the output format will be"ssh" but using
    the scp-like syntax.
- username::AbstractString="": the username to use in the output if provided.
- password::AbstractString="": the password to use in the output if provided.
- host::AbstractString="": the hostname to use in the output. A hostname is required to be speci-
    fied.
- port::Union{AbstractString,Integer}="": the port number to use in the output if provided. Can-
    not be specified when using the scp-like syntax.
- path::AbstractString="": the path to use in the output if provided.

```

Warning  
Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero  
or destroy the sensitive data after use and the password may remain in memory; possibly to  
be exposed by an uninitialized memory.

Examples

julia> LibGit2.git_url(username="git", host="github.com", path="JuliaLang/julia.git")  
"git@github.com:JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="https", host="github.com", path="/JuliaLang/julia.git")  
"https://github.com/JuliaLang/julia.git"

julia> LibGit2.git_url(scheme="ssh", username="git", host="github.com", port=2222,  
↪→ path="JuliaLang/julia.git")  
"ssh://git@github.com:2222/JuliaLang/julia.git"

```
LibGit2.@githash_str– Macro.

```

@githash_str-> AbstractGitHash

Construct a git hash object from the given string, returning aGitShortHashif the string is shorter than 40  
hexadecimal digits, otherwise aGitHash.  
Examples

```

#### CHAPTER 73. LIBGIT2 1012

```

julia> LibGit2.githash"d114feb74ce633"  
GitShortHash("d114feb74ce633")

julia> LibGit2.githash"d114feb74ce63307afe878a5228ad014e0289a85"  
GitHash("d114feb74ce63307afe878a5228ad014e0289a85")

```
LibGit2.head– Function.

```

LibGit2.head(repo::GitRepo)-> GitReference

Return aGitReferenceto the current HEAD ofrepo.  
head(pkg::AbstractString) -> String

Return current HEADGitHashof thepkgrepo as a string.

```
LibGit2.head!– Function.

```

LibGit2.head!(repo::GitRepo, ref::GitReference)-> GitReference

Set the HEAD ofrepoto the object pointed to byref.

```
LibGit2.head_oid– Function.

```

LibGit2.head_oid(repo::GitRepo)-> GitHash

Lookup the object id of the current HEAD of git repositoryrepo.

```
LibGit2.headname– Function.

```

LibGit2.headname(repo::GitRepo)

Lookup the name of the current HEAD of git repositoryrepo. Ifrepois currently detached, return the name  
of the HEAD it's detached from.

```
LibGit2.init– Function.

```

LibGit2.init(path:: AbstractString , bare:: Bool = false ) -> GitRepo

Open a new git repository atpath. Ifbareisfalse, the working tree will be created inpath/.git. Ifbare  
istrue, no working directory will be created.

```
LibGit2.is_ancestor_of– Function.

```

is_ancestor_of(a:: AbstractString , b :: AbstractString , repo::GitRepo)-> Bool

Returntrueifa, aGitHashin string form, is an ancestor ofb, aGitHashin string form.  
Examples

julia> repo= LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file1);

julia> commit_oid1= LibGit2.commit(repo,"commit1");

julia> LibGit2.add!(repo, test_file2);

```

#### CHAPTER 73. LIBGIT2 1013

```

julia> commit_oid2= LibGit2.commit(repo,"commit2");

julia> LibGit2.is_ancestor_of(string(commit_oid1), string(commit_oid2), repo)  
true

```
LibGit2.isbinary– Function.

```

isbinary(blob::GitBlob)-> Bool

Use a heuristic to guess if a file is binary: searching for NULL bytes and looking for a reasonable ratio of  
printable to non-printable characters among the first 8000 bytes.

```
LibGit2.iscommit– Function.

```

iscommit(id:: AbstractString , repo::GitRepo)-> Bool

Check if commitid(which is aGitHashin string form) is in the repository.  
Examples

julia> repo= LibGit2.GitRepo(repo_path);

julia> LibGit2.add!(repo, test_file);

julia> commit_oid= LibGit2.commit(repo,"add test_file");

julia> LibGit2.iscommit(string(commit_oid), repo)  
true

```
LibGit2.isdiff– Function.

```

LibGit2.isdiff(repo::GitRepo, treeish:: AbstractString , pathspecs:: AbstractString ="";  
↪→ cached:: Bool = false )

Checks if there are any differences between the tree specified bytreeishand the tracked files in the  
working tree (ifcached=false) or the index (ifcached=true).pathspecsare the specifications for options  
for the diff.  
Examples

repo= LibGit2.GitRepo(repo_path)  
LibGit2.isdiff(repo,"HEAD") # should be false  
open(joinpath(repo_path, new_file),"a") do f  
println(f,"here's my cool new file")  
end  
LibGit2.isdiff(repo,"HEAD") # now true

Equivalent togit diff-index [-- ].

```
LibGit2.isdirty– Function.

```

LibGit2.isdirty(repo::GitRepo, pathspecs:: AbstractString =""; cached:: Bool = false ) -> Bool

Check if there have been any changes to tracked files in the working tree (ifcached=false) or the index  
(ifcached=true).pathspecsare the specifications for options for the diff.  
Examples

```

#### CHAPTER 73. LIBGIT2 1014

```

repo= LibGit2.GitRepo(repo_path)  
LibGit2.isdirty(repo)# should be false  
open(joinpath(repo_path, new_file),"a") do f  
println(f,"here's my cool new file")  
end  
LibGit2.isdirty(repo)# now true  
LibGit2.isdirty(repo, new_file)# now true

Equivalent togit diff-index HEAD [-- ].

```
LibGit2.isorphan– Function.

```

LibGit2.isorphan(repo::GitRepo)

Check if the current branch is an"orphan" branch, i.e. has no commits. The first commit to this branch  
will have no parents.

```
LibGit2.isset– Function.

```

isset(val:: Integer , flag:: Integer )

Test whether the bits ofvalindexed byflagare set ( 1 ) or unset ( 0 ).

```
LibGit2.iszero– Function.

```

iszero(id::GitHash)-> Bool

Determine whether all hexadecimal digits of the givenGitHashare zero.

```
LibGit2.lookup_branch– Function.

```

lookup_branch(repo::GitRepo, branch_name:: AbstractString , remote:: Bool = false ) ->  
↪→ Union {GitReference, Nothing}

Determine if the branch specified bybranch_nameexists in the repositoryrepo. Ifremoteistrue,repois  
assumed to be a remote git repository. Otherwise, it is part of the local filesystem.  
Return either aGitReferenceto the requested branch if it exists, ornothingif not.

```
LibGit2.map– Function.

```

LibGit2.map(f:: Function , walker::GitRevWalker; oid::GitHash=GitHash(), range:: AbstractString ="",  
↪→ by:: Cint =Consts.SORT_NONE, rev:: Bool = false )

Using theGitRevWalkerwalkerto "walk" over every commit in the repository's history, applyfto each  
commitinthewalk. Thekeywordargumentsare: *oid: TheGitHashofthecommittobeginthewalkfrom.  
The default is to usepush_head!and therefore the HEAD commit and all its ancestors. *range: A range  
ofGitHashs in the formatoid1..oid2.fwill be applied to all commits between the two. *by: The sorting  
method. Thedefaultisnottosort. Otheroptionsaretosortbytopology(LibGit2.Consts.SORT_TOPOLOGICAL),  
to sort forwards in time (LibGit2.Consts.SORT_TIME, most ancient first) or to sort backwards in time  
(LibGit2.Consts.SORT_REVERSE, most recent first). *rev: Whether to reverse the sorted order (for in-  
stance, if topological sorting is used).  
Examples

oids= LibGit2.with(LibGit2.GitRevWalker(repo)) do walker  
LibGit2.map((oid, repo)->string(oid), walker, by=LibGit2.Consts.SORT_TIME)  
end

```

#### CHAPTER 73. LIBGIT2 1015

```

Here,LibGit2.mapvisits each commit using theGitRevWalkerand finds itsGitHash.

```
LibGit2.mirror_callback– Function.

```

Mirror callback function  
Function sets+refs/_:refs/_refspecs andmirrorflag for remote reference.

```
LibGit2.mirror_cb– Function.

```

C function pointer formirror_callback

```
LibGit2.message– Function.

```

message(c::GitCommit, raw:: Bool = false )

Return the commit message describing the changes made in commitc. Ifrawisfalse, return a slightly  
"cleaned up" message (which has any leading newlines removed). Ifrawistrue, the message is not  
stripped of any such newlines.

```
LibGit2.merge_analysis– Function.

```

merge_analysis(repo::GitRepo, anns:: Vector {GitAnnotated})-> analysis, preference

Run analysis on the branches pointed to by the annotated branch tipsannsand determine under what cir-  
cumstancestheycanbemerged. Forinstance,ifanns[1]issimplyanancestorofann[2],thenmerge_analysis  
will report that a fast-forward merge is possible.  
Returntwooutputs,analysisandpreference.analysishasseveralpossiblevalues: *MERGE_ANALYSIS_NONE:  
it is not possible to merge the elements ofanns. *MERGE_ANALYSIS_NORMAL: a regular merge, when HEAD  
and the commits that the user wishes to merge have all diverged from a common ancestor. In this case  
the changes have to be resolved and conflicts may occur. *MERGE_ANALYSIS_UP_TO_DATE: all the input  
commits the user wishes to merge can be reached from HEAD, so no merge needs to be performed. *  
MERGE_ANALYSIS_FASTFORWARD: the input commit is a descendant of HEAD and so no merge needs to be  
performed - instead, the user can simply checkout the input commit(s). *MERGE_ANALYSIS_UNBORN: the  
HEAD of the repository refers to a commit which does not exist. It is not possible to merge, but it may be  
possibletocheckouttheinputcommits.preferencealsohasseveralpossiblevalues: *MERGE_PREFERENCE_NONE:  
the user has no preference. *MERGE_PREFERENCE_NO_FASTFORWARD: do not allow any fast-forward merges.  
*MERGE_PREFERENCE_FASTFORWARD_ONLY: allow only fast-forward merges and no other type (which may  
introduce conflicts).preferencecan be controlled through the repository or global git configuration.

```
LibGit2.name– Function.

```

LibGit2.name(ref::GitReference)

Return the full name ofref.  
name(rmt::GitRemote)

Getthenameofaremoterepository,forinstance"origin". Iftheremoteisanonymous(seeGitRemoteAnon)  
the name will be an empty string"".  
Examples

julia> repo_url= "https://github.com/JuliaLang/Example.jl";

julia> repo= LibGit2.clone(cache_repo,"test_directory");

```

#### CHAPTER 73. LIBGIT2 1016

```

julia> remote= LibGit2.GitRemote(repo,"origin", repo_url);

julia> name(remote)  
"origin"

LibGit2.name(tag::GitTag)

The name oftag(e.g."v0.5").

```
LibGit2.need_update– Function.

```

need_update(repo::GitRepo)

Equivalent togit update-index. Returntrueifreponeeds updating.

```
LibGit2.objtype– Function.

```

objtype(obj_type::Consts.OBJECT)

Return the type corresponding to the enum value.

```
LibGit2.path– Function.

```

LibGit2.path(repo::GitRepo)

Return the base file path of the repositoryrepo.

```
- for normal repositories, this will typically be the parent directory of the".git" directory (note: this
    may be different than the working directory, seeworkdirfor more details).
- for bare repositories, this is the location of the"git" files.

```

See alsogitdir,workdir.

```
LibGit2.peel– Function.

```

peel([T,] ref::GitReference)

Recursively peelrefuntil an object of typeTis obtained. If noTis provided, thenrefwill be peeled until  
an object other than aGitTagis obtained.

```
- AGitTagwill be peeled to the object it references.
- AGitCommitwill be peeled to aGitTree.

```

Note  
Only annotated tags can be peeled toGitTagobjects. Lightweight tags (the default) are refer-  
ences underrefs/tags/which point directly toGitCommitobjects.

peel([T,] obj::GitObject)

Recursively peelobjuntil an object of typeTis obtained. If noTis provided, thenobjwill be peeled until  
the type changes.

```
- AGitTagwill be peeled to the object it references.
- AGitCommitwill be peeled to aGitTree.


#### CHAPTER 73. LIBGIT2 1017

LibGit2.posixpath– Function.

```

LibGit2.posixpath(path)

Standardise the path stringpathto use POSIX separators.

```
LibGit2.push– Function.

```

push(rmt::GitRemote, refspecs; force:: Bool = false , options::PushOptions=PushOptions())

Push to the specifiedrmtremote git repository, usingrefspecsto determine which remote branch(es) to  
push to. The keyword arguments are:

```
- force: iftrue, a force-push will occur, disregarding conflicts.
- options: determines the options for the push, e.g. which proxy headers to use. SeePushOptions
    for more information.

```

Note  
You can add information about the push refspecs in two other ways: by setting an option in the  
repository'sGitConfig(withpush.defaultas the key) or by callingadd_push!. Otherwise you  
will need to explicitly specify a push refspec in the call topushfor it to have any effect, like so:  
LibGit2.push(repo, refspecs=["refs/heads/master"]).

push(repo::GitRepo; kwargs...)

Pushes updates to an upstream ofrepo.  
The keyword arguments are:

```
- remote::AbstractString="origin": the name of the upstream remote to push to.
- remoteurl::AbstractString="": the URL ofremote.
- refspecs=AbstractString[]: determines properties of the push.
- force::Bool=false: determines if the push will be a force push, overwriting the remote branch.
- credentials=nothing: provides credentials and/or settings when authenticating against a private
    remote.
- callbacks=Callbacks(): user provided callbacks and payloads.

```

Equivalent togit push [|] [].

```
LibGit2.push!– Method.

```

LibGit2.push!(w::GitRevWalker, cid::GitHash)

StarttheGitRevWalkerwalkeratcommitcid. Thisfunctioncanbeusedtoapplyafunctiontoallcommits  
since a certain year, by passing the first commit of that year ascidand then passing the resultingwto  
LibGit2.map.

```
LibGit2.push_head!– Function.

```

LibGit2.push_head!(w::GitRevWalker)

Push the HEAD commit and its ancestors onto theGitRevWalkerw. This ensures that HEAD and all its  
ancestor commits will be encountered during the walk.

```

#### CHAPTER 73. LIBGIT2 1018

LibGit2.push_refspecs– Function.

```

push_refspecs(rmt::GitRemote)-> Vector {String}

Get the push refspecs for the specifiedrmt. These refspecs contain information about which branch(es) to  
push to.  
Examples

julia> remote= LibGit2.get(LibGit2.GitRemote, repo,"upstream");

julia> LibGit2.add_push!(repo, remote,"refs/heads/master");

julia> close(remote);

julia> remote= LibGit2.get(LibGit2.GitRemote, repo,"upstream");

julia> LibGit2.push_refspecs(remote)  
String["refs/heads/master"]

```
LibGit2.raw– Function.

```

raw(id::GitHash)-> Vector { UInt8 }

Obtain the raw bytes of theGitHashas a vector of length 20.

```
LibGit2.read_tree!– Function.

```

LibGit2.read_tree!(idx::GitIndex, tree::GitTree)  
LibGit2.read_tree!(idx::GitIndex, treehash::AbstractGitHash)

Read the treetree(or the tree pointed to bytreehashin the repository owned byidx) into the indexidx.  
The current index contents will be replaced.

```
LibGit2.rebase!– Function.

```

LibGit2.rebase!(repo::GitRepo, upstream:: AbstractString ="", newbase:: AbstractString ="")

Attempt an automatic merge rebase of the current branch, fromupstreamif provided, or otherwise from  
the upstream tracking branch.newbaseis the branch to rebase onto. By default this isupstream.  
If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository  
and working tree in its original state, and the function will throw aGitError. This is roughly equivalent to  
the following command line statement:  
git rebase --merge []  
if [ -d ".git/rebase-merge" ]; then  
git rebase --abort  
fi

```
LibGit2.ref_list– Function.

```

LibGit2.ref_list(repo::GitRepo)-> Vector {String}

Get a list of all reference names in thereporepository.

```
LibGit2.reftype– Function.


#### CHAPTER 73. LIBGIT2 1019

```

LibGit2.reftype(ref::GitReference)-> Cint

Return aCintcorresponding to the type ofref:

```
- 0 if the reference is invalid
- 1 if the reference is an object id
- 2 if the reference is symbolic

LibGit2.remotes– Function.

```

LibGit2.remotes(repo::GitRepo)

Return a vector of the names of the remotes ofrepo.

```
LibGit2.remove!– Function.

```

remove!(repo::GitRepo, files:: AbstractString ...)  
remove!(idx::GitIndex, files:: AbstractString ...)

Remove all the files with paths specified byfilesin the indexidx(or the index of therepo).

```
LibGit2.reset– Function.

```

reset(val:: Integer , flag:: Integer )

Unset the bits ofvalindexed byflag, returning them to 0.

```
LibGit2.reset!– Function.

```

reset!(payload, [config])-> CredentialPayload

Resetthepayloadstatebacktotheinitialvaluessothatitcanbeusedagainwithinthecredentialcallback.  
If aconfigis provided the configuration will also be updated.  
Updates some entries, determined by thepathspecs, in the index from the target commit tree.  
Sets the current head to the specified commit oid and optionally resets the index and working tree to  
match.  
git reset [] [–] ...  
reset!(repo::GitRepo, id::GitHash, mode::Cint=Consts.RESET_MIXED)

Reset the repositoryrepoto its state atid, using one of three modes set bymode:

```
1. Consts.RESET_SOFT- move HEAD toid.
2. Consts.RESET_MIXED- default, move HEAD toidand reset the index toid.
3. Consts.RESET_HARD- move HEAD toid, reset the index toid, and discard all working changes.

```

Examples

# fetch changes

LibGit2.fetch(repo)  
isfile(joinpath(repo_path, our_file))# will be false

# fastforward merge the changes

```

#### CHAPTER 73. LIBGIT2 1020

```

LibGit2.merge!(repo, fastforward= true )

# because there was not any file locally, but there is

# a file remotely, we need to reset the branch

head_oid= LibGit2.head_oid(repo)  
new_head= LibGit2.reset!(repo, head_oid, LibGit2.Consts.RESET_HARD)

In this example, the remote which is being fetched from does have a file calledour_filein its index, which  
is why we must reset.  
Equivalent togit reset [--soft | --mixed | --hard] .  
Examples

repo= LibGit2.GitRepo(repo_path)  
head_oid= LibGit2.head_oid(repo)  
open(joinpath(repo_path,"file1"), "w") do f  
write(f,"111  
")  
end  
LibGit2.add!(repo,"file1")  
mode= LibGit2.Consts.RESET_HARD

# will discard the changes to file1

# and unstage it

new_head= LibGit2.reset!(repo, head_oid, mode)

```
LibGit2.restore– Function.

```

restore(s::State, repo::GitRepo)

Return a repositoryrepoto a previousState s, for example the HEAD of a branch before a merge attempt.  
scan be generated using thesnapshotfunction.

```
LibGit2.revcount– Function.

```

LibGit2.revcount(repo::GitRepo, commit1:: AbstractString , commit2:: AbstractString )

Listthenumberofrevisionsbetweencommit1andcommit2(committishOIDsinstringform). Sincecommit1  
andcommit2may be on different branches,revcountperforms a"left-right" revision list (and count),  
returning a tuple ofInts - the number of left and right commits, respectively. A left (or right) commit  
refers to which side of a symmetric difference in a tree the commit is reachable from.  
Equivalent togit rev-list --left-right --count .  
Examples

repo= LibGit2.GitRepo(repo_path)  
repo_file= open(joinpath(repo_path, test_file),"a")  
println(repo_file,"hello world")  
flush(repo_file)  
LibGit2.add!(repo, test_file)  
commit_oid1= LibGit2.commit(repo,"commit 1")  
println(repo_file,"hello world again")  
flush(repo_file)  
LibGit2.add!(repo, test_file)  
commit_oid2= LibGit2.commit(repo,"commit 2")  
LibGit2.revcount(repo, string(commit_oid1), string(commit_oid2))

```

#### CHAPTER 73. LIBGIT2 1021

```

This will return(-1, 0).

```
LibGit2.set_remote_url– Function.

```

set_remote_url(repo::GitRepo, remote_name, url)  
set_remote_url(repo::String, remote_name, url)

Set both the fetch and pushurlforremote_namefor theGitRepoor the git repository located atpath.  
Typically git repos use"origin"as the remote name.  
Examples

repo_path= joinpath(tempdir(),"Example")  
repo= LibGit2.init(repo_path)  
LibGit2.set_remote_url(repo,"upstream", "https://github.com/JuliaLang/Example.jl")  
LibGit2.set_remote_url(repo_path,"upstream2", "https://github.com/JuliaLang/Example2.jl")

```
LibGit2.shortname– Function.

```

LibGit2.shortname(ref::GitReference)

Return a shortened version of the name ofrefthat's "human-readable".

julia> repo= LibGit2.GitRepo(path_to_repo);

julia> branch_ref= LibGit2.head(repo);

julia> LibGit2.name(branch_ref)  
"refs/heads/master"

julia> LibGit2.shortname(branch_ref)  
"master"

```
LibGit2.snapshot– Function.

```

snapshot(repo::GitRepo)-> State

Take a snapshot of the current state of the repositoryrepo, storing the current HEAD, index, and any  
uncommitted work. The outputStatecan be used later during a call torestoreto return the repository  
to the snapshotted state.

```
LibGit2.split_cfg_entry– Function.

```

LibGit2.split_cfg_entry(ce::LibGit2.ConfigEntry)-> Tuple {String,String,String,String}

Break theConfigEntryup to the following pieces: section, subsection, name, and value.  
Examples  
Given the git configuration file containing:  
[credential "https://example.com"]  
username = me

TheConfigEntrywould look like the following:

```

#### CHAPTER 73. LIBGIT2 1022

```

julia> entry  
ConfigEntry("credential.https://example.com.username", "me")

julia> LibGit2.split_cfg_entry(entry)  
("credential", "https://example.com", "username", "me")

Refer to thegit config syntax documentationfor more details.

```
LibGit2.status– Function.

```

LibGit2.status(repo::GitRepo, path::String)-> Union { Cuint , Cvoid}

Lookup the status of the file atpathin the git repositoryrepo. For instance, this can be used to check if  
the file atpathhas been modified and needs to be staged and committed.

```
LibGit2.stage– Function.

```

stage(ie::IndexEntry)-> Cint

Get the stage number ofie. The stage number 0 represents the current state of the working tree, but  
other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on  
anIndexEntrydescribe which side(s) of the conflict the current state of the file belongs to. Stage 0 is the  
state before the attempted merge, stage 1 is the changes which have been made locally, stages 2 and  
larger are for changes from other branches (for instance, in the case of a multi-branch"octopus" merge,  
stages 2 , 3 , and 4 might be used).

```
LibGit2.tag_create– Function.

```

LibGit2.tag_create(repo::GitRepo, tag:: AbstractString , commit; kwargs...)

Create a new git tagtag(e.g."v0.5") in the repositoryrepo, at the commitcommit.  
The keyword arguments are:

```
- msg::AbstractString="": the message for the tag.
- force::Bool=false: iftrue, existing references will be overwritten.
- sig::Signature=Signature(repo): the tagger's signature.

LibGit2.tag_delete– Function.

```

LibGit2.tag_delete(repo::GitRepo, tag:: AbstractString )

Remove the git tagtagfrom the repositoryrepo.

```
LibGit2.tag_list– Function.

```

LibGit2.tag_list(repo::GitRepo)-> Vector {String}

Get a list of all tags in the git repositoryrepo.

```
LibGit2.target– Function.

```

LibGit2.target(tag::GitTag)

TheGitHashof the target object oftag.

```

#### CHAPTER 73. LIBGIT2 1023

LibGit2.toggle– Function.

```

toggle(val:: Integer , flag:: Integer )

Flip the bits ofvalindexed byflag, so that if a bit is 0 it will be 1 after the toggle, and vice-versa.

```
LibGit2.transact– Function.

```

transact(f:: Function , repo::GitRepo)

Apply functionfto the git repositoryrepo, taking asnapshotbefore applyingf. If an error occurs within  
f,repowill be returned to its snapshot state usingrestore. The error which occurred will be rethrown,  
but the state ofrepowill not be corrupted.

```
LibGit2.treewalk– Function.

```

treewalk(f, tree::GitTree, post:: Bool = false )

Traverse the entries intreeand its subtrees in post or pre order. Preorder means beginning at the root and  
then traversing the leftmost subtree (and recursively on down through that subtree's leftmost subtrees)  
and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree,  
traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and  
finally visiting the tree root last of all.  
The function parameterfshould have following signature:  
(String, GitTreeEntry) -> Cint

A negative value returned fromfstops the tree walk. A positive value means that the entry will be skipped  
ifpostisfalse.

```
LibGit2.upstream– Function.

```

upstream(ref::GitReference)-> Union {GitReference, Nothing}

Determine if the branch containingrefhas a specified upstream branch.  
Return either aGitReferenceto the upstream branch if it exists, ornothingif the requested branch does  
not have an upstream counterpart.

```
LibGit2.update!– Function.

```

update!(repo::GitRepo, files:: AbstractString ...)  
update!(idx::GitIndex, files:: AbstractString ...)

Update all the files with paths specified byfilesin the indexidx(or the index of therepo). Match the  
state of each file in the index with the current state on disk, removing it if it has been removed on disk, or  
updating its entry in the object database.

```
LibGit2.url– Function.

```

url(rmt::GitRemote)

Get the fetch URL of a remote git repository.  
Examples

```

#### CHAPTER 73. LIBGIT2 1024

```

julia> repo_url= "https://github.com/JuliaLang/Example.jl";

julia> repo= LibGit2.init(mktempdir());

julia> remote= LibGit2.GitRemote(repo,"origin", repo_url);

julia> LibGit2.url(remote)  
"https://github.com/JuliaLang/Example.jl"

```
LibGit2.version– Function.

```

version()-> VersionNumber

Return the version of libgit2 in use, as aVersionNumber.

```
LibGit2.with– Function.

```

with(f:: Function , obj)

Resource management helper function. Appliesftoobj, making sure to callcloseonobjafterfsuccess-  
fully returns or throws an error. Ensures that allocated git resources are finalized as soon as they are no  
longer needed.

```
LibGit2.with_warn– Function.

```

with_warn(f:: Function , :: Type {T}, args...)

Resource management helper function. Applyftoargs, first constructing an instance of typeTfromargs.  
Makes sure to callcloseon the resulting object afterfsuccessfully returns or throws an error. Ensures  
that allocated git resources are finalized as soon as they are no longer needed. If an error is thrown byf,  
a warning is shown containing the error.

```
LibGit2.workdir– Function.

```

LibGit2.workdir(repo::GitRepo)

Return the location of the working directory ofrepo. This will throw an error for bare repositories.

Note  
This will typically be the parent directory ofgitdir(repo), but can be different in some cases:  
e.g. if either thecore.worktreeconfiguration variable or theGIT_WORK_TREEenvironment  
variable is set.

See alsogitdir,path.

```
LibGit2.GitObject– Method.

```

(:: Type {T})(te::GitTreeEntry) where T<:GitObject

Get the git object to whichterefers and return it as its actual type (the typeentrytypewould show), for  
instance aGitBloborGitTag.  
Examples

tree= LibGit2.GitTree(repo,"HEAD^{tree}")  
tree_entry= tree[1]  
blob= LibGit2.GitBlob(tree_entry)

```

#### CHAPTER 73. LIBGIT2 1025

LibGit2.UserPasswordCredential– Type.

```

Credential that support onlyuserandpasswordparameters

```
LibGit2.SSHCredential– Type.

```

SSH credential type

```
LibGit2.isfilled– Function.

```

isfilled(cred::AbstractCredential)-> Bool

Verifies that a credential is ready for use in authentication.

```
LibGit2.CachedCredentials– Type.

```

Caches credential information for re-use

```
LibGit2.CredentialPayload– Type.

```

LibGit2.CredentialPayload

RetainsthestatebetweenmultiplecallstothecredentialcallbackforthesameURL.ACredentialPayload  
instance is expected to bereset!whenever it will be used with a different URL.

```
LibGit2.approve– Function.

```

approve(payload::CredentialPayload; shred:: Bool = true ) -> Nothing

Store thepayloadcredential for re-use in a future authentication. Should only be called when authentica-  
tion was successful.  
Theshredkeyword controls whether sensitive information in the payload credential field should be de-  
stroyed. Should only be set tofalseduring testing.

```
LibGit2.reject– Function.

```

reject(payload::CredentialPayload; shred:: Bool = true ) -> Nothing

Discard thepayloadcredential from begin re-used in future authentication. Should only be called when  
authentication was unsuccessful.  
Theshredkeyword controls whether sensitive information in the payload credential field should be de-  
stroyed. Should only be set tofalseduring testing.

```

**Chapter 74**

**Dynamic Linker**

Base.Libc.Libdl.dlopen– Function.

```

dlopen(libfile:: AbstractString [, flags:: Integer ]; throw_error: Bool = true )

Load a shared library, returning an opaque handle.  
The extension given by the constantdlext(.so,.dll, or.dylib) can be omitted from thelibfilestring,  
as it is automatically appended if needed. Iflibfileis not an absolute path name, then the paths in the  
arrayDL_LOAD_PATHare searched forlibfile, followed by the system load path.  
The optional flags argument is a bitwise-or of zero or more ofRTLD_LOCAL,RTLD_GLOBAL,RTLD_LAZY,  
RTLD_NOW,RTLD_NODELETE,RTLD_NOLOAD,RTLD_DEEPBIND, andRTLD_FIRST. These are converted to the  
corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are  
ignored if the specified functionality is not available on the current platform. The default flags are plat-  
form specific. On MacOS the defaultdlopenflags areRTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBALwhile on  
other platforms the defaults areRTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL. An important usage of these  
flags is to specify non default behavior for when the dynamic library loader binds library references to  
exported symbols and if the bound references are put into process local or global scope. For instance  
RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBALallows the library's symbols to be available for usage in other  
shared libraries, addressing situations where there are dependencies between shared libraries.  
If the library cannot be found, this method throws an error, unless the keyword argumentthrow_erroris  
set tofalse, in which case this method returnsnothing.

Note  
From Julia 1.6 on, this method replaces paths starting with@executable_path/with the path  
to the Julia executable, allowing for relocatable relative-path loads. In Julia 1.5 and earlier, this  
only worked on macOS.

source

```
Base.Libc.Libdl.dlopen_e– Function.

```

dlopen_e(libfile:: AbstractString [, flags:: Integer ])

Similar todlopen, except returnsC_NULLinstead of raising errors. This method is now deprecated in favor  
ofdlopen(libfile::AbstractString [, flags::Integer]; throw_error=false).  
source

```
Base.Libc.Libdl.RTLD_NOW– Constant.

#### 1026


#### CHAPTER 74. DYNAMIC LINKER 1027

```

RTLD_DEEPBIND  
RTLD_FIRST  
RTLD_GLOBAL  
RTLD_LAZY  
RTLD_LOCAL  
RTLD_NODELETE  
RTLD_NOLOAD  
RTLD_NOW

Enum constant fordlopen. See your platform man page for details, if applicable.  
source

```
Base.Libc.Libdl.dlsym– Function.

```

dlsym(handle, sym; throw_error:: Bool = true )

Look up a symbol from a shared library handle, return callable function pointer on success.  
If the symbol cannot be found, this method throws an error, unless the keyword argumentthrow_erroris  
set tofalse, in which case this method returnsnothing.  
source

```
Base.Libc.Libdl.dlsym_e– Function.

```

dlsym_e(handle, sym)

Look up a symbol from a shared library handle, silently returnC_NULLon lookup failure. This method is  
now deprecated in favor ofdlsym(handle, sym; throw_error=false).  
source

```
Base.Libc.Libdl.dlclose– Function.

```

dlclose(handle)

Close shared library referenced by handle.  
source  
dlclose(::Nothing)

For the very common pattern usage pattern of  
try  
hdl = dlopen(library_name)  
... do something  
finally  
dlclose(hdl)  
end

We define adlclose()method that accepts a parameter of typeNothing, so that user code does not have  
to change its behavior for the case thatlibrary_namewas not found.  
source

```
Base.Libc.Libdl.dlext– Constant.

```

dlext

```

#### CHAPTER 74. DYNAMIC LINKER 1028

```

File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.  
source

```
Base.Libc.Libdl.dllist– Function.

```

dllist()

Return the paths of dynamic libraries currently loaded in aVector{String}.  
source

```
Base.Libc.Libdl.dlpath– Function.

```

dlpath(handle:: Ptr {Cvoid})

Given a libraryhandlefromdlopen, return the full path.  
source  
dlpath(libname::Union{AbstractString, Symbol})

Get the full path of the librarylibname.  
Example

julia> dlpath("libjulia")

source

```
Base.Libc.Libdl.find_library– Function.

```

find_library(names, locations)

Searches for the first library innamesin the paths in thelocationslist,DL_LOAD_PATH, or system library  
paths (in that order) which can successfully be dlopen'd. On success, the return value will be one of the  
names (potentially prefixed by one of the paths in locations). This string can be assigned to aglobal  
constand used as the library name in futureccall's. On failure, it returns the empty string.  
source

```
Base.DL_LOAD_PATH– Constant.

```

DL_LOAD_PATH

When callingdlopen, the paths in this list will be searched first, in order, before searching the system  
locations for a valid library handle.  
source

```

**Chapter 75**

**Linear Algebra**

In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations
of many common and useful linear algebra operations which can be loaded withusing LinearAlgebra. Basic
operations, such astr,det, andinvare all supported:

```

julia> A = [1 2 3; 4 1 6; 7 8 1]  
3×3 Matrix{Int64}:  
1 2 3  
4 1 6  
7 8 1

julia> tr(A)  
3

julia> det(A)  
104.0

julia> inv(A)  
3×3 Matrix{Float64}:  
-0.451923 0.211538 0.0865385  
0.365385 -0.192308 0.0576923  
0.240385 0.0576923 -0.0673077

```
As well as other useful operations, such as finding eigenvalues or eigenvectors:

```

julia> A = [-4. -17.; 2. 2.]  
2×2 Matrix{Float64}:  
-4.0 -17.0  
2.0 2.0

julia> eigvals(A)  
2-element Vector{ComplexF64}:  
-1.0 - 5.0im  
-1.0 + 5.0im

julia> eigvecs(A)  
2×2 Matrix{ComplexF64}:  
0.945905-0.0im 0.945905+0.0im  
-0.166924+0.278207im -0.166924-0.278207im

```
#### 1029


#### CHAPTER 75. LINEAR ALGEBRA 1030

In addition, Julia provides manyfactorizationswhich can be used to speed up problems such as linear solve
or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory
reasons) to the problem. See the documentation onfactorizefor more information. As an example:

```

julia> A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]  
3×3 Matrix{Float64}:  
1.5 2.0 -4.0  
3.0 -1.0 -6.0  
-10.0 2.3 4.0

julia> factorize(A)  
LU{Float64, Matrix{Float64}}  
L factor:  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
-0.15 1.0 0.0  
-0.3 -0.132196 1.0  
U factor:  
3×3 Matrix{Float64}:  
-10.0 2.3 4.0  
0.0 2.345 -3.4  
0.0 0.0 -5.24947

```
SinceAis not Hermitian, symmetric, triangular, tridiagonal, or bidiagonal, an LU factorization may be the best
we can do. Compare with:

```

julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]  
3×3 Matrix{Float64}:  
1.5 2.0 -4.0  
2.0 -1.0 -3.0  
-4.0 -3.0 5.0

julia> factorize(B)  
BunchKaufman{Float64, Matrix{Float64}}  
D factor:  
3×3 Tridiagonal{Float64, Vector{Float64}}:  
-1.64286 0.0 ⋅  
0.0 -2.8 0.0  
⋅ 0.0 5.0  
U factor:  
3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:  
1.0 0.142857 -0.8  
⋅ 1.0 -0.6  
⋅ ⋅ 1.0  
permutation:  
3-element Vector{Int64}:  
1  
2  
3

```
Here, Julia was able to detect thatBis in fact symmetric, and used a more appropriate factorization. Often it's
possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric,
or tridiagonal. Julia provides some special types so that you can"tag" matrices as having these properties. For
instance:


#### CHAPTER 75. LINEAR ALGEBRA 1031

```

julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]  
3×3 Matrix{Float64}:  
1.5 2.0 -4.0  
2.0 -1.0 -3.0  
-4.0 -3.0 5.0

julia> sB = Symmetric (B)  
3×3 Symmetric{Float64, Matrix{Float64}}:  
1.5 2.0 -4.0  
2.0 -1.0 -3.0  
-4.0 -3.0 5.0

```
sBhas been tagged as a matrix that's (real) symmetric, so for later operations we might perform on it, such
as eigenfactorization or computing matrix-vector products, efficiencies can be found by only referencing half
of it. For example:

```

julia> B = [1.5 2 -4; 2 -1 -3; -4 -3 5]  
3×3 Matrix{Float64}:  
1.5 2.0 -4.0  
2.0 -1.0 -3.0  
-4.0 -3.0 5.0

julia> sB = Symmetric (B)  
3×3 Symmetric{Float64, Matrix{Float64}}:  
1.5 2.0 -4.0  
2.0 -1.0 -3.0  
-4.0 -3.0 5.0

julia> x = [1; 2; 3]  
3-element Vector{Int64}:  
1  
2  
3

julia> sB\x  
3-element Vector{Float64}:  
-1.7391304347826084  
-1.1086956521739126  
-1.4565217391304346

```
The\operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to
write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.

### 75.1 Special matrices.

Matrices with special symmetries and structuresarise often in linear algebra and are frequently associated
with various matrix factorizations. Julia features a rich collection of special matrix types, which allow for fast
computation with specialized routines that are specially developed for particular matrix types.

The following tables summarize the types of special matrices that have been implemented in Julia, as well as
whether hooks to various optimized methods for them in LAPACK are available.

### Elementary operations

Legend:


#### CHAPTER 75. LINEAR ALGEBRA 1032

```

Type Description  
Symmetric Symmetric matrix  
Hermitian Hermitian matrix  
UpperTriangular Upper triangular matrix  
UnitUpperTriangular Upper triangular matrixwith unit diagonal  
LowerTriangular Lower triangular matrix  
UnitLowerTriangular Lower triangular matrixwith unit diagonal  
UpperHessenberg Upper Hessenberg matrix  
Tridiagonal Tridiagonal matrix  
SymTridiagonal Symmetric tridiagonal matrix  
Bidiagonal Upper/lowerbidiagonal matrix  
Diagonal Diagonal matrix  
UniformScaling Uniform scaling operator

Matrix type + - * \ Other functions with optimized methods  
Symmetric MV inv,sqrt,exp  
Hermitian MV inv,sqrt,exp  
UpperTriangular MV MV inv,det  
UnitUpperTriangular MV MV inv,det  
LowerTriangular MV MV inv,det  
UnitLowerTriangular MV MV inv,det  
UpperHessenberg MM inv,det  
SymTridiagonal M M MS MV eigmax,eigmin  
Tridiagonal M M MS MV  
Bidiagonal M M MS MV  
Diagonal M M MV MV inv,det,logdet,/  
UniformScaling M M MVS MVS /

Key Description  
M (matrix) An optimized method for matrix-matrix operations is available  
V (vector) An optimized method for matrix-vector operations is available  
S (scalar) An optimized method for matrix-scalar operations is available

```
### Matrix factorizations

Legend:

### The uniform scaling operator

AUniformScalingoperator represents a scalar times the identity operator,λ*I. The identity operatorIis
defined as a constant and is an instance ofUniformScaling. The size of these operators are generic and
match the other matrix in the binary operations+,-,*and\. ForA+IandA-Ithis means thatAmust be
square. Multiplication with the identity operatorIis a noop (except for checking that the scaling factor is one)
and therefore almost without overhead.

To see theUniformScalingoperator in action:

```

julia> U = UniformScaling (2);

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:

```

#### CHAPTER 75. LINEAR ALGEBRA 1033

```

Matrix type LAPACK eigen eigvals eigvecs svd svdvals  
Symmetric SY ARI  
Hermitian HE ARI  
UpperTriangular TR A A A  
UnitUpperTriangular TR A A A  
LowerTriangular TR A A A  
UnitLowerTriangular TR A A A  
SymTridiagonal ST A ARI AV  
Tridiagonal GT  
Bidiagonal BD A A  
Diagonal DI A

Key Description Example  
A (all) An optimized method to find all the characteristic values and/or vectors is  
available

e.g.  
eigvals(M)  
R  
(range)

An optimized method to find theilth through theihth characteristic values  
are available

eigvals(M,  
il, ih)  
I (in-  
terval)

An optimized method to find the characteristic values in the interval [vl,vh] is  
available

eigvals(M,  
vl, vh)  
V  
(vec-  
tors)

An optimized method to find the characteristic vectors corresponding to the  
characteristic valuesx=[x1, x2,...]is available

eigvecs(M,  
x)

1 2  
3 4

julia> a + U  
2×2 Matrix{Int64}:  
3 2  
3 6

julia> a * U  
2×2 Matrix{Int64}:  
2 4  
6 8

julia> [a U]  
2×4 Matrix{Int64}:  
1 2 2 0  
3 4 0 2

julia> b = [1 2 3; 4 5 6]  
2×3 Matrix{Int64}:  
1 2 3  
4 5 6

julia> b - U  
ERROR: DimensionMismatch("matrix is not square: dimensions are (2, 3)")  
Stacktrace:  
[...]

```
Ifyouneedtosolvemanysystemsoftheform(A+μI)x = bforthesameAanddifferentμ,itmightbebeneficial


#### CHAPTER 75. LINEAR ALGEBRA 1034

to first compute the Hessenberg factorizationFofAvia thehessenbergfunction. GivenF, Julia employs an
efficient algorithm for(F+μ*I) \ b(equivalent to(A+μ*I)x \ b) and related operations like determinants.

### 75.2 Matrix factorizations.

Matrix factorizations (a.k.a. matrix decompositions)compute the factorization of a matrix into a product of
matrices, and are one of the central concepts in linear algebra.

The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details
of their associated methods can be found in theStandard functionssection of the Linear Algebra documenta-
tion.

```

Type Description  
BunchKaufman Bunch-Kaufman factorization  
Cholesky Cholesky factorization  
CholeskyPivoted PivotedCholesky factorization  
LDLt LDL(T) factorization  
LU LU factorization  
QR QR factorization  
QRCompactWY Compact WY form of the QR factorization  
QRPivoted PivotedQR factorization  
LQ QR factorizationoftranspose(A)  
Hessenberg Hessenberg decomposition  
Eigen Spectral decomposition  
GeneralizedEigen Generalized spectral decomposition  
SVD Singular value decomposition  
GeneralizedSVD Generalized SVD  
Schur Schur decomposition  
GeneralizedSchur Generalized Schur decomposition

```
### 75.3 Standard functions

Linear algebra functions in Julia are largely implemented by calling functions fromLAPACK. Sparse matrix
factorizations call functions fromSuiteSparse. Other sparse solvers are available as Julia packages.

Base.:*– Method.

```

*(A:: AbstractMatrix , B :: AbstractMatrix )

Matrix multiplication.  
Examples

julia> [1 1; 0 1] * [1 0; 1 1]  
2×2 Matrix{Int64}:  
2 1  
1 1

```
Base.:\– Method.

```

(A, B)

```

#### CHAPTER 75. LINEAR ALGEBRA 1035

```

Matrix division using a polyalgorithm. For input matricesAandB, the resultXis such thatA*X == Bwhen  
Ais square. The solver that is used depends upon the structure ofA. IfAis upper or lower triangular  
(or diagonal), no factorization ofAis required and the system is solved with either forward or backward  
substitution. For non-triangular square matrices, an LU factorization is used.  
For rectangularAthe result is the minimum-norm least squares solution computed by a pivoted QR factor-  
ization ofAand a rank estimate ofAbased on the R factor.  
WhenAis sparse, a similar polyalgorithm is used. For indefinite matrices, theLDLtfactorization does not  
use pivoting during the numerical factorization and therefore the procedure can fail even for invertible  
matrices.  
See also:factorize,pinv.  
Examples

julia> A = [1 0; 1 -2]; B= [32; -4];

julia> X = A \ B  
2-element Vector{Float64}:  
32.0  
18.0

julia> A * X == B  
true

```
LinearAlgebra.SingularException– Type.

```

SingularException

Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A  
linear solve involving such a matrix cannot be computed. Theinfofield indicates the location of (one of)  
the singular value(s).

```
LinearAlgebra.PosDefException– Type.

```

PosDefException

Exception thrown when the input matrix was notpositive definite. Some linear algebra functions and  
factorizations are only applicable to positive definite matrices. Theinfofield indicates the location of (one  
of) the eigenvalue(s) which is (are) less than/equal to 0.

```
LinearAlgebra.ZeroPivotException– Type.

```

ZeroPivotException<: Exception

Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and  
cannot proceed. This may not mean that the matrix is singular: it may be fruitful to switch to a diffent  
factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. Theinfo  
field indicates the location of (one of) the zero pivot(s).

```
LinearAlgebra.dot– Function.

```

dot(x, y)  
x ⋅ y

```

#### CHAPTER 75. LINEAR ALGEBRA 1036

```

Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.  
dotalso works on arbitrary iterable objects, including arrays of any dimension, as long asdotis defined  
on the elements.  
dotis semantically equivalent tosum(dot(vx,vy) for (vx,vy) in zip(x, y)), with the added restric-  
tion that the arguments must have equal lengths.  
x ⋅ y(where⋅can be typed by tab-completing\cdotin the REPL) is a synonym fordot(x, y).  
Examples

julia> dot([1; 1], [ 2; 3])  
5

julia> dot([im; im], [ 1; 1])  
0 - 2im

julia> dot(1:5, 2:6)  
70

julia> x = fill(2., ( 5,5));

julia> y = fill(3., ( 5,5));

julia> dot(x, y)  
150.0

```
LinearAlgebra.dot– Method.

```

dot(x, A, y)

Compute the generalized dot productdot(x, A_y)between two vectorsxandy, without storing the  
intermediate result ofA_y. As for the two-argumentdot(_,_), this acts recursively. Moreover, for complex  
vectors, the first vector is conjugated.

Julia 1.4  
Three-argumentdotrequires at least Julia 1.4.

Examples

julia> dot([1; 1], [ 1 2; 3 4], [ 2; 3])  
26

julia> dot(1:5, reshape(1:25, 5, 5), 2:6)  
4850

julia> ⋅(1:5, reshape(1:25, 5, 5), 2:6) == dot(1:5, reshape(1:25, 5, 5), 2:6)  
true

```
LinearAlgebra.cross– Function.

```

cross(x, y)  
×(x,y)

Compute the cross product of two 3-vectors.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1037

```

julia> a = [0;1;0]  
3-element Vector{Int64}:  
0  
1  
0

julia> b = [0;0;1]  
3-element Vector{Int64}:  
0  
0  
1

julia> cross(a,b)  
3-element Vector{Int64}:  
1  
0  
0

```
LinearAlgebra.factorize– Function.

```

factorize(A)

Compute a convenient factorization ofA, based upon the type of the input matrix.factorizechecksAto  
seeifitissymmetric/triangular/etc. ifAispassedasagenericmatrix.factorizecheckseveryelementofA  
toverify/ruleouteachproperty. Itwillshort-circuitassoonasitcanruleoutsymmetry/triangularstructure.  
The return value can be reused for efficient solving of multiple systems. For example:A=factorize(A);  
x=A\b; y=A\C.

Properties ofA type of factorization  
Positive-definite Cholesky (seecholesky)  
Dense Symmetric/Hermitian Bunch-Kaufman (seebunchkaufman)  
Sparse Symmetric/Hermitian LDLt (seeldlt)  
Triangular Triangular  
Diagonal Diagonal  
Bidiagonal Bidiagonal  
Tridiagonal LU (seelu)  
Symmetric real tridiagonal LDLt (seeldlt)  
General square LU (seelu)  
General non-square QR (seeqr)

Iffactorizeis called on a Hermitian positive-definite matrix, for instance, thenfactorizewill return a  
Cholesky factorization.  
Examples

julia> A = Array ( Bidiagonal (fill(1.0, ( 5, 5)), :U))  
5×5 Matrix{Float64}:  
1.0 1.0 0.0 0.0 0.0  
0.0 1.0 1.0 0.0 0.0  
0.0 0.0 1.0 1.0 0.0  
0.0 0.0 0.0 1.0 1.0  
0.0 0.0 0.0 0.0 1.0

julia> factorize(A)# factorize will check to see that A is already factorized

```

#### CHAPTER 75. LINEAR ALGEBRA 1038

```

5×5 Bidiagonal{Float64, Vector{Float64}}:  
1.0 1.0 ⋅ ⋅ ⋅  
⋅ 1.0 1.0 ⋅ ⋅  
⋅ ⋅ 1.0 1.0 ⋅  
⋅ ⋅ ⋅ 1.0 1.0  
⋅ ⋅ ⋅ ⋅ 1.0

This returns a5×5 Bidiagonal{Float64}, which can now be passed to other linear algebra functions (e.g.  
eigensolvers) which will use specialized methods forBidiagonaltypes.

```
LinearAlgebra.Diagonal– Type.

```

Diagonal (V:: AbstractVector )

Construct a matrix withVas its diagonal.  
See alsodiag,diagm.  
Examples

julia>Diagonal ([1, 10, 100])  
3×3 Diagonal{Int64, Vector{Int64}}:  
1 ⋅ ⋅  
⋅ 10 ⋅  
⋅ ⋅ 100

julia> diagm([7, 13])  
2×2 Matrix{Int64}:  
7 0  
0 13

Diagonal(A::AbstractMatrix)

Construct a matrix from the diagonal ofA.  
Examples

julia> A = permutedims(reshape(1:15, 5, 3))  
3×5 Matrix{Int64}:  
1 2 3 4 5  
6 7 8 9 10  
11 12 13 14 15

julia>Diagonal (A)  
3×3 Diagonal{Int64, Vector{Int64}}:  
1 ⋅ ⋅  
⋅ 7 ⋅  
⋅ ⋅ 13

julia> diag(A,2)  
3-element Vector{Int64}:  
3  
9  
15

Diagonal{T}(undef, n)

```

#### CHAPTER 75. LINEAR ALGEBRA 1039

```

Construct an uninitializedDiagonal{T}of lengthn. Seeundef.

```
LinearAlgebra.Bidiagonal– Type.

```

Bidiagonal (dv::V, ev::V, uplo:: Symbol ) where V<: AbstractVector

Constructs an upper (uplo=:U) or lower (uplo=:L) bidiagonal matrix using the given diagonal (dv) and off-  
diagonal (ev) vectors. The result is of typeBidiagonaland provides efficient specialized linear solvers,  
but may be converted into a regular matrix withconvert(Array, _)(orArray(_)for short). The length  
ofevmust be one less than the length ofdv.  
Examples

julia> dv = [1, 2, 3, 4]  
4-element Vector{Int64}:  
1  
2  
3  
4

julia> ev = [7, 8, 9]  
3-element Vector{Int64}:  
7  
8  
9

julia> Bu = Bidiagonal (dv, ev,:U) # ev is on the first superdiagonal  
4×4 Bidiagonal{Int64, Vector{Int64}}:  
1 7 ⋅ ⋅  
⋅ 2 8 ⋅  
⋅ ⋅ 3 9  
⋅ ⋅ ⋅ 4

julia> Bl = Bidiagonal (dv, ev,:L) # ev is on the first subdiagonal  
4×4 Bidiagonal{Int64, Vector{Int64}}:  
1 ⋅ ⋅ ⋅  
7 2 ⋅ ⋅  
⋅ 8 3 ⋅  
⋅ ⋅ 9 4

Bidiagonal(A, uplo::Symbol)

Construct aBidiagonalmatrix from the main diagonal ofAand its first super- (ifuplo=:U) or sub-diagonal  
(ifuplo=:L).  
Examples

julia> A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]  
4×4 Matrix{Int64}:  
1 1 1 1  
2 2 2 2  
3 3 3 3  
4 4 4 4

julia>Bidiagonal (A, :U) # contains the main diagonal and first superdiagonal of A  
4×4 Bidiagonal{Int64, Vector{Int64}}:  
1 1 ⋅ ⋅

```

#### CHAPTER 75. LINEAR ALGEBRA 1040

```

⋅ 2 2 ⋅  
⋅ ⋅ 3 3  
⋅ ⋅ ⋅ 4

julia>Bidiagonal (A, :L) # contains the main diagonal and first subdiagonal of A  
4×4 Bidiagonal{Int64, Vector{Int64}}:  
1 ⋅ ⋅ ⋅  
2 2 ⋅ ⋅  
⋅ 3 3 ⋅  
⋅ ⋅ 4 4

```
LinearAlgebra.SymTridiagonal– Type.

```

SymTridiagonal (dv::V, ev::V) where V<: AbstractVector

Construct a symmetric tridiagonal matrix from the diagonal (dv) and first sub/super-diagonal (ev), respec-  
tively. The result is of typeSymTridiagonaland provides efficient specialized eigensolvers, but may be  
converted into a regular matrix withconvert(Array, _)(orArray(_)for short).  
ForSymTridiagonalblock matrices, the elements ofdvare symmetrized. The argumentevis interpreted  
as the superdiagonal. Blocks from the subdiagonal are (materialized) transpose of the corresponding  
superdiagonal blocks.  
Examples

julia> dv = [1, 2, 3, 4]  
4-element Vector{Int64}:  
1  
2  
3  
4

julia> ev = [7, 8, 9]  
3-element Vector{Int64}:  
7  
8  
9

julia>SymTridiagonal (dv, ev)  
4×4 SymTridiagonal{Int64, Vector{Int64}}:  
1 7 ⋅ ⋅  
7 2 8 ⋅  
⋅ 8 3 9  
⋅ ⋅ 9 4

julia> A = SymTridiagonal (fill([1 2; 3 4], 3), fill([1 2; 3 4], 2));

julia> A[1,1]  
2×2 Symmetric{Int64, Matrix{Int64}}:  
1 2  
2 4

julia> A[1,2]  
2×2 Matrix{Int64}:  
1 2  
3 4

```

#### CHAPTER 75. LINEAR ALGEBRA 1041

```

julia> A[2,1]  
2×2 Matrix{Int64}:  
1 3  
2 4

SymTridiagonal(A::AbstractMatrix)

Constructasymmetrictridiagonalmatrixfromthediagonalandfirstsuperdiagonalofthesymmetricmatrix  
A.  
Examples

julia> A = [1 2 3; 2 4 5; 3 5 6]  
3×3 Matrix{Int64}:  
1 2 3  
2 4 5  
3 5 6

julia>SymTridiagonal (A)  
3×3 SymTridiagonal{Int64, Vector{Int64}}:  
1 2 ⋅  
2 4 5  
⋅ 5 6

julia> B = reshape([[1 2; 2 3], [ 1 2; 3 4], [ 1 3; 2 4], [ 1 2; 2 3]], 2, 2);

julia>SymTridiagonal (B)  
2×2 SymTridiagonal{Matrix{Int64}, Vector{Matrix{Int64}}}:  
[1 2; 2 3] [1 3; 2 4]  
[1 2; 3 4] [1 2; 2 3]

```
LinearAlgebra.Tridiagonal– Type.

```

Tridiagonal (dl::V, d ::V, du::V) where V<: AbstractVector

Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively.  
The result is of typeTridiagonaland provides efficient specialized linear solvers, but may be converted  
into a regular matrix withconvert(Array, _)(orArray(_)for short). The lengths ofdlanddumust be  
one less than the length ofd.  
Examples

julia> dl = [1, 2, 3];

julia> du = [4, 5, 6];

julia> d = [7, 8, 9, 0];

julia>Tridiagonal (dl, d, du)  
4×4 Tridiagonal{Int64, Vector{Int64}}:  
7 4 ⋅ ⋅  
1 8 5 ⋅  
⋅ 2 9 6  
⋅ ⋅ 3 0

Tridiagonal(A)

```

#### CHAPTER 75. LINEAR ALGEBRA 1042

```

Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix  
A.  
Examples

julia> A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]  
4×4 Matrix{Int64}:  
1 2 3 4  
1 2 3 4  
1 2 3 4  
1 2 3 4

julia>Tridiagonal (A)  
4×4 Tridiagonal{Int64, Vector{Int64}}:  
1 2 ⋅ ⋅  
1 2 3 ⋅  
⋅ 2 3 4  
⋅ ⋅ 3 4

```
LinearAlgebra.Symmetric– Type.

```

Symmetric (A, uplo=:U)

Construct aSymmetricview of the upper (ifuplo = :U) or lower (ifuplo = :L) triangle of the matrixA.  
Examples

julia> A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]  
5×5 Matrix{Int64}:  
1 0 2 0 3  
0 4 0 5 0  
6 0 7 0 8  
0 9 0 1 0  
2 0 3 0 4

julia> Supper= Symmetric (A)  
5×5 Symmetric{Int64, Matrix{Int64}}:  
1 0 2 0 3  
0 4 0 5 0  
2 0 7 0 8  
0 5 0 1 0  
3 0 8 0 4

julia> Slower= Symmetric (A, :L)  
5×5 Symmetric{Int64, Matrix{Int64}}:  
1 0 6 0 2  
0 4 0 9 0  
6 0 7 0 3  
0 9 0 1 0  
2 0 3 0 4

Note thatSupperwill not be equal toSlowerunlessAis itself symmetric (e.g. ifA == transpose(A)).

```
LinearAlgebra.Hermitian– Type.

```

Hermitian (A, uplo=:U)

```

#### CHAPTER 75. LINEAR ALGEBRA 1043

```

Construct aHermitianview of the upper (ifuplo = :U) or lower (ifuplo = :L) triangle of the matrixA.  
Examples

julia> A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia> Hupper= Hermitian (A)  
5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:  
1+0im 0+0im 2+2im 0+0im 3-3im  
0+0im 4+0im 0+0im 5+0im 0+0im  
2-2im 0+0im 7+0im 0+0im 8+8im  
0+0im 5+0im 0+0im 1+0im 0+0im  
3+3im 0+0im 8-8im 0+0im 4+0im

julia> Hlower= Hermitian (A, :L)  
5×5 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:  
1+0im 0+0im 6+6im 0+0im 2-2im  
0+0im 4+0im 0+0im 9+0im 0+0im  
6-6im 0+0im 7+0im 0+0im 3+3im  
0+0im 9+0im 0+0im 1+0im 0+0im  
2+2im 0+0im 3-3im 0+0im 4+0im

Note thatHupperwill not be equal toHlowerunlessAis itself Hermitian (e.g. ifA == adjoint(A)).  
All non-real parts of the diagonal will be ignored.

Hermitian (fill(complex(1,1), 1, 1)) == fill(1, 1, 1)

```
LinearAlgebra.LowerTriangular– Type.

```

LowerTriangular (A:: AbstractMatrix )

Construct aLowerTriangularview of the matrixA.  
Examples

julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]  
3×3 Matrix{Float64}:  
1.0 2.0 3.0  
4.0 5.0 6.0  
7.0 8.0 9.0

julia>LowerTriangular (A)  
3×3 LowerTriangular{Float64, Matrix{Float64}}:  
1.0 ⋅ ⋅  
4.0 5.0 ⋅  
7.0 8.0 9.0

```
LinearAlgebra.UpperTriangular– Type.

```

UpperTriangular (A:: AbstractMatrix )

Construct anUpperTriangularview of the matrixA.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1044

```

julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]  
3×3 Matrix{Float64}:  
1.0 2.0 3.0  
4.0 5.0 6.0  
7.0 8.0 9.0

julia>UpperTriangular (A)  
3×3 UpperTriangular{Float64, Matrix{Float64}}:  
1.0 2.0 3.0  
⋅ 5.0 6.0  
⋅ ⋅ 9.0

```
LinearAlgebra.UnitLowerTriangular– Type.

```

UnitLowerTriangular(A:: AbstractMatrix )

Construct aUnitLowerTriangularview of the matrixA. Such a view has theoneunitof theeltypeofA  
on its diagonal.  
Examples

julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]  
3×3 Matrix{Float64}:  
1.0 2.0 3.0  
4.0 5.0 6.0  
7.0 8.0 9.0

julia> UnitLowerTriangular(A)  
3×3 UnitLowerTriangular{Float64, Matrix{Float64}}:  
1.0 ⋅ ⋅  
4.0 1.0 ⋅  
7.0 8.0 1.0

```
LinearAlgebra.UnitUpperTriangular– Type.

```

UnitUpperTriangular(A:: AbstractMatrix )

Construct anUnitUpperTriangularview of the matrixA. Such a view has theoneunitof theeltypeofA  
on its diagonal.  
Examples

julia> A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]  
3×3 Matrix{Float64}:  
1.0 2.0 3.0  
4.0 5.0 6.0  
7.0 8.0 9.0

julia> UnitUpperTriangular(A)  
3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:  
1.0 2.0 3.0  
⋅ 1.0 6.0  
⋅ ⋅ 1.0

```
LinearAlgebra.UpperHessenberg– Type.

```

UpperHessenberg(A:: AbstractMatrix )

```

#### CHAPTER 75. LINEAR ALGEBRA 1045

```

Construct anUpperHessenbergview of the matrixA. Entries ofAbelow the first subdiagonal are ignored.  
Efficient algorithms are implemented forH \ b,det(H), and similar.  
See also thehessenbergfunction to factor any matrix into a similar upper-Hessenberg matrix.  
IfF::Hessenbergis the factorization object, the unitary matrix can be accessed withF.Qand the Hes-  
senberg matrix withF.H. WhenQis extracted, the resulting type is theHessenbergQobject, and may be  
converted to a regular matrix withconvert(Array, _)(orArray(_)for short).  
Iterating the decomposition produces the factorsF.QandF.H.  
Examples

julia> A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]  
4×4 Matrix{Int64}:  
1 2 3 4  
5 6 7 8  
9 10 11 12  
13 14 15 16

julia> UpperHessenberg(A)  
4×4 UpperHessenberg{Int64, Matrix{Int64}}:  
1 2 3 4  
5 6 7 8  
⋅ 10 11 12  
⋅ ⋅ 15 16

```
LinearAlgebra.UniformScaling– Type.

```

UniformScaling {T<: Number }

Generically sized uniform scaling operator defined as a scalar times the identity operator,λ*I. Although  
without an explicitsize, it acts similarly to a matrix in many cases and includes support for some indexing.  
See alsoI.

Julia 1.6  
Indexing using ranges is available as of Julia 1.6.

Examples

julia> J = UniformScaling (2.)  
UniformScaling{Float64}  
2.0*I

julia> A = [1. 2.; 3. 4.]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> J*A  
2×2 Matrix{Float64}:  
2.0 4.0  
6.0 8.0

julia> J[1:2, 1:2]  
2×2 Matrix{Float64}:  
2.0 0.0  
0.0 2.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1046

LinearAlgebra.I– Constant.

```

I

An object of typeUniformScaling, representing an identity matrix of any size.  
Examples

julia> fill(1, ( 5,6)) * I == fill(1, ( 5,6))  
true

julia> [1 2im 3; 1im 2 3] * I  
2×3 Matrix{Complex{Int64}}:  
1+0im 0+2im 3+0im  
0+1im 2+0im 3+0im

```
LinearAlgebra.UniformScaling– Method.

```

(I:: UniformScaling )(n:: Integer )

Construct aDiagonalmatrix from aUniformScaling.

Julia 1.2  
This method is available as of Julia 1.2.

Examples

julia> I(3)  
3×3 Diagonal{Bool, Vector{Bool}}:  
1 ⋅ ⋅  
⋅ 1 ⋅  
⋅ ⋅ 1

julia> (0.7*I)(3)  
3×3 Diagonal{Float64, Vector{Float64}}:  
0.7 ⋅ ⋅  
⋅ 0.7 ⋅  
⋅ ⋅ 0.7

```
LinearAlgebra.Factorization– Type.

```

LinearAlgebra. Factorization

Abstract type formatrix factorizationsa.k.a. matrix decompositions. Seeonline documentationfor a list  
of available matrix factorizations.

```
LinearAlgebra.LU– Type.

```

LU <: Factorization

Matrix factorization type of theLUfactorization of a square matrixA. This is the return type oflu, the  
corresponding matrix factorization function.  
The individual components of the factorizationF::LUcan be accessed viagetproperty:  
Iterating the factorization produces the componentsF.L,F.U, andF.p.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1047

```

Component Description  
F.L L(unit lower triangular) part ofLU  
F.U U(upper triangular) part ofLU  
F.p (right) permutationVector  
F.P (right) permutationMatrix

julia> A = [4 3; 6 3]  
2×2 Matrix{Int64}:  
4 3  
6 3

julia> F = lu(A)  
LU{Float64, Matrix{Float64}}  
L factor:  
2×2 Matrix{Float64}:  
1.0 0.0  
0.666667 1.0  
U factor:  
2×2 Matrix{Float64}:  
6.0 3.0  
0.0 1.0

julia> F.L * F.U == A[F.p, :]  
true

julia> l, u, p= lu(A);# destructuring via iteration

julia> l == F.L && u == F.U && p == F.p  
true

```
LinearAlgebra.lu– Function.

```

lu(A, pivot= RowMaximum(); check= true ) -> F::LU

Compute the LU factorization ofA.  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
In most cases, ifAis a subtypeSofAbstractMatrix{T}with an element typeTsupporting+,-,*and/,  
the return type isLU{T,S{T}}. If pivoting is chosen (default) the element type should also supportabsand  
<. Pivoting can be turned off by passingpivot = NoPivot().  
The individual components of the factorizationFcan be accessed viagetproperty:

Component Description  
F.L L(lower triangular) part ofLU  
F.U U(upper triangular) part ofLU  
F.p (right) permutationVector  
F.P (right) permutationMatrix

Iterating the factorization produces the componentsF.L,F.U, andF.p.  
The relationship betweenFandAis  
F.L*F.U == A[F.p, :]

```

#### CHAPTER 75. LINEAR ALGEBRA 1048

```

Ffurther supports the following functions:

Supported function LU LU{T,Tridiagonal{T}}  
/ ✓  
\ ✓ ✓  
inv ✓ ✓  
det ✓ ✓  
logdet ✓ ✓  
logabsdet ✓ ✓  
size ✓ ✓

Examples

julia> A = [4 3; 6 3]  
2×2 Matrix{Int64}:  
4 3  
6 3

julia> F = lu(A)  
LU{Float64, Matrix{Float64}}  
L factor:  
2×2 Matrix{Float64}:  
1.0 0.0  
0.666667 1.0  
U factor:  
2×2 Matrix{Float64}:  
6.0 3.0  
0.0 1.0

julia> F.L * F.U == A[F.p, :]  
true

julia> l, u, p= lu(A);# destructuring via iteration

julia> l == F.L && u == F.U && p == F.p  
true

lu(A::SparseMatrixCSC; check = true) -> F::UmfpackLU

Compute the LU factorization of a sparse matrixA.  
For sparseAwith real or complex element type, the return type ofFisUmfpackLU{Tv, Ti}, withTv=  
Float64orComplexF64respectively andTiis an integer type (Int32orInt64).  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
The individual components of the factorizationFcan be accessed by indexing:  
The relation betweenFandAis  
F.L_F.U == (F.Rs ._ A)[F.p, F.q]  
Ffurther supports the following functions:

```
#### • \


#### CHAPTER 75. LINEAR ALGEBRA 1049

```

Component Description  
L L(lower triangular) part ofLU  
U U(upper triangular) part ofLU  
p right permutationVector  
q left permutationVector  
Rs Vectorof scaling factors  
: (L,U,p,q,Rs)components

```
- cond
- det

```

Note  
lu(A::SparseMatrixCSC)uses the UMFPACK library that is part of SuiteSparse. As this library  
only supports sparse matrices withFloat64orComplexF64elements,luconvertsAinto a copy  
that is of typeSparseMatrixCSC{Float64}orSparseMatrixCSC{ComplexF64}as appropriate.

```
LinearAlgebra.lu!– Function.

```

lu!(A, pivot= RowMaximum(); check= true ) -> LU

lu! is the same aslu, but saves space by overwriting the inputA, instead of creating a copy. An  
InexactErrorexception is thrown if the factorization produces a number not representable by the ele-  
ment type ofA, e.g. for integer types.  
Examples

julia> A = [4. 3.; 6. 3.]  
2×2 Matrix{Float64}:  
4.0 3.0  
6.0 3.0

julia> F = lu!(A)  
LU{Float64, Matrix{Float64}}  
L factor:  
2×2 Matrix{Float64}:  
1.0 0.0  
0.666667 1.0  
U factor:  
2×2 Matrix{Float64}:  
6.0 3.0  
0.0 1.0

julia> iA = [4 3; 6 3]  
2×2 Matrix{Int64}:  
4 3  
6 3

julia> lu!(iA)  
ERROR: InexactError: Int64(0.6666666666666666)  
Stacktrace:  
[...]

lu!(F::UmfpackLU, A::SparseMatrixCSC; check=true) -> F::UmfpackLU

```

#### CHAPTER 75. LINEAR ALGEBRA 1050

```

Compute the LU factorization of a sparse matrixA, reusing the symbolic factorization of an already existing  
LU factorization stored inF. The sparse matrixAmust have an identical nonzero pattern as the matrix used  
to create the LU factorizationF, otherwise an error is thrown.  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.

Note  
lu!(F::UmfpackLU, A::SparseMatrixCSC)uses the UMFPACK library that is part of SuiteS-  
parse. As this library only supports sparse matrices withFloat64orComplexF64elements,lu!  
convertsAintoacopythatisoftypeSparseMatrixCSC{Float64}orSparseMatrixCSC{ComplexF64}  
as appropriate.

Julia 1.5  
lu!forUmfpackLUrequires at least Julia 1.5.

Examples

julia> A = sparse( Float64 [1.0 2.0; 0.0 3.0]);

julia> F = lu(A);

julia> B = sparse( Float64 [1.0 1.0; 0.0 1.0]);

julia> lu!(F, B);

julia> F \ ones(2)  
2-element Vector{Float64}:  
0.0  
1.0

```
LinearAlgebra.Cholesky– Type.

```

Cholesky<: Factorization

Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite  
matrixA. This is the return type ofcholesky, the corresponding matrix factorization function.  
The triangular Cholesky factor can be obtained from the factorizationF::CholeskyviaF.LandF.U, where  
A ≈ F.U' * F.U ≈ F.L * F.L'.  
The following functions are available forCholeskyobjects:size,,inv,det,logdetandisposdef.  
Iterating the decomposition produces the componentsLandU.  
Examples

julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]  
3×3 Matrix{Float64}:  
4.0 12.0 -16.0  
12.0 37.0 -43.0  
-16.0 -43.0 98.0

julia> C = cholesky(A)  
Cholesky{Float64, Matrix{Float64}}  
U factor:

```

#### CHAPTER 75. LINEAR ALGEBRA 1051

```

3×3 UpperTriangular{Float64, Matrix{Float64}}:  
2.0 6.0 -8.0  
⋅ 1.0 5.0  
⋅ ⋅ 3.0

julia> C.U  
3×3 UpperTriangular{Float64, Matrix{Float64}}:  
2.0 6.0 -8.0  
⋅ 1.0 5.0  
⋅ ⋅ 3.0

julia> C.L  
3×3 LowerTriangular{Float64, Matrix{Float64}}:  
2.0 ⋅ ⋅  
6.0 1.0 ⋅  
-8.0 5.0 3.0

julia> C.L * C.U == A  
true

julia> l, u= C; # destructuring via iteration

julia> l == C.L && u == C.U  
true

```
LinearAlgebra.CholeskyPivoted– Type.

```

CholeskyPivoted

Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive  
semi-definite matrixA. This is the return type ofcholesky(_, Val(true)), the corresponding matrix fac-  
torization function.  
The triangular Cholesky factor can be obtained from the factorizationF::CholeskyPivotedviaF.Land  
F.U,andthepermutationviaF.p,whereA[F.p, F.p] ≈ Ur' * Ur ≈ Lr * Lr'withUr = F.U[1:F.rank,  
:]andLr = F.L[:, 1:F.rank], or alternativelyA ≈ Up' * Up ≈ Lp * Lp'withUp = F.U[1:F.rank,  
invperm(F.p)]andLp = F.L[invperm(F.p), 1:F.rank].  
The following functions are available forCholeskyPivotedobjects:size,,inv,det, andrank.  
Iterating the decomposition produces the componentsLandU.  
Examples

julia> X = [1.0, 2.0, 3.0, 4.0];

julia> A = X * X';

julia> C = cholesky(A, Val ( true ), check= false )  
CholeskyPivoted{Float64, Matrix{Float64}}  
U factor with rank 1:  
4×4 UpperTriangular{Float64, Matrix{Float64}}:  
4.0 2.0 3.0 1.0  
⋅ 0.0 6.0 2.0  
⋅ ⋅ 9.0 3.0  
⋅ ⋅ ⋅ 1.0  
permutation:

```

#### CHAPTER 75. LINEAR ALGEBRA 1052

```

4-element Vector{Int64}:  
4  
2  
3  
1

julia> C.U[1:C.rank,:]' * C.U[1:C.rank,:] ≈ A[C.p, C .p]  
true

julia> l, u= C; # destructuring via iteration

julia> l == C.L && u == C.U  
true

```
LinearAlgebra.cholesky– Function.

```

cholesky(A:: SparseMatrixCSC ; shift= 0.0, check= true , perm= nothing) -> CHOLMOD.Factor

Compute the Cholesky factorization of a sparse positive definite matrixA.Amust be aSparseMatrixCSCor  
aSymmetric/Hermitianview of aSparseMatrixCSC. Note that even ifAdoesn't have the type tag, it must  
still be symmetric or Hermitian. Ifpermis not given, a fill-reducing permutation is used.F = cholesky(A)  
is most frequently used to solve systems of equations withF\b, but also the methodsdiag,det, and  
logdetare defined forF. You can also extract individual factors fromF, usingF.L. However, since pivoting  
is on by default, the factorization is internally represented asA == P'_L_L'_Pwith a permutation matrix  
P; using justLwithout accounting forPwill give incorrect answers. To include the effects of permutation,  
it's typically preferable to extract"combined" factors likePtL = F.PtL(the equivalent ofP'_L) andLtP  
= F.UP(the equivalent ofL'_P).  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
Setting the optionalshiftkeyword argument computes the factorization ofA+shift_Iinstead ofA. If the  
permargument is provided, it should be a permutation of1:size(A,1)giving the ordering to use (instead  
of CHOLMOD's default AMD ordering).  
Examples  
In the following example, the fill-reducing permutation used is[3, 2, 1]. Ifpermis set to1:3to enforce  
no permutation, the number of nonzero elements in the factor is 6.

julia> A = [2 1 1; 1 2 0; 1 0 2]  
3×3 Matrix{Int64}:  
2 1 1  
1 2 0  
1 0 2

julia> C = cholesky(sparse(A))  
SuiteSparse.CHOLMOD.Factor{Float64}  
type: LLt  
method: simplicial  
maxnnz: 5  
nnz: 5  
success: true

julia> C.p  
3-element Vector{Int64}:  
3

```

#### CHAPTER 75. LINEAR ALGEBRA 1053

```

2  
1

julia> L = sparse(C.L);

julia>Matrix (L)  
3×3 Matrix{Float64}:  
1.41421 0.0 0.0  
0.0 1.41421 0.0  
0.707107 0.707107 1.0

julia> L * L' ≈ A[C.p, C .p]  
true

julia> P = sparse(1:3, C .p, ones(3))  
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:  
⋅ ⋅ 1.0  
⋅ 1.0 ⋅  
1.0 ⋅ ⋅

julia> P' * L * L' * P ≈ A  
true

julia> C = cholesky(sparse(A), perm=1:3)  
SuiteSparse.CHOLMOD.Factor{Float64}  
type: LLt  
method: simplicial  
maxnnz: 6  
nnz: 6  
success: true

julia> L = sparse(C.L);

julia>Matrix (L)  
3×3 Matrix{Float64}:  
1.41421 0.0 0.0  
0.707107 1.22474 0.0  
0.707107 -0.408248 1.1547

julia> L * L' ≈ A  
true

Note  
This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or com-  
plexdoubles. InputmatricesnotofthoseelementtypeswillbeconvertedtoSparseMatrixCSC{Float64}  
orSparseMatrixCSC{ComplexF64}as appropriate.  
ManyotherfunctionsfromCHOLMODarewrappedbutnotexportedfromtheBase.SparseArrays.CHOLMOD  
module.

cholesky(A, Val(false); check = true) -> Cholesky

Compute the Cholesky factorization of a dense symmetric positive definite matrixAand return aCholesky  
factorization. The matrixAcan either be aSymmetricorHermitianStridedMatrixor a perfectly sym-  
metric or HermitianStridedMatrix.

```

#### CHAPTER 75. LINEAR ALGEBRA 1054

```

The triangular Cholesky factor can be obtained from the factorizationFviaF.LandF.U, whereA ≈ F.U'

-   F.U ≈ F.L * F.L'.  
    The following functions are available forCholeskyobjects:size,,inv,det,logdetandisposdef.  
    If you have a matrixAthat is slightly non-Hermitian due to roundoff errors in its construction, wrap it in  
    Hermitian(A)before passing it tocholeskyin order to treat it as perfectly Hermitian.  
    Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
    for checking the decomposition's validity (viaissuccess) lies with the user.  
    Examples

julia> A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]  
3×3 Matrix{Float64}:  
4.0 12.0 -16.0  
12.0 37.0 -43.0  
-16.0 -43.0 98.0

julia> C = cholesky(A)  
Cholesky{Float64, Matrix{Float64}}  
U factor:  
3×3 UpperTriangular{Float64, Matrix{Float64}}:  
2.0 6.0 -8.0  
⋅ 1.0 5.0  
⋅ ⋅ 3.0

julia> C.U  
3×3 UpperTriangular{Float64, Matrix{Float64}}:  
2.0 6.0 -8.0  
⋅ 1.0 5.0  
⋅ ⋅ 3.0

julia> C.L  
3×3 LowerTriangular{Float64, Matrix{Float64}}:  
2.0 ⋅ ⋅  
6.0 1.0 ⋅  
-8.0 5.0 3.0

julia> C.L * C.U == A  
true

cholesky(A, Val(true); tol = 0.0, check = true) -> CholeskyPivoted

ComputethepivotedCholeskyfactorizationofadensesymmetricpositivesemi-definitematrixAandreturn  
aCholeskyPivotedfactorization. The matrixAcan either be aSymmetricorHermitianStridedMatrix  
or a perfectly symmetric or HermitianStridedMatrix.  
The triangular Cholesky factor can be obtained from the factorizationFviaF.LandF.U, and the per-  
mutation viaF.p, whereA[F.p, F.p] ≈ Ur' * Ur ≈ Lr * Lr'withUr = F.U[1:F.rank, :]andLr =  
F.L[:, 1:F.rank],oralternativelyA ≈ Up' * Up ≈ Lp * Lp'withUp = F.U[1:F.rank, invperm(F.p)]  
andLp = F.L[invperm(F.p), 1:F.rank].  
The following functions are available forCholeskyPivotedobjects:size,,inv,det, andrank.  
The argumenttoldetermines the tolerance for determining the rank. For negative values, the tolerance  
is the machine precision.

```

#### CHAPTER 75. LINEAR ALGEBRA 1055

```

If you have a matrixAthat is slightly non-Hermitian due to roundoff errors in its construction, wrap it in  
Hermitian(A)before passing it tocholeskyin order to treat it as perfectly Hermitian.  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
Examples

julia> X = [1.0, 2.0, 3.0, 4.0];

julia> A = X * X';

julia> C = cholesky(A, Val ( true ), check= false )  
CholeskyPivoted{Float64, Matrix{Float64}}  
U factor with rank 1:  
4×4 UpperTriangular{Float64, Matrix{Float64}}:  
4.0 2.0 3.0 1.0  
⋅ 0.0 6.0 2.0  
⋅ ⋅ 9.0 3.0  
⋅ ⋅ ⋅ 1.0  
permutation:  
4-element Vector{Int64}:  
4  
2  
3  
1

julia> C.U[1:C.rank,:]' * C.U[1:C.rank,:] ≈ A[C.p, C .p]  
true

julia> l, u= C; # destructuring via iteration

julia> l == C.L && u == C.U  
true

```
LinearAlgebra.cholesky!– Function.

```

cholesky!(F::CHOLMOD.Factor, A:: SparseMatrixCSC ; shift= 0.0, check= true ) -> CHOLMOD.Factor

ComputetheCholesky(LL′)factorizationofA,reusingthesymbolicfactorizationF.AmustbeaSparseMatrixCSC  
or aSymmetric/Hermitianview of aSparseMatrixCSC. Note that even ifAdoesn't have the type tag, it  
must still be symmetric or Hermitian.  
See alsocholesky.

Note  
This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or com-  
plexdoubles. InputmatricesnotofthoseelementtypeswillbeconvertedtoSparseMatrixCSC{Float64}  
orSparseMatrixCSC{ComplexF64}as appropriate.

cholesky!(A::StridedMatrix, Val(false); check = true) -> Cholesky

The same ascholesky, but saves space by overwriting the inputA, instead of creating a copy. An  
InexactErrorexception is thrown if the factorization produces a number not representable by the ele-  
ment type ofA, e.g. for integer types.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1056

```

julia> A = [1 2; 2 50]  
2×2 Matrix{Int64}:  
1 2  
2 50

julia> cholesky!(A)  
ERROR: InexactError: Int64(6.782329983125268)  
Stacktrace:  
[...]

cholesky!(A::StridedMatrix, Val(true); tol = 0.0, check = true) -> CholeskyPivoted

The same ascholesky, but saves space by overwriting the inputA, instead of creating a copy. An  
InexactErrorexception is thrown if the factorization produces a number not representable by the ele-  
ment type ofA, e.g. for integer types.

```
LinearAlgebra.lowrankupdate– Function.

```

lowrankupdate(C::Cholesky, v:: AbstractVector ) -> CC::Cholesky

Update a Cholesky factorizationCwith the vectorv. IfA = C.U'C.UthenCC = cholesky(C.U'C.U +  
v*v')but the computation ofCConly usesO(n^2)operations.

```
LinearAlgebra.lowrankdowndate– Function.

```

lowrankdowndate(C::Cholesky, v:: AbstractVector ) -> CC::Cholesky

Downdate a Cholesky factorizationCwith the vectorv. IfA = C.U'C.UthenCC = cholesky(C.U'C.U -  
v*v')but the computation ofCConly usesO(n^2)operations.

```
LinearAlgebra.lowrankupdate!– Function.

```

lowrankupdate!(C::Cholesky, v:: AbstractVector ) -> CC::Cholesky

Update a Cholesky factorizationCwith the vectorv. IfA = C.U'C.UthenCC = cholesky(C.U'C.U +  
v*v')but the computation ofCConly usesO(n^2)operations. The input factorizationCis updated in  
place such that on exitC == CC. The vectorvis destroyed during the computation.

```
LinearAlgebra.lowrankdowndate!– Function.

```

lowrankdowndate!(C::Cholesky, v:: AbstractVector ) -> CC::Cholesky

Downdate a Cholesky factorizationCwith the vectorv. IfA = C.U'C.UthenCC = cholesky(C.U'C.U -  
v*v')but the computation ofCConly usesO(n^2)operations. The input factorizationCis updated in place  
such that on exitC == CC. The vectorvis destroyed during the computation.

```
LinearAlgebra.LDLt– Type.

```

LDLt<: Factorization

MatrixfactorizationtypeoftheLDLtfactorizationofarealSymTridiagonalmatrixSsuchthatS = L_Diagonal(d)_L',  
whereLis aUnitLowerTriangularmatrix anddis a vector. The main use of anLDLtfactorizationF =  
ldlt(S)is to solve the linear system of equationsSx = bwithF\b. This is the return type ofldlt, the  
corresponding matrix factorization function.  
The individual components of the factorizationF::LDLtcan be accessed viagetproperty:  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1057

```

Component Description  
F.L L(unit lower triangular) part ofLDLt  
F.D D(diagonal) part ofLDLt  
F.Lt Lt(unit upper triangular) part ofLDLt  
F.d diagonal values ofDas aVector

julia> S = SymTridiagonal ([3., 4., 5.], [ 1., 2.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
3.0 1.0 ⋅  
1.0 4.0 2.0  
⋅ 2.0 5.0

julia> F = ldlt(S)  
LDLt{Float64, SymTridiagonal{Float64, Vector{Float64}}}  
L factor:  
3×3 UnitLowerTriangular{Float64, SymTridiagonal{Float64, Vector{Float64}}}:  
1.0 ⋅ ⋅  
0.333333 1.0 ⋅  
0.0 0.545455 1.0  
D factor:  
3×3 Diagonal{Float64, Vector{Float64}}:  
3.0 ⋅ ⋅  
⋅ 3.66667 ⋅  
⋅ ⋅ 3.90909

```
LinearAlgebra.ldlt– Function.

```

ldlt(A:: SparseMatrixCSC ; shift= 0.0, check= true , perm=nothing) -> CHOLMOD.Factor

ComputetheLDL′factorizationofasparsematrixA.AmustbeaSparseMatrixCSCoraSymmetric/Hermitian  
view of aSparseMatrixCSC. Note that even ifAdoesn't have the type tag, it must still be symmetric or  
Hermitian. A fill-reducing permutation is used.F = ldlt(A)is most frequently used to solve systems of  
equationsA_x = bwithF\b. The returned factorization objectFalso supports the methodsdiag,det,  
logdet, andinv. You can extract individual factors fromFusingF.L. However, since pivoting is on by  
default, the factorization is internally represented asA == P'_L_D_L'_Pwith a permutation matrixP; us-  
ing justLwithout accounting forPwill give incorrect answers. To include the effects of permutation, it  
is typically preferable to extract"combined" factors likePtL = F.PtL(the equivalent ofP'_L) andLtP =  
F.UP(the equivalent ofL'_P). The complete list of supported factors is:L, :PtL, :D, :UP, :U, :LD,  
:DU, :PtLD, :DUP.  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
Setting the optionalshiftkeyword argument computes the factorization ofA+shift_Iinstead ofA. If the  
permargument is provided, it should be a permutation of1:size(A,1)giving the ordering to use (instead  
of CHOLMOD's default AMD ordering).

Note  
This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or com-  
plexdoubles. InputmatricesnotofthoseelementtypeswillbeconvertedtoSparseMatrixCSC{Float64}  
orSparseMatrixCSC{ComplexF64}as appropriate.  
ManyotherfunctionsfromCHOLMODarewrappedbutnotexportedfromtheBase.SparseArrays.CHOLMOD  
module.

```

#### CHAPTER 75. LINEAR ALGEBRA 1058

```

ldlt(S::SymTridiagonal) -> LDLt

ComputeanLDLtfactorizationoftherealsymmetrictridiagonalmatrixSsuchthatS = L_Diagonal(d)_L'  
whereLis a unit lower triangular matrix anddis a vector. The main use of anLDLtfactorizationF =  
ldlt(S)is to solve the linear system of equationsSx = bwithF\b.  
Examples

julia> S = SymTridiagonal ([3., 4., 5.], [ 1., 2.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
3.0 1.0 ⋅  
1.0 4.0 2.0  
⋅ 2.0 5.0

julia> ldltS= ldlt(S);

julia> b = [6., 7., 8.];

julia> ldltS\ b  
3-element Vector{Float64}:  
1.7906976744186047  
0.627906976744186  
1.3488372093023255

julia> S \ b  
3-element Vector{Float64}:  
1.7906976744186047  
0.627906976744186  
1.3488372093023255

```
LinearAlgebra.ldlt!– Function.

```

ldlt!(F::CHOLMOD.Factor, A:: SparseMatrixCSC ; shift= 0.0, check= true ) -> CHOLMOD.Factor

Compute theLDL′factorization ofA, reusing the symbolic factorizationF.Amust be aSparseMatrixCSC  
or aSymmetric/Hermitianview of aSparseMatrixCSC. Note that even ifAdoesn't have the type tag, it  
must still be symmetric or Hermitian.  
See alsoldlt.

Note  
This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or com-  
plexdoubles. InputmatricesnotofthoseelementtypeswillbeconvertedtoSparseMatrixCSC{Float64}  
orSparseMatrixCSC{ComplexF64}as appropriate.

ldlt!(S::SymTridiagonal) -> LDLt

Same asldlt, but saves space by overwriting the inputS, instead of creating a copy.  
Examples

julia> S = SymTridiagonal ([3., 4., 5.], [ 1., 2.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
3.0 1.0 ⋅  
1.0 4.0 2.0  
⋅ 2.0 5.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1059

```

julia> ldltS= ldlt!(S);

julia> ldltS=== S  
false

julia> S  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
3.0 0.333333 ⋅  
0.333333 3.66667 0.545455  
⋅ 0.545455 3.90909

```
LinearAlgebra.QR– Type.

```

QR <: Factorization

```
A QR matrix factorization stored in a packed format, typically obtained fromqr. IfAis anm×nmatrix, then

A=QR

```

whereQis an orthogonal/unitary matrix andRis upper triangular. The matrixQis stored as a sequence  
of Householder reflectorsviand coefficientsτiwhere:

```
Q=

min∏(m,n)

```

i=1

```
(I−τiviviT).

```

Iterating the decomposition produces the componentsQandR.  
The object has two fields:

```
- factorsis anm×nmatrix.
    **-** The upper triangular part contains the elements ofR, that isR = triu(F.factors)for aQR
       objectF.
    **-** The subdiagonal part contains the reflectorsvistored in a packed format whereviis theith
       column of the matrixV = I + tril(F.factors, -1).
- τis a vector of lengthmin(m,n)containing the coefficientsaui.

LinearAlgebra.QRCompactWY– Type.

```

QRCompactWY<: Factorization

A QR matrix factorization stored in a compact blocked format, typically obtained fromqr. IfAis anm×n  
matrix, then

```
A=QR

```

whereQis an orthogonal/unitary matrix andRis upper triangular. It is similar to theQRformat except that  
the orthogonal/unitary matrixQis stored in Compact WY format^1. For the block sizenb, it is stored as a  
m×nlower trapezoidal matrixVand a matrixT= (T 1 T 2 ... Tb− 1 Tb′)composed ofb=dmin(m, n)/nbe

```

#### CHAPTER 75. LINEAR ALGEBRA 1060

```

upper triangular matricesTjof sizenb×nb(j= 1, ..., b− 1 ) and an upper trapezoidalnb×min(m, n)−  
(b−1)nbmatrixTb′(j=b) whose upper square part denoted withTbsatisfying

```
Q=

min∏(m,n)

```

i=1

```
(I−τiviviT) =

∏b

```

j=1

```
(I−VjTjVjT)

```

such thatviis theith column ofV,τiis theith element of[diag(T_1); diag(T_2); ...; diag(T_b)],  
and(V 1 V 2 ... Vb)is the leftm×min(m, n)block ofV. When constructed usingqr, the block size is given  
bynb=min(m, n,36).  
Iterating the decomposition produces the componentsQandR.  
The object has two fields:

```
- factors, as in theQRtype, is anm×nmatrix.
    **-** The upper triangular part contains the elements ofR, that isR = triu(F.factors)for aQR
       objectF.
    **-** The subdiagonal part contains the reflectorsvistored in a packed format such thatV = I +
       tril(F.factors, -1).
- Tis anb-by-min(m, n)matrix as described above. The subdiagonal elements for each triangular
    matrixTjare ignored.

```

Note  
This format should not to be confused with the older WY representation^2.

```
LinearAlgebra.QRPivoted– Type.

```

QRPivoted<: Factorization

A QR matrix factorization with column pivoting in a packed format, typically obtained fromqr. IfAis an  
m×nmatrix, then

```
AP=QR

```

wherePis a permutation matrix,Qis an orthogonal/unitary matrix andRis upper triangular. The matrix  
Qis stored as a sequence of Householder reflectors:

```
Q=

min∏(m,n)

```

i=1

```
(I−τiviviT).

```

Iterating the decomposition produces the componentsQ,R, andp.  
The object has three fields:

```
(^2) C Bischof and C Van Loan,"The WY representation for products of Householder matrices", SIAM J Sci Stat Comput 8 (1987), s2-s13.
doi:10.1137/0908009
(^1) R Schreiber and C Van Loan,"A storage-efficient WY representation for products of Householder transformations", SIAM J Sci Stat
Comput 10 (1989), 53-57.doi:10.1137/0910005


#### CHAPTER 75. LINEAR ALGEBRA 1061

- factorsis anm×nmatrix.
    **-** The upper triangular part contains the elements ofR, that isR = triu(F.factors)for aQR
       objectF.
    **-** The subdiagonal part contains the reflectorsvistored in a packed format whereviis theith
       column of the matrixV = I + tril(F.factors, -1).
- τis a vector of lengthmin(m,n)containing the coefficientsaui.
- jpvtis an integer vector of lengthncorresponding to the permutationP.

LinearAlgebra.qr– Function.

```

qr(A:: SparseMatrixCSC ; tol=_default_tol(A), ordering=ORDERING_DEFAULT)-> QRSparse

Compute theQRfactorization of a sparse matrixA. Fill-reducing row and column permutations are used  
such thatF.R = F.Q'*A[F.prow,F.pcol]. The main application of this type is to solve least squares or  
underdetermined problems with. The function calls the C library SPQR.

Note  
qr(A::SparseMatrixCSC)uses the SPQR library that is part of SuiteSparse. As this library only  
supports sparse matrices withFloat64orComplexF64elements, as of Julia v1.4qrconvertsA  
into a copy that is of typeSparseMatrixCSC{Float64}orSparseMatrixCSC{ComplexF64}as  
appropriate.

Examples

julia> A = sparse([1,2,3,4], [ 1,1,2,2], [ 1.0,1.0,1.0,1.0])  
4×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:  
1.0 ⋅  
1.0 ⋅  
⋅ 1.0  
⋅ 1.0

julia> qr(A)  
SuiteSparse.SPQR.QRSparse{Float64, Int64}  
Q factor:  
4×4 SuiteSparse.SPQR.QRSparseQ{Float64, Int64}:  
-0.707107 0.0 0.0 -0.707107  
0.0 -0.707107 -0.707107 0.0  
0.0 -0.707107 0.707107 0.0  
-0.707107 0.0 0.0 0.707107  
R factor:  
2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:  
-1.41421 ⋅  
⋅ -1.41421  
Row permutation:  
4-element Vector{Int64}:  
1  
3  
4  
2  
Column permutation:  
2-element Vector{Int64}:  
1  
2

```

#### CHAPTER 75. LINEAR ALGEBRA 1062

```

qr(A, pivot = NoPivot(); blocksize) -> F

Compute the QR factorization of the matrixA: an orthogonal (or unitary ifAis complex-valued) matrixQ,  
and an upper triangular matrixRsuch that

```
A=QR

```

The returned objectFstores the factorization in a packed format:

```
- ifpivot == ColumnNorm()thenFis aQRPivotedobject,
- otherwise if the element type ofAis a BLAS type (Float32,Float64,ComplexF32orComplexF64),
    thenFis aQRCompactWYobject,
- otherwiseFis aQRobject.

```

The individual components of the decompositionFcan be retrieved via property accessors:

```
- F.Q: the orthogonal/unitary matrixQ
- F.R: the upper triangular matrixR
- F.p: the permutation vector of the pivot (QRPivotedonly)
- F.P: the permutation matrix of the pivot (QRPivotedonly)

```

Iterating the decomposition produces the componentsQ,R, and if extantp.  
The following functions are available for theQRobjects:inv,size, and. WhenAis rectangular,\will  
return a least squares solution and if the solution is not unique, the one with smallest norm is returned.  
WhenAis not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.  
Multiplication with respect to either full/square or non-full/squareQis allowed, i.e. bothF.Q_F.RandF.Q_A  
are supported. AQmatrix can be converted into a regular matrix withMatrix. This operation returns  
the "thin" Q factor, i.e., ifAism×nwithm>=n, thenMatrix(F.Q)yields anm×nmatrix with orthonormal  
columns. To retrieve the"full" Q factor, anm×morthogonal matrix, useF.Q*Matrix(I,m,m). Ifm<=n, then  
Matrix(F.Q)yields anm×morthogonal matrix.  
The block size for QR decomposition can be specified by keyword argumentblocksize :: Integerwhen  
pivot == NoPivot()andA isa StridedMatrix{<:BlasFloat}. Itisignoredwhenblocksize > minimum(size(A)).  
SeeQRCompactWY.

Julia 1.4  
Theblocksizekeyword argument requires Julia 1.4 or later.

Examples

julia> A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]  
3×2 Matrix{Float64}:  
3.0 -6.0  
4.0 -8.0  
0.0 1.0

julia> F = qr(A)  
LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}}  
Q factor:

```

#### CHAPTER 75. LINEAR ALGEBRA 1063

```

3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}:  
-0.6 0.0 0.8  
-0.8 0.0 -0.6  
0.0 -1.0 0.0  
R factor:  
2×2 Matrix{Float64}:  
-5.0 10.0  
0.0 -1.0

julia> F.Q * F.R == A  
true

Note  
qrreturnsmultipletypesbecauseLAPACKusesseveralrepresentationsthatminimizethemem-  
ory storage requirements of products of Householder elementary reflectors, so that theQand  
Rmatrices can be stored compactly rather as two separate dense matrices.

```
LinearAlgebra.qr!– Function.

```

qr!(A, pivot= NoPivot(); blocksize)

qr!is the same asqrwhenAis a subtype ofStridedMatrix, but saves space by overwriting the inputA,  
instead of creating a copy. AnInexactErrorexception is thrown if the factorization produces a number  
not representable by the element type ofA, e.g. for integer types.

Julia 1.4  
Theblocksizekeyword argument requires Julia 1.4 or later.

Examples

julia> a = [1. 2.; 3. 4.]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> qr!(a)  
LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}}  
Q factor:  
2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}}:  
-0.316228 -0.948683  
-0.948683 0.316228  
R factor:  
2×2 Matrix{Float64}:  
-3.16228 -4.42719  
0.0 -0.632456

julia> a = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> qr!(a)  
ERROR: InexactError: Int64(3.1622776601683795)  
Stacktrace:  
[...]

```

#### CHAPTER 75. LINEAR ALGEBRA 1064

LinearAlgebra.LQ– Type.

```

LQ <: Factorization

MatrixfactorizationtypeoftheLQfactorizationofamatrixA.TheLQdecompositionistheQRdecomposition  
oftranspose(A). This is the return type oflq, the corresponding matrix factorization function.  
IfS::LQis the factorization object, the lower triangular component can be obtained viaS.L, and the  
orthogonal/unitary component viaS.Q, such thatA ≈ S.L*S.Q.  
Iterating the decomposition produces the componentsS.LandS.Q.  
Examples

julia> A = [5. 7.; -2. -4.]  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> S = lq(A)  
LQ{Float64, Matrix{Float64}}  
L factor:  
2×2 Matrix{Float64}:  
-8.60233 0.0  
4.41741 -0.697486  
Q factor:  
2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}}:  
-0.581238 -0.813733  
-0.813733 0.581238

julia> S.L * S.Q  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> l, q= S; # destructuring via iteration

julia> l == S.L && q == S.Q  
true

```
LinearAlgebra.lq– Function.

```

lq(A)-> S::LQ

Compute the LQ decomposition ofA. The decomposition's lower triangular component can be obtained  
from theLQobjectSviaS.L, and the orthogonal/unitary component viaS.Q, such thatA ≈ S.L*S.Q.  
Iterating the decomposition produces the componentsS.LandS.Q.  
The LQ decomposition is the QR decomposition oftranspose(A), and it is useful in order to compute the  
minimum-norm solutionlq(A) \ bto an underdetermined system of equations (Ahas more columns than  
rows, but has full row rank).  
Examples

julia> A = [5. 7.; -2. -4.]  
2×2 Matrix{Float64}:  
5.0 7.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1065

```

-2.0 -4.0

julia> S = lq(A)  
LQ{Float64, Matrix{Float64}}  
L factor:  
2×2 Matrix{Float64}:  
-8.60233 0.0  
4.41741 -0.697486  
Q factor:  
2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}}:  
-0.581238 -0.813733  
-0.813733 0.581238

julia> S.L * S.Q  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> l, q= S; # destructuring via iteration

julia> l == S.L && q == S.Q  
true

```
LinearAlgebra.lq!– Function.

```

lq!(A)-> LQ

Compute theLQfactorization ofA, using the input matrix as a workspace. See alsolq.

```
LinearAlgebra.BunchKaufman– Type.

```

BunchKaufman<: Factorization

Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrixAas  
P'UDU'PorP'LDL'P, depending on whether the upper (the default) or the lower triangle is stored inA.  
IfAis complex symmetric thenU'andL'denote the unconjugated transposes, i.e.transpose(U)and  
transpose(L), respectively. This is the return type ofbunchkaufman, the corresponding matrix factoriza-  
tion function.  
IfS::BunchKaufmanis the factorization object, the components can be obtained viaS.D,S.UorS.Las  
appropriate givenS.uplo, andS.p.  
Iterating the decomposition produces the componentsS.D,S.UorS.Las appropriate givenS.uplo, and  
S.p.  
Examples

julia> A = [1 2; 2 3]  
2×2 Matrix{Int64}:  
1 2  
2 3

julia> S = bunchkaufman(A)# A gets wrapped internally by Symmetric(A)  
BunchKaufman{Float64, Matrix{Float64}}  
D factor:  
2×2 Tridiagonal{Float64, Vector{Float64}}:  
-0.333333 0.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1066

```

0.0 3.0  
U factor:  
2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:  
1.0 0.666667  
⋅ 1.0  
permutation:  
2-element Vector{Int64}:  
1  
2

julia> d, u, p= S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p  
true

julia> S = bunchkaufman( Symmetric (A, :L))  
BunchKaufman{Float64, Matrix{Float64}}  
D factor:  
2×2 Tridiagonal{Float64, Vector{Float64}}:  
3.0 0.0  
0.0 -0.333333  
L factor:  
2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:  
1.0 ⋅  
0.666667 1.0  
permutation:  
2-element Vector{Int64}:  
2  
1

```
LinearAlgebra.bunchkaufman– Function.

```

bunchkaufman(A, rook:: Bool = false ; check= true ) -> S::BunchKaufman

Compute the Bunch-Kaufman^3 factorization of a symmetric or Hermitian matrixAasP'_U_D_U'_Por  
P'_L_D_L'_P, depending on which triangle is stored inA, and return aBunchKaufmanobject. Note that  
ifAis complex symmetric thenU'andL'denote the unconjugated transposes, i.e.transpose(U)and  
transpose(L).  
Iterating the decomposition produces the componentsS.D,S.UorS.Las appropriate givenS.uplo, and  
S.p.  
Ifrookistrue, rook pivoting is used. Ifrookis false, rook pivoting is not used.  
Whencheck = true, an error is thrown if the decomposition fails. Whencheck = false, responsibility  
for checking the decomposition's validity (viaissuccess) lies with the user.  
The following functions are available forBunchKaufmanobjects:size,,inv,issymmetric,ishermitian,  
getindex.  
Examples

julia> A = [1 2; 2 3]  
2×2 Matrix{Int64}:

```
(^3) J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Com-
putation 31:137 (1977), 163-179.url.


#### CHAPTER 75. LINEAR ALGEBRA 1067

```

1 2  
2 3

julia> S = bunchkaufman(A)# A gets wrapped internally by Symmetric(A)  
BunchKaufman{Float64, Matrix{Float64}}  
D factor:  
2×2 Tridiagonal{Float64, Vector{Float64}}:  
-0.333333 0.0  
0.0 3.0  
U factor:  
2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:  
1.0 0.666667  
⋅ 1.0  
permutation:  
2-element Vector{Int64}:  
1  
2

julia> d, u, p= S; # destructuring via iteration

julia> d == S.D && u == S.U && p == S.p  
true

julia> S.U_S.D_S.U' - S.P_A_S.P'  
2×2 Matrix{Float64}:  
0.0 0.0  
0.0 0.0

julia> S = bunchkaufman( Symmetric (A, :L))  
BunchKaufman{Float64, Matrix{Float64}}  
D factor:  
2×2 Tridiagonal{Float64, Vector{Float64}}:  
3.0 0.0  
0.0 -0.333333  
L factor:  
2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:  
1.0 ⋅  
0.666667 1.0  
permutation:  
2-element Vector{Int64}:  
2  
1

julia> S.L_S.D_S.L' - A[S.p, S .p]  
2×2 Matrix{Float64}:  
0.0 0.0  
0.0 0.0

```
LinearAlgebra.bunchkaufman!– Function.

```

bunchkaufman!(A, rook:: Bool = false ; check= true ) -> BunchKaufman

bunchkaufman! is the same asbunchkaufman, but saves space by overwriting the inputA, instead of  
creating a copy.

```
LinearAlgebra.Eigen– Type.


#### CHAPTER 75. LINEAR ALGEBRA 1068

```

Eigen<: Factorization

Matrix factorization type of the eigenvalue/spectral decomposition of a square matrixA. This is the return  
type ofeigen, the corresponding matrix factorization function.  
IfF::Eigenis the factorization object, the eigenvalues can be obtained viaF.valuesand the eigenvectors  
asthecolumnsofthematrixF.vectors. (ThektheigenvectorcanbeobtainedfromthesliceF.vectors[:,  
k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.  
Examples

julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])  
Eigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}  
values:  
3-element Vector{Float64}:  
1.0  
3.0  
18.0  
vectors:  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

julia> F.values  
3-element Vector{Float64}:  
1.0  
3.0  
18.0

julia> F.vectors  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

julia> vals, vecs= F; # destructuring via iteration

julia> vals== F.values&& vecs== F.vectors  
true

```
LinearAlgebra.GeneralizedEigen– Type.

```

GeneralizedEigen<: Factorization

Matrixfactorizationtypeofthegeneralizedeigenvalue/spectraldecompositionofAandB.Thisisthereturn  
type ofeigen, the corresponding matrix factorization function, when called with two matrix arguments.  
IfF::GeneralizedEigenis the factorization object, the eigenvalues can be obtained viaF.valuesand the  
eigenvectors as the columns of the matrixF.vectors. (Thekth eigenvector can be obtained from the slice  
F.vectors[:, k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1069

```

julia> A = [1 0; 0 -1]  
2×2 Matrix{Int64}:  
1 0  
0 -1

julia> B = [0 1; 1 0]  
2×2 Matrix{Int64}:  
0 1  
1 0

julia> F = eigen(A, B)  
GeneralizedEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}  
values:  
2-element Vector{ComplexF64}:  
0.0 - 1.0im  
0.0 + 1.0im  
vectors:  
2×2 Matrix{ComplexF64}:  
0.0+1.0im 0.0-1.0im  
-1.0+0.0im -1.0-0.0im

julia> F.values  
2-element Vector{ComplexF64}:  
0.0 - 1.0im  
0.0 + 1.0im

julia> F.vectors  
2×2 Matrix{ComplexF64}:  
0.0+1.0im 0.0-1.0im  
-1.0+0.0im -1.0-0.0im

julia> vals, vecs= F; # destructuring via iteration

julia> vals== F.values&& vecs== F.vectors  
true

```
LinearAlgebra.eigvals– Function.

```

eigvals(A; permute:: Bool = true , scale:: Bool = true , sortby)-> values

Return the eigenvalues ofA.  
For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigen-  
value calculation. Thepermute,scale, andsortbykeywords are the same as foreigen!.  
Examples

julia> diag_matrix= [1 0; 0 4]  
2×2 Matrix{Int64}:  
1 0  
0 4

julia> eigvals(diag_matrix)  
2-element Vector{Float64}:  
1.0  
4.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1070

```

For a scalar input,eigvalswill return a scalar.  
Example

julia> eigvals(-2)  
-2

eigvals(A, B) -> values

Computes the generalized eigenvalues ofAandB.  
Examples

julia> A = [1 0; 0 -1]  
2×2 Matrix{Int64}:  
1 0  
0 -1

julia> B = [0 1; 1 0]  
2×2 Matrix{Int64}:  
0 1  
1 0

julia> eigvals(A,B)  
2-element Vector{ComplexF64}:  
0.0 - 1.0im  
0.0 + 1.0im

eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values

Returns the eigenvalues ofA. It is possible to calculate only a subset of the eigenvalues by specifying a  
UnitRangeirangecovering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.  
Examples

julia> A = SymTridiagonal ([1.; 2.; 1.], [ 2.; 3.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
1.0 2.0 ⋅  
2.0 2.0 3.0  
⋅ 3.0 1.0

julia> eigvals(A,2:2)  
1-element Vector{Float64}:  
0.9999999999999996

julia> eigvals(A)  
3-element Vector{Float64}:  
-2.1400549446402604  
1.0000000000000002  
5.140054944640259

eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values

Returns the eigenvalues ofA. It is possible to calculate only a subset of the eigenvalues by specifying a  
pairvlandvufor the lower and upper boundaries of the eigenvalues.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1071

```

julia> A = SymTridiagonal ([1.; 2.; 1.], [ 2.; 3.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
1.0 2.0 ⋅  
2.0 2.0 3.0  
⋅ 3.0 1.0

julia> eigvals(A,-1, 2)  
1-element Vector{Float64}:  
1.0000000000000009

julia> eigvals(A)  
3-element Vector{Float64}:  
-2.1400549446402604  
1.0000000000000002  
5.140054944640259

```
LinearAlgebra.eigvals!– Function.

```

eigvals!(A; permute:: Bool = true , scale:: Bool = true , sortby)-> values

Same aseigvals, but saves space by overwriting the inputA, instead of creating a copy. Thepermute,  
scale, andsortbykeywords are the same as foreigen.

Note  
The input matrixAwill not contain its eigenvalues aftereigvals!is called on it -Ais used as  
a workspace.

Examples

julia> A = [1. 2.; 3. 4.]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> eigvals!(A)  
2-element Vector{Float64}:  
-0.3722813232690143  
5.372281323269014

julia> A  
2×2 Matrix{Float64}:  
-0.372281 -1.0  
0.0 5.37228

eigvals!(A, B; sortby) -> values

Same aseigvals, but saves space by overwriting the inputA(andB), instead of creating copies.

Note  
The input matricesAandBwill not contain their eigenvalues aftereigvals!is called. They are  
used as workspaces.

Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1072

```

julia> A = [1. 0.; 0. -1.]  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 -1.0

julia> B = [0. 1.; 1. 0.]  
2×2 Matrix{Float64}:  
0.0 1.0  
1.0 0.0

julia> eigvals!(A, B)  
2-element Vector{ComplexF64}:  
0.0 - 1.0im  
0.0 + 1.0im

julia> A  
2×2 Matrix{Float64}:  
-0.0 -1.0  
1.0 -0.0

julia> B  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 1.0

eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> values

Same aseigvals, but saves space by overwriting the inputA, instead of creating a copy.irangeis a range  
of eigenvalue indices to search for - for instance, the 2nd to 8th eigenvalues.  
eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> values

Same aseigvals, but saves space by overwriting the inputA, instead of creating a copy.vlis the lower  
bound of the interval to search for eigenvalues, andvuis the upper bound.

```
LinearAlgebra.eigmax– Function.

```

eigmax(A; permute:: Bool = true , scale:: Bool = true )

Return the largest eigenvalue ofA. The optionpermute=truepermutes the matrix to become closer to  
upper triangular, andscale=truescales the matrix by its diagonal elements to make rows and columns  
more equal in norm. Note that if the eigenvalues ofAare complex, this method will fail, since complex  
numbers cannot be sorted.  
Examples

julia> A = [0 im; -im 0]  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+1im  
0-1im 0+0im

julia> eigmax(A)  
1.0

julia> A = [0 im; -1 0]  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+1im

```

#### CHAPTER 75. LINEAR ALGEBRA 1073

```

-1+0im 0+0im

julia> eigmax(A)  
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:  
`A` cannot have complex eigenvalues.  
Stacktrace:  
[...]

```
LinearAlgebra.eigmin– Function.

```

eigmin(A; permute:: Bool = true , scale:: Bool = true )

Return the smallest eigenvalue ofA. The optionpermute=truepermutes the matrix to become closer to  
upper triangular, andscale=truescales the matrix by its diagonal elements to make rows and columns  
more equal in norm. Note that if the eigenvalues ofAare complex, this method will fail, since complex  
numbers cannot be sorted.  
Examples

julia> A = [0 im; -im 0]  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+1im  
0-1im 0+0im

julia> eigmin(A)  
-1.0

julia> A = [0 im; -1 0]  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+1im  
-1+0im 0+0im

julia> eigmin(A)  
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:  
`A` cannot have complex eigenvalues.  
Stacktrace:  
[...]

```
LinearAlgebra.eigvecs– Function.

```

eigvecs(A:: SymTridiagonal [, eigvals])-> Matrix

Return a matrixMwhose columns are the eigenvectors ofA. (Thekth eigenvector can be obtained from  
the sliceM[:, k].)  
Iftheoptionalvectorofeigenvalueseigvalsisspecified,eigvecsreturnsthespecificcorrespondingeigen-  
vectors.  
Examples

julia> A = SymTridiagonal ([1.; 2.; 1.], [ 2.; 3.])  
3×3 SymTridiagonal{Float64, Vector{Float64}}:  
1.0 2.0 ⋅  
2.0 2.0 3.0  
⋅ 3.0 1.0

julia> eigvals(A)

```

#### CHAPTER 75. LINEAR ALGEBRA 1074

```

3-element Vector{Float64}:  
-2.1400549446402604  
1.0000000000000002  
5.140054944640259

julia> eigvecs(A)  
3×3 Matrix{Float64}:  
0.418304 -0.83205 0.364299  
-0.656749 -7.39009e-16 0.754109  
0.627457 0.5547 0.546448

julia> eigvecs(A, [1.])  
3×1 Matrix{Float64}:  
0.8320502943378438  
4.263514128092366e-17  
-0.5547001962252291

eigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -> Matrix

Return a matrixMwhose columns are the eigenvectors ofA. (Thekth eigenvector can be obtained from  
the sliceM[:, k].) Thepermute,scale, andsortbykeywords are the same as foreigen.  
Examples

julia> eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

eigvecs(A, B) -> Matrix

Return a matrixMwhose columns are the generalized eigenvectors ofAandB. (Thekth eigenvector can  
be obtained from the sliceM[:, k].)  
Examples

julia> A = [1 0; 0 -1]  
2×2 Matrix{Int64}:  
1 0  
0 -1

julia> B = [0 1; 1 0]  
2×2 Matrix{Int64}:  
0 1  
1 0

julia> eigvecs(A, B)  
2×2 Matrix{ComplexF64}:  
0.0+1.0im 0.0-1.0im  
-1.0+0.0im -1.0-0.0im

```
LinearAlgebra.eigen– Function.

```

eigen(A; permute:: Bool = true , scale:: Bool = true , sortby)-> Eigen

```

#### CHAPTER 75. LINEAR ALGEBRA 1075

```

Computes the eigenvalue decomposition ofA, returning anEigenfactorization objectFwhich contains  
the eigenvalues inF.valuesand the eigenvectors in the columns of the matrixF.vectors. (Thekth  
eigenvector can be obtained from the sliceF.vectors[:, k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.  
The following functions are available forEigenobjects:inv,det, andisposdef.  
For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigen-  
vector calculation. The optionpermute=truepermutes the matrix to become closer to upper triangular,  
andscale=truescales the matrix by its diagonal elements to make rows and columns more equal in norm.  
The default istruefor both options.  
By default, the eigenvalues and vectors are sorted lexicographically by(real(λ),imag(λ)). A different  
comparison functionby(λ)can be passed tosortby, or you can passsortby=nothingto leave the eigen-  
valuesinanarbitraryorder. Somespecialmatrixtypes(e.g.DiagonalorSymTridiagonal)mayimplement  
their own sorting convention and not accept asortbykeyword.  
Examples

julia> F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])  
Eigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}  
values:  
3-element Vector{Float64}:  
1.0  
3.0  
18.0  
vectors:  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

julia> F.values  
3-element Vector{Float64}:  
1.0  
3.0  
18.0

julia> F.vectors  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

julia> vals, vecs= F; # destructuring via iteration

julia> vals== F.values&& vecs== F.vectors  
true

eigen(A, B) -> GeneralizedEigen

Computes the generalized eigenvalue decomposition ofAandB, returning aGeneralizedEigenfactoriza-  
tion objectFwhich contains the generalized eigenvalues inF.valuesand the generalized eigenvectors  
in the columns of the matrixF.vectors. (Thekth generalized eigenvector can be obtained from the slice  
F.vectors[:, k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.

```

#### CHAPTER 75. LINEAR ALGEBRA 1076

```

Any keyword arguments passed toeigenare passed through to the lower-leveleigen!function.  
Examples

julia> A = [1 0; 0 -1]  
2×2 Matrix{Int64}:  
1 0  
0 -1

julia> B = [0 1; 1 0]  
2×2 Matrix{Int64}:  
0 1  
1 0

julia> F = eigen(A, B);

julia> F.values  
2-element Vector{ComplexF64}:  
0.0 - 1.0im  
0.0 + 1.0im

julia> F.vectors  
2×2 Matrix{ComplexF64}:  
0.0+1.0im 0.0-1.0im  
-1.0+0.0im -1.0-0.0im

julia> vals, vecs= F; # destructuring via iteration

julia> vals== F.values&& vecs== F.vectors  
true

eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -> Eigen

Computes the eigenvalue decomposition ofA, returning anEigenfactorization objectFwhich contains  
the eigenvalues inF.valuesand the eigenvectors in the columns of the matrixF.vectors. (Thekth  
eigenvector can be obtained from the sliceF.vectors[:, k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.  
The following functions are available forEigenobjects:inv,det, andisposdef.  
TheUnitRangeirangespecifies indices of the sorted eigenvalues to search for.

Note  
Ifirangeis not1:n, wherenis the dimension ofA, then the returned factorization will be a  
truncated factorization.

eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -> Eigen

Computes the eigenvalue decomposition ofA, returning anEigenfactorization objectFwhich contains  
the eigenvalues inF.valuesand the eigenvectors in the columns of the matrixF.vectors. (Thekth  
eigenvector can be obtained from the sliceF.vectors[:, k].)  
Iterating the decomposition produces the componentsF.valuesandF.vectors.  
The following functions are available forEigenobjects:inv,det, andisposdef.  
vlis the lower bound of the window of eigenvalues to search for, andvuis the upper bound.

```

#### CHAPTER 75. LINEAR ALGEBRA 1077

```

Note  
If [vl,vu] does not contain all eigenvalues ofA, then the returned factorization will be a trun-  
cated factorization.

```
LinearAlgebra.eigen!– Function.

```

eigen!(A, [B]; permute, scale, sortby)

Same aseigen, but saves space by overwriting the inputA(andB), instead of creating a copy.

```
LinearAlgebra.Hessenberg– Type.

```

Hessenberg<: Factorization

AHessenbergobject represents the Hessenberg factorizationQHQ'of a square matrix, or a shiftQ(H+μI)Q'  
thereof, which is produced by thehessenbergfunction.

```
LinearAlgebra.hessenberg– Function.

```

hessenberg(A)-> Hessenberg

ComputetheHessenbergdecompositionofAandreturnaHessenbergobject. IfFisthefactorizationobject,  
the unitary matrix can be accessed withF.Q(of typeLinearAlgebra.HessenbergQ) and the Hessenberg  
matrix withF.H(of typeUpperHessenberg), either of which may be converted to a regular matrix with  
Matrix(F.H)orMatrix(F.Q).  
IfAisHermitianor real-Symmetric, then the Hessenberg decomposition produces a real-symmetric tridi-  
agonal matrix andF.His of typeSymTridiagonal.  
Note that the shifted factorizationA+μI = Q (H+μI) Q'can be constructed efficiently byF + μ_Iusing  
theUniformScalingobjectI, which creates a newHessenbergobject with shared storage and a modified  
shift. The shift of a givenFis obtained byF.μ. This is useful because multiple shifted solves(F + μ_I)  
b(for differentμand/orb) can be performed efficiently onceFis created.  
Iterating the decomposition produces the factorsF.Q, F.H, F.μ.  
Examples

julia> A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]  
3×3 Matrix{Float64}:  
4.0 9.0 7.0  
4.0 4.0 1.0  
4.0 3.0 2.0

julia> F = hessenberg(A)  
Hessenberg{Float64, UpperHessenberg{Float64, Matrix{Float64}}, Matrix{Float64}, Vector{Float64},  
↪→ Bool}  
Q factor:  
3×3 LinearAlgebra.HessenbergQ{Float64, Matrix{Float64}, Vector{Float64}, false}:  
1.0 0.0 0.0  
0.0 -0.707107 -0.707107  
0.0 -0.707107 0.707107  
H factor:  
3×3 UpperHessenberg{Float64, Matrix{Float64}}:  
4.0 -11.3137 -1.41421  
-5.65685 5.0 2.0  
⋅ -1.0444e-15 1.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1078

```

julia> F.Q * F.H * F.Q'  
3×3 Matrix{Float64}:  
4.0 9.0 7.0  
4.0 4.0 1.0  
4.0 3.0 2.0

julia> q, h= F; # destructuring via iteration

julia> q == F.Q && h == F.H  
true

```
LinearAlgebra.hessenberg!– Function.

```

hessenberg!(A)-> Hessenberg

hessenberg!is the same ashessenberg, but saves space by overwriting the inputA, instead of creating  
a copy.

```
LinearAlgebra.Schur– Type.

```

Schur<: Factorization

Matrix factorization type of the Schur factorization of a matrixA. This is the return type ofschur(_), the  
corresponding matrix factorization function.  
IfF::Schuristhefactorizationobject,the(quasi)triangularSchurfactorcanbeobtainedviaeitherF.Schur  
orF.Tandtheorthogonal/unitarySchurvectorsviaF.vectorsorF.ZsuchthatA = F.vectors * F.Schur

-   F.vectors'. The eigenvalues ofAcan be obtained withF.values.  
    Iterating the decomposition produces the componentsF.T,F.Z, andF.values.  
    Examples

julia> A = [5. 7.; -2. -4.]  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> F = schur(A)  
Schur{Float64, Matrix{Float64}}  
T factor:  
2×2 Matrix{Float64}:  
3.0 9.0  
0.0 -2.0  
Z factor:  
2×2 Matrix{Float64}:  
0.961524 0.274721  
-0.274721 0.961524  
eigenvalues:  
2-element Vector{Float64}:  
3.0  
-2.0

julia> F.vectors* F.Schur* F.vectors'  
2×2 Matrix{Float64}:  
5.0 7.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1079

```

-2.0 -4.0

julia> t, z, vals= F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals== F.values  
true

```
LinearAlgebra.GeneralizedSchur– Type.

```

GeneralizedSchur<: Factorization

Matrix factorization type of the generalized Schur factorization of two matricesAandB. This is the return  
type ofschur(_, _), the corresponding matrix factorization function.  
IfF::GeneralizedSchuristhefactorizationobject, the(quasi)triangularSchurfactorscanbeobtainedvia  
F.SandF.T, the left unitary/orthogonal Schur vectors viaF.leftorF.Q, and the right unitary/orthogonal  
SchurvectorscanbeobtainedwithF.rightorF.ZsuchthatA=F.left_F.S_F.right'andB=F.left_F.T_F.right'.  
The generalized eigenvalues ofAandBcan be obtained withF.α./F.β.  
Iterating the decomposition produces the componentsF.S,F.T,F.Q,F.Z,F.α, andF.β.

```
LinearAlgebra.schur– Function.

```

schur(A:: StridedMatrix ) -> F::Schur

Computes the Schur factorization of the matrixA. The (quasi) triangular Schur factor can be obtained from  
theSchurobjectFwith eitherF.SchurorF.Tand the orthogonal/unitary Schur vectors can be obtained  
withF.vectorsorF.Zsuch thatA = F.vectors * F.Schur * F.vectors'. The eigenvalues ofAcan be  
obtained withF.values.  
For realA, the Schur factorization is"quasitriangular", which means that it is upper-triangular except with  
2×2 diagonal blocks for any conjugate pair of complex eigenvalues; this allows the factorization to be  
purely real even when there are complex eigenvalues. To obtain the (complex) purely upper-triangular  
Schur factorization from a real quasitriangular factorization, you can useSchur{Complex}(schur(A)).  
Iterating the decomposition produces the componentsF.T,F.Z, andF.values.  
Examples

julia> A = [5. 7.; -2. -4.]  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> F = schur(A)  
Schur{Float64, Matrix{Float64}}  
T factor:  
2×2 Matrix{Float64}:  
3.0 9.0  
0.0 -2.0  
Z factor:  
2×2 Matrix{Float64}:  
0.961524 0.274721  
-0.274721 0.961524  
eigenvalues:  
2-element Vector{Float64}:  
3.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1080

```

-2.0

julia> F.vectors* F.Schur* F.vectors'  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> t, z, vals= F; # destructuring via iteration

julia> t == F.T && z == F.Z && vals== F.values  
true

schur(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur

Computes the Generalized Schur (or QZ) factorization of the matricesAandB. The (quasi) triangular Schur  
factors can be obtained from theSchurobjectFwithF.SandF.T, the left unitary/orthogonal Schur vec-  
tors can be obtained withF.leftorF.Qand the right unitary/orthogonal Schur vectors can be obtained  
withF.rightorF.Zsuch thatA=F.left_F.S_F.right'andB=F.left_F.T_F.right'. The generalized  
eigenvalues ofAandBcan be obtained withF.α./F.β.  
Iterating the decomposition produces the componentsF.S,F.T,F.Q,F.Z,F.α, andF.β.

```
LinearAlgebra.schur!– Function.

```

schur!(A:: StridedMatrix ) -> F::Schur

Same asschurbut uses the input argumentAas workspace.  
Examples

julia> A = [5. 7.; -2. -4.]  
2×2 Matrix{Float64}:  
5.0 7.0  
-2.0 -4.0

julia> F = schur!(A)  
Schur{Float64, Matrix{Float64}}  
T factor:  
2×2 Matrix{Float64}:  
3.0 9.0  
0.0 -2.0  
Z factor:  
2×2 Matrix{Float64}:  
0.961524 0.274721  
-0.274721 0.961524  
eigenvalues:  
2-element Vector{Float64}:  
3.0  
-2.0

julia> A  
2×2 Matrix{Float64}:  
3.0 9.0  
0.0 -2.0

schur!(A::StridedMatrix, B::StridedMatrix) -> F::GeneralizedSchur

```

#### CHAPTER 75. LINEAR ALGEBRA 1081

```

Same asschurbut uses the input matricesAandBas workspace.

```
LinearAlgebra.ordschur– Function.

```

ordschur(F::Schur, select:: Union { Vector { Bool }, BitVector }) -> F::Schur

Reorders the Schur factorizationFof a matrixA = Z_T_Z'according to the logical arrayselectreturning  
the reordered factorizationFobject. The selected eigenvalues appear in the leading diagonal ofF.Schur  
andthecorrespondingleadingcolumnsofF.vectorsformanorthogonal/unitarybasisofthecorresponding  
right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both  
included or both excluded viaselect.  
ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur

Reorders the Generalized Schur factorizationFof a matrix pair(A, B) = (Q_S_Z', Q_T_Z')according  
to the logical arrayselectand returns a GeneralizedSchur objectF. The selected eigenvalues appear in  
the leading diagonal of bothF.SandF.T, and the left and right orthogonal/unitary Schur vectors are also  
reordered such that(A, B) = F.Q_(F.S, F.T)_F.Z'still holds and the generalized eigenvalues ofAand  
Bcan still be obtained withF.α./F.β.

```
LinearAlgebra.ordschur!– Function.

```

ordschur!(F::Schur, select:: Union { Vector { Bool }, BitVector }) -> F::Schur

Same asordschurbut overwrites the factorizationF.  
ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -> F::GeneralizedSchur

Same asordschurbut overwrites the factorizationF.

```
LinearAlgebra.SVD– Type.

```

SVD <: Factorization

Matrix factorization type of the singular value decomposition (SVD) of a matrixA. This is the return type of  
svd(_), the corresponding matrix factorization function.  
IfF::SVDis the factorization object,U,S,VandVtcan be obtained viaF.U,F.S,F.VandF.Vt, such that  
A = U * Diagonal(S) * Vt. The singular values inSare sorted in descending order.  
Iterating the decomposition produces the componentsU,S, andV.  
Examples

julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]  
4×5 Matrix{Float64}:  
1.0 0.0 0.0 0.0 2.0  
0.0 0.0 3.0 0.0 0.0  
0.0 0.0 0.0 0.0 0.0  
0.0 2.0 0.0 0.0 0.0

julia> F = svd(A)  
SVD{Float64, Float64, Matrix{Float64}}  
U factor:  
4×4 Matrix{Float64}:  
0.0 1.0 0.0 0.0  
1.0 0.0 0.0 0.0  
0.0 0.0 0.0 -1.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1082

```

0.0 0.0 1.0 0.0  
singular values:  
4-element Vector{Float64}:  
3.0  
2.23606797749979  
2.0  
0.0  
Vt factor:  
4×5 Matrix{Float64}:  
-0.0 0.0 1.0 -0.0 0.0  
0.447214 0.0 0.0 0.0 0.894427  
-0.0 1.0 0.0 -0.0 0.0  
0.0 0.0 0.0 1.0 0.0

julia> F.U * Diagonal (F.S) * F.Vt  
4×5 Matrix{Float64}:  
1.0 0.0 0.0 0.0 2.0  
0.0 0.0 3.0 0.0 0.0  
0.0 0.0 0.0 0.0 0.0  
0.0 2.0 0.0 0.0 0.0

julia> u, s, v= F; # destructuring via iteration

julia> u == F.U && s == F.S && v == F.V  
true

```
LinearAlgebra.GeneralizedSVD– Type.

```

GeneralizedSVD<: Factorization

Matrix factorization type of the generalized singular value decomposition (SVD) of two matricesAandB,  
such thatA = F.U_F.D1_F.R0_F.Q'andB = F.V_F.D2_F.R0_F.Q'. This is the return type ofsvd(_, _),  
the corresponding matrix factorization function.  
For an M-by-N matrixAand P-by-N matrixB,

```
- Uis a M-by-M orthogonal matrix,
- Vis a P-by-P orthogonal matrix,
- Qis a N-by-N orthogonal matrix,
- D1is a M-by-(K+L) diagonal matrix with 1s in the first K entries,
- D2is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,
- R0isa(K+L)-by-Nmatrixwhoserightmost(K+L)-by-(K+L)blockisnonsingularupperblocktriangular,

```

K+Lis the effective numerical rank of the matrix[A; B].  
Iterating the decomposition produces the componentsU,V,Q,D1,D2, andR0.  
The entries ofF.D1andF.D2are related, as explained in the LAPACK documentation for thegeneralized  
SVD and thexGGSVD3routine which is called underneath (in LAPACK 3.6.0 and newer).  
Examples

julia> A = [1. 0.; 0. -1.]  
2×2 Matrix{Float64}:  
1.0 0.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1083

```

0.0 -1.0

julia> B = [0. 1.; 1. 0.]  
2×2 Matrix{Float64}:  
0.0 1.0  
1.0 0.0

julia> F = svd(A, B)  
GeneralizedSVD{Float64, Matrix{Float64}}  
U factor:  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 1.0  
V factor:  
2×2 Matrix{Float64}:  
-0.0 -1.0  
1.0 0.0  
Q factor:  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 1.0  
D1 factor:  
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:  
0.707107 ⋅  
⋅ 0.707107  
D2 factor:  
2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:  
0.707107 ⋅  
⋅ 0.707107  
R0 factor:  
2×2 Matrix{Float64}:  
1.41421 0.0  
0.0 -1.41421

julia> F.U_F.D1_F.R0*F.Q'  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 -1.0

julia> F.V_F.D2_F.R0*F.Q'  
2×2 Matrix{Float64}:  
0.0 1.0  
1.0 0.0

```
LinearAlgebra.svd– Function.

```

svd(A; full:: Bool = false , alg::Algorithm= default_svd_alg(A))-> SVD

Compute the singular value decomposition (SVD) ofAand return anSVDobject.  
U,S,VandVtcan be obtained from the factorizationFwithF.U,F.S,F.VandF.Vt, such thatA = U

-   Diagonal(S) * Vt. The algorithm producesVtand henceVtis more efficient to extract thanV. The  
    singular values inSare sorted in descending order.  
    Iterating the decomposition produces the componentsU,S, andV.

```

#### CHAPTER 75. LINEAR ALGEBRA 1084

```

Iffull = false(default), a"thin" SVD is returned. For aM×NmatrixA, in the full factorizationUisM  
\times MandVisN \times N, while in the thin factorizationUisM \times KandVisN \times K, where  
K = \min(M,N)is the number of singular values.  
Ifalg = DivideAndConquer()a divide-and-conquer algorithm is used to calculate the SVD. Another (typ-  
ically slower but more accurate) option isalg = QRIteration().

Julia 1.3  
Thealgkeyword argument requires Julia 1.3 or later.

Examples

julia> A = rand(4,3);

julia> F = svd(A);# Store the Factorization Object

julia> A ≈ F.U * Diagonal (F.S) * F.Vt  
true

julia> U, S, V= F; # destructuring via iteration

julia> A ≈ U* Diagonal (S) * V'  
true

julia> Uonly,= svd(A);# Store U only

julia> Uonly== U  
true

svd(A, B) -> GeneralizedSVD

Compute the generalized SVD ofAandB, returning aGeneralizedSVDfactorization objectFsuch that  
[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'

```
- Uis a M-by-M orthogonal matrix,
- Vis a P-by-P orthogonal matrix,
- Qis a N-by-N orthogonal matrix,
- D1is a M-by-(K+L) diagonal matrix with 1s in the first K entries,
- D2is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,
- R0isa(K+L)-by-Nmatrixwhoserightmost(K+L)-by-(K+L)blockisnonsingularupperblocktriangular,

```

K+Lis the effective numerical rank of the matrix[A; B].  
Iterating the decomposition produces the componentsU,V,Q,D1,D2, andR0.  
The generalized SVD is used in applications such as when one wants to compare how much belongs toA  
vs. how much belongs toB, as in human vs yeast genome, or signal vs noise, or between clusters vs within  
clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)  
It decomposes[A; B]into[UC; VS]H, where[UC; VS]is a natural orthogonal basis for the column space  
of[A; B], andH = RQ'is a natural non-orthogonal basis for the rowspace of[A;B], where the top rows  
are most closely attributed to theAmatrix, and the bottom to theBmatrix. The multi-cosine/sine matrices  
CandSprovide a multi-measure of how muchAvs how muchB, andUandVprovide directions in which  
these are measured.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1085

```

julia> A = randn(3,2); B =randn(4,2);

julia> F = svd(A, B);

julia> U,V,Q,C,S,R= F;

julia> H = R*Q';

julia> [A; B] ≈ [U*C; V _S]_H  
true

julia> [A; B] ≈ [F.U_F.D1; F.V_F.D2]_F.R0_F.Q'  
true

julia> Uonly,= svd(A,B);

julia> U == Uonly  
true

```
LinearAlgebra.svd!– Function.

```

svd!(A; full:: Bool = false , alg::Algorithm= default_svd_alg(A))-> SVD

svd!is the same assvd, but saves space by overwriting the inputA, instead of creating a copy. See  
documentation ofsvdfor details.  
svd!(A, B) -> GeneralizedSVD

svd!is the same assvd, but modifies the argumentsAandBin-place, instead of making copies. See  
documentation ofsvdfor details.

```
LinearAlgebra.svdvals– Function.

```

svdvals(A)

Return the singular values ofAin descending order.  
Examples

julia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]  
4×5 Matrix{Float64}:  
1.0 0.0 0.0 0.0 2.0  
0.0 0.0 3.0 0.0 0.0  
0.0 0.0 0.0 0.0 0.0  
0.0 2.0 0.0 0.0 0.0

julia> svdvals(A)  
4-element Vector{Float64}:  
3.0  
2.23606797749979  
2.0  
0.0

svdvals(A, B)

Return the generalized singular values from the generalized singular value decomposition ofAandB. See  
alsosvd.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1086

```

julia> A = [1. 0.; 0. -1.]  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 -1.0

julia> B = [0. 1.; 1. 0.]  
2×2 Matrix{Float64}:  
0.0 1.0  
1.0 0.0

julia> svdvals(A, B)  
2-element Vector{Float64}:  
1.0  
1.0

```
LinearAlgebra.svdvals!– Function.

```

svdvals!(A)

Return the singular values ofA, saving space by overwriting the input. See alsosvdvalsandsvd. “‘  
svdvals!(A, B)

ReturnthegeneralizedsingularvaluesfromthegeneralizedsingularvaluedecompositionofAandB,saving  
space by overwritingAandB. See alsosvdandsvdvals.

```
LinearAlgebra.Givens– Type.

```

LinearAlgebra.Givens(i1,i2,c,s)-> G

A Givens rotation linear operator. The fieldscandsrepresent the cosine and sine of the rotation angle,  
respectively. TheGivenstypesupportsleftmultiplicationG_Aandconjugatedtransposerightmultiplication  
A_G'. The type doesn't have asizeand can therefore be multiplied with matrices of arbitrary size as long  
asi2<=size(A,2)forG_Aori2<=size(A,1)forA_G'.  
See alsogivens.

```
LinearAlgebra.givens– Function.

```

givens(f::T, g ::T, i1:: Integer , i2 :: Integer ) where {T}-> (G::Givens, r::T)

Computes the Givens rotationGand scalarrsuch that for any vectorxwhere  
x[i1] = f  
x[i2] = g

the result of the multiplication  
y = G*x

has the property that  
y[i1] = r  
y[i2] = 0

See alsoLinearAlgebra.Givens.  
givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -> (G::Givens, r)

```

#### CHAPTER 75. LINEAR ALGEBRA 1087

```

Computes the Givens rotationGand scalarrsuch that the result of the multiplication  
B = G*A

has the property that  
B[i1,j] = r  
B[i2,j] = 0

See alsoLinearAlgebra.Givens.  
givens(x::AbstractVector, i1::Integer, i2::Integer) -> (G::Givens, r)

Computes the Givens rotationGand scalarrsuch that the result of the multiplication  
B = G*x

has the property that  
B[i1] = r  
B[i2] = 0

See alsoLinearAlgebra.Givens.

```
LinearAlgebra.triu– Function.

```

triu(M)

Upper triangle of a matrix.  
Examples

julia> a = fill(1.0, ( 4,4))  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

julia> triu(a)  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
0.0 1.0 1.0 1.0  
0.0 0.0 1.0 1.0  
0.0 0.0 0.0 1.0

triu(M, k::Integer)

Returns the upper triangle ofMstarting from thekth superdiagonal.  
Examples

julia> a = fill(1.0, ( 4,4))  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1088

```

julia> triu(a,3)  
4×4 Matrix{Float64}:  
0.0 0.0 0.0 1.0  
0.0 0.0 0.0 0.0  
0.0 0.0 0.0 0.0  
0.0 0.0 0.0 0.0

julia> triu(a,-3)  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

```
LinearAlgebra.triu!– Function.

```

triu!(M)

Upper triangle of a matrix, overwritingMin the process. See alsotriu.  
triu!(M, k::Integer)

Return the upper triangle ofMstarting from thekth superdiagonal, overwritingMin the process.  
Examples

julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]  
5×5 Matrix{Int64}:  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5

julia> triu!(M,1)  
5×5 Matrix{Int64}:  
0 2 3 4 5  
0 0 3 4 5  
0 0 0 4 5  
0 0 0 0 5  
0 0 0 0 0

```
LinearAlgebra.tril– Function.

```

tril(M)

Lower triangle of a matrix.  
Examples

julia> a = fill(1.0, ( 4,4))  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1089

```

julia> tril(a)  
4×4 Matrix{Float64}:  
1.0 0.0 0.0 0.0  
1.0 1.0 0.0 0.0  
1.0 1.0 1.0 0.0  
1.0 1.0 1.0 1.0

tril(M, k::Integer)

Returns the lower triangle ofMstarting from thekth superdiagonal.  
Examples

julia> a = fill(1.0, ( 4,4))  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

julia> tril(a,3)  
4×4 Matrix{Float64}:  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0  
1.0 1.0 1.0 1.0

julia> tril(a,-3)  
4×4 Matrix{Float64}:  
0.0 0.0 0.0 0.0  
0.0 0.0 0.0 0.0  
0.0 0.0 0.0 0.0  
1.0 0.0 0.0 0.0

```
LinearAlgebra.tril!– Function.

```

tril!(M)

Lower triangle of a matrix, overwritingMin the process. See alsotril.  
tril!(M, k::Integer)

Return the lower triangle ofMstarting from thekth superdiagonal, overwritingMin the process.  
Examples

julia> M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]  
5×5 Matrix{Int64}:  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5

julia> tril!(M,2)  
5×5 Matrix{Int64}:  
1 2 3 0 0

```

#### CHAPTER 75. LINEAR ALGEBRA 1090

```

1 2 3 4 0  
1 2 3 4 5  
1 2 3 4 5  
1 2 3 4 5

```
LinearAlgebra.diagind– Function.

```

diagind(M, k:: Integer =0)

AnAbstractRangegiving the indices of thekth diagonal of the matrixM.  
See also:diag,diagm,Diagonal.  
Examples

julia> A = [1 2 3; 4 5 6; 7 8 9]  
3×3 Matrix{Int64}:  
1 2 3  
4 5 6  
7 8 9

julia> diagind(A,-1)  
2:4:6

```
LinearAlgebra.diag– Function.

```

diag(M, k:: Integer =0)

Thekth diagonal of a matrix, as a vector.  
See alsodiagm,diagind,Diagonal,isdiag.  
Examples

julia> A = [1 2 3; 4 5 6; 7 8 9]  
3×3 Matrix{Int64}:  
1 2 3  
4 5 6  
7 8 9

julia> diag(A,1)  
2-element Vector{Int64}:  
2  
6

```
LinearAlgebra.diagm– Function.

```

diagm(kv:: Pair {<: Integer ,<: AbstractVector }...)  
diagm(m:: Integer , n :: Integer , kv :: Pair {<: Integer ,<: AbstractVector }...)

Construct a matrix fromPairs of diagonals and vectors. Vectorkv.secondwill be placed on thekv.first  
diagonal. Bydefaultthematrixissquareanditssizeisinferredfromkv, butanon-squaresizem×n(padded  
with zeros as needed) can be specified by passingm,nas the first arguments.  
diagmconstructs a full matrix; if you want storage-efficient versions with fast arithmetic, seeDiagonal,  
BidiagonalTridiagonalandSymTridiagonal.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1091

```

julia> diagm(1 => [1,2,3])  
4×4 Matrix{Int64}:  
0 1 0 0  
0 0 2 0  
0 0 0 3  
0 0 0 0

julia> diagm(1 => [1,2,3], -1 => [4,5])  
4×4 Matrix{Int64}:  
0 1 0 0  
4 0 2 0  
0 5 0 3  
0 0 0 0

diagm(v::AbstractVector)  
diagm(m::Integer, n::Integer, v::AbstractVector)

Construct a matrix with elements of the vector as diagonal elements. By default, the matrix is square  
and its size is given bylength(v), but a non-square sizem×ncan be specified by passingm,nas the first  
arguments.  
Examples

julia> diagm([1,2,3])  
3×3 Matrix{Int64}:  
1 0 0  
0 2 0  
0 0 3

```
LinearAlgebra.rank– Function.

```

rank(A:: AbstractMatrix ; atol:: Real =0, rtol:: Real =atol>0? 0 : n*ε)  
rank(A:: AbstractMatrix , rtol:: Real )

Compute the rank of a matrix by counting how many singular values ofAhave magnitude greater than  
max(atol, rtol_σ₁)whereσ₁isA's largest singular value.atolandrtolare the absolute and relative  
tolerances, respectively. The default relative tolerance isn_ε, wherenis the size of the smallest dimension  
ofA, andεis theepsof the element type ofA.

Julia 1.1  
Theatolandrtolkeyword arguments requires at least Julia 1.1. In Julia 1.0rtolis available  
as a positional argument, but this will be deprecated in Julia 2.0.

Examples

julia> rank( Matrix (I, 3, 3))  
3

julia> rank(diagm(0 => [1, 0, 2]))  
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.1)  
2

julia> rank(diagm(0 => [1, 0.001, 2]), rtol=0.00001)

```

#### CHAPTER 75. LINEAR ALGEBRA 1092

```

3

julia> rank(diagm(0 => [1, 0.001, 2]), atol=1.5)  
1

```
LinearAlgebra.norm– Function.

```

norm(A, p:: Real =2)

For any iterable containerA(including arrays of any dimension) of numbers (or any element type for which  
normis defined), compute thep-norm (defaulting top=2) as ifAwere a vector of the corresponding length.  
Thep-norm is defined as

```
‖A‖p=

```

(n  
∑

i=1

```
|ai|p

)1/p

```

withaithe entries ofA,|ai|thenormofai, andnthe length ofA. Since thep-norm is computed using  
thenorms of the entries ofA, thep-norm of a vector of vectors is not compatible with the interpretation of  
it as a block vector in general ifp != 2.  
pcan assume any numeric value (even though not all values produce a mathematically valid vector norm).  
In particular,norm(A, Inf)returns the largest value inabs.(A), whereasnorm(A, -Inf)returns the  
smallest. IfAis a matrix andp=2, then this is equivalent to the Frobenius norm.  
The second argumentpis not necessarily a part of the interface fornorm, i.e. a custom type may only  
implementnorm(A)without second argument.  
Useopnormto compute the operator norm of a matrix.  
Examples

julia> v = [3, -2, 6]  
3-element Vector{Int64}:  
3  
-2  
6

julia> norm(v)  
7.0

julia> norm(v,1)  
11.0

julia> norm(v,Inf)  
6.0

julia> norm([1 2 3; 4 5 6; 7 8 9])  
16.881943016134134

julia> norm([1 2 3 4 5 6 7 8 9])  
16.881943016134134

julia> norm(1:9)  
16.881943016134134

```

#### CHAPTER 75. LINEAR ALGEBRA 1093

```

julia> norm(hcat(v,v),1) == norm(vcat(v,v),1) != norm([v,v],1)  
true

julia> norm(hcat(v,v),2) == norm(vcat(v,v),2) == norm([v,v],2)  
true

julia> norm(hcat(v,v),Inf) == norm(vcat(v,v),Inf) != norm([v,v],Inf)  
true

norm(x::Number, p::Real=2)

For numbers, return(|x|p)1/p.  
Examples

julia> norm(2, 1)  
2.0

julia> norm(-2, 1)  
2.0

julia> norm(2, 2)  
2.0

julia> norm(-2, 2)  
2.0

julia> norm(2, Inf)  
2.0

julia> norm(-2, Inf)  
2.0

```
LinearAlgebra.opnorm– Function.

```

opnorm(A:: AbstractMatrix , p :: Real =2)

Compute the operator norm (or matrix norm) induced by the vectorp-norm, where valid values ofpare  
1 , 2 , orInf. (Note that for sparse matrices,p=2is currently not implemented.) Usenormto compute the  
Frobenius norm.  
Whenp=1, the operator norm is the maximum absolute column sum ofA:

‖A‖ 1 =max  
1 jn

```
∑m

```

i=1

```
|aij|

```

withaijthe entries ofA, andmandnits dimensions.  
Whenp=2, the operator norm is the spectral norm, equal to the largest singular value ofA.  
Whenp=Inf, the operator norm is the maximum absolute row sum ofA:

‖A‖∞=max  
1 im

```
∑n

```

j=1

```
|aij|


#### CHAPTER 75. LINEAR ALGEBRA 1094

```

Examples

julia> A = [1 -2 -3; 2 3 -1]  
2×3 Matrix{Int64}:  
1 -2 -3  
2 3 -1

julia> opnorm(A,Inf)  
6.0

julia> opnorm(A,1)  
5.0

opnorm(x::Number, p::Real=2)

For numbers, return(|x|p)1/p. This is equivalent tonorm.  
opnorm(A::Adjoint{<:Any,<:AbstracVector}, q::Real=2)  
opnorm(A::Transpose{<:Any,<:AbstracVector}, q::Real=2)

For Adjoint/Transpose-wrapped vectors, return the operatorq-norm ofA, which is equivalent to thep-norm  
with valuep = q/(q-1). They coincide atp = q = 2. Usenormto compute thepnorm ofAas a vector.  
The difference in norm between a vector space and its dual arises to preserve the relationship between  
duality and the dot product, and the result is consistent with the operatorp-norm of a1 × nmatrix.  
Examples

julia> v = [1; im];

julia> vc = v';

julia> opnorm(vc,1)  
1.0

julia> norm(vc,1)  
2.0

julia> norm(v,1)  
2.0

julia> opnorm(vc,2)  
1.4142135623730951

julia> norm(vc,2)  
1.4142135623730951

julia> norm(v,2)  
1.4142135623730951

julia> opnorm(vc,Inf)  
2.0

julia> norm(vc,Inf)  
1.0

julia> norm(v,Inf)  
1.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1095

LinearAlgebra.normalize!– Function.

```

normalize!(a:: AbstractArray , p :: Real =2)

Normalize the arrayain-place so that itsp-norm equals unity, i.e.norm(a, p) == 1. See alsonormalize  
andnorm.

```
LinearAlgebra.normalize– Function.

```

normalize(a:: AbstractArray , p :: Real =2)

Normalize the arrayaso that itsp-norm equals unity, i.e.norm(a, p) == 1. See alsonormalize!and  
norm.  
Examples

julia> a = [1,2,4];

julia> b = normalize(a)  
3-element Vector{Float64}:  
0.2182178902359924  
0.4364357804719848  
0.8728715609439696

julia> norm(b)  
1.0

julia> c = normalize(a,1)  
3-element Vector{Float64}:  
0.14285714285714285  
0.2857142857142857  
0.5714285714285714

julia> norm(c,1)  
1.0

julia> a = [1 2 4 ; 1 2 4]  
2×3 Matrix{Int64}:  
1 2 4  
1 2 4

julia> norm(a)  
6.48074069840786

julia> normalize(a)  
2×3 Matrix{Float64}:  
0.154303 0.308607 0.617213  
0.154303 0.308607 0.617213

```
LinearAlgebra.cond– Function.

```

cond(M, p:: Real =2)

ConditionnumberofthematrixM,computedusingtheoperatorp-norm. Validvaluesforpare 1 , 2 (default),  
orInf.

```
LinearAlgebra.condskeel– Function.


#### CHAPTER 75. LINEAR ALGEBRA 1096

```

condskeel(M, [x, p:: Real =Inf])

```
κS(M, p) =

```

∥  
∥|M|  
∣  
∣M−^1  
∣  
∣  
∥  
∥  
p

```
κS(M, x, p) =

```

∥  
∥|M|  
∣  
∣M−^1  
∣  
∣|x|  
∥  
∥  
p  
‖x‖p

Skeel condition numberκSof the matrixM, optionally with respect to the vectorx, as computed using the  
operatorp-norm. |M|denotes the matrix of (entry wise) absolute values ofM;|M|ij=|Mij|. Valid  
values forpare 1 , 2 andInf(default).  
This quantity is also known in the literature as the Bauer condition number, relative condition number, or  
componentwise relative condition number.

```
LinearAlgebra.tr– Function.

```

tr(M)

Matrix trace. Sums the diagonal elements ofM.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> tr(A)  
5

```
LinearAlgebra.det– Function.

```

det(M)

Matrix determinant.  
See also:logdetandlogabsdet.  
Examples

julia> M = [1 0; 2 2]  
2×2 Matrix{Int64}:  
1 0  
2 2

julia> det(M)  
2.0

```
LinearAlgebra.logdet– Function.

```

logdet(M)

Log of matrix determinant. Equivalent tolog(det(M)), but may provide increased accuracy and/or speed.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1097

```

julia> M = [1 0; 2 2]  
2×2 Matrix{Int64}:  
1 0  
2 2

julia> logdet(M)  
0.6931471805599453

julia> logdet( Matrix (I, 3, 3))  
0.0

```
LinearAlgebra.logabsdet– Function.

```

logabsdet(M)

Logofabsolutevalueofmatrixdeterminant. Equivalentto(log(abs(det(M))), sign(det(M))),butmay  
provide increased accuracy and/or speed.  
Examples

julia> A = [-1. 0.; 0. 1.]  
2×2 Matrix{Float64}:  
-1.0 0.0  
0.0 1.0

julia> det(A)  
-1.0

julia> logabsdet(A)  
(0.0, -1.0)

julia> B = [2. 0.; 0. 1.]  
2×2 Matrix{Float64}:  
2.0 0.0  
0.0 1.0

julia> det(B)  
2.0

julia> logabsdet(B)  
(0.6931471805599453, 1.0)

```
Base.inv– Method.

```

inv(M)

Matrix inverse. Computes matrixNsuch thatM * N = I, whereIis the identity matrix. Computed by  
solving the left-divisionN = M \ I.  
Examples

julia> M = [2 5; 1 3]  
2×2 Matrix{Int64}:  
2 5  
1 3

julia> N = inv(M)

```

#### CHAPTER 75. LINEAR ALGEBRA 1098

```

2×2 Matrix{Float64}:  
3.0 -5.0  
-1.0 2.0

julia> M_N == N_M == Matrix (I, 2, 2)  
true

```
LinearAlgebra.pinv– Function.

```

pinv(M; atol:: Real =0, rtol:: Real =atol>0? 0 : n*ε)  
pinv(M, rtol:: Real ) = pinv(M; rtol=rtol)# to be deprecated in Julia 2.0

Computes the Moore-Penrose pseudoinverse.  
For matricesMwith floating point elements, it is convenient to compute the pseudoinverse by inverting  
only singular values greater thanmax(atol, rtol_σ₁)whereσ₁is the largest singular value ofM.  
The optimal choice of absolute (atol) and relative tolerance (rtol) varies both with the value ofMand the  
intended application of the pseudoinverse. The default relative tolerance isn_ε, wherenis the size of the  
smallest dimension ofM, andεis theepsof the element type ofM.  
Forinvertingdenseill-conditionedmatricesinaleast-squaressense,rtol = sqrt(eps(real(float(one(eltype(M))))))  
is recommended.  
For more information, see^4 ,^5 ,^6 ,^7.  
Examples

julia> M = [1.5 1.3; 1.2 1.9]  
2×2 Matrix{Float64}:  
1.5 1.3  
1.2 1.9

julia> N = pinv(M)  
2×2 Matrix{Float64}:  
1.47287 -1.00775  
-0.930233 1.16279

julia> M * N  
2×2 Matrix{Float64}:  
1.0 -2.22045e-16  
4.44089e-16 1.0

```
LinearAlgebra.nullspace– Function.

```

nullspace(M; atol:: Real =0, rtol:: Real =atol>0? 0 : n*ε)  
nullspace(M, rtol:: Real ) = nullspace(M; rtol=rtol)# to be deprecated in Julia 2.0

```
(^4) Issue 8859,"Fix least squares", https://github.com/JuliaLang/julia/pull/8859
(^5) Åke Björck,"Numerical Methods for Least Squares Problems", SIAM Press, Philadelphia, 1996,"Other Titles in Applied Mathematics",
Vol. 51.doi:10.1137/1.9781611971484
(^6) G. W. Stewart,"Rank Degeneracy", SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413.doi:10.1137/0905030
(^7) Konstantinos Konstantinides and Kung Yao,"Statistical analysis of effective singular values in matrix rank determination", IEEE
Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763.doi:10.1109/29.1585


#### CHAPTER 75. LINEAR ALGEBRA 1099

```

Computes a basis for the nullspace ofMby including the singular vectors ofMwhose singular values have  
magnitudes greater thanmax(atol, rtol_σ₁), whereσ₁isM's largest singular value.  
By default, the relative tolerancertolisn_ε, wherenis the size of the smallest dimension ofM, andεis  
theepsof the element type ofM.  
Examples

julia> M = [1 0 0; 0 1 0; 0 0 0]  
3×3 Matrix{Int64}:  
1 0 0  
0 1 0  
0 0 0

julia> nullspace(M)  
3×1 Matrix{Float64}:  
0.0  
0.0  
1.0

julia> nullspace(M, rtol=3)  
3×3 Matrix{Float64}:  
0.0 1.0 0.0  
1.0 0.0 0.0  
0.0 0.0 1.0

julia> nullspace(M, atol=0.95)  
3×1 Matrix{Float64}:  
0.0  
0.0  
1.0

```
Base.kron– Function.

```

kron(A, B)

Kronecker tensor product of two vectors or two matrices.  
For real vectorsvandw, the Kronecker product is related to the outer product bykron(v,w) == vec(w *  
transpose(v))orw * transpose(v) == reshape(kron(v,w), (length(w), length(v))). Note how  
the ordering ofvandwdiffers on the left and right of these expressions (due to column-major storage).  
For complex vectors, the outer productw * v'also differs by conjugation ofv.  
Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> B = [im 1; 1 -im]  
2×2 Matrix{Complex{Int64}}:  
0+1im 1+0im  
1+0im 0-1im

julia> kron(A, B)  
4×4 Matrix{Complex{Int64}}:

```

#### CHAPTER 75. LINEAR ALGEBRA 1100

```

0+1im 1+0im 0+2im 2+0im  
1+0im 0-1im 2+0im 0-2im  
0+3im 3+0im 0+4im 4+0im  
3+0im 0-3im 4+0im 0-4im

julia> v = [1, 2]; w= [3, 4, 5];

julia> w*transpose(v)  
3×2 Matrix{Int64}:  
3 6  
4 8  
5 10

julia> reshape(kron(v,w), (length(w), length(v)))  
3×2 Matrix{Int64}:  
3 6  
4 8  
5 10

```
Base.kron!– Function.

```

kron!(C, A, B)

kron!is the in-place version ofkron. Computeskron(A, B)and stores the result inCoverwriting the  
existing value ofC.

Tip  
Bounds checking can be disabled by@inbounds, but you need to take care of the shape ofC,A,  
Byourself.

Julia 1.6  
This function requires Julia 1.6 or later.

```
Base.exp– Method.

```

exp(A:: AbstractMatrix )

Compute the matrix exponential ofA, defined by

```
eA=

∑∞

```

n=0

An  
n!  
.

For symmetric or HermitianA, an eigendecomposition (eigen) is used, otherwise the scaling and squaring  
algorithm (see^8 ) is chosen.  
Examples

julia> A = Matrix (1.0I, 2, 2)  
2×2 Matrix{Float64}:  
1.0 0.0

```
(^8) Nicholas J. Higham,"The squaring and scaling method for the matrix exponential revisited", SIAM Journal on Matrix Analysis and
Applications, 26(4), 2005, 1179-1193.doi:10.1137/090768539


#### CHAPTER 75. LINEAR ALGEBRA 1101

```

0.0 1.0

julia> exp(A)  
2×2 Matrix{Float64}:  
2.71828 0.0  
0.0 2.71828

```
Base.cis– Method.

```

cis(A:: AbstractMatrix )

```
Computeexp(iA)for a square matrixA.

```

Julia 1.7  
Support for usingciswith matrices was added in Julia 1.7.

Examples

julia> cis([π 0; 0 π]) ≈-I  
true

```
Base.:^– Method.

```

^(A:: AbstractMatrix , p :: Number )

Matrix power, equivalent toexp(plog(A))  
Examples

julia> [1 2; 0 3]^3  
2×2 Matrix{Int64}:  
1 26  
0 27

```
Base.:^– Method.

```

^(b:: Number , A :: AbstractMatrix )

```
Matrix exponential, equivalent toexp(log(b)A).

```

Julia 1.1  
Support for raisingIrrationalnumbers (like ) to a matrix was added in Julia 1.1.

Examples

julia> 2^[1 2; 0 3]  
2×2 Matrix{Float64}:  
2.0 6.0  
0.0 8.0

julia> ^[1 2; 0 3]  
2×2 Matrix{Float64}:  
2.71828 17.3673  
0.0 20.0855

```

#### CHAPTER 75. LINEAR ALGEBRA 1102

Base.log– Method.

```

log(A:: StridedMatrix )

IfAhas no negative real eigenvalue, compute the principal matrix logarithm ofA, i.e. the unique matrixX  
such thateX=Aand−π < Im(λ)< πfor all the eigenvaluesλofX. IfAhas nonpositive eigenvalues,  
a nonprincipal matrix function is returned whenever possible.  
IfAissymmetricorHermitian, itseigendecomposition(eigen)isused, ifAistriangularanimprovedversion  
of the inverse scaling and squaring method is employed (see^9 and^10 ). IfAis real with no negative  
eigenvalues, then the real Schur form is computed. Otherwise, the complex Schur form is computed. Then  
the upper (quasi-)triangular algorithm in^10 is used on the upper (quasi-)triangular factor.  
Examples

julia> A = Matrix (2.7182818*I, 2, 2)  
2×2 Matrix{Float64}:  
2.71828 0.0  
0.0 2.71828

julia> log(A)  
2×2 Matrix{Float64}:  
1.0 0.0  
0.0 1.0

```
Base.sqrt– Method.

```

sqrt(A:: AbstractMatrix )

IfAhas no negative real eigenvalues, compute the principal matrix square root ofA, that is the unique  
matrixXwith eigenvalues having positive real part such thatX^2 =A. Otherwise, a nonprincipal square  
root is returned.  
IfAis real-symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the square root. For  
such matrices, eigenvalues λ that appear to be slightly negative due to roundoff errors are treated as if  
they were zero More precisely, matrices with all eigenvalues≥ -rtol*(max |λ|)are treated as semidefi-  
nite (yielding a Hermitian square root), with negative eigenvalues taken to be zero.rtolis a keyword  
argument tosqrt(in the Hermitian/real-symmetric case only) that defaults to machine precision scaled  
bysize(A,1).  
Otherwise, the square root is determined by means of the Björck-Hammarling method^11 , which computes  
the complex Schur form (schur) and then the complex square root of the triangular factor. If a real square  
root exists, then an extension of this method^12 that computes the real Schur form and then the real square  
root of the quasi-triangular factor is instead used.  
Examples

```
(^9) Awad H. Al-Mohy and Nicholas J. Higham,"Improved inverse scaling and squaring algorithms for the matrix logarithm", SIAM Journal
on Scientific Computing, 34(4), 2012, C153-C169.doi:10.1137/110852553
(^10) AwadH.Al-Mohy, NicholasJ.HighamandSamuelD.Relton,"ComputingtheFréchetderivativeofthematrixlogarithmandestimating
the condition number", SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410.doi:10.1137/120885991
(^11) Åke Björck and Sven Hammarling,"A Schur method for the square root of a matrix", Linear Algebra and its Applications, 52-53, 1983,
127-140.doi:10.1016/0024-3795(83)80010-X
(^12) Nicholas J. Higham,"Computing real square roots of a real matrix", Linear Algebra and its Applications, 88-89, 1987, 405-430.
doi:10.1016/0024-3795(87)90118-2


#### CHAPTER 75. LINEAR ALGEBRA 1103

```

julia> A = [4 0; 0 4]  
2×2 Matrix{Int64}:  
4 0  
0 4

julia> sqrt(A)  
2×2 Matrix{Float64}:  
2.0 0.0  
0.0 2.0

```
Base.cos– Method.

```

cos(A:: AbstractMatrix )

Compute the matrix cosine of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the cosine. Otherwise,  
the cosine is determined by callingexp.  
Examples

julia> cos(fill(1.0, ( 2,2)))  
2×2 Matrix{Float64}:  
0.291927 -0.708073  
-0.708073 0.291927

```
Base.sin– Method.

```

sin(A:: AbstractMatrix )

Compute the matrix sine of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the sine. Otherwise, the  
sine is determined by callingexp.  
Examples

julia> sin(fill(1.0, ( 2,2)))  
2×2 Matrix{Float64}:  
0.454649 0.454649  
0.454649 0.454649

```
Base.Math.sincos– Method.

```

sincos(A:: AbstractMatrix )

Compute the matrix sine and cosine of a square matrixA.  
Examples

julia> S, C= sincos(fill(1.0, ( 2,2)));

julia> S  
2×2 Matrix{Float64}:  
0.454649 0.454649  
0.454649 0.454649

```

#### CHAPTER 75. LINEAR ALGEBRA 1104

```

julia> C  
2×2 Matrix{Float64}:  
0.291927 -0.708073  
-0.708073 0.291927

```
Base.tan– Method.

```

tan(A:: AbstractMatrix )

Compute the matrix tangent of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the tangent. Otherwise,  
the tangent is determined by callingexp.  
Examples

julia> tan(fill(1.0, ( 2,2)))  
2×2 Matrix{Float64}:  
-1.09252 -1.09252  
-1.09252 -1.09252

```
Base.Math.sec– Method.

```

sec(A:: AbstractMatrix )

Compute the matrix secant of a square matrixA.

```
Base.Math.csc– Method.

```

csc(A:: AbstractMatrix )

Compute the matrix cosecant of a square matrixA.

```
Base.Math.cot– Method.

```

cot(A:: AbstractMatrix )

Compute the matrix cotangent of a square matrixA.

```
Base.cosh– Method.

```

cosh(A:: AbstractMatrix )

Compute the matrix hyperbolic cosine of a square matrixA.

```
Base.sinh– Method.

```

sinh(A:: AbstractMatrix )

Compute the matrix hyperbolic sine of a square matrixA.

```
Base.tanh– Method.

```

tanh(A:: AbstractMatrix )

Compute the matrix hyperbolic tangent of a square matrixA.

```
Base.Math.sech– Method.


#### CHAPTER 75. LINEAR ALGEBRA 1105

```

sech(A:: AbstractMatrix )

Compute the matrix hyperbolic secant of square matrixA.

```
Base.Math.csch– Method.

```

csch(A:: AbstractMatrix )

Compute the matrix hyperbolic cosecant of square matrixA.

```
Base.Math.coth– Method.

```

coth(A:: AbstractMatrix )

Compute the matrix hyperbolic cotangent of square matrixA.

```
Base.acos– Method.

```

acos(A:: AbstractMatrix )

Compute the inverse matrix cosine of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse cosine.  
Otherwise,theinversecosineisdeterminedbyusinglogandsqrt. Forthetheoryandlogarithmicformulas  
used to compute this function, see^13.  
Examples

julia> acos(cos([0.5 0.1; -0.2 0.3]))  
2×2 Matrix{ComplexF64}:  
0.5-8.32667e-17im 0.1+0.0im  
-0.2+2.63678e-16im 0.3-3.46945e-16im

```
Base.asin– Method.

```

asin(A:: AbstractMatrix )

Compute the inverse matrix sine of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse sine. Other-  
wise, the inverse sine is determined by usinglogandsqrt. For the theory and logarithmic formulas used  
to compute this function, see^14.  
Examples

julia> asin(sin([0.5 0.1; -0.2 0.3]))  
2×2 Matrix{ComplexF64}:  
0.5-4.16334e-17im 0.1-5.55112e-17im  
-0.2+9.71445e-17im 0.3-1.249e-16im

```
Base.atan– Method.

(^13) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577
(^14) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577


#### CHAPTER 75. LINEAR ALGEBRA 1106

```

atan(A:: AbstractMatrix )

Compute the inverse matrix tangent of a square matrixA.  
IfAis symmetric or Hermitian, its eigendecomposition (eigen) is used to compute the inverse tangent.  
Otherwise, the inverse tangent is determined by usinglog. For the theory and logarithmic formulas used  
to compute this function, see^15.  
Examples

julia> atan(tan([0.5 0.1; -0.2 0.3]))  
2×2 Matrix{ComplexF64}:  
0.5+1.38778e-17im 0.1-2.77556e-17im  
-0.2+6.93889e-17im 0.3-4.16334e-17im

```
Base.Math.asec– Method.

```

asec(A:: AbstractMatrix )

Compute the inverse matrix secant ofA.

```
Base.Math.acsc– Method.

```

acsc(A:: AbstractMatrix )

Compute the inverse matrix cosecant ofA.

```
Base.Math.acot– Method.

```

acot(A:: AbstractMatrix )

Compute the inverse matrix cotangent ofA.

```
Base.acosh– Method.

```

acosh(A:: AbstractMatrix )

ComputetheinversehyperbolicmatrixcosineofasquarematrixA.Forthetheoryandlogarithmicformulas  
used to compute this function, see^16.

```
Base.asinh– Method.

```

asinh(A:: AbstractMatrix )

Compute the inverse hyperbolic matrix sine of a square matrixA. For the theory and logarithmic formulas  
used to compute this function, see^17.

```
Base.atanh– Method.

(^15) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577
(^16) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577
(^17) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577


#### CHAPTER 75. LINEAR ALGEBRA 1107

```

atanh(A:: AbstractMatrix )

Compute the inverse hyperbolic matrix tangent of a square matrixA. For the theory and logarithmic for-  
mulas used to compute this function, see^18.

```
Base.Math.asech– Method.

```

asech(A:: AbstractMatrix )

Compute the inverse matrix hyperbolic secant ofA.

```
Base.Math.acsch– Method.

```

acsch(A:: AbstractMatrix )

Compute the inverse matrix hyperbolic cosecant ofA.

```
Base.Math.acoth– Method.

```

acoth(A:: AbstractMatrix )

Compute the inverse matrix hyperbolic cotangent ofA.

```
LinearAlgebra.lyap– Function.

```

lyap(A, C)

Computes the solutionXto the continuous Lyapunov equationAX + XA' + C = 0, where no eigenvalue  
ofAhas a zero real part and no two eigenvalues are negative complex conjugates of each other.  
Examples

julia> A = [3. 4.; 5. 6]  
2×2 Matrix{Float64}:  
3.0 4.0  
5.0 6.0

julia> B = [1. 1.; 1. 2.]  
2×2 Matrix{Float64}:  
1.0 1.0  
1.0 2.0

julia> X = lyap(A, B)  
2×2 Matrix{Float64}:  
0.5 -0.5  
-0.5 0.25

julia> A_X + X_A' + B  
2×2 Matrix{Float64}:  
0.0 6.66134e-16  
6.66134e-16 8.88178e-16

```
LinearAlgebra.sylvester– Function.

(^18) Mary Aprahamian and Nicholas J. Higham,"Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms",
MIMS EPrint: 2016.4.https://doi.org/10.1137/16M1057577


#### CHAPTER 75. LINEAR ALGEBRA 1108

```

sylvester(A, B, C)

Computes the solutionXto the Sylvester equationAX + XB + C = 0, whereA,BandChave compatible  
dimensions andAand-Bhave no eigenvalues with equal real part.  
Examples

julia> A = [3. 4.; 5. 6]  
2×2 Matrix{Float64}:  
3.0 4.0  
5.0 6.0

julia> B = [1. 1.; 1. 2.]  
2×2 Matrix{Float64}:  
1.0 1.0  
1.0 2.0

julia> C = [1. 2.; -2. 1]  
2×2 Matrix{Float64}:  
1.0 2.0  
-2.0 1.0

julia> X = sylvester(A, B, C)  
2×2 Matrix{Float64}:  
-4.46667 1.93333  
3.73333 -1.8

julia> A_X + X_B + C  
2×2 Matrix{Float64}:  
2.66454e-15 1.77636e-15  
-3.77476e-15 4.44089e-16

```
LinearAlgebra.issuccess– Function.

```

issuccess(F:: Factorization )

Test that a factorization of a matrix succeeded.

Julia 1.6  
issuccess(::CholeskyPivoted)requires Julia 1.6 or later.

julia> F = cholesky([1 0; 0 1]);

julia> LinearAlgebra.issuccess(F)  
true

julia> F = lu([1 0; 0 0]; check= false );

julia> LinearAlgebra.issuccess(F)  
false

```
LinearAlgebra.issymmetric– Function.

```

issymmetric(A)-> Bool

```

#### CHAPTER 75. LINEAR ALGEBRA 1109

```

Test whether a matrix is symmetric.  
Examples

julia> a = [1 2; 2 -1]  
2×2 Matrix{Int64}:  
1 2  
2 -1

julia> issymmetric(a)  
true

julia> b = [1 im; -im 1]  
2×2 Matrix{Complex{Int64}}:  
1+0im 0+1im  
0-1im 1+0im

julia> issymmetric(b)  
false

```
LinearAlgebra.isposdef– Function.

```

isposdef(A)-> Bool

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of  
A.  
See alsoisposdef!,cholesky.  
Examples

julia> A = [1 2; 2 50]  
2×2 Matrix{Int64}:  
1 2  
2 50

julia> isposdef(A)  
true

```
LinearAlgebra.isposdef!– Function.

```

isposdef!(A)-> Bool

Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of  
A, overwritingAin the process. See alsoisposdef.  
Examples

julia> A = [1. 2.; 2. 50.];

julia> isposdef!(A)  
true

julia> A  
2×2 Matrix{Float64}:  
1.0 2.0  
2.0 6.78233

```

#### CHAPTER 75. LINEAR ALGEBRA 1110

LinearAlgebra.istril– Function.

```

istril(A:: AbstractMatrix , k :: Integer = 0) -> Bool

Test whetherAis lower triangular starting from thekth superdiagonal.  
Examples

julia> a = [1 2; 2 -1]  
2×2 Matrix{Int64}:  
1 2  
2 -1

julia> istril(a)  
false

julia> istril(a,1)  
true

julia> b = [1 0; -im -1]  
2×2 Matrix{Complex{Int64}}:  
1+0im 0+0im  
0-1im -1+0im

julia> istril(b)  
true

julia> istril(b,-1)  
false

```
LinearAlgebra.istriu– Function.

```

istriu(A:: AbstractMatrix , k :: Integer = 0) -> Bool

Test whetherAis upper triangular starting from thekth superdiagonal.  
Examples

julia> a = [1 2; 2 -1]  
2×2 Matrix{Int64}:  
1 2  
2 -1

julia> istriu(a)  
false

julia> istriu(a,-1)  
true

julia> b = [1 im; 0 -1]  
2×2 Matrix{Complex{Int64}}:  
1+0im 0+1im  
0+0im -1+0im

julia> istriu(b)  
true

```

#### CHAPTER 75. LINEAR ALGEBRA 1111

```

julia> istriu(b,1)  
false

```
LinearAlgebra.isdiag– Function.

```

isdiag(A)-> Bool

Test whether a matrix is diagonal.  
Examples

julia> a = [1 2; 2 -1]  
2×2 Matrix{Int64}:  
1 2  
2 -1

julia> isdiag(a)  
false

julia> b = [im 0; 0 -im]  
2×2 Matrix{Complex{Int64}}:  
0+1im 0+0im  
0+0im 0-1im

julia> isdiag(b)  
true

```
LinearAlgebra.ishermitian– Function.

```

ishermitian(A)-> Bool

Test whether a matrix is Hermitian.  
Examples

julia> a = [1 2; 2 -1]  
2×2 Matrix{Int64}:  
1 2  
2 -1

julia> ishermitian(a)  
true

julia> b = [1 im; -im 1]  
2×2 Matrix{Complex{Int64}}:  
1+0im 0+1im  
0-1im 1+0im

julia> ishermitian(b)  
true

```
Base.transpose– Function.

```

transpose(A)

```

#### CHAPTER 75. LINEAR ALGEBRA 1112

```

Lazy transpose. Mutating the returned object should appropriately mutateA. Often, but not always, yields  
Transpose(A), whereTransposeis a lazy transpose wrapper. Note that this operation is recursive.  
This operation is intended for linear algebra usage - for general data manipulation seepermutedims, which  
is non-recursive.  
Examples

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> transpose(A)  
2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  
3+2im 8+7im  
9+2im 4+6im

```
LinearAlgebra.transpose!– Function.

```

transpose!(dest,src)

Transpose arraysrcand store the result in the preallocated arraydest, which should have a size corre-  
sponding to(size(src,2),size(src,1)). No in-place transposition is supported and unexpected results  
will happen ifsrcanddesthave overlapping memory regions.  
Examples

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> B = zeros( Complex { Int64 }, 2, 2)  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+0im  
0+0im 0+0im

julia> transpose!(B, A);

julia> B  
2×2 Matrix{Complex{Int64}}:  
3+2im 8+7im  
9+2im 4+6im

julia> A  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

```
LinearAlgebra.Transpose– Type.

```

Transpose

Lazywrappertypeforatransposeviewoftheunderlyinglinearalgebraobject,usuallyanAbstractVector/AbstractMatrix,  
but also someFactorization, for instance. Usually, theTransposeconstructor should not be called di-  
rectly, usetransposeinstead. To materialize the view usecopy.

```

#### CHAPTER 75. LINEAR ALGEBRA 1113

```

This type is intended for linear algebra usage - for general data manipulation seepermutedims.  
Examples

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> transpose(A)  
2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  
3+2im 8+7im  
9+2im 4+6im

```
Base.adjoint– Function.

```

A'  
adjoint(A)

Lazy adjoint (conjugate transposition). Note thatadjointis applied recursively to elements.  
For number types,adjointreturns the complex conjugate, and therefore it is equivalent to the identity  
function for real numbers.  
This operation is intended for linear algebra usage - for general data manipulation seepermutedims.  
Examples

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> adjoint(A)  
2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  
3-2im 8-7im  
9-2im 4-6im

julia> x = [3, 4im]  
2-element Vector{Complex{Int64}}:  
3 + 0im  
0 + 4im

julia> x'x  
25 + 0im

```
LinearAlgebra.adjoint!– Function.

```

adjoint!(dest,src)

Conjugatetransposearraysrcandstoretheresultinthepreallocatedarraydest, whichshouldhaveasize  
corresponding to(size(src,2),size(src,1)). No in-place transposition is supported and unexpected  
results will happen ifsrcanddesthave overlapping memory regions.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1114

```

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> B = zeros( Complex { Int64 }, 2, 2)  
2×2 Matrix{Complex{Int64}}:  
0+0im 0+0im  
0+0im 0+0im

julia> adjoint!(B, A);

julia> B  
2×2 Matrix{Complex{Int64}}:  
3-2im 8-7im  
9-2im 4-6im

julia> A  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

```
LinearAlgebra.Adjoint– Type.

```

Adjoint

Lazywrappertypeforanadjointviewoftheunderlyinglinearalgebraobject,usuallyanAbstractVector/AbstractMatrix,  
but also someFactorization, for instance. Usually, theAdjointconstructor should not be called directly,  
useadjointinstead. To materialize the view usecopy.  
This type is intended for linear algebra usage - for general data manipulation seepermutedims.  
Examples

julia> A = [3+2im 9+2im; 8+7im 4+6im]  
2×2 Matrix{Complex{Int64}}:  
3+2im 9+2im  
8+7im 4+6im

julia> adjoint(A)  
2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  
3-2im 8-7im  
9-2im 4-6im

```
Base.copy– Method.

```

copy(A::Transpose)  
copy(A::Adjoint)

Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to  
elements.  
This operation is intended for linear algebra usage - for general data manipulation seepermutedims, which  
is non-recursive.  
Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1115

```

julia> A = [1 2im; -3im 4]  
2×2 Matrix{Complex{Int64}}:  
1+0im 0+2im  
0-3im 4+0im

julia> T = transpose(A)  
2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  
1+0im 0-3im  
0+2im 4+0im

julia> copy(T)  
2×2 Matrix{Complex{Int64}}:  
1+0im 0-3im  
0+2im 4+0im

```
LinearAlgebra.stride1– Function.

```

stride1(A)-> Int

Return the distance between successive array elements in dimension 1 in units of element size.  
Examples

julia> A = [1,2,3,4]  
4-element Vector{Int64}:  
1  
2  
3  
4

julia> LinearAlgebra.stride1(A)  
1

julia> B = view(A,2:2:4)  
2-element view(::Vector{Int64}, 2:2:4) with eltype Int64:  
2  
4

julia> LinearAlgebra.stride1(B)  
2

```
LinearAlgebra.checksquare– Function.

```

LinearAlgebra.checksquare(A)

Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.  
Examples

julia> A = fill(1, ( 4,4)); B= fill(1, ( 5,5));

julia> LinearAlgebra.checksquare(A, B)  
2-element Vector{Int64}:  
4  
5

```
LinearAlgebra.peakflops– Function.


#### CHAPTER 75. LINEAR ALGEBRA 1116

```

LinearAlgebra.peakflops(n:: Integer =2000; parallel:: Bool = false )

peakflopscomputes the peak flop rate of the computer by using double precisiongemm!. By default, if  
no arguments are specified, it multiplies a matrix of sizen x n, wheren = 2000. If the underlying BLAS  
is using multiple threads, higher flop rates are realized. The number of BLAS threads can be set with  
BLAS.set_num_threads(n).  
If the keyword argumentparallelis set totrue,peakflopsis run in parallel on all the worker processors.  
The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is  
used. The argumentnstill refers to the size of the problem that is solved on each processor.

Julia 1.1  
This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library  
InteractiveUtils.

```
### 75.4 Low-level matrix operations.

In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output
vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated
allocations. These in-place operations are suffixed with! below (e.g. mul!) according to the usual Julia
convention.

LinearAlgebra.mul!– Function.

```

mul!(Y, A, B)-> Y

Calculates the matrix-matrix or matrix-vector productABand stores the result inY, overwriting the exist-  
ing value ofY. Note thatYmust not be aliased with eitherAorB.  
Examples

julia> A=[1.0 2.0; 3.0 4.0]; B =[1.0 1.0; 1.0 1.0]; Y= similar(B); mul!(Y, A, B);

julia> Y  
2×2 Matrix{Float64}:  
3.0 3.0  
7.0 7.0

Implementation  
For custom matrix and vector types, it is recommended to implement 5-argumentmul!rather than imple-  
menting 3-argumentmul!directly if possible.  
mul!(C, A, B, α, β) -> C

Combined inplace matrix-matrix or matrix-vector multiply-addAB+C. The result is stored inCby over-  
writing it. Note thatCmust not be aliased with eitherAorB.

Julia 1.3  
Five-argumentmul!requires at least Julia 1.3.

Examples

```

#### CHAPTER 75. LINEAR ALGEBRA 1117

```

julia> A=[1.0 2.0; 3.0 4.0]; B =[1.0 1.0; 1.0 1.0]; C =[1.0 2.0; 3.0 4.0];

julia> mul!(C, A, B,100.0, 10.0) === C  
true

julia> C  
2×2 Matrix{Float64}:  
310.0 320.0  
730.0 740.0

```
LinearAlgebra.lmul!– Function.

```

lmul!(a:: Number , B :: AbstractArray )

Scale an arrayBby a scalaraoverwritingBin-place. Usermul!to multiply scalar from right. The scaling  
operation respects the semantics of the multiplication*betweenaand an element ofB. In particular, this  
also applies to multiplication involving non-finite numbers such asNaNand±Inf.

Julia 1.1  
Prior to Julia 1.1,NaNand±Infentries inBwere treated inconsistently.

Examples

julia> B = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> lmul!(2, B)  
2×2 Matrix{Int64}:  
2 4  
6 8

julia> lmul!(0.0, [ Inf])  
1-element Vector{Float64}:  
NaN

lmul!(A, B)

Calculate the matrix-matrix productAB, overwritingB, and return the result. Here,Amust be of special  
matrix type, like, e.g.,Diagonal,UpperTriangularorLowerTriangular, or of some orthogonal type, see  
QR.  
Examples

julia> B = [0 1; 1 0];

julia> A = LinearAlgebra. UpperTriangular ([1 2; 0 3]);

julia> LinearAlgebra.lmul!(A, B);

julia> B  
2×2 Matrix{Int64}:  
2 1  
3 0

```

#### CHAPTER 75. LINEAR ALGEBRA 1118

```

julia> B = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> lmul!(F.Q, B)  
2×2 Matrix{Float64}:  
3.0 4.0  
1.0 2.0

```
LinearAlgebra.rmul!– Function.

```

rmul!(A:: AbstractArray , b :: Number )

Scale an arrayAby a scalarboverwritingAin-place. Uselmul!to multiply scalar from left. The scaling  
operation respects the semantics of the multiplication*between an element ofAandb. In particular, this  
also applies to multiplication involving non-finite numbers such asNaNand±Inf.

Julia 1.1  
Prior to Julia 1.1,NaNand±Infentries inAwere treated inconsistently.

Examples

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> rmul!(A,2)  
2×2 Matrix{Int64}:  
2 4  
6 8

julia> rmul!([NaN], 0.0)  
1-element Vector{Float64}:  
NaN

rmul!(A, B)

Calculate the matrix-matrix productAB, overwritingA, and return the result. Here,Bmust be of special  
matrix type, like, e.g.,Diagonal,UpperTriangularorLowerTriangular, or of some orthogonal type, see  
QR.  
Examples

julia> A = [0 1; 1 0];

julia> B = LinearAlgebra. UpperTriangular ([1 2; 0 3]);

julia> LinearAlgebra.rmul!(A, B);

julia> A  
2×2 Matrix{Int64}:  
0 3  
1 2

```

#### CHAPTER 75. LINEAR ALGEBRA 1119

```

julia> A = [1.0 2.0; 3.0 4.0];

julia> F = qr([0 1; -1 0]);

julia> rmul!(A, F.Q)  
2×2 Matrix{Float64}:  
2.0 1.0  
4.0 3.0

```
LinearAlgebra.ldiv!– Function.

```

ldiv!(Y, A, B)-> Y

ComputeA \ Bin-place and store the result inY, returning the result.  
The argumentAshould not be a matrix. Rather, instead of matrices it should be a factorization object (e.g.  
produced byfactorizeorcholesky). The reason for this is that factorization itself is both expensive and  
typically allocates memory (although it can also be done in-place via, e.g.,lu!), and performance-critical  
situations requiringldiv!usually also require fine-grained control over the factorization ofA.  
Examples

julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

julia> Y = zero(X);

julia> ldiv!(Y, qr(A), X);

julia> Y  
3-element Vector{Float64}:  
0.7128099173553719  
-0.051652892561983806  
0.10020661157024781

julia> A\X  
3-element Vector{Float64}:  
0.7128099173553719  
-0.05165289256198342  
0.1002066115702479

ldiv!(A, B)

ComputeA \ Bin-place and overwritingBto store the result.  
The argumentAshould not be a matrix. Rather, instead of matrices it should be a factorization object (e.g.  
produced byfactorizeorcholesky). The reason for this is that factorization itself is both expensive and  
typically allocates memory (although it can also be done in-place via, e.g.,lu!), and performance-critical  
situations requiringldiv!usually also require fine-grained control over the factorization ofA.  
Examples

julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> X = [1; 2.5; 3];

```

#### CHAPTER 75. LINEAR ALGEBRA 1120

```

julia> Y = copy(X);

julia> ldiv!(qr(A), X);

julia> X  
3-element Vector{Float64}:  
0.7128099173553719  
-0.051652892561983806  
0.10020661157024781

julia> A\Y  
3-element Vector{Float64}:  
0.7128099173553719  
-0.05165289256198342  
0.1002066115702479

ldiv!(a::Number, B::AbstractArray)

Divide each entry in an arrayBby a scalaraoverwritingBin-place. Userdiv!to divide scalar from right.  
Examples

julia> B = [1.0 2.0; 3.0 4.0]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> ldiv!(2.0, B)  
2×2 Matrix{Float64}:  
0.5 1.0  
1.5 2.0

```
LinearAlgebra.rdiv!– Function.

```

rdiv!(A, B)

ComputeA / Bin-place and overwritingAto store the result.  
The argumentBshould not be a matrix. Rather, instead of matrices it should be a factorization object (e.g.  
produced byfactorizeorcholesky). The reason for this is that factorization itself is both expensive and  
typically allocates memory (although it can also be done in-place via, e.g.,lu!), and performance-critical  
situations requiringrdiv!usually also require fine-grained control over the factorization ofB.  
rdiv!(A::AbstractArray, b::Number)

Divide each entry in an arrayAby a scalarboverwritingAin-place. Useldiv!to divide scalar from left.  
Examples

julia> A = [1.0 2.0; 3.0 4.0]  
2×2 Matrix{Float64}:  
1.0 2.0  
3.0 4.0

julia> rdiv!(A,2.0)  
2×2 Matrix{Float64}:  
0.5 1.0  
1.5 2.0

```

#### CHAPTER 75. LINEAR ALGEBRA 1121

### 75.5 BLAS functions.

In Julia (as in much of scientific computation), dense linear-algebra operations are based on theLAPACK library,
which in turn is built on top of basic linear-algebra building-blocks known as theBLAS. There are highly opti-
mizedimplementationsofBLASavailableforeverycomputerarchitecture,andsometimesinhigh-performance
linear algebra routines it is useful to call the BLAS functions directly.

LinearAlgebra.BLASprovides wrappers for some of the BLAS functions. Those BLAS functions that overwrite
one of the input arrays have names ending in'!'. Usually, a BLAS function has four methods defined, for
Float64,Float32,ComplexF64, andComplexF32arrays.

### BLAS character arguments

Many BLAS functions accept arguments that determine whether to transpose an argument (trans), which
triangle of a matrix to reference (uploorul), whether the diagonal of a triangular matrix can be assumed to
be all ones (dA) or which side of a matrix multiplication the input argument belongs on (side). The possibilities
are:

**Multiplication order**

```

side Meaning  
'L' The argument goes on the left side of a matrix-matrix operation.  
'R' The argument goes on the right side of a matrix-matrix operation.

```
**Triangle referencing**

```

uplo/ul Meaning  
'U' Only the upper triangle of the matrix will be used.  
'L' Only the lower triangle of the matrix will be used.

```
**Transposition operation**

```

trans/tX Meaning  
'N' The input matrixXis not transposed or conjugated.  
'T' The input matrixXwill be transposed.  
'C' The input matrixXwill be conjugated and transposed.

```
**Unit diagonal**

```

diag/dX Meaning  
'N' The diagonal values of the matrixXwill be read.  
'U' The diagonal of the matrixXis assumed to be all ones.

```
LinearAlgebra.BLAS– Module.

```

Interface to BLAS subroutines.

```
LinearAlgebra.BLAS.dot– Function.

```

dot(n, X, incx, Y, incy)

```

#### CHAPTER 75. LINEAR ALGEBRA 1122

```

Dot product of two vectors consisting ofnelements of arrayXwith strideincxandnelements of arrayY  
with strideincy.  
Examples

julia> BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)  
10.0

```
LinearAlgebra.BLAS.dotu– Function.

```

dotu(n, X, incx, Y, incy)

Dot function for two complex vectors consisting ofnelements of arrayXwith strideincxandnelements  
of arrayYwith strideincy.  
Examples

julia> BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)  
-10.0 + 10.0im

```
LinearAlgebra.BLAS.dotc– Function.

```

dotc(n, X, incx, U, incy)

Dot function for two complex vectors, consisting ofnelements of arrayXwith strideincxandnelements  
of arrayUwith strideincy, conjugating the first vector.  
Examples

julia> BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)  
10.0 - 10.0im

```
LinearAlgebra.BLAS.blascopy!– Function.

```

blascopy!(n, X, incx, Y, incy)

Copynelements of arrayXwith strideincxto arrayYwith strideincy. ReturnsY.

```
LinearAlgebra.BLAS.nrm2– Function.

```

nrm2(n, X, incx)

2-norm of a vector consisting ofnelements of arrayXwith strideincx.  
Examples

julia> BLAS.nrm2(4, fill(1.0, 8), 2)  
2.0

julia> BLAS.nrm2(1, fill(1.0, 8), 2)  
1.0

```
LinearAlgebra.BLAS.asum– Function.

```

asum(n, X, incx)

```

#### CHAPTER 75. LINEAR ALGEBRA 1123

```

Sum of the magnitudes of the firstnelements of arrayXwith strideincx.  
For a real array, the magnitude is the absolute value. For a complex array, the magnitude is the sum of  
the absolute value of the real part and the absolute value of the imaginary part.  
Examples

julia> BLAS.asum(5, fill(1.0im, 10), 2)  
5.0

julia> BLAS.asum(2, fill(1.0im, 10), 5)  
2.0

```
LinearAlgebra.axpy!– Function.

```

axpy!(a, X, Y)

OverwriteYwithX*a + Y, whereais a scalar. ReturnY.  
Examples

julia> x = [1; 2; 3];

julia> y = [4; 5; 6];

julia> BLAS.axpy!(2, x, y)  
3-element Vector{Int64}:  
6  
9  
12

```
LinearAlgebra.axpby!– Function.

```

axpby!(a, X, b, Y)

OverwriteYwithX_a + Y_b, whereaandbare scalars. ReturnY.  
Examples

julia> x = [1., 2, 3];

julia> y = [4., 5, 6];

julia> BLAS.axpby!(2., x,3., y)  
3-element Vector{Float64}:  
14.0  
19.0  
24.0

```
LinearAlgebra.BLAS.scal!– Function.

```

scal!(n, a, X, incx)  
scal!(a, X)

OverwriteXwitha*Xfor the firstnelements of arrayXwith strideincx. ReturnsX.  
Ifnandincxare not provided,length(X)andstride(X,1)are used.

```

#### CHAPTER 75. LINEAR ALGEBRA 1124

LinearAlgebra.BLAS.scal– Function.

```

scal(n, a, X, incx)  
scal(a, X)

ReturnXscaled byafor the firstnelements of arrayXwith strideincx.  
Ifnandincxare not provided,length(X)andstride(X,1)are used.

```
LinearAlgebra.BLAS.iamax– Function.

```

iamax(n, dx, incx)  
iamax(dx)

Find the index of the element ofdxwith the maximum absolute value.nis the length ofdx, andincxis the  
stride. Ifnandincxarenotprovided,theyassumedefaultvaluesofn=length(dx)andincx=stride1(dx).

```
LinearAlgebra.BLAS.ger!– Function.

```

ger!(alpha, x, y, A)

Rank-1 update of the matrixAwith vectorsxandyasalpha_x_y' + A.

```
LinearAlgebra.BLAS.syr!– Function.

```

syr!(uplo, alpha, x, A)

Rank-1 update of the symmetric matrixAwith vectorxasalpha_x_transpose(x) + A.uplocontrols  
which triangle ofAis updated. ReturnsA.

```
LinearAlgebra.BLAS.syrk!– Function.

```

syrk!(uplo, trans, alpha, A, beta, C)

Rank-k update of the symmetric matrixCasalpha_A_transpose(A) + beta_Coralpha_transpose(A)*A

-   beta*Caccording totrans. Only theuplotriangle ofCis used. ReturnsC.

```
LinearAlgebra.BLAS.syrk– Function.

```

syrk(uplo, trans, alpha, A)

Returns either the upper triangle or the lower triangle ofA, according touplo, ofalpha_A_transpose(A)  
oralpha_transpose(A)_A, according totrans.

```
LinearAlgebra.BLAS.syr2k!– Function.

```

syr2k!(uplo, trans, alpha, A, B, beta, C)

Rank-2kupdateofthesymmetricmatrixCasalpha_A_transpose(B) + alpha_B_transpose(A) + beta_C  
oralpha_transpose(A)_B + alpha_transpose(B)_A + beta_Caccording totrans. Only theuplotrian-  
gle ofCis used. ReturnsC.

```
LinearAlgebra.BLAS.syr2k– Function.

```

syr2k(uplo, trans, alpha, A, B)

Returnstheuplotriangleofalpha_A_transpose(B) + alpha_B_transpose(A)oralpha_transpose(A)_B

-   alpha_transpose(B)_A, according totrans.

```

#### CHAPTER 75. LINEAR ALGEBRA 1125

```

syr2k(uplo, trans, A, B)

ReturnstheuplotriangleofA_transpose(B) + B_transpose(A)ortranspose(A)_B + transpose(B)_A,  
according totrans.

```
LinearAlgebra.BLAS.her!– Function.

```

her!(uplo, alpha, x, A)

Methods for complex arrays only. Rank-1 update of the Hermitian matrixAwith vectorxasalpha_x_x' +  
A.uplocontrols which triangle ofAis updated. ReturnsA.

```
LinearAlgebra.BLAS.herk!– Function.

```

herk!(uplo, trans, alpha, A, beta, C)

Methods for complex arrays only. Rank-k update of the Hermitian matrixCasalpha_A_A' + beta_Cor  
alpha_A'_A + beta_Caccording totrans. Only theuplotriangle ofCis updated. ReturnsC.

```
LinearAlgebra.BLAS.herk– Function.

```

herk(uplo, trans, alpha, A)

Methods for complex arrays only. Returns theuplotriangle ofalpha_A_A'oralpha_A'_A, according to  
trans.

```
LinearAlgebra.BLAS.her2k!– Function.

```

her2k!(uplo, trans, alpha, A, B, beta, C)

Rank-2kupdateoftheHermitianmatrixCasalpha_A_B' + alpha_B_A' + beta_Coralpha_A'_B + alpha_B'*A

-   beta*Caccording totrans. The scalarbetahas to be real. Only theuplotriangle ofCis used. Returns  
    C.

```
LinearAlgebra.BLAS.her2k– Function.

```

her2k(uplo, trans, alpha, A, B)

Returnstheuplotriangleofalpha_A_B' + alpha_B_A'oralpha_A'_B + alpha_B'_A,accordingtotrans.  
her2k(uplo, trans, A, B)

Returns theuplotriangle ofA_B' + B_A'orA'_B + B'_A, according totrans.

```
LinearAlgebra.BLAS.gbmv!– Function.

```

gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)

Update vectoryasalpha_A_x + beta_yoralpha_A'_x + beta_yaccording totrans. The matrixAis a  
general band matrix of dimensionmbysize(A,2)withklsub-diagonals andkusuper-diagonals.alpha  
andbetaare scalars. Return the updatedy.

```
LinearAlgebra.BLAS.gbmv– Function.

```

gbmv(trans, m, kl, ku, alpha, A, x)

Returnalpha_A_xoralpha_A'_xaccording totrans. The matrixAis a general band matrix of dimension  
mbysize(A,2)withklsub-diagonals andkusuper-diagonals, andalphais a scalar.

```

#### CHAPTER 75. LINEAR ALGEBRA 1126

LinearAlgebra.BLAS.sbmv!– Function.

```

sbmv!(uplo, k, alpha, A, x, beta, y)

Update vectoryasalpha_A_x + beta*ywhereAis a symmetric band matrix of ordersize(A,2)withk  
super-diagonalsstoredintheargumentA.ThestoragelayoutforAisdescribedthereferenceBLASmodule,  
level-2 BLAS athttp://www.netlib.org/lapack/explore-html/. Only theuplotriangle ofAis used.  
Return the updatedy.

```
LinearAlgebra.BLAS.sbmv– Method.

```

sbmv(uplo, k, alpha, A, x)

Returnalpha_A_xwhereAis a symmetric band matrix of ordersize(A,2)withksuper-diagonals stored  
in the argumentA. Only theuplotriangle ofAis used.

```
LinearAlgebra.BLAS.sbmv– Method.

```

sbmv(uplo, k, A, x)

ReturnA*xwhereAis a symmetric band matrix of ordersize(A,2)withksuper-diagonals stored in the  
argumentA. Only theuplotriangle ofAis used.

```
LinearAlgebra.BLAS.gemm!– Function.

```

gemm!(tA, tB, alpha, A, B, beta, C)

UpdateCasalpha_A_B + beta*Cor the other three variants according totAandtB. Return the updated  
C.

```
LinearAlgebra.BLAS.gemm– Method.

```

gemm(tA, tB, alpha, A, B)

Returnalpha_A_Bor the other three variants according totAandtB.

```
LinearAlgebra.BLAS.gemm– Method.

```

gemm(tA, tB, A, B)

ReturnA*Bor the other three variants according totAandtB.

```
LinearAlgebra.BLAS.gemv!– Function.

```

gemv!(tA, alpha, A, x, beta, y)

Update the vectoryasalpha_A_x + beta_yoralpha_A'x + beta*yaccording totA.alphaandbetaare  
scalars. Return the updatedy.

```
LinearAlgebra.BLAS.gemv– Method.

```

gemv(tA, alpha, A, x)

Returnalpha_A_xoralpha*A'xaccording totA.alphais a scalar.

```
LinearAlgebra.BLAS.gemv– Method.

```

gemv(tA, A, x)

```

#### CHAPTER 75. LINEAR ALGEBRA 1127

```

ReturnA*xorA'xaccording totA.

```
LinearAlgebra.BLAS.symm!– Function.

```

symm!(side, ul, alpha, A, B, beta, C)

UpdateCasalpha_A_B + beta_Coralpha_B_A + beta_Caccording toside. Ais assumed to be sym-  
metric. Only theultriangle ofAis used. Return the updatedC.

```
LinearAlgebra.BLAS.symm– Method.

```

symm(side, ul, alpha, A, B)

Returnalpha_A_Boralpha_B_Aaccording toside.Ais assumed to be symmetric. Only theultriangle of  
Ais used.

```
LinearAlgebra.BLAS.symm– Method.

```

symm(side, ul, A, B)

ReturnA_BorB_Aaccording toside.Ais assumed to be symmetric. Only theultriangle ofAis used.

```
LinearAlgebra.BLAS.symv!– Function.

```

symv!(ul, alpha, A, x, beta, y)

Update the vectoryasalpha_A_x + beta*y.Ais assumed to be symmetric. Only theultriangle ofAis  
used.alphaandbetaare scalars. Return the updatedy.

```
LinearAlgebra.BLAS.symv– Method.

```

symv(ul, alpha, A, x)

Returnalpha_A_x.Ais assumed to be symmetric. Only theultriangle ofAis used.alphais a scalar.

```
LinearAlgebra.BLAS.symv– Method.

```

symv(ul, A, x)

ReturnA*x.Ais assumed to be symmetric. Only theultriangle ofAis used.

```
LinearAlgebra.BLAS.hemm!– Function.

```

hemm!(side, ul, alpha, A, B, beta, C)

UpdateCasalpha_A_B + beta_Coralpha_B_A + beta_Caccording toside.Ais assumed to be Hermi-  
tian. Only theultriangle ofAis used. Return the updatedC.

```
LinearAlgebra.BLAS.hemm– Method.

```

hemm(side, ul, alpha, A, B)

Returnalpha_A_Boralpha_B_Aaccording toside.Ais assumed to be Hermitian. Only theultriangle of  
Ais used.

```
LinearAlgebra.BLAS.hemm– Method.

```

hemm(side, ul, A, B)

```

#### CHAPTER 75. LINEAR ALGEBRA 1128

```

ReturnA_BorB_Aaccording toside.Ais assumed to be Hermitian. Only theultriangle ofAis used.

```
LinearAlgebra.BLAS.hemv!– Function.

```

hemv!(ul, alpha, A, x, beta, y)

Update the vectoryasalpha_A_x + beta*y.Ais assumed to be Hermitian. Only theultriangle ofAis  
used.alphaandbetaare scalars. Return the updatedy.

```
LinearAlgebra.BLAS.hemv– Method.

```

hemv(ul, alpha, A, x)

Returnalpha_A_x.Ais assumed to be Hermitian. Only theultriangle ofAis used.alphais a scalar.

```
LinearAlgebra.BLAS.hemv– Method.

```

hemv(ul, A, x)

ReturnA*x.Ais assumed to be Hermitian. Only theultriangle ofAis used.

```
LinearAlgebra.BLAS.trmm!– Function.

```

trmm!(side, ul, tA, dA, alpha, A, B)

UpdateBasalpha_A_Bor one of the other three variants determined bysideandtA. Only theultriangle  
ofAis used.dAdetermines if the diagonal values are read or are assumed to be all ones. Returns the  
updatedB.

```
LinearAlgebra.BLAS.trmm– Function.

```

trmm(side, ul, tA, dA, alpha, A, B)

Returnsalpha_A_Bor one of the other three variants determined bysideandtA. Only theultriangle of  
Ais used.dAdetermines if the diagonal values are read or are assumed to be all ones.

```
LinearAlgebra.BLAS.trsm!– Function.

```

trsm!(side, ul, tA, dA, alpha, A, B)

OverwriteBwith the solution toA_X = alpha_Bor one of the other three variants determined bysideand  
tA. Only theultriangle ofAis used.dAdetermines if the diagonal values are read or are assumed to be  
all ones. Returns the updatedB.

```
LinearAlgebra.BLAS.trsm– Function.

```

trsm(side, ul, tA, dA, alpha, A, B)

ReturnthesolutiontoA_X = alpha_Boroneoftheotherthreevariantsdeterminedbydeterminedbyside  
andtA. Only theultriangle ofAis used.dAdetermines if the diagonal values are read or are assumed to  
be all ones.

```
LinearAlgebra.BLAS.trmv!– Function.

```

trmv!(ul, tA, dA, A, b)

Returnop(A)*b, whereopis determined bytA. Only theultriangle ofAis used. dAdetermines if the  
diagonal values are read or are assumed to be all ones. The multiplication occurs in-place onb.

```

#### CHAPTER 75. LINEAR ALGEBRA 1129

LinearAlgebra.BLAS.trmv– Function.

```

trmv(ul, tA, dA, A, b)

Returnop(A)*b, whereopis determined bytA. Only theultriangle ofAis used. dAdetermines if the  
diagonal values are read or are assumed to be all ones.

```
LinearAlgebra.BLAS.trsv!– Function.

```

trsv!(ul, tA, dA, A, b)

Overwritebwith the solution toA*x = bor one of the other two variants determined bytAandul. dA  
determines if the diagonal values are read or are assumed to be all ones. Return the updatedb.

```
LinearAlgebra.BLAS.trsv– Function.

```

trsv(ul, tA, dA, A, b)

Return the solution toA*x = bor one of the other two variants determined bytAandul.dAdetermines  
if the diagonal values are read or are assumed to be all ones.

```
LinearAlgebra.BLAS.set_num_threads– Function.

```

set_num_threads(n:: Integer )  
set_num_threads(::Nothing)

Set the number of threads the BLAS library should use equal ton::Integer.  
Also acceptsnothing, in which case julia tries to guess the default number of threads. Passingnothingis  
discouraged and mainly exists for historical reasons.

```
LinearAlgebra.BLAS.get_num_threads– Function.

```

get_num_threads()

Get the number of threads the BLAS library is using.

Julia 1.6  
get_num_threadsrequires at least Julia 1.6.

```
### 75.6 LAPACK functions

LinearAlgebra.LAPACKprovides wrappers for some of the LAPACK functions for linear algebra. Those func-
tions that overwrite one of the input arrays have names ending in'!'.

Usuallyafunctionhas4methodsdefined, oneeachforFloat64,Float32,ComplexF64andComplexF32arrays.

Note that the LAPACK API provided by Julia can and will change in the future. Since this API is not user-facing,
there is no commitment to support/deprecate this specific set of functions in future releases.

LinearAlgebra.LAPACK– Module.

```

Interfaces to LAPACK subroutines.

```
LinearAlgebra.LAPACK.gbtrf!– Function.

```

gbtrf!(kl, ku, m, AB)-> (AB, ipiv)

```

#### CHAPTER 75. LINEAR ALGEBRA 1130

```

Compute the LU factorization of a banded matrixAB.klis the first subdiagonal containing a nonzero band,  
kuis the last superdiagonal containing one, andmis the first dimension of the matrixAB. Returns the LU  
factorization in-place andipiv, the vector of pivots used.

```
LinearAlgebra.LAPACK.gbtrs!– Function.

```

gbtrs!(trans, kl, ku, m, AB, ipiv, B)

Solve the equationAB * X = B.transdetermines the orientation ofAB. It may beN(no transpose),T  
(transpose), orC(conjugate transpose).klis the first subdiagonal containing a nonzero band,kuis the  
last superdiagonal containing one, andmis the first dimension of the matrixAB.ipivis the vector of pivots  
returned fromgbtrf!. Returns the vector or matrixX, overwritingBin-place.

```
LinearAlgebra.LAPACK.gebal!– Function.

```

gebal!(job, A)-> (ilo, ihi, scale)

BalancethematrixAbeforecomputingitseigensystemorSchurfactorization.jobcanbeoneofN(Awillnot  
be permuted or scaled),P(Awill only be permuted),S(Awill only be scaled), orB(Awill be both permuted  
and scaled). ModifiesAin-place and returnsilo,ihi, andscale. If permuting was turned on,A[i,j]  
= 0ifj > iand1 < j < iloorj > ihi. scalecontains information about the scaling/permutations  
performed.

```
LinearAlgebra.LAPACK.gebak!– Function.

```

gebak!(job, side, ilo, ihi, scale, V)

Transform the eigenvectorsVof a matrix balanced usinggebal!to the unscaled/unpermuted eigenvectors  
of the original matrix. ModifiesVin-place.sidecan beL(left eigenvectors are transformed) orR(right  
eigenvectors are transformed).

```
LinearAlgebra.LAPACK.gebrd!– Function.

```

gebrd!(A)-> (A, d,e, tauq, taup)

ReduceAin-placetobidiagonalformA = QBP'.ReturnsA,containingthebidiagonalmatrixB;d, containing  
the diagonal elements ofB;e, containing the off-diagonal elements ofB;tauq, containing the elementary  
reflectors representingQ; andtaup, containing the elementary reflectors representingP.

```
LinearAlgebra.LAPACK.gelqf!– Function.

```

gelqf!(A, tau)

Compute theLQfactorization ofA,A = LQ.taucontains scalars which parameterize the elementary re-  
flectors of the factorization.taumust have length greater than or equal to the smallest dimension of  
A.  
ReturnsAandtaumodified in-place.  
gelqf!(A) -> (A, tau)

Compute theLQfactorization ofA,A = LQ.  
ReturnsA,modifiedin-place, andtau, whichcontainsscalarswhichparameterizetheelementaryreflectors  
of the factorization.

```
LinearAlgebra.LAPACK.geqlf!– Function.


#### CHAPTER 75. LINEAR ALGEBRA 1131

```

geqlf!(A, tau)

Compute theQLfactorization ofA,A = QL.taucontains scalars which parameterize the elementary re-  
flectors of the factorization.taumust have length greater than or equal to the smallest dimension of  
A.  
ReturnsAandtaumodified in-place.  
geqlf!(A) -> (A, tau)

Compute theQLfactorization ofA,A = QL.  
ReturnsA,modifiedin-place, andtau, whichcontainsscalarswhichparameterizetheelementaryreflectors  
of the factorization.

```
LinearAlgebra.LAPACK.geqrf!– Function.

```

geqrf!(A, tau)

Compute theQRfactorization ofA,A = QR.taucontains scalars which parameterize the elementary re-  
flectors of the factorization.taumust have length greater than or equal to the smallest dimension of  
A.  
ReturnsAandtaumodified in-place.  
geqrf!(A) -> (A, tau)

Compute theQRfactorization ofA,A = QR.  
ReturnsA,modifiedin-place, andtau, whichcontainsscalarswhichparameterizetheelementaryreflectors  
of the factorization.

```
LinearAlgebra.LAPACK.geqp3!– Function.

```

geqp3!(A, [jpvt, tau])-> (A, tau, jpvt)

Compute the pivotedQRfactorization ofA,AP = QRusing BLAS level 3.Pis a pivoting matrix, represented  
byjpvt. taustores the elementary reflectors. The argumentsjpvtandtauare optional and allow for  
passing preallocated arrays. When passed,jpvtmust have length greater than or equal tonifAis an(m  
x n)matrix andtaumust have length greater than or equal to the smallest dimension ofA.  
A,jpvt, andtauare modified in-place.

```
LinearAlgebra.LAPACK.gerqf!– Function.

```

gerqf!(A, tau)

Compute theRQfactorization ofA,A = RQ.taucontains scalars which parameterize the elementary re-  
flectors of the factorization.taumust have length greater than or equal to the smallest dimension of  
A.  
ReturnsAandtaumodified in-place.  
gerqf!(A) -> (A, tau)

Compute theRQfactorization ofA,A = RQ.  
ReturnsA,modifiedin-place, andtau, whichcontainsscalarswhichparameterizetheelementaryreflectors  
of the factorization.

```

#### CHAPTER 75. LINEAR ALGEBRA 1132

LinearAlgebra.LAPACK.geqrt!– Function.

```

geqrt!(A, T)

Compute the blockedQRfactorization ofA,A = QR.Tcontains upper triangular block reflectors which  
parameterize the elementary reflectors of the factorization. The first dimension ofTsets the block size  
and it must be between 1 andn. The second dimension ofTmust equal the smallest dimension ofA.  
ReturnsAandTmodified in-place.  
geqrt!(A, nb) -> (A, T)

Compute the blockedQRfactorization ofA,A = QR.nbsets the block size and it must be between 1 andn,  
the second dimension ofA.  
ReturnsA, modified in-place, andT, which contains upper triangular block reflectors which parameterize  
the elementary reflectors of the factorization.

```
LinearAlgebra.LAPACK.geqrt3!– Function.

```

geqrt3!(A, T)

RecursivelycomputestheblockedQRfactorizationofA,A = QR.Tcontainsuppertriangularblockreflectors  
which parameterize the elementary reflectors of the factorization. The first dimension ofTsets the block  
size and it must be between 1 andn. The second dimension ofTmust equal the smallest dimension ofA.  
ReturnsAandTmodified in-place.  
geqrt3!(A) -> (A, T)

Recursively computes the blockedQRfactorization ofA,A = QR.  
ReturnsA, modified in-place, andT, which contains upper triangular block reflectors which parameterize  
the elementary reflectors of the factorization.

```
LinearAlgebra.LAPACK.getrf!– Function.

```

getrf!(A)-> (A, ipiv, info)

Compute the pivotedLUfactorization ofA,A = LU.  
ReturnsA, modified in-place,ipiv, the pivoting information, and aninfocode which indicates success  
(info = 0), a singular value inU(info = i, in which caseU[i,i]is singular), or an error code (info <  
0 ).

```
LinearAlgebra.LAPACK.tzrzf!– Function.

```

tzrzf!(A)-> (A, tau)

Transforms the upper trapezoidal matrixAto upper triangular form in-place. ReturnsAandtau, the scalar  
parameters for the elementary reflectors of the transformation.

```
LinearAlgebra.LAPACK.ormrz!– Function.

```

ormrz!(side, trans, A, tau, C)

Multiplies the matrixCbyQfrom the transformation supplied bytzrzf!. Depending onsideortransthe  
multiplication can be left-sided (side = L, Q_C) or right-sided (side = R, C_Q) andQcan be unmodified  
(trans = N), transposed (trans = T), or conjugate transposed (trans = C). Returns matrixCwhich is  
modified in-place with the result of the multiplication.

```

#### CHAPTER 75. LINEAR ALGEBRA 1133

LinearAlgebra.LAPACK.gels!– Function.

```

gels!(trans, A, B)-> (F, B, ssr)

Solves the linear equationA * X = B,transpose(A) * X = B, oradjoint(A) * X = Busing a QR or LQ  
factorization. Modifies the matrix/vectorBin place with the solution. Ais overwritten with itsQRorLQ  
factorization.transmay be one ofN(no modification),T(transpose), orC(conjugate transpose).gels!  
searches for the minimum norm/least squares solution.Amay be under or over determined. The solution  
is returned inB.

```
LinearAlgebra.LAPACK.gesv!– Function.

```

gesv!(A, B)-> (B, A, ipiv)

Solves the linear equationA * X = BwhereAis a square matrix using theLUfactorization ofA.Ais  
overwritten with itsLUfactorization andBis overwritten with the solutionX.ipivcontains the pivoting  
information for theLUfactorization ofA.

```
LinearAlgebra.LAPACK.getrs!– Function.

```

getrs!(trans, A, ipiv, B)

SolvesthelinearequationA * X = B,transpose(A) * X = B,oradjoint(A) * X = BforsquareA.Mod-  
ifies the matrix/vectorBin place with the solution.Ais theLUfactorization fromgetrf!, withipivthe  
pivoting information.transmay be one ofN(no modification),T(transpose), orC(conjugate transpose).

```
LinearAlgebra.LAPACK.getri!– Function.

```

getri!(A, ipiv)

Computes the inverse ofA, using itsLUfactorization found bygetrf!.ipivis the pivot information output  
andAcontains theLUfactorization ofgetrf!.Ais overwritten with its inverse.

```
LinearAlgebra.LAPACK.gesvx!– Function.

```

gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B)-> (X, equed, R, C, B, rcond, ferr, berr, work)

Solves the linear equationA * X = B(trans = N),transpose(A) * X = B(trans = T), oradjoint(A)

-   X = B(trans = C)usingtheLUfactorizationofA.factmaybeE,inwhichcaseAwillbeequilibratedand  
    copied toAF;F, in which caseAFandipivfrom a previousLUfactorization are inputs; orN, in which caseA  
    will be copied toAFand then factored. Iffact = F,equedmay beN, meaningAhas not been equilibrated;  
    R, meaningAwas multiplied byDiagonal(R)from the left;C, meaningAwas multiplied byDiagonal(C)  
    from the right; orB, meaningAwas multiplied byDiagonal(R)from the left andDiagonal(C)from the  
    right. Iffact = Fandequed = RorBthe elements ofRmust all be positive. Iffact = Fandequed = C  
    orBthe elements ofCmust all be positive.  
    Returns the solutionX;equed, which is an output iffactis notN, and describes the equilibration that  
    was performed;R, the row equilibration diagonal;C, the column equilibration diagonal;B, which may be  
    overwritten with its equilibrated formDiagonal(R)_B(iftrans = Nandequed = R,B) orDiagonal(C)_B  
    (iftrans = T,Candequed = C,B);rcond, the reciprocal condition number ofAafter equilbrating;ferr,  
    theforwarderrorboundforeachsolutionvectorinX;berr, theforwarderrorboundforeachsolutionvector  
    inX; andwork, the reciprocal pivot growth factor.  
    gesvx!(A, B)

The no-equilibration, no-transpose simplification ofgesvx!.

```

#### CHAPTER 75. LINEAR ALGEBRA 1134

LinearAlgebra.LAPACK.gelsd!– Function.

```

gelsd!(A, B, rcond)-> (B, rnk)

Computes the least norm solution ofA * X = Bby finding theSVDfactorization ofA, then dividing-and-  
conquering the problem.Bis overwritten with the solutionX. Singular values belowrcondwill be treated  
as zero. Returns the solution inBand the effective rank ofAinrnk.

```
LinearAlgebra.LAPACK.gelsy!– Function.

```

gelsy!(A, B, rcond)-> (B, rnk)

Computes the least norm solution ofA * X = Bby finding the fullQRfactorization ofA, then dividing-and-  
conquering the problem.Bis overwritten with the solutionX. Singular values belowrcondwill be treated  
as zero. Returns the solution inBand the effective rank ofAinrnk.

```
LinearAlgebra.LAPACK.gglse!– Function.

```

gglse!(A, c, B, d)-> (X,res)

Solves the equationA * x = cwherexis subject to the equality constraintB * x = d. Uses the formula  
||c - A*x||^2 = 0to solve. ReturnsXand the residual sum-of-squares.

```
LinearAlgebra.LAPACK.geev!– Function.

```

geev!(jobvl, jobvr, A)-> (W, VL, VR)

Finds the eigensystem ofA. Ifjobvl = N, the left eigenvectors ofAaren 't computed. Ifjobvr = N, the  
right eigenvectors ofAaren 't computed. Ifjobvl = Vorjobvr = V, the corresponding eigenvectors are  
computed. Returns the eigenvalues inW, the right eigenvectors inVR, and the left eigenvectors inVL.

```
LinearAlgebra.LAPACK.gesdd!– Function.

```

gesdd!(job, A)-> (U, S, VT)

Finds the singular value decomposition ofA,A = U * S * V', using a divide and conquer approach. Ifjob  
= A, all the columns ofUand the rows ofV'are computed. Ifjob = N, no columns ofUor rows ofV'are  
computed. Ifjob = O,Ais overwritten with the columns of (thin)Uand the rows of (thin)V'. Ifjob = S,  
the columns of (thin)Uand the rows of (thin)V'are computed and returned separately.

```
LinearAlgebra.LAPACK.gesvd!– Function.

```

gesvd!(jobu, jobvt, A)-> (U, S, VT)

Finds the singular value decomposition ofA,A = U * S * V'. Ifjobu = A, all the columns ofUare com-  
puted. Ifjobvt = Aall the rows ofV'are computed. Ifjobu = N, no columns ofUare computed. Ifjobvt  
= Nno rows ofV'are computed. Ifjobu = O,Ais overwritten with the columns of (thin)U. Ifjobvt = O,  
Ais overwritten with the rows of (thin)V'. Ifjobu = S, the columns of (thin)Uare computed and returned  
separately. Ifjobvt = Sthe rows of (thin)V'are computed and returned separately.jobuandjobvtcan't  
both beO.  
ReturnsU,S, andVt, whereSare the singular values ofA.

```
LinearAlgebra.LAPACK.ggsvd!– Function.

```

ggsvd!(jobu, jobv, jobq, A, B)-> (U, V, Q, alpha, beta, k, l, R)

```

#### CHAPTER 75. LINEAR ALGEBRA 1135

```

Finds the generalized singular value decomposition ofAandB,U'_A_Q = D1_RandV'_B_Q = D2_R.D1  
hasalphaon its diagonal andD2hasbetaon its diagonal. Ifjobu = U, the orthogonal/unitary matrixUis  
computed. Ifjobv = Vthe orthogonal/unitary matrixVis computed. Ifjobq = Q, the orthogonal/unitary  
matrixQiscomputed. Ifjobu,jobvorjobqisN,thatmatrixisnotcomputed. Thisfunctionis onlyavailable  
in LAPACK versions prior to 3.6.0.

```
LinearAlgebra.LAPACK.ggsvd3!– Function.

```

ggsvd3!(jobu, jobv, jobq, A, B)-> (U, V, Q, alpha, beta, k, l, R)

Finds the generalized singular value decomposition ofAandB,U'_A_Q = D1_RandV'_B_Q = D2_R.D1  
hasalphaon its diagonal andD2hasbetaon its diagonal. Ifjobu = U, the orthogonal/unitary matrixUis  
computed. Ifjobv = Vthe orthogonal/unitary matrixVis computed. Ifjobq = Q, the orthogonal/unitary  
matrixQis computed. Ifjobu,jobv, orjobqisN, that matrix is not computed. This function requires  
LAPACK 3.6.0.

```
LinearAlgebra.LAPACK.geevx!– Function.

```

geevx!(balanc, jobvl, jobvr, sense, A)-> (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)

Finds the eigensystem ofAwith matrix balancing. Ifjobvl = N, the left eigenvectors ofAaren 't computed.  
Ifjobvr = N, the right eigenvectors ofAaren 't computed. Ifjobvl = Vorjobvr = V, the corresponding  
eigenvectors are computed. Ifbalanc = N, no balancing is performed. Ifbalanc = P,Ais permuted  
but not scaled. Ifbalanc = S,Ais scaled but not permuted. Ifbalanc = B,Ais permuted and scaled. If  
sense = N,noreciprocalconditionnumbersarecomputed. Ifsense = E,reciprocalconditionnumbersare  
computed for the eigenvalues only. Ifsense = V, reciprocal condition numbers are computed for the right  
eigenvectors only. Ifsense = B, reciprocal condition numbers are computed for the right eigenvectors and  
the eigenvectors. Ifsense = E,B, the right and left eigenvectors must be computed.

```
LinearAlgebra.LAPACK.ggev!– Function.

```

ggev!(jobvl, jobvr, A, B)-> (alpha, beta, vl, vr)

Finds the generalized eigendecomposition ofAandB. Ifjobvl = N, the left eigenvectors aren't computed.  
Ifjobvr = N,therighteigenvectorsaren'tcomputed. Ifjobvl = Vorjobvr = V,thecorrespondingeigen-  
vectors are computed.

```
LinearAlgebra.LAPACK.gtsv!– Function.

```

gtsv!(dl, d, du, B)

Solves the equationA * X = BwhereAis a tridiagonal matrix withdlon the subdiagonal,don the diag-  
onal, andduon the superdiagonal.  
OverwritesBwith the solutionXand returns it.

```
LinearAlgebra.LAPACK.gttrf!– Function.

```

gttrf!(dl, d, du)-> (dl, d, du, du2, ipiv)

Finds theLUfactorization of a tridiagonal matrix withdlon the subdiagonal,don the diagonal, andduon  
the superdiagonal.  
Modifiesdl,d, andduin-place and returns them and the second superdiagonaldu2and the pivoting vector  
ipiv.

```
LinearAlgebra.LAPACK.gttrs!– Function.


#### CHAPTER 75. LINEAR ALGEBRA 1136

```

gttrs!(trans, dl, d, du, du2, ipiv, B)

Solves the equationA * X = B(trans = N),transpose(A) * X = B(trans = T), oradjoint(A) * X =  
B(trans = C) using theLUfactorization computed bygttrf!.Bis overwritten with the solutionX.

```
LinearAlgebra.LAPACK.orglq!– Function.

```

orglq!(A, tau, k= length(tau))

Explicitly finds the matrixQof aLQfactorization after callinggelqf!onA. Uses the output ofgelqf!.Ais  
overwritten byQ.

```
LinearAlgebra.LAPACK.orgqr!– Function.

```

orgqr!(A, tau, k= length(tau))

Explicitly finds the matrixQof aQRfactorization after callinggeqrf!onA. Uses the output ofgeqrf!.Ais  
overwritten byQ.

```
LinearAlgebra.LAPACK.orgql!– Function.

```

orgql!(A, tau, k= length(tau))

Explicitly finds the matrixQof aQLfactorization after callinggeqlf!onA. Uses the output ofgeqlf!.Ais  
overwritten byQ.

```
LinearAlgebra.LAPACK.orgrq!– Function.

```

orgrq!(A, tau, k= length(tau))

Explicitly finds the matrixQof aRQfactorization after callinggerqf!onA. Uses the output ofgerqf!.Ais  
overwritten byQ.

```
LinearAlgebra.LAPACK.ormlq!– Function.

```

ormlq!(side, trans, A, tau, C)

ComputesQ * C(trans = N),transpose(Q) * C(trans = T),adjoint(Q) * C(trans = C) forside =  
Lor the equivalent right-sided multiplication forside = RusingQfrom aLQfactorization ofAcomputed  
usinggelqf!.Cis overwritten.

```
LinearAlgebra.LAPACK.ormqr!– Function.

```

ormqr!(side, trans, A, tau, C)

ComputesQ * C(trans = N),transpose(Q) * C(trans = T),adjoint(Q) * C(trans = C) forside =  
Lor the equivalent right-sided multiplication forside = RusingQfrom aQRfactorization ofAcomputed  
usinggeqrf!.Cis overwritten.

```
LinearAlgebra.LAPACK.ormql!– Function.

```

ormql!(side, trans, A, tau, C)

ComputesQ * C(trans = N),transpose(Q) * C(trans = T),adjoint(Q) * C(trans = C) forside =  
Lor the equivalent right-sided multiplication forside = RusingQfrom aQLfactorization ofAcomputed  
usinggeqlf!.Cis overwritten.

```

#### CHAPTER 75. LINEAR ALGEBRA 1137

LinearAlgebra.LAPACK.ormrq!– Function.

```

ormrq!(side, trans, A, tau, C)

ComputesQ * C(trans = N),transpose(Q) * C(trans = T),adjoint(Q) * C(trans = C) forside =  
Lor the equivalent right-sided multiplication forside = RusingQfrom aRQfactorization ofAcomputed  
usinggerqf!.Cis overwritten.

```
LinearAlgebra.LAPACK.gemqrt!– Function.

```

gemqrt!(side, trans, V, T, C)

ComputesQ * C(trans = N),transpose(Q) * C(trans = T),adjoint(Q) * C(trans = C) forside =  
Lor the equivalent right-sided multiplication forside = RusingQfrom aQRfactorization ofAcomputed  
usinggeqrt!.Cis overwritten.

```
LinearAlgebra.LAPACK.posv!– Function.

```

posv!(uplo, A, B)-> (A, B)

Finds the solution toA * X = BwhereAis a symmetric or Hermitian positive definite matrix. Ifuplo = U  
the upper Cholesky decomposition ofAis computed. Ifuplo = Lthe lower Cholesky decomposition ofAis  
computed.Ais overwritten by its Cholesky decomposition.Bis overwritten with the solutionX.

```
LinearAlgebra.LAPACK.potrf!– Function.

```

potrf!(uplo, A)

Computes the Cholesky (upper ifuplo = U, lower ifuplo = L) decomposition of positive-definite matrix  
A.Ais overwritten and returned with an info code.

```
LinearAlgebra.LAPACK.potri!– Function.

```

potri!(uplo, A)

Computes the inverse of positive-definite matrixAafter callingpotrf!to find its (upper ifuplo = U, lower  
ifuplo = L) Cholesky decomposition.  
Ais overwritten by its inverse and returned.

```
LinearAlgebra.LAPACK.potrs!– Function.

```

potrs!(uplo, A, B)

FindsthesolutiontoA * X = BwhereAisasymmetricorHermitianpositivedefinitematrixwhoseCholesky  
decomposition was computed bypotrf!. Ifuplo = Uthe upper Cholesky decomposition ofAwas com-  
puted. Ifuplo = LthelowerCholeskydecompositionofAwascomputed.Bisoverwrittenwiththesolution  
X.

```
LinearAlgebra.LAPACK.pstrf!– Function.

```

pstrf!(uplo, A, tol)-> (A, piv, rank, info)

Computes the (upper ifuplo = U, lower ifuplo = L) pivoted Cholesky decomposition of positive-definite  
matrixAwith a user-set tolerancetol.Ais overwritten by its Cholesky decomposition.  
ReturnsA, the pivotspiv, the rank ofA, and aninfocode. Ifinfo = 0, the factorization succeeded. If  
info = i > 0, thenAis indefinite or rank-deficient.

```

#### CHAPTER 75. LINEAR ALGEBRA 1138

LinearAlgebra.LAPACK.ptsv!– Function.

```

ptsv!(D, E, B)

SolvesA * X = Bfor positive-definite tridiagonalA.Dis the diagonal ofAandEis the off-diagonal.Bis  
overwritten with the solutionXand returned.

```
LinearAlgebra.LAPACK.pttrf!– Function.

```

pttrf!(D, E)

Computes the LDLt factorization of a positive-definite tridiagonal matrix withDas diagonal andEas off-  
diagonal.DandEare overwritten and returned.

```
LinearAlgebra.LAPACK.pttrs!– Function.

```

pttrs!(D, E, B)

SolvesA * X = Bfor positive-definite tridiagonalAwith diagonalDand off-diagonalEafter computingA's  
LDLt factorization usingpttrf!.Bis overwritten with the solutionX.

```
LinearAlgebra.LAPACK.trtri!– Function.

```

trtri!(uplo, diag, A)

Finds the inverse of (upper ifuplo = U, lower ifuplo = L) triangular matrixA. Ifdiag = N,Ahas non-unit  
diagonal elements. Ifdiag = U, all diagonal elements ofAare one.Ais overwritten with its inverse.

```
LinearAlgebra.LAPACK.trtrs!– Function.

```

trtrs!(uplo, trans, diag, A, B)

SolvesA * X = B(trans = N),transpose(A) * X = B(trans = T), oradjoint(A) * X = B(trans =  
C) for (upper ifuplo = U, lower ifuplo = L) triangular matrixA. Ifdiag = N,Ahas non-unit diagonal  
elements. Ifdiag = U, all diagonal elements ofAare one.Bis overwritten with the solutionX.

```
LinearAlgebra.LAPACK.trcon!– Function.

```

trcon!(norm, uplo, diag, A)

Finds the reciprocal condition number of (upper ifuplo = U, lower ifuplo = L) triangular matrixA. Ifdiag  
= N,Ahas non-unit diagonal elements. Ifdiag = U, all diagonal elements ofAare one. Ifnorm = I, the  
condition number is found in the infinity norm. Ifnorm = Oor 1 , the condition number is found in the one  
norm.

```
LinearAlgebra.LAPACK.trevc!– Function.

```

trevc!(side, howmny, select, T, VL= similar(T), VR= similar(T))

Finds the eigensystem of an upper triangular matrixT. Ifside = R, the right eigenvectors are computed.  
Ifside = L, the left eigenvectors are computed. Ifside = B, both sets are computed. Ifhowmny = A, all  
eigenvectors are found. Ifhowmny = B, all eigenvectors are found and backtransformed usingVLandVR.  
Ifhowmny = S, only the eigenvectors corresponding to the values inselectare computed.

```
LinearAlgebra.LAPACK.trrfs!– Function.

```

trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr)-> (Ferr, Berr)

```

#### CHAPTER 75. LINEAR ALGEBRA 1139

```

EstimatestheerrorinthesolutiontoA * X = B(trans = N),transpose(A) * X = B(trans = T),adjoint(A)

-   X = B(trans = C) forside = L, or the equivalent equations a right-handedside = R X * Aafter com-  
    putingXusingtrtrs!. Ifuplo = U,Ais upper triangular. Ifuplo = L,Ais lower triangular. Ifdiag = N,  
    Ahas non-unit diagonal elements. Ifdiag = U, all diagonal elements ofAare one.FerrandBerrare  
    optional inputs.Ferris the forward error andBerris the backward error, each component-wise.

```
LinearAlgebra.LAPACK.stev!– Function.

```

stev!(job, dv, ev)-> (dv, Zmat)

Computes the eigensystem for a symmetric tridiagonal matrix withdvas diagonal andevas off-diagonal.  
Ifjob = Nonly the eigenvalues are found and returned indv. Ifjob = Vthen the eigenvectors are also  
found and returned inZmat.

```
LinearAlgebra.LAPACK.stebz!– Function.

```

stebz!(range, order, vl, vu, il, iu, abstol, dv, ev)-> (dv, iblock, isplit)

Computes the eigenvalues for a symmetric tridiagonal matrix withdvas diagonal andevas off-diagonal.  
Ifrange = A, all the eigenvalues are found. Ifrange = V, the eigenvalues in the half-open interval(vl,  
vu]are found. Ifrange = I, the eigenvalues with indices betweenilandiuare found. Iforder = B,  
eigvalues are ordered within a block. Iforder = E, they are ordered across all the blocks.abstolcan be  
set as a tolerance for convergence.

```
LinearAlgebra.LAPACK.stegr!– Function.

```

stegr!(jobz, range, dv, ev, vl, vu, il, iu)-> (w, Z)

Computes the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) for a symmetric tridi-  
agonal matrix withdvas diagonal andevas off-diagonal. Ifrange = A, all the eigenvalues are found. If  
range = V, the eigenvalues in the half-open interval(vl, vu]are found. Ifrange = I, the eigenvalues  
with indices betweenilandiuare found. The eigenvalues are returned inwand the eigenvectors inZ.

```
LinearAlgebra.LAPACK.stein!– Function.

```

stein!(dv, ev_in, w_in, iblock_in, isplit_in)

Computes the eigenvectors for a symmetric tridiagonal matrix withdvas diagonal andev_inas off-  
diagonal.w_inspecifies the input eigenvalues for which to find corresponding eigenvectors.iblock_in  
specifies the submatrices corresponding to the eigenvalues inw_in. isplit_inspecifies the splitting  
points between the submatrix blocks.

```
LinearAlgebra.LAPACK.syconv!– Function.

```

syconv!(uplo, A, ipiv)-> (A, work)

Converts a symmetric matrixA(which has been factorized into a triangular matrix) into two matricesL  
andD. Ifuplo = U,Ais upper triangular. Ifuplo = L, it is lower triangular.ipivis the pivot vector from  
the triangular factorization.Ais overwritten byLandD.

```
LinearAlgebra.LAPACK.sysv!– Function.

```

sysv!(uplo, A, B)-> (B, A, ipiv)

Finds the solution toA * X = Bfor symmetric matrixA. Ifuplo = U, the upper half ofAis stored. Ifuplo  
= L, the lower half is stored.Bis overwritten by the solutionX.Ais overwritten by its Bunch-Kaufman  
factorization.ipivcontains pivoting information about the factorization.

```

#### CHAPTER 75. LINEAR ALGEBRA 1140

LinearAlgebra.LAPACK.sytrf!– Function.

```

sytrf!(uplo, A)-> (A, ipiv, info)

Computes the Bunch-Kaufman factorization of a symmetric matrixA. Ifuplo = U, the upper half ofAis  
stored. Ifuplo = L, the lower half is stored.  
ReturnsA, overwritten by the factorization, a pivot vectoripiv, and the error codeinfowhich is a non-  
negative integer. Ifinfois positive the matrix is singular and the diagonal part of the factorization is  
exactly zero at positioninfo.

```
LinearAlgebra.LAPACK.sytri!– Function.

```

sytri!(uplo, A, ipiv)

Computes the inverse of a symmetric matrixAusing the results ofsytrf!. Ifuplo = U, the upper half of  
Ais stored. Ifuplo = L, the lower half is stored.Ais overwritten by its inverse.

```
LinearAlgebra.LAPACK.sytrs!– Function.

```

sytrs!(uplo, A, ipiv, B)

Solves the equationA * X = Bfor a symmetric matrixAusing the results ofsytrf!. Ifuplo = U, the  
upper half ofAis stored. Ifuplo = L, the lower half is stored.Bis overwritten by the solutionX.

```
LinearAlgebra.LAPACK.hesv!– Function.

```

hesv!(uplo, A, B)-> (B, A, ipiv)

Finds the solution toA * X = Bfor Hermitian matrixA. Ifuplo = U, the upper half ofAis stored. Ifuplo  
= L, the lower half is stored.Bis overwritten by the solutionX.Ais overwritten by its Bunch-Kaufman  
factorization.ipivcontains pivoting information about the factorization.

```
LinearAlgebra.LAPACK.hetrf!– Function.

```

hetrf!(uplo, A)-> (A, ipiv, info)

Computes the Bunch-Kaufman factorization of a Hermitian matrixA. Ifuplo = U, the upper half ofAis  
stored. Ifuplo = L, the lower half is stored.  
ReturnsA, overwritten by the factorization, a pivot vectoripiv, and the error codeinfowhich is a non-  
negative integer. Ifinfois positive the matrix is singular and the diagonal part of the factorization is  
exactly zero at positioninfo.

```
LinearAlgebra.LAPACK.hetri!– Function.

```

hetri!(uplo, A, ipiv)

Computes the inverse of a Hermitian matrixAusing the results ofsytrf!. Ifuplo = U, the upper half ofA  
is stored. Ifuplo = L, the lower half is stored.Ais overwritten by its inverse.

```
LinearAlgebra.LAPACK.hetrs!– Function.

```

hetrs!(uplo, A, ipiv, B)

Solves the equationA * X = Bfor a Hermitian matrixAusing the results ofsytrf!. Ifuplo = U, the upper  
half ofAis stored. Ifuplo = L, the lower half is stored.Bis overwritten by the solutionX.

```

#### CHAPTER 75. LINEAR ALGEBRA 1141

LinearAlgebra.LAPACK.syev!– Function.

```

syev!(jobz, uplo, A)

Finds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrixA. If  
uplo = U, the upper triangle ofAis used. Ifuplo = L, the lower triangle ofAis used.

```
LinearAlgebra.LAPACK.syevr!– Function.

```

syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol)-> (W, Z)

Finds the eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric matrixA. If  
uplo = U, the upper triangle ofAis used. Ifuplo = L, the lower triangle ofAis used. Ifrange = A, all  
the eigenvalues are found. Ifrange = V, the eigenvalues in the half-open interval(vl, vu]are found. If  
range = I, the eigenvalues with indices betweenilandiuare found.abstolcan be set as a tolerance  
for convergence.  
The eigenvalues are returned inWand the eigenvectors inZ.

```
LinearAlgebra.LAPACK.sygvd!– Function.

```

sygvd!(itype, jobz, uplo, A, B)-> (w, A, B)

Finds the generalized eigenvalues (jobz = N) or eigenvalues and eigenvectors (jobz = V) of a symmetric  
matrixAand symmetric positive-definite matrixB. Ifuplo = U, the upper triangles ofAandBare used. If  
uplo = L, the lower triangles ofAandBare used. Ifitype = 1, the problem to solve isA * x = lambda

-   B * x. Ifitype = 2, the problem to solve isA * B * x = lambda * x. Ifitype = 3, the problem to  
    solve isB * A * x = lambda * x.

```
LinearAlgebra.LAPACK.bdsqr!– Function.

```

bdsqr!(uplo, d, e_, Vt, U, C)-> (d, Vt, U, C)

Computes the singular value decomposition of a bidiagonal matrix withdon the diagonal ande_on the  
off-diagonal. Ifuplo = U,e_is the superdiagonal. Ifuplo = L,e_is the subdiagonal. Can optionally also  
compute the productQ' * C.  
Returns the singular values ind, and the matrixCoverwritten withQ' * C.

```
LinearAlgebra.LAPACK.bdsdc!– Function.

```

bdsdc!(uplo, compq, d, e_)-> (d, e, u, vt, q, iq)

Computes the singular value decomposition of a bidiagonal matrix withdon the diagonal ande_on the  
off-diagonal using a divide and conqueq method. Ifuplo = U,e_is the superdiagonal. Ifuplo = L,e_is  
the subdiagonal. Ifcompq = N, only the singular values are found. Ifcompq = I, the singular values and  
vectors are found. Ifcompq = P, the singular values and vectors are found in compact form. Only works  
for real types.  
Returns the singular values ind, and ifcompq = P, the compact singular vectors iniq.

```
LinearAlgebra.LAPACK.gecon!– Function.

```

gecon!(normtype, A, anorm)

Finds the reciprocal condition number of matrixA. Ifnormtype = I, the condition number is found in the  
infinity norm. Ifnormtype = Oor 1 , the condition number is found in the one norm.Amust be the result  
ofgetrf!andanormis the norm ofAin the relevant norm.

```

#### CHAPTER 75. LINEAR ALGEBRA 1142

LinearAlgebra.LAPACK.gehrd!– Function.

```

gehrd!(ilo, ihi, A)-> (A, tau)

Converts a matrixAto Hessenberg form. IfAis balanced withgebal!theniloandihiare the outputs of  
gebal!. Otherwise they should beilo = 1andihi = size(A,2).taucontains the elementary reflectors  
of the factorization.

```
LinearAlgebra.LAPACK.orghr!– Function.

```

orghr!(ilo, ihi, A, tau)

Explicitly findsQ, the orthogonal/unitary matrix fromgehrd!.ilo,ihi,A, andtaumust correspond to the  
input/output togehrd!.

```
LinearAlgebra.LAPACK.gees!– Function.

```

gees!(jobvs, A)-> (A, vs, w)

Computes the eigenvalues (jobvs = N) or the eigenvalues and Schur vectors (jobvs = V) of matrixA.A  
is overwritten by its Schur form.  
ReturnsA,vscontaining the Schur vectors, andw, containing the eigenvalues.

```
LinearAlgebra.LAPACK.gges!– Function.

```

gges!(jobvsl, jobvsr, A, B)-> (A, B, alpha, beta, vsl, vsr)

Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (jobsvl = V), or right  
Schur vectors (jobvsr = V) ofAandB.  
The generalized eigenvalues are returned inalphaandbeta. The left Schur vectors are returned invsl  
and the right Schur vectors are returned invsr.

```
LinearAlgebra.LAPACK.trexc!– Function.

```

trexc!(compq, ifst, ilst, T, Q)-> (T, Q)  
trexc!(ifst, ilst, T, Q)-> (T, Q)

Reorder the Schur factorizationTof a matrix, such that the diagonal block ofTwith row indexifstis  
moved to row indexilst. Ifcompq = V, the Schur vectorsQare reordered. Ifcompq = Nthey are not  
modified. The 4-arg method calls the 5-arg method withcompq = V.

```
LinearAlgebra.LAPACK.trsen!– Function.

```

trsen!(job, compq, select, T, Q)-> (T, Q, w, s, sep)  
trsen!(select, T, Q)-> (T, Q, w, s, sep)

Reorder the Schur factorization of a matrix and optionally finds reciprocal condition numbers. Ifjob = N,  
no condition numbers are found. Ifjob = E, only the condition number for this cluster of eigenvalues is  
found. Ifjob = V, only the condition number for the invariant subspace is found. Ifjob = Bthen the  
condition numbers for the cluster and subspace are found. Ifcompq = Vthe Schur vectorsQare updated.  
Ifcompq = Nthe Schur vectors are not modified.selectdetermines which eigenvalues are in the cluster.  
The 3-arg method calls the 5-arg method withjob = Nandcompq = V.  
ReturnsT,Q, reordered eigenvalues inw, the condition number of the cluster of eigenvaluess, and the  
condition number of the invariant subspacesep.

```

#### CHAPTER 75. LINEAR ALGEBRA 1143

LinearAlgebra.LAPACK.tgsen!– Function.

```

tgsen!(select, S, T, Q, Z)-> (S, T, alpha, beta, Q, Z)

Reorders the vectors of a generalized Schur decomposition. selectspecifies the eigenvalues in each  
cluster.

```
LinearAlgebra.LAPACK.trsyl!– Function.

```

trsyl!(transa, transb, A, B, C, isgn=1) -> (C, scale)

Solves the Sylvester matrix equationA * X +/- X * B = scale*CwhereAandBare both quasi-upper  
triangular. Iftransa = N,Ais not modified. Iftransa = T,Ais transposed. Iftransa = C,Ais conjugate  
transposed. Similarly fortransbandB. Ifisgn = 1, the equationA * X + X * B = scale * Cis solved.  
Ifisgn = -1, the equationA * X - X * B = scale * Cis solved.  
ReturnsX(overwritingC) andscale.

```

**Chapter 76**

**Logging**

TheLoggingmodule provides a way to record the history and progress of a computation as a log of events.
Events are created by inserting a logging statement into the source code, for example:

```

@warn"Abandon printf debugging, all ye who enter here!"  
┌ Warning: Abandon printf debugging, all ye who enter here!  
└@Main REPL[1]:1

```
The system provides several advantages over peppering your source code with calls toprintln(). First, it
allows you to control the visibility and presentation of messages without editing the source code. For example,
in contrast to the@warnabove

```

@debug"The sum of some values $ (sum(rand(100)))"

```
will produce no output by default. Furthermore, it's very cheap to leave debug statements like this in the
source code because the system avoids evaluating the message if it would later be ignored. In this case
sum(rand(100))and the associated string processing will never be executed unless debug logging is enabled.

Second, the logging tools allow you to attach arbitrary data to each event as a set of key–value pairs. This
allows you to capture local variables and other program state for later analysis. For example, to attach the
local array variableAand the sum of a vectorvas the keysyou can use

```

A = ones( Int , 4, 4)  
v = ones(100)  
@info"Some variables" A s =sum(v)

# output

┌ Info: Some variables  
│ A=  
│ 4×4 Matrix { Int64 }:  
│ 1 1 1 1  
│ 1 1 1 1  
│ 1 1 1 1  
│ 1 1 1 1  
└ s= 100.0

```
All of the logging macros@debug,@info,@warnand@errorshare common features that are described in detail
in the documentation for the more general macro@logmsg.

#### 1144


#### CHAPTER 76. LOGGING 1145

### 76.1 Log event structure

Each event generates several pieces of data, some provided by the user and some automatically extracted.
Let 's examine the user-defined data first:

- The log level is a broad category for the message that is used for early filtering. There are several
    standard levels of typeLogLevel; user-defined levels are also possible. Each is distinct in purpose:
       **-** Logging.Debug(log level -1000) is information intended for the developer of the program. These
          events are disabled by default.
       **-** Logging.Info(log level 0) is for general information to the user. Think of it as an alternative to
          usingprintlndirectly.
       **-** Logging.Warn(log level 1000) means something is wrong and action is likely required but that for
          now the program is still working.
       **-** Logging.Error(log level 2000) means something is wrong and it is unlikely to be recovered, at
          leastbythispartofthecode. Oftenthislog-levelisunneededasthrowinganexceptioncanconvey
          all the required information.
- Themessageisanobjectdescribingtheevent. ByconventionAbstractStringspassedasmessagesare
    assumedtobeinmarkdownformat. Othertypeswillbedisplayedusingprint(io, obj)orstring(obj)
    for text-based output and possiblyshow(io,mime,obj)for other multimedia displays used in the in-
    stalled logger.
- Optionalkey–valuepairsallowarbitrarydatatobeattachedtoeachevent. Somekeyshaveconventional
    meaning that can affect the way an event is interpreted (see@logmsg).

The system also generates some standard information for each event:

- Themodulein which the logging macro was expanded.
- Thefileandlinewhere the logging macro occurs in the source code.
- A messageidthat is a unique, fixed identifier for the source code statement where the logging macro
    appears. This identifier is designed to be fairly stable even if the source code of the file changes, as long
    as the logging statement itself remains the same.
- Agroupfor the event, which is set to the base name of the file by default, without extension. This can
    be used to group messages into categories more finely than the log level (for example, all deprecation
    warnings have group:depwarn), or into logical groupings across or within modules.

Notice that some useful information such as the event time is not included by default. This is because such
information can be expensive to extract and is also dynamically available to the current logger. It's simple to
define acustom loggerto augment event data with the time, backtrace, values of global variables and other
useful information as required.

### 76.2 Processing log events

As you can see in the examples, logging statements make no mention of where log events go or how they are
processed. This is a key design feature that makes the system composable and natural for concurrent use. It
does this by separating two different concerns:


#### CHAPTER 76. LOGGING 1146

- Creating log events is the concern of the module author who needs to decide where events are triggered
    and which information to include.
- Processing of log events — that is, display, filtering, aggregation and recording — is the concern of the
    application author who needs to bring multiple modules together into a cooperating application.

### Loggers

Processing of events is performed by a logger, which is the first piece of user configurable code to see the
event. All loggers must be subtypes ofAbstractLogger.

When an event is triggered, the appropriate logger is found by looking for a task-local logger with the global
logger as fallback. The idea here is that the application code knows how log events should be processed and
exists somewhere at the top of the call stack. So we should look up through the call stack to discover the
logger — that is, the logger should be dynamically scoped. (This is a point of contrast with logging frameworks
where the logger is lexically scoped; provided explicitly by the module author or as a simple global variable.
In such a system it's awkward to control logging while composing functionality from multiple modules.)

Thegloballoggermaybesetwithglobal_logger, andtask-localloggerscontrolledusingwith_logger. Newly
spawned tasks inherit the logger of the parent task.

Therearethreeloggertypesprovidedbythelibrary.ConsoleLoggeristhedefaultloggeryouseewhenstarting
the REPL. It displays events in a readable text format and tries to give simple but user friendly control over
formatting and filtering. NullLoggeris a convenient way to drop all messages where necessary; it is the
logging equivalent of thedevnullstream.SimpleLoggeris a very simplistic text formatting logger, mainly
useful for debugging the logging system itself.

Custom loggers should come with overloads for the functions described in thereference section.

### Early filtering and message handling

When an event occurs, a few steps of early filtering occur to avoid generating messages that will be discarded:

1. The message log level is checked against a global minimum level (set viadisable_logging). This is a
    crude but extremely cheap global setting.
2. The current logger state is looked up and the message level checked against the logger's cached min-
    imum level, as found by callingLogging.min_enabled_level. This behavior can be overridden via
    environment variables (more on this later).
3. TheLogging.shouldlogfunction is called with the current logger, taking some minimal information
    (level, module, group, id) which can be computed statically. Most usefully,shouldlogis passed an
    eventidwhich can be used to discard events early based on a cached predicate.

If all these checks pass, the message and key–value pairs are evaluated in full and passed to the current logger
via theLogging.handle_messagefunction.handle_message()may perform additional filtering as required
and display the event to the screen, save it to a file, etc.

Exceptions that occur while generating the log event are captured and logged by default. This prevents indi-
vidualbrokeneventsfromcrashingtheapplication, whichishelpfulwhenenablinglittle-useddebugeventsina
productionsystem. ThisbehaviorcanbecustomizedperloggertypebyextendingLogging.catch_exceptions.


#### CHAPTER 76. LOGGING 1147

### 76.3 Testing log events

Log events are a side effect of running normal code, but you might find yourself wanting to test particular
informational messages and warnings. TheTestmodule provides a@test_logsmacro that can be used to
pattern match against the log event stream.

### 76.4 Environment variables.

Message filtering can be influenced through theJULIA_DEBUGenvironment variable, and serves as an easy
way to enable debug logging for a file or module. For example, loading julia withJULIA_DEBUG=loadingwill
activate@debuglog messages inloading.jl:

```

$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'┌  
Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an  
invalid cache header└  
@ Base loading.jl:1328  
[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL  
┌  
Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an  
invalid cache header└  
@ Base loading.jl:1328  
...

```
Similarly, the environment variable can be used to enable debug logging of modules, such asPkg, or module
roots (seeBase.moduleroot). To enable all debug logging, use the special valueall.

To turn debug logging on from the REPL, setENV["JULIA_DEBUG"]to the name of the module of interest.
Functions defined in the REPL belong to moduleMain; logging for them can be enabled like this:

```

julia> foo()= @debug"foo"  
foo (generic function with 1 method)

julia> foo()

julia> ENV["JULIA_DEBUG"] = Main  
Main

julia> foo()  
┌ Debug: foo  
└ @ Main REPL[1]:1

```
### 76.5 Examples

### Example: Writing log events to a file

Sometimes it can be useful to write log events to a file. Here is an example of how to use a task-local and
global logger to write information to a text file:

```

# Load the logging module

julia>using Logging

# Open a textfile for writing

julia> io = open("log.txt", "w+")  
IOStream()

```

#### CHAPTER 76. LOGGING 1148

```

# Create a simple logger

julia> logger= SimpleLogger(io)  
SimpleLogger(IOStream(), Info, Dict{Any,Int64}())

# Log a task-specific message

julia> with_logger(logger) do  
@info("a context specific log message")  
end

# Write all buffered messages to the file

julia> flush(io)

# Set the global logger to logger

julia> global_logger(logger)  
SimpleLogger(IOStream(), Info, Dict{Any,Int64}())

# This message will now also be written to the file

julia> @info("a global log message")

# Close the file

julia> close(io)

```
### Example: Enable debug-level messages

Here is an example of creating aConsoleLoggerthat lets through any messages with log level higher than, or
equal, toLogging.Debug.

```

julia>using Logging

# Create a ConsoleLogger that prints any log messages with level >= Debug to stderr

julia> debuglogger= ConsoleLogger(stderr, Logging.Debug)

# Enable debuglogger for a task

julia> with_logger(debuglogger) do  
@debug"a context specific log message"  
end

# Set the global logger

julia> global_logger(debuglogger)

```
### 76.6 Reference

### Logging module

Logging.Logging– Module.

```

Utilities for capturing, filtering and presenting streams of log events. Normally you don't need to import  
Loggingto create log events; for this the standard logging macros such as@infoare already exported by  
Baseand available by default.

```
### Creating events

Logging.@logmsg– Macro.


#### CHAPTER 76. LOGGING 1149

```

@debugmessage [key=value| value...]  
@info message [key=value| value...]  
@warn message [key=value| value...]  
@errormessage [key=value| value...]

@logmsglevel message [key=value| value...]

Create a log record with an informationalmessage. For convenience, four logging macros@debug,@info,  
@warnand@errorare defined which log at the standard severity levelsDebug,Info,WarnandError.  
@logmsgallowslevelto be set programmatically to anyLogLevelor custom log level types.  
messageshould be an expression which evaluates to a string which is a human readable description of the  
log event. By convention, this string will be formatted as markdown when presented.  
The optional list ofkey=valuepairs supports arbitrary user defined metadata which will be passed through  
to the logging backend as part of the log record. If only avalueexpression is supplied, a key representing  
the expression will be generated usingSymbol. For example,xbecomesx=x, andfoo(10)becomes  
Symbol("foo(10)")=foo(10). For splatting a list of key value pairs, use the normal splatting syntax,  
@info "blah" kws....  
There are some keys which allow automatically generated log data to be overridden:

```
- _module=modcan be used to specify a different originating module from the source location of the
    message.
- _group=symbolcan be used to override the message group (this is normally derived from the base
    name of the source file).
- _id=symbolcan be used to override the automatically generated unique message identifier. This is
    useful if you need to very closely associate messages generated on different source lines.
- _file=stringand_line=integercan be used to override the apparent source location of a log
    message.

```

There 's also some key value pairs which have conventional meaning:

```
- maxlog=integershould be used as a hint to the backend that the message should be displayed no
    more thanmaxlogtimes.
- exception=exshould be used to transport an exception with a log message, often used with@error.
    An associated backtracebtmay be attached using the tupleexception=(ex,bt).

```

Examples

@debug"Verbose debugging information. Invisible by default"  
@info "An informational message"  
@warn "Something was odd. You should pay attention"  
@error"A non fatal error occurred"

x = 10  
@info"Some variables attached to the message"x a =42.0

@debug begin  
sA = sum(A)  
"sum(A) = $sA is an expensive operation, evaluated only when `shouldlog` returns true"  
end

for i=1:10000

```

#### CHAPTER 76. LOGGING 1150

```

@info"With the default backend, you will only see (i = $i ) ten times" maxlog=10  
@debug"Algorithm1"i progress=i/10000  
end

source

```
Logging.LogLevel– Type.

```

LogLevel(level)

Severity/verbosity of a log record.  
The log level provides a key against which potential log records may be filtered, before any other work is  
done to construct the log record data structure itself.  
Examples

julia> Logging.LogLevel(0) == Logging.Info  
true

source

```
Logging.Debug– Constant.

```

Debug

Alias forLogLevel(-1000).

```
Logging.Info– Constant.

```

Info

Alias forLogLevel(0).

```
Logging.Warn– Constant.

```

Warn

Alias forLogLevel(1000).

```
Logging.Error– Constant.

```

Error

Alias forLogLevel(2000).

```
### Processing events with AbstractLogger

Event processing is controlled by overriding functions associated withAbstractLogger:

```

Methods to implement Brief description  
Logging.handle_message Handle a log event  
Logging.shouldlog Early filtering of events  
Logging.min_enabled_level Lower bound for log level of accepted events  
Optional methods Default definition Brief description  
Logging.catch_exceptions true Catch exceptions during event evaluation

```
Logging.AbstractLogger– Type.


#### CHAPTER 76. LOGGING 1151

```

A logger controls how log records are filtered and dispatched. When a log record is generated, the logger  
is the first piece of user configurable code which gets to inspect the record and decide what to do with it.  
source

```
Logging.handle_message– Function.

```

handle_message(logger, level, message, _module, group, id, file, line; key1=val1,...)

Log a message tologgeratlevel. The logical location at which the message was generated is given  
by module_moduleandgroup; the source location byfileandline. idis an arbitrary unique value  
(typically aSymbol) to be used as a key to identify the log statement when filtering.  
source

```
Logging.shouldlog– Function.

```

shouldlog(logger, level, _module, group, id)

Return true whenloggeraccepts a message atlevel, generated for_module,groupand with unique log  
identifierid.  
source

```
Logging.min_enabled_level– Function.

```

min_enabled_level(logger)

Return the minimum enabled level forloggerfor early filtering. That is, the log level below or equal to  
which all messages are filtered.  
source

```
Logging.catch_exceptions– Function.

```

catch_exceptions(logger)

Return true if the logger should catch exceptions which happen during log record construction. By default,  
messages are caught  
By default all exceptions are caught to prevent log message generation from crashing the program. This  
lets users confidently toggle little-used functionality - such as debug logging - in a production system.  
If you want to use logging as an audit trail you should disable this for your logger type.  
source

```
Logging.disable_logging– Function.

```

disable_logging(level)

Disable all log messages at log levels equal to or less thanlevel. This is a global setting, intended to  
make debug logging extremely cheap when disabled.  
Examples

Logging.disable_logging(Logging.Info)# Disable debug and info

source

```

#### CHAPTER 76. LOGGING 1152

### Using Loggers

Logger installation and inspection:

Logging.global_logger– Function.

```

global_logger()

Return the global logger, used to receive messages when no specific logger exists for the current task.  
global_logger(logger)

Set the global logger tologger, and return the previous global logger.  
source

```
Logging.with_logger– Function.

```

with_logger( function , logger)

Executefunction, directing all log messages tologger.  
Example

function test(x)  
@info"x = $x "  
end

with_logger(logger) do  
test(1)  
test([1,2])  
end

source

```
Logging.current_logger– Function.

```

current_logger()

Return the logger for the current task, or the global logger if none is attached to the task.  
source

```
Loggers that are supplied with the system:

Logging.NullLogger– Type.

```

NullLogger()

Logger which disables all messages and produces no output - the logger equivalent of /dev/null.  
source

```
Logging.ConsoleLogger– Type.

```

ConsoleLogger([stream,] min_level=Info; meta_formatter=default_metafmt,  
show_limited= true , right_justify=0)

```

#### CHAPTER 76. LOGGING 1153

```

Logger with formatting optimized for readability in a text console, for example interactive work with the  
Julia REPL.  
Log levels less thanmin_levelare filtered out.  
Message formatting can be controlled by setting keyword arguments:

```
- meta_formatteris a function which takes the log event metadata(level, _module, group, id,
    file, line)and returns a color (as would be passed to printstyled), prefix and suffix for the log
    message. The default is to prefix with the log level and a suffix containing the module, file and line
    location.
- show_limitedlimits the printing of large data structures to something which can fit on the screen
    by setting the:limit IOContextkey during formatting.
- right_justifyis the integer column which log metadata is right justified at. The default is zero
    (metadata goes on its own line).

Logging.SimpleLogger– Type.

```

SimpleLogger([stream,] min_level=Info)

Simplistic logger for logging all messages with level greater than or equal tomin_leveltostream. If  
stream is closed then messages with log level greater or equal toWarnwill be logged tostderrand below  
tostdout.  
source

```

**Chapter 77**

**Markdown**

This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The fol-
lowing Markdown elements are supported:

### 77.1 Inline elements

Here "inline" refers to elements that can be found within blocks of text, i.e. paragraphs. These include the
following elements.

### Bold

Surround words with two asterisks,**, to display the enclosed text in boldface.

```

A paragraph containing a **bold** word.

```
### Italics

Surround words with one asterisk,*, to display the enclosed text in italics.

```

A paragraph containing an _italicized_ word.

```
### Literals

Surround text that should be displayed exactly as written with single backticks,`.

```

A paragraph containing a `literal` word.

```
Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia
program.

```

Tip  
To include a backtick character within literal text use three backticks rather than one to enclose  
the text.  
A paragraph containing `` `backtick` characters ``.

By extension any odd number of backticks may be used to enclose a lesser number of backticks.

```
#### 1154


#### CHAPTER 77. MARKDOWN 1155

### LATEX

Surround text that should be displayed as mathematics using LATEXsyntax with double backticks,``.

```

A paragraph containing some `\LaTeX` markup.

Tip  
Aswithliteralsintheprevioussection,ifliteralbackticksneedtobewrittenwithindoublebackticks  
use an even number greater than two. Note that if a single literal backtick needs to be included  
within LATEXmarkup then two enclosing backticks is sufficient.

Note  
The\character should be escaped appropriately if the text is embedded in a Julia source code,  
for example,"`\\LaTeX` syntax in a docstring.", since it is interpreted as a string literal.  
Alternatively, in order to avoid escaping, it is possible to use therawstring macro together with  
the@docmacro:  
@doc raw"`\LaTeX` syntax in a docstring." functionname

```
### Links

Links to either external or internal targets can be written using the following syntax, where the text enclosed
in square brackets,[ ], is the name of the link and the text enclosed in parentheses,( ), is the URL.

```

A paragraph containing a link to [Julia](http://www.julialang.org/).

```
It's also possible to add cross-references to other documented functions/methods/variables within the Julia
documentation itself. For example:

```

"""  
tryparse(type, str; base)

Like [`parse`](https://pdf2md.morethan.io/@ref), but returns either a value of the requested type,  
or [`nothing`](https://pdf2md.morethan.io/@ref) if the string does not contain a valid number.  
"""

```
This will create a link in the generated docs to theparsedocumentation (which has more information about
what this function actually does), and to thenothingdocumentation. It's good to include cross references
to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming
functions.

```

Note  
The above cross referencing is not a Markdown feature, and relies onDocumenter.jl, which is used  
to build base Julia's documentation.

```
### Footnote references

Named and numbered footnote references can be written using the following syntax. A footnote name must
be a single alphanumeric word containing no punctuation.

```

A paragraph containing a numbered footnote [[1]](https://pdf2md.morethan.io/#fn1) and a named one [^named].

```

#### CHAPTER 77. MARKDOWN 1156

```

Note  
The text associated with a footnote can be written anywhere within the same page as the footnote  
reference. The syntax used to define the footnote text is discussed in theFootnotessection below.

```
### 77.2 Toplevel elements

The following elements can be written either at the"toplevel" of a document or within another"toplevel"
element.

### Paragraphs

A paragraph is a block of plain text, possibly containing any number of inline elements defined in theInline
elementssection above, with one or more blank lines above and below it.

```

This is a paragraph.

And this is _another_ paragraph containing some emphasized text.  
A new line, but still part of the same paragraph.

```
### Headers

A document can be split up into different sections using headers. Headers use the following syntax:

```

# Level One

## Level Two

### Level Three

#### Level Four

##### Level Five

###### Level Six

```
A header line can contain any inline syntax in the same way as a paragraph can.

```

Tip  
Trytoavoidusingtoo manylevelsofheader withinasingledocument. Aheavilynested document  
may be indicative of a need to restructure it or split it into several pages covering separate topics.

```
### Code blocks

Sourcecodecanbedisplayedasaliteralblockusinganindentoffourspacesasshowninthefollowingexample.

```

This is a paragraph.

function func(x)

# ...

end

Another paragraph.

```
Additionally, code blocks can be enclosed using triple backticks with an optional"language" to specify how a
block of code should be highlighted.


#### CHAPTER 77. MARKDOWN 1157

```

A code block without a "language":

```
function func(x)
# ...
end
```

and another one with the "language" specified as `julia`:

```julia
function func(x)
# ...
end
```

Note  
"Fenced"codeblocks,asshowninthelastexample,shouldbepreferredoverindentedcodeblocks  
since there is no way to specify what language an indented code block is written in.

```
### Block quotes

Text from external sources, such as quotations from books or websites, can be quoted using>characters
prepended to each line of the quote as follows.

```

Here's a quote:

> Julia is a high-level, high-performance dynamic programming language for  
> technical computing, with syntax that is familiar to users of other  
> technical computing environments.

```
Notethatasinglespacemustappearafterthe>characteroneachline. Quotedblocksmaythemselvescontain
other toplevel or inline elements.

### Images

The syntax for images is similar to the link syntax mentioned above. Prepending a!character to a link will
display an image from the specified URL rather than a link to it.

```

![alternative text](https://pdf2md.morethan.io/link/to/image.png)

```
### Lists

Unordered lists can be written by prepending each item in a list with either*,+, or-.

```

A list of items:

-   item one
-   item two
-   item three

```
Note the two spaces before each*and the single space after each one.

Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should
be left between each list item when including any toplevel elements within a list.


#### CHAPTER 77. MARKDOWN 1158

```

Another list:

-   item one

-   item two

```
f(x) = x
```

-   And a sublist:

-   sub-item one
-   sub-item two

Note  
The contents of each item in the list must line up with the first line of the item. In the above  
example the fenced code block must be indented by four spaces to align with theiinitem two.

```
Ordered lists are written by replacing the"bullet" character, either*,+, or-, with a positive integer followed
by either.or).

```

Two ordered lists:

```
1. item one
2. item two
3. item three

```

5.  item five
6.  item six
7.  item seven

```
An ordered list may start from a number other than one, as in the second list of the above example, where it
is numbered from five. As with unordered lists, ordered lists can contain nested toplevel elements.

### Display equations

LargeLATEXequationsthatdonotfitinlinewithinaparagraphmaybewrittenasdisplayequationsusingafenced
code block with the"language"mathas in the example below.

```

```math
f(a) = \frac{1}{2\pi}\int_{0}^{2\pi} (\alpha+R\cos(\theta))d\theta
```

```
### Footnotes

This syntax is paired with the inline syntax forFootnote references. Make sure to read that section as well.

Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from
the:character that is appended to the footnote label.

```

```

#### CHAPTER 77. MARKDOWN 1159

```

Named footnote text containing several toplevel elements.

-   item one
-   item two
-   item three

```julia
function func(x)
# ...
end
```

Note  
No checks are done during parsing to make sure that all footnote references have matching foot-  
notes.

```
### Horizontal rules

The equivalent of an<hr>HTML tag can be achieved using three hyphens (---). For example:

```

Text above the line.

---

And text below the line.

```
### Tables

Basictablescanbewrittenusingthesyntaxdescribedbelow. Notethatmarkdowntableshavelimitedfeatures
and cannot contain nested toplevel elements unlike other elements discussed above – only inline elements are
allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or
columns of the table.

```

Column One

Column Two

Column Three

Row `1`

Column `2`

_Row_ 2

**Row** 2

Column `3`

Note  
As illustrated in the above example each column of|characters must be aligned vertically.  
A:character on either end of a column's header separator (the row containing-characters)  
specifies whether the row is left-aligned, right-aligned, or (when:appears on both ends) center-  
aligned. Providing no:characters will default to right-aligning the column.

```
### Admonitions

Specially formatted blocks, known as admonitions, can be used to highlight particular remarks. They can be
defined using the following!!!syntax:


#### CHAPTER 77. MARKDOWN 1160

```

!!! note

This is the content of the note.

!!! warning "Beware!"

And this is another one.

This warning admonition has a custom title: `"Beware!"`.

```
The first word after!!!declares the type of the admonition. There are standard admonition types that should
produce special styling. Namely (in order of decreasing severity):danger,warning,info/note, andtip.

Youcanalsouseyourownadmonitiontypes, aslongasthetypenameonlycontainslowercaseLatincharacters
(a-z). For example, you could have aterminologyblock like this:

```

!!! terminology "julia vs Julia"

Strictly speaking, "Julia" refers to the language,  
and "julia" to the standard implementation.

```
However, unless the code rendering the Markdown special-cases that particular admonition type, it will get
the default styling.

A custom title for the box can be provided as a string (in double quotes) after the admonition type. If no title
text is specified after the admonition type, then the type name will be used as the title (e.g."Note"for the
noteadmonition).

Admonitions, like most other toplevel elements, can contain other toplevel elements (e.g. lists, images).

### 77.3 Markdown Syntax Extensions

Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it
will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown
content is rendered the usualshowmethods will be called, and these can be overridden as usual. This design
allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering
the basic syntax.

In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom
flavour of Markdown can be used, but this should generally be unnecessary.


**Chapter 78**

**Memory-mapped I/O**

Mmap.Anonymous– Type.

```

Mmap.Anonymous(name:: AbstractString ="", readonly:: Bool = false , create:: Bool = true )

Create anIO-like object for creating zeroed-out mmapped-memory that is not tied to a file for use inmmap.  
Used bySharedArrayfor creating shared memory arrays.  
Examples

julia>using Mmap

julia> anon= Mmap.Anonymous();

julia> isreadable(anon)  
true

julia> iswritable(anon)  
true

julia> isopen(anon)  
true

```
Mmap.mmap– Function.

```

mmap(io:: Union { IOStream , AbstractString ,Mmap.AnonymousMmap}[, type :: Type { Array {T,N}}, dims,  
↪→ offset]; grow:: Bool = true , shared:: Bool = true )  
mmap( type :: Type { Array {T,N}}, dims)

Create anArraywhose values are linked to a file, using memory-mapping. This provides a convenient way  
of working with data too large to fit in the computer's memory.  
The type is anArray{T,N}with a bits-type element ofTand dimensionNthat determines how the bytes  
of the array are interpreted. Note that the file must be stored in binary format, and no format conversions  
are possible (this is a limitation of operating systems, not Julia).  
dimsis a tuple or singleIntegerspecifying the size or length of the array.  
The file is passed via the stream argument, either as an openIOStreamor filename string. When you  
initialize the stream, use"r"for a "read-only" array, and"w+"to create a new array used to write values  
to disk.  
If notypeargument is specified, the default isVector{UInt8}.

```
#### 1161


#### CHAPTER 78. MEMORY-MAPPED I/O 1162

```

Optionally, you can specify an offset (in bytes) if, for example, you want to skip over a header in the file.  
The default value for the offset is the current stream position for anIOStream.  
Thegrowkeywordargumentspecifieswhetherthediskfileshouldbegrowntoaccommodatetherequested  
size of array (if the total file size is < requested array size). Write privileges are required to grow the file.  
Thesharedkeyword argument specifies whether the resultingArrayand changes made to it will be visible  
to other processes mapping the same file.  
For example, the following code

# Create a file for mmapping

# (you could alternatively use mmap to do this step, too)

using Mmap  
A = rand(1:20, 5, 30)  
s = open("/tmp/mmap.bin", "w+")

# We'll write the dimensions of the array as the first two Ints in the file

write(s, size(A,1))  
write(s, size(A,2))

# Now write the data

write(s, A)  
close(s)

# Test by reading it back in

s = open("/tmp/mmap.bin") # default is read-only  
m = read(s, Int )  
n = read(s, Int )  
A2 = mmap(s, Matrix { Int }, (m,n))

creates am-by-n Matrix{Int}, linked to the file associated with streams.  
A more portable file would need to encode the word size – 32 bit or 64 bit – and endianness information  
in the header. In practice, consider encoding binary data using standard formats like HDF5 (which can be  
used with memory-mapping).  
mmap(io, BitArray, [dims, offset])

Create aBitArraywhose values are linked to a file, using memory-mapping; it has the same purpose,  
works in the same way, and has the same arguments, asmmap, but the byte representation is different.  
Examples

julia>using Mmap

julia> io = open("mmap.bin", "w+");

julia> B = mmap(io, BitArray , ( 25,30000));

julia> B[3, 4000] = true ;

julia> Mmap.sync!(B);

julia> close(io);

julia> io = open("mmap.bin", "r+");

julia> C = mmap(io, BitArray , ( 25,30000));

```

#### CHAPTER 78. MEMORY-MAPPED I/O 1163

```

julia> C[3, 4000]  
true

julia> C[2, 4000]  
false

julia> close(io)

julia> rm("mmap.bin")

This creates a 25-by-30000BitArray, linked to the file associated with streamio.

```
Mmap.sync!– Function.

```

Mmap.sync!(array)

Forces synchronization between the in-memory version of a memory-mappedArrayorBitArrayand the  
on-disk version.

```

**Chapter 79**

**Pkg**

Pkg is Julia's builtin package manager, and handles operations such as installing, updating and removing
packages.

```

Note  
What follows is a very brief introduction to Pkg. For more information onProject.tomlfiles,  
Manifest.tomlfiles, package version compatibility ([compat]), environments, registries, etc.,  
it is highly recommended to read the full manual, which is available here:https://pkgdocs.ju-  
lialang.org.

```
What follows is a quick overview of Pkg, Julia's package manager. It should help new users become familiar
with basic Pkg features.

Pkg comes with a REPL. Enter the Pkg REPL by pressing]from the Julia REPL. To get back to the Julia REPL,
press backspace or ^C.

```

Note  
This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we rec-  
ommend the Pkg API. The Pkg API is fully documented in theAPI Referencesection of the Pkg  
documentation.

```
Upon entering the Pkg REPL, you should see a similar prompt:

```

(v1.1) pkg>

```
To add a package, useadd:

```

(v1.1) pkg> add Example

Note  
Some Pkg output has been omitted in order to keep this guide focused. This will help maintain a  
good pace and not get bogged down in details. If you require more details, refer to subsequent  
sections of the Pkg manual.

```
We can also specify multiple packages at once:

#### 1164


#### CHAPTER 79. PKG 1165

```

(v1.1) pkg> add JSON StaticArrays

```
To remove packages, userm:

```

(v1.1) pkg> rm JSON StaticArrays

```
So far, we have referred only to registered packages. Pkg also supports working with unregistered packages.
To add an unregistered package, specify a URL:

```

(v1.1) pkg> add https://github.com/JuliaLang/Example.jl

```
Usermto remove this package by name:

```

(v1.1) pkg> rm Example

```
Useupdateto update an installed package:

```

(v1.1) pkg> update Example

```
To update all installed packages, useupdatewithout any arguments:

```

(v1.1) pkg> update

```
Up to this point, we have covered basic package management: adding, updating and removing packages. This
will be familiar if you have used other package managers. Pkg offers significant advantages over traditional
package managers by organizing dependencies into **environments**.

You may have noticed the(v1.1)in the REPL prompt. This lets us knowv1.1is the **active environment**. The
active environment is the environment that will be modified by Pkg commands such asadd,rmandupdate.

Let 's set up a new environment so we may experiment. To set the active environment, useactivate:

```

(v1.1) pkg> activate tutorial  
[ Info: activating new environment at `/tmp/tutorial/Project.toml`.

```
Pkgletsusknowwearecreatinganewenvironmentandthatthisenvironmentwillbestoredinthe/tmp/tutorial
directory.

Pkg has also updated the REPL prompt in order to reflect the new active environment:

```

(tutorial) pkg>

```
We can ask for information about the active environment by usingstatus:

```

(tutorial) pkg> status  
Status `/tmp/tutorial/Project.toml`  
(empty environment)

```

#### CHAPTER 79. PKG 1166

/tmp/tutorial/Project.tomlis the location of the active environment's **project file**. A project file is where
Pkg stores metadata for an environment. Notice this new environment is empty. Let us add a package and
observe:

```

(tutorial) pkg> add Example  
...

(tutorial) pkg> status  
Status `/tmp/tutorial/Project.toml`  
[7876af07] Example v0.5.1

```
We can seetutorialnow containsExampleas a dependency.

Say we are working onExampleand feel it needs new functionality. How can we modify the source code? We
can usedevelopto set up a git clone of theExamplepackage.

```

(tutorial) pkg> develop --local Example  
...

(tutorial) pkg> status  
Status `/tmp/tutorial/Project.toml`  
[7876af07] Example v0.5.1+ [`dev/Example`]

```
Notice the feedback has changed.dev/Examplerefers to the location of the newly created clone. If we look
inside the/tmp/tutorialdirectory, we will notice the following files:

```

tutorial├──  
dev│  
└── Example├──  
Manifest.toml└──  
Project.toml

```
InsteadofloadingaregisteredversionofExample,Juliawillloadthesourcecodecontainedintutorial/dev/Example.

Let 's try it out. First we modify the file attutorial/dev/Example/src/Example.jland add a simple function:

```

plusone(x:: Int ) = x + 1

```
Now we can go back to the Julia REPL and load the package:

```

julia>import Example

Warn  
A package can only be loaded once per Julia session. If you have runimport Examplein the  
current Julia session, you will have to restart Julia and rerunactivate tutorialin the Pkg REPL.  
Revise.jlcan make this process significantly more pleasant, but setting it up is beyond the scope  
of this guide.

```
Julia should load our new code. Let's test it:

```

julia> Example.plusone(1)  
2

```

#### CHAPTER 79. PKG 1167

Say we have a change of heart and decide the world is not ready for such elegant code. We can tell Pkg to
stop using the local clone and use a registered version instead. We do this withfree:

```

(tutorial) pkg> free Example

```
When you are done experimenting withtutorial, you can return to the **default environment** by running
activatewith no arguments:

```

(tutorial) pkg> activate

(v1.1) pkg>

```
If you are ever stuck, you can askPkgfor help:

```

(v1.1) pkg>?

```
You should see a list of available commands along with short descriptions. You can ask for more detailed help
by specifying a command:

```

(v1.1) pkg> ?develop

```
This guide should help you get started withPkg.Pkghas much more to offer in terms of powerful package
management, read the full manual to learn more!


**Chapter 80**

**Printf**

Printf.@printf– Macro.

```

@printf([io:: IO ], " %F mt", args...)

Printargsusing Cprintfstyle format specification string. Optionally, anIOmay be passed as the first  
argument to redirect output.  
Examples

julia> @printf"Hello %s " "world"  
Hello world

julia> @printf"Scientific notation %e " 1.234  
Scientific notation 1.234000e+00

julia> @printf"Scientific notation three digits %.3e " 1.23456  
Scientific notation three digits 1.235e+00

julia> @printf"Decimal two digits %.2f " 1.23456  
Decimal two digits 1.23

julia> @printf"Padded to length 5 %5i " 123  
Padded to length 5 123

julia> @printf"Padded with zeros to length 6 %06i " 123  
Padded with zeros to length 6 000123

julia> @printf"Use shorter of decimal or scientific %g %g " 1.2312300000.0  
Use shorter of decimal or scientific 1.23 1.23e+07

For a systematic specification of the format, seehere. See also@sprintf.  
Caveats  
InfandNaNareprintedconsistentlyasInfandNaNforflags%a,%A,%e,%E,%f,%F,%g, and%G.Furthermore,  
if a floating point number is equally close to the numeric values of two possible output strings, the output  
string further away from zero is chosen.  
Examples

julia> @printf(" %f %F %f %F ", Inf, Inf, NaN, NaN)  
Inf Inf NaN NaN

```
#### 1168


#### CHAPTER 80. PRINTF 1169

```

julia> @printf" %.0f%.1f%f " 0.5 0.025-0.0078125  
0 0.0 -0.007812

```
Printf.@sprintf– Macro.

```

@sprintf(" %F mt", args...)

Return@printfformatted output as string.  
Examples

julia> @sprintf"this is a %s %15.1f " "test"34.567  
"this is a test 34.6"

```

**Chapter 81**

**Profiling**

Profile.@profile– Macro.

```

@profile

@profile runs your expression while taking periodic backtraces. These are appended to  
an internal buffer of backtraces.

```
The methods inProfileare not exported and need to be called e.g. asProfile.print().

Profile.clear– Function.

```

clear()

Clear any existing backtraces from the internal buffer.

```
Profile.print– Function.

```

print([io:: IO = stdout,] [data:: Vector ]; kwargs...)

Prints profiling results toio(by default,stdout). If you do not supply adatavector, the internal buffer of  
accumulated backtraces will be used.  
The keyword arguments can be any combination of:

```
- format– Determines whether backtraces are printed with (default,:tree) or without (:flat) inden-
    tation indicating tree structure.
- C– Iftrue, backtraces from C and Fortran code are shown (normally they are excluded).
- combine– Iftrue(default), instruction pointers are merged that correspond to the same line of code.
- maxdepth– Limits the depth higher thanmaxdepthin the:treeformat.
- sortedby– Controls the order in:flatformat. :filefuncline(default) sorts by the source line,
    :countsortsinorderofnumberofcollectedsamples, and:overheadsortsbythenumberofsamples
    incurred by each function by itself.
- noisefloor–Limitsframesthatexceedtheheuristicnoisefloorofthesample(onlyappliestoformat
    :tree). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for
    whichn <= noisefloor * √N, wherenis the number of samples on this line, andNis the number
    of samples for the callee.
- mincount– Limits the printout to only those lines with at leastmincountoccurrences.

#### 1170


#### CHAPTER 81. PROFILING 1171

- recur– Controls the recursion handling in:treeformat.:off(default) prints the tree as normal.
    :flatinstead compresses any recursion (by ip), showing the approximate effect of converting any
    self-recursion into an iterator.:flatcdoes the same but also includes collapsing of C frames (may
    do odd things aroundjl_apply).

```

print([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)

Printsprofilingresultstoio. Thisvariantisusedtoexamineresultsexportedbyapreviouscalltoretrieve.  
Supply the vectordataof backtraces and a dictionarylidictof line information.  
SeeProfile.print([io], data)for an explanation of the valid keyword arguments.

```
Profile.init– Function.

```

init(; n:: Integer , delay:: Real ))

Configure thedelaybetween backtraces (measured in seconds), and the numbernof instruction pointers  
that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally  
consist of a long list of instruction pointers. Current settings can be obtained by calling this function with  
no arguments, and each can be set independently using keywords or in the order(n, delay).

```
Profile.fetch– Function.

```

fetch()-> data

Returns a copy of the buffer of profile backtraces. Note that the values indatahave meaning only on this  
machine in the current session, because it depends on the exact memory addresses used in JIT-compiling.  
This function is primarily for internal use;retrievemay be a better choice for most users.

```
Profile.retrieve– Function.

```

retrieve()-> data, lidict

"Exports" profiling results in a portable format, returning the set of all backtraces (data) and a dictionary  
that maps the (session-specific) instruction pointers indatatoLineInfovalues that store the file name,  
function name, and line number. This function allows you to save profiling results for future analysis.

```
Profile.callers– Function.

```

callers(funcname, [data, lidict], [filename=], [linerange=<start:stop>]) ->  
↪→ Vector { Tuple {count, lineinfo}}

Given a previous profiling run, determine who called a particular function. Supplying the filename (and  
optionally, range of line numbers over which the function is defined) allows you to disambiguate an over-  
loadedmethod. Thereturnedvalueisavectorcontainingacountofthenumberofcallsandlineinformation  
aboutthecaller. Onecanoptionallysupplybacktracedataobtainedfromretrieve; otherwise, thecurrent  
internal profile buffer is used.

```
Profile.clear_malloc_data– Function.

```

clear_malloc_data()

Clears any stored memory allocation data when running julia with--track-allocation. Execute the  
command(s) you want to test (to force JIT-compilation), then callclear_malloc_data. Then execute your  
command(s) again, quit Julia, and examine the resulting*.memfiles.

```

**Chapter 82**

**The Julia REPL**

Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into thejuliaex-
ecutable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history,
tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by
simply callingjuliawith no arguments or double-clicking on the executable:

```

$ julia

_  
_ _ _(_)_ | Documentation: https://docs.julialang.org  
(_) | (_) (_) |  
_ _ _| |_ __ _ | Type "?" for help, "]?" for Pkg help.  
| | | | | | |/ _` | |  
| | |_| | | | (_| | | Version 1.7.2 (2022-02-06)  
_/ |__'_|_|_|__'_| | Official https://julialang.org/ release  
|__/ |

julia>

```
To exit the interactive session, type^D– the control key together with thedkey on a blank line – or typeexit()
followed by the return or enter key. The REPL greets you with a banner and ajulia>prompt.

### 82.1 The different prompt modes.

### The Julian mode

The REPL has five main modes of operation. The first and most common is the Julian prompt. It is the default
mode of operation; each new line initially starts withjulia>. It is here that you can enter Julia expressions.
Hitting return or enter after a complete expression has been entered will evaluate the entry and show the
result of the last expression.

```

julia> string(1 + 2)  
"3"

```
There are a number useful features unique to interactive work. In addition to showing the result, the REPL also
binds the result to the variableans. A trailing semicolon on the line can be used as a flag to suppress showing
the result.

#### 1172


#### CHAPTER 82. THE JULIA REPL 1173

```

julia> string(3 * 4);

julia> ans  
"12"

```
In Julia mode, the REPL supports something called prompt pasting. This activates when pasting text that starts
withjulia>into the REPL. In that case, only expressions starting withjulia>are parsed, others are removed.
This makes it possible to paste a chunk of code that has been copied from a REPL session without having to
scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with
REPL.enable_promptpaste(::Bool). If it is enabled, you can try it out by pasting the code block above this
paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due
to its limitation at detecting when a paste occurs.

Objects are printed at the REPL using theshowfunction with a specificIOContext. In particular, the:limit
attribute is set totrue. Other attributes can receive in certainshowmethods a default value if it's not already
set, like:compact. It 's possible, as an experimental feature, to specify the attributes used by the REPL via the
Base.active_repl.options.iocontextdictionary (associating values to attributes). For example:

```

julia> rand(2, 2)  
2×2 Array{Float64,2}:  
0.8833 0.329197  
0.719708 0.59114

julia> show(IOContext(stdout,:compact=> false ), "text/plain", rand(2, 2))  
0.43540323669187075 0.15759787870609387  
0.2540832269192739 0.4597637838786053  
julia> Base.active_repl.options.iocontext[:compact]= false ;

julia> rand(2, 2)  
2×2 Array{Float64,2}:  
0.2083967319174056 0.13330606013126012  
0.6244375177790158 0.9777957560761545

```
In order to define automatically the values of this dictionary at startup time, one can use theatreplinit
function in the~/.julia/config/startup.jlfile, for example:

```

atreplinit() do repl  
repl.options.iocontext[:compact]= false  
end

```
### Help mode

When the cursor is at the beginning of the line, the prompt can be changed to a help mode by typing?. Julia
will attempt to print help or documentation for anything entered in help mode:

```

julia>? # upon typing ?, the prompt changes (in place) to: help?>

help?> string  
search: string String Cstring Cwstring RevString randstring bytestring SubString

string(xs...)

Create a string from any values using the print function.

```

#### CHAPTER 82. THE JULIA REPL 1174

Macros, types and variables can also be queried:

```

help?> @time  
@time

A macro to execute an expression, printing the time it took to execute, the number of allocations,  
and the total number of bytes its execution caused to be allocated, before returning the value of  
the  
expression.

See also @timev, @timed, @elapsed, and @allocated.

help?> Int32  
search: Int32 UInt32

Int32 <: Signed

32-bit signed integer type.

```
A string or regex literal searches all docstrings usingapropos:

```

help?> "aprop"  
REPL.stripmd  
Base.Docs.apropos

help?> r"ap..p"  
Base∘.:  
Base.shell_escape_posixly  
Distributed.CachingPool  
REPL.stripmd  
Base.Docs.apropos

```
Help mode can be exited by pressing backspace at the beginning of the line.

### Shell mode

Just as help mode is useful for quick access to documentation, another common task is to use the system shell
to execute system commands. Just as?entered help mode when at the beginning of the line, a semicolon (;)
will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.

```

julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> echo hello  
hello

Note  
For Windows users, Julia's shell mode does not expose windows shell commands. Hence, this will  
fail:

julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> dir  
ERROR: IOError: could not spawn `dir`: no such file or directory (ENOENT)  
Stacktrace!  
.......

```

#### CHAPTER 82. THE JULIA REPL 1175

However, you can get access toPowerShelllike this:

```

julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> powershell  
Windows PowerShell  
Copyright (C) Microsoft Corporation. All rights reserved.  
PS C:\Users\elm>

```
... and tocmd.exelike that (see thedircommand):

```

julia> ; # upon typing ;, the prompt changes (in place) to: shell>

shell> cmd  
Microsoft Windows [version 10.0.17763.973]  
(c) 2018 Microsoft Corporation. All rights reserved.  
C:\Users\elm>dir  
Volume in drive C has no label  
Volume Serial Number is 1643-0CD7  
Directory of C:\Users\elm

29/01/2020 22:15

.  
29/01/2020 22:15

..  
02/02/2020 08:06

.atom

```
### Pkg mode

The Package manager mode accepts specialized commands for loading and updating packages. It is entered
by pressing the]key at the Julian REPL prompt and exited by pressing CTRL-C or pressing the backspace key
at the beginning of the line. The prompt for this mode ispkg>. It supports its own help-mode, which is entered
by pressing?at the beginning of the line of thepkg>prompt. The Package manager mode is documented in
the Pkg manual, available athttps://julialang.github.io/Pkg.jl/v1/.

### Search modes

In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an
incremental search through the previous history, type^R– the control key together with therkey. The prompt
will change to(reverse-i-search)`':, and as you type the search query will appear in the quotes. The most
recent result that matches the query will dynamically update to the right of the colon as more is typed. To find
an older result using the same query, simply type^Ragain.

Just as^Ris a reverse search,^Sis a forward search, with the prompt(i-search)`':. The two may be used
in conjunction with each other to move through the previous or next matching results, respectively.

### 82.2 Key bindings.

The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above
(^Dto exit,^Rand^Sfor searching), but there are many more. In addition to the control-key, there are also
meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down
with a key to send the meta-key (or can be configured to do so), or pressing Esc and then the key.


#### CHAPTER 82. THE JULIA REPL 1176

### Customizing keybindings

Julia'sREPLkeybindingsmaybefullycustomizedtoauser'spreferencesbypassingadictionarytoREPL.setup_interface.
The keys of this dictionary may be characters or strings. The key'*'refers to the default action. Control plus
characterxbindings are indicated with"^x". Meta plusxcan be written"\\M-x"or"\ex", and Control plus
xcan be written"\\C-x"or"^x". The values of the custom keymap must benothing(indicating that the
input should be ignored) or functions that accept the signature(PromptState, AbstractREPL, Char). The
REPL.setup_interfacefunction must be called before the REPL is initialized, by registering the operation with
atreplinit. For example, to bind the up and down arrow keys to move through history without prefix search,
one could put the following code in~/.julia/config/startup.jl:

```

import REPL  
import REPL.LineEdit

const mykeys= Dict { Any , Any }(

# Up Arrow

"\e[A"=> (s,o...)->(LineEdit.edit_move_up(s)|| LineEdit.history_prev(s,  
↪→ LineEdit.mode(s).hist)),

# Down Arrow

"\e[B"=> (s,o...)->(LineEdit.edit_move_down(s)|| LineEdit.history_next(s,  
↪→ LineEdit.mode(s).hist))  
)

function customize_keys(repl)  
repl.interface= REPL.setup_interface(repl; extra_repl_keymap= mykeys)  
end

atreplinit(customize_keys)

```
Users should refer toLineEdit.jlto discover the available actions on key input.

### 82.3 Tab completion

In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and
then press the tab key to get a list all matches:

```

julia> stri[TAB]  
stride strides string strip

julia> Stri[TAB]  
StridedArray StridedMatrix StridedVecOrMat StridedVector String

```
The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list
of LaTeX matches as well:

```

julia> \pi[TAB]  
julia> π  
π = 3.1415926535897...

julia> e_1[TAB]= [1,0]  
julia> e₁ = [1,0]  
2-element Array{Int64,1}:  
1

```

#### CHAPTER 82. THE JULIA REPL 1177

```

0

julia> e^1[TAB]= [1 0]  
julia> e¹ = [1 0]  
1×2 Array{Int64,2}:  
1 0

julia> \sqrt[TAB] 2 # √ is equivalent to the sqrt function  
julia> √2  
1.4142135623730951

julia> \hbar[TAB](https://pdf2md.morethan.io/h)= h / 2\pi[TAB]  
julia> ħ(h)= h / 2π  
ħ (generic function with 1 method)

julia> \h[TAB]  
\hat \hermitconjmatrix \hkswarow \hrectangle  
\hatapprox \hexagon \hookleftarrow \hrectangleblack  
\hbar \hexagonblack \hookrightarrow \hslash  
\heartsuit \hksearow \house \hspace

julia> α=" \a lpha[TAB]" # LaTeX completion also works in strings  
julia> α="α"

```
A full list of tab-completions can be found in theUnicode Inputsection of the manual.

Completion of paths works for strings and julia's shell mode:

```

julia> path="/[TAB]"  
.dockerenv .juliabox/ boot/ etc/ lib/ media/ opt/ root/  
↪→ sbin/ sys/ usr/  
.dockerinit bin/ dev/ home/ lib64/ mnt/ proc/ run/  
↪→ srv/ tmp/ var/  
shell> /[TAB]  
.dockerenv .juliabox/ boot/ etc/ lib/ media/ opt/ root/  
↪→ sbin/ sys/ usr/  
.dockerinit bin/ dev/ home/ lib64/ mnt/ proc/ run/  
↪→ srv/ tmp/ var/

```
Tab completion can help with investigation of the available methods matching the input arguments:

```

julia> max([TAB]# All methods are displayed, not shown here due to size of the list

julia> max([1, 2], [TAB]# All methods where `Vector{Int}` matches as first argument  
max(x, y) in Base at operators.jl:215  
max(a, b, c, xs...) in Base at operators.jl:281

julia> max([1, 2], max(1, 2), [TAB]# All methods matching the arguments.  
max(x, y) in Base at operators.jl:215  
max(a, b, c, xs...) in Base at operators.jl:281

```
Keywords are also displayed in the suggested methods after;, see below line wherelimitandkeepemptyare
keyword arguments:


#### CHAPTER 82. THE JULIA REPL 1178

```

julia> split("1 1 1", [TAB]  
split(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302  
split(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277

```
The completion of the methods uses type inference and can therefore see if the arguments match even if the
arguments are output from functions. The function needs to be type stable for the completion to be able to
remove non-matching methods.

Tab completion can also help completing fields:

```

julia>import UUIDs

julia> UUIDs.uuid[TAB]  
uuid1 uuid4 uuid_version

```
Fields for output from functions can also be completed:

```

julia> split("","")[1].[TAB]  
lastindex offset string

```
The completion of fields for output from functions uses type inference, and it can only suggest fields if the
function is type stable.

Dictionary keys can also be tab completed:

```

julia> foo = Dict ("qwer1"=>1, "qwer2"=>2, "asdf"=>3)  
Dict{String,Int64} with 3 entries:  
"qwer2" => 2  
"asdf" => 3  
"qwer1" => 1

julia> foo["q[TAB]

"qwer1" "qwer2"  
julia> foo["qwer

```
### 82.4 Customizing Colors

The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you
can add something like the following to your~/.julia/config/startup.jlfile, which is to be placed inside
your home directory:

```

function customize_colors(repl)  
repl.prompt_color= Base.text_colors[:cyan]  
end

atreplinit(customize_colors)

```
The available color keys can be seen by typingBase.text_colorsin the help mode of the REPL. In addition,
the integers 0 to 255 can be used as color keys for terminals with 256 color support.


#### CHAPTER 82. THE JULIA REPL 1179

You can also change the colors for the help and shell prompts and input and answer text by setting the
appropriate field ofreplin thecustomize_colorsfunction above (respectively,help_color,shell_color,
input_color, andanswer_color). For the latter two, be sure that theenvcolorsfield is also set to false.

It is also possible to apply boldface formatting by usingBase.text_colors[:bold]as a color. For instance, to
print answers in boldface font, one can use the following as a~/.julia/config/startup.jl:

```

function customize_colors(repl)  
repl.envcolors= false  
repl.answer_color= Base.text_colors[:bold]  
end

atreplinit(customize_colors)

```
Youcanalsocustomizethecolorusedtorenderwarningandinformationalmessagesbysettingtheappropriate
environment variables. For instance, to render error, warning, and informational messages respectively in
magenta, yellow, and cyan you can add the following to your~/.julia/config/startup.jlfile:

```

ENV["JULIA_ERROR_COLOR"] = :magenta  
ENV["JULIA_WARN_COLOR"] = :yellow  
ENV["JULIA_INFO_COLOR"] = :cyan

```
### 82.5 TerminalMenus.

TerminalMenusisasubmoduleoftheJuliaREPLandenablessmall,low-profileinteractivemenusintheterminal.

### Examples

```

import REPL  
using REPL.TerminalMenus

options= ["apple", "orange", "grape", "strawberry",  
"blueberry", "peach", "lemon", "lime"]

```
**RadioMenu**

The RadioMenu allows the user to select one option from the list. Therequestfunction displays the interactive
menu and returns the index of the selected choice. If a user presses'q' orctrl-c,requestwill return a-1.

```

# `pagesize` is the number of items to be displayed at a time.

# The UI will scroll if the number of options is greater

# than the `pagesize`

menu= RadioMenu(options, pagesize=4)

# `request` displays the menu and returns the index after the

# user has selected a choice

choice= request("Choose your favorite fruit:", menu)

if choice!= -1  
println("Your favorite fruit is ", options[choice],"!")  
else  
println("Menu canceled.")  
end

```

#### CHAPTER 82. THE JULIA REPL 1180

Output:

```

Choose your favorite fruit:  
^ grape  
strawberry

> blueberry  
> v peach  
> Your favorite fruit is blueberry!

```
**MultiSelectMenu**

The MultiSelectMenu allows users to select many choices from a list.

```

# here we use the default `pagesize` 10

menu= MultiSelectMenu(options)

# `request` returns a `Set` of selected indices

# if the menu us canceled (ctrl-c or q), return an empty set

choices= request("Select the fruits you like:", menu)

if length(choices)> 0  
println("You like the following fruits:")  
for i in choices  
println(" - ", options[i])  
end  
else  
println("Menu canceled.")  
end

```
Output:

```

Select the fruits you like:  
[press: d=done, a=all, n=none]  
[ ] apple

> [X] orange  
> [X] grape  
> [ ] strawberry  
> [ ] blueberry  
> [X] peach  
> [ ] lemon  
> [ ] lime  
> You like the following fruits:

```
- orange
- grape
- peach

### Customization / Configuration

**ConfiguredMenu subtypes**

Starting with Julia 1.6, the recommended way to configure menus is via the constructor. For instance, the
default multiple-selection menu

```

julia> menu = MultiSelectMenu(options, pagesize=5);

julia> request(menu) # ASCII is used by default

```

#### CHAPTER 82. THE JULIA REPL 1181

```

[press: d=done, a=all, n=none]  
[ ] apple  
[X] orange  
[ ] grape

> [X] strawberry  
> v [ ] blueberry

```
can instead be rendered with Unicode selection and navigation characters with

```

julia> menu= MultiSelectMenu(options, pagesize=5, charset=:unicode);

julia> request(menu)  
[press: d=done, a=all, n=none]  
⬚ apple  
✓ orange  
⬚ grape  
→ ✓ strawberry  
↓ ⬚ blueberry

```
More fine-grained configuration is also possible:

```

julia> menu= MultiSelectMenu(options, pagesize=5, charset=:unicode, checked="YEP!",  
↪→ unchecked="NOPE", cursor='');

julia> request(menu)  
julia> request(menu)  
[press: d=done, a=all, n=none]  
NOPE apple  
YEP! orange  
NOPE grape  
YEP! strawberry  
↓ NOPE blueberry

```
Aside from the overallcharsetoption, forRadioMenuthe configurable options are:

- cursor::Char='>'|'→': character to use for cursor
- up_arrow::Char='^'|'↑': character to use for up arrow
- down_arrow::Char='v'|'↓': character to use for down arrow
- updown_arrow::Char='I'|'↕': character to use for up/down arrow in one-line page
- scroll_wrap::Bool=false: optionally wrap-around at the beginning/end of a menu
- ctrl_c_interrupt::Bool=true: Iffalse, return empty on ^C, iftruethrow InterruptException() on
    ^C

MultiSelectMenuadds:

- checked::String="[X]"|"✓": string to use for checked
- unchecked::String="[ ]"|"⬚"): string to use for unchecked

You can create new menu types of your own. Types that are derived fromTerminalMenus.ConfiguredMenu
configure the menu options at construction time.


#### CHAPTER 82. THE JULIA REPL 1182

**Legacy interface**

PriortoJulia1.6,andstillsupportedthroughoutJulia1.x,onecanalsoconfiguremenusbycallingTerminalMenus.config().

### 82.6 References.

### REPL

Base.atreplinit– Function.

```

atreplinit(f)

Registeraone-argumentfunctiontobecalledbeforetheREPLinterfaceisinitializedininteractivesessions;  
this is useful to customize the interface. The argument offis the REPL object. This function should be  
called from within the.julia/config/startup.jlinitialization file.  
source

```
### TerminalMenus

**Configuration**

REPL.TerminalMenus.Config– Type.

```

Config(; scroll_wrap= false , ctrl_c_interrupt= true , charset=:ascii, cursor:: Char , up_arrow:: Char ,  
↪→ down_arrow:: Char )

Configure behavior for selection menus via keyword arguments:

```
- scroll_wrap, iftrue, causes the menu to wrap around when scrolling above the first or below the
    last entry
- ctrl_c_interrupt, iftrue, throwsanInterruptExceptioniftheuserhitsCtrl-Cduringmenuselec-
    tion. Iffalse,TerminalMenus.requestwill return the default result fromTerminalMenus.selected.
- charsetaffects the default values forcursor,up_arrow, anddown_arrow, and can be:asciior
    :unicode
- cursoris the character printed to indicate the option that will be chosen by hitting"Enter. " Defaults
    are '>' or '→', depending oncharset.
- up_arrowis the character printed when the display does not include the first entry. Defaults are'^'
    or '↑', depending oncharset.
- down_arrowis the character printed when the display does not include the last entry. Defaults are
    'v' or '↓', depending oncharset.

```

Subtypes ofConfiguredMenuwill printcursor,up_arrow, anddown_arrowautomatically as needed, your  
writelinemethod should not print them.

Julia 1.6  
Configis available as of Julia 1.6. On older releases use the globalCONFIG.

```
REPL.TerminalMenus.MultiSelectConfig– Type.

```

MultiSelectConfig(; charset=:ascii, checked::String, unchecked::String, kwargs...)

Configure behavior for a multiple-selection menu via keyword arguments:

```

#### CHAPTER 82. THE JULIA REPL 1183

- checkedis the string to print when an option has been selected. Defaults are"[X]" or "✓", depending
    oncharset.
- uncheckedis the string to print when an option has not been selected. Defaults are"[ ] " or "⬚",
    depending oncharset.

```

All other keyword arguments are as described forTerminalMenus.Config.checkedanduncheckedare  
not printed automatically, and should be printed by yourwritelinemethod.

Julia 1.6  
MultiSelectConfigis available as of Julia 1.6. On older releases use the globalCONFIG.

```
REPL.TerminalMenus.config– Function.

```

config( )

Keyword-only function to configure global menu parameters  
Arguments

```
- charset::Symbol=:na: ui characters to use (:asciior:unicode); overridden by other arguments
- cursor::Char='>'|'→': character to use for cursor
- up_arrow::Char='^'|'↑': character to use for up arrow
- down_arrow::Char='v'|'↓': character to use for down arrow
- checked::String="[X]"|"✓": string to use for checked
- unchecked::String="[ ]"|"⬚"): string to use for unchecked
- scroll::Symbol=:nowrap: If:wrapwrapcursoraroundtopandbottom,if:nowrapdonotwrapcursor
- supress_output::Bool=false: Ignored legacy argument, passsuppress_outputas a keyword ar-
    gument torequestinstead.
- ctrl_c_interrupt::Bool=true: Iffalse, return empty on ^C, iftruethrow InterruptException()
    on ^C

```

Julia 1.6  
As of Julia 1.6,configis deprecated. UseConfigorMultiSelectConfiginstead.

```
**User interaction**

REPL.TerminalMenus.request– Function.

```

request(m::AbstractMenu; cursor=1)

Display the menu and enter interactive mode.cursorindicates the item number used for the initial cursor  
position.cursorcan be either anIntor aRefValue{Int}. The latter is useful for observation and control  
of the cursor position from the outside.  
Returnsselected(m).

Julia 1.6  
Thecursorargument requires Julia 1.6 or later.

request([term,] msg::AbstractString, m::AbstractMenu)

Shorthand forprintln(msg); request(m).

```

#### CHAPTER 82. THE JULIA REPL 1184

**AbstractMenu extension interface**

AnysubtypeofAbstractMenumustbemutable,andmustcontainthefieldspagesize::Intandpageoffset::Int.
Any subtype must also implement the following functions:

REPL.TerminalMenus.pick– Function.

```

pick(m::AbstractMenu, cursor:: Int )

Defines what happens when a user presses the Enter key while the menu is open. Iftrueis returned,  
request()will exit.cursorindexes the position of the selection.

```
REPL.TerminalMenus.cancel– Function.

```

cancel(m::AbstractMenu)

Define what happens when a user cancels ('q' or ctrl-c) a menu.request()will always exit after calling  
this function.

```
REPL.TerminalMenus.writeline– Function.

```

writeline(buf:: IO , m ::AbstractMenu, idx:: Int , iscursor:: Bool )

Write the option at indexidxtobuf.iscursor, iftrue, indicates that this item is at the current cursor  
position (the one that will be selected by hitting"Enter").  
Ifmis aConfiguredMenu,TerminalMenuswill print the cursor indicator. Otherwise the callee is expected  
to handle such printing.

Julia 1.6  
writelinerequires Julia 1.6 or higher.  
OnolderversionsofJulia,thiswaswriteLine(buf::IO, m::AbstractMenu, idx, iscursor::Bool)  
andmis assumed to be unconfigured. The selection and cursor indicators can be obtained from  
TerminalMenus.CONFIG.  
This older function is supported on all Julia 1.x versions but will be dropped in Julia 2.0.

```
It must also implement eitheroptionsornumoptions:

REPL.TerminalMenus.options– Function.

```

options(m::AbstractMenu)

Return a list of strings to be displayed as options in the current page.  
Alternatively, implementnumoptions, in which caseoptionsis not needed.

```
REPL.TerminalMenus.numoptions– Function.

```

numoptions(m::AbstractMenu)-> Int

Return the number of options in menum. Defaults tolength(options(m)).

Julia 1.6  
This function requires Julia 1.6 or later.

```
If the subtype does not have a field namedselected, it must also implement

REPL.TerminalMenus.selected– Function.


#### CHAPTER 82. THE JULIA REPL 1185

```

selected(m::AbstractMenu)

Return information about the user-selected option. By default it returnsm.selected.

```
The following are optional but can allow additional customization:

REPL.TerminalMenus.header– Function.

```

header(m::AbstractMenu)-> String

Returns a header string to be printed above the menu. Defaults to"".

```
REPL.TerminalMenus.keypress– Function.

```

keypress(m::AbstractMenu, i:: UInt32 ) -> Bool

Handle any non-standard keypress event. Iftrueis returned,TerminalMenus.requestwill exit. Defaults  
tofalse.

```

#### CHAPTER 82. THE JULIA REPL 1186

```

Keybinding Description  
Program  
control  
^D Exit (when buffer is empty)  
^C Interrupt or cancel  
^L Clear console screen  
Return/Enter,^J New line, executing if it is complete  
meta-  
Return/Enter

Insert new line without executing it

?or; Enter help or shell mode (when at start of a line)  
^R,^S Incremental history search, described above  
Cursor  
movement  
Right arrow,^F Move right one character  
Left arrow,^B Move left one character  
ctrl-Right,  
meta-F

Move right one word

ctrl-Left,meta-B Move left one word  
Home,^A Move to beginning of line  
End,^E Move to end of line  
Up arrow,^P Move up one line (or change to the previous history entry that matches the text  
before the cursor)  
Down arrow,^N Move down one line (or change to the next history entry that matches the text before  
the cursor)  
Shift-Arrow Key Move cursor according to the direction of the Arrow key, while activating the region  
("shift selection")  
Page-up,meta-P Change to the previous history entry  
Page-down,  
meta-N

Change to the next history entry

meta-< Change to the first history entry (of the current session if it is before the current  
position in history)  
meta-> Change to the last history entry  
^-Space Set the"mark" in the editing region (and de-activate the region if it's active)  
^-Space  
^-Space

Set the"mark" in the editing region and make the region"active", i.e. highlighted

^G De-activate the region (i.e. make it not highlighted)  
^X^X Exchange the current position with the mark  
Editing  
Backspace,^H Delete the previous character, or the whole region when it's active  
Delete,^D Forward delete one character (when buffer has text)  
meta-Backspace Delete the previous word  
meta-d Forward delete the next word  
^W Delete previous text up to the nearest whitespace  
meta-w Copy the current region in the kill ring  
meta-W "Kill" the current region, placing the text in the kill ring  
^K "Kill" to end of line, placing the text in the kill ring  
^Y "Yank " insert the text from the kill ring  
meta-y Replace a previously yanked text with an older entry from the kill ring  
^T Transpose the characters about the cursor  
meta-Up arrow Transpose current line with line above  
meta-Down  
arrow

Transpose current line with line below

meta-u Change the next word to uppercase  
meta-c Change the next word to titlecase  
meta-l Change the next word to lowercase  
^/,^_ Undo previous editing action  
^Q Write a number in REPL and press^Qto open editor at corresponding stackframe or  
method  
meta-Left  
Arrow

indent the current line on the left

meta-Right  
Arrow

indent the current line on the right

meta-. insert last word from previous history entry

```

**Chapter 83**

**Random Numbers**

Random number generation in Julia uses theXoshiro256++algorithm by default, with per-Taskstate. Other
RNG types can be plugged in by inheriting theAbstractRNGtype; they can then be used to obtain multi-
ple streams of random numbers. Besides the defaultTaskLocalRNGtype, theRandompackage also provides
MersenneTwister,RandomDevice(which exposes OS-provided entropy), andXoshiro(for explicitly-managed
Xoshiro256++ streams).

Most functions related to random generation accept an optionalAbstractRNGobject as first argument. Some
alsoacceptdimensionspecificationsdims...(whichcanalsobegivenasatuple)togeneratearraysofrandom
values. In a multi-threaded program, you should generally use different RNG objects from different threads or
tasks in order to be thread-safe. However, the default RNG is thread-safe as of Julia 1.3 (using a per-thread
RNG up to version 1.6, and per-task thereafter).

TheprovidedRNGscangenerateuniformrandomnumbersofthefollowingtypes:Float16,Float32,Float64,
BigFloat,Bool,Int8,UInt8,Int16,UInt16,Int32,UInt32,Int64,UInt64,Int128,UInt128,BigInt(or
complexnumbersofthosetypes). Randomfloatingpointnumbersaregenerateduniformlyin[0,1). AsBigInt
represents unbounded integers, the interval must be specified (e.g.rand(big.(1:6))).

Additionally, normal and exponential distributions are implemented for someAbstractFloatandComplex
types, seerandnandrandexpfor details.

```

Warning  
Because the precise way in which random numbers are generated is considered an implemen-  
tation detail, bug fixes and speed improvements may change the stream of numbers that are  
generated after a version change. Relying on a specific seed or generated stream of numbers  
during unit testing is thus discouraged - consider testing properties of the methods in question  
instead.

```
### 83.1 Random numbers module.

Random.Random– Module.

```

Random

Support for generating random numbers. Providesrand,randn,AbstractRNG,MersenneTwister, and  
RandomDevice.

```
### 83.2 Random generation functions.

Base.rand– Function.

#### 1187


#### CHAPTER 83. RANDOM NUMBERS 1188

```

rand([rng=GLOBAL_RNG], [S], [dims...])

Pick a random element or array of random elements from the set of values specified byS;Scan be

```
- an indexable collection (for example1:9or('x', "y", :z)),
- anAbstractDictorAbstractSetobject,
- a string (considered as a collection of characters), or
- a type: the set of values to pick from is then equivalent totypemin(S):typemax(S)for integers (this
    is not applicable toBigInt), to[0,1)for floating point numbers and to[0,1) +i[0,1)for complex
    floating point numbers;

```

Sdefaults toFloat64. When only one argument is passed besides the optionalrngand is aTuple, it is  
interpreted as a collection of values (S) and not asdims.

Julia 1.1  
Support forSas a tuple requires at least Julia 1.1.

Examples

julia> rand( Int , 2)  
2-element Array{Int64,1}:  
1339893410598768192  
1575814717733606317

julia>using Random

julia> rand( MersenneTwister (0), Dict (1=>2, 3=>4))  
1=>2

julia> rand((2, 3))  
3

julia> rand( Float64 , ( 2, 3))  
2×3 Array{Float64,2}:  
0.999717 0.0143835 0.540787  
0.696556 0.783855 0.938235

Note  
The complexity ofrand(rng, s::Union{AbstractDict,AbstractSet})is linear in the length  
ofs, unless an optimized method with constant complexity is available, which is the case for  
Dict,SetandBitSet. For more than a few calls, userand(rng, collect(s))instead, or  
eitherrand(rng, Dict(s))orrand(rng, Set(s))as appropriate.

```
Random.rand!– Function.

```

rand!([rng=GLOBAL_RNG], A, [S=eltype(A)])

Populate the arrayAwith random values. IfSis specified (Scan be a type or a collection, cf.randfor de-  
tails), the values are picked randomly fromS. This is equivalent tocopyto!(A, rand(rng, S, size(A)))  
but without allocating a new array.  
Examples

```

#### CHAPTER 83. RANDOM NUMBERS 1189

```

julia> rng = MersenneTwister (1234);

julia> rand!(rng, zeros(5))  
5-element Vector{Float64}:  
0.5908446386657102  
0.7667970365022592  
0.5662374165061859  
0.4600853424625171  
0.7940257103317943

```
Random.bitrand– Function.

```

bitrand([rng=GLOBAL_RNG], [dims...])

Generate aBitArrayof random boolean values.  
Examples

julia> rng = MersenneTwister (1234);

julia> bitrand(rng,10)  
10-element BitVector:  
0 0 0 0 1 0 0 0 1 1

```
Base.randn– Function.

```

randn([rng=GLOBAL_RNG], [T= Float64 ], [dims...])

Generate a normally-distributed random number of typeTwith mean 0 and standard deviation 1. Option-  
ally generate an array of normally-distributed random numbers. TheBasemodule currently provides an  
implementation for the typesFloat16,Float32, andFloat64(the default), and theirComplexcounter-  
parts. When the type argument is complex, the values are drawn from the circularly symmetric complex  
normal distribution of variance 1 (corresponding to real and imaginary part having independent normal  
distribution with mean zero and variance1/2).  
Examples

julia>using Random

julia> rng = MersenneTwister (1234);

julia> randn(rng, ComplexF64)  
0.6133070881429037 - 0.6376291670853887im

julia> randn(rng, ComplexF32, (2, 3))  
2×3 Matrix{ComplexF32}:  
-0.349649-0.638457im 0.376756-0.192146im -0.396334-0.0136413im  
0.611224+1.56403im 0.355204-0.365563im 0.0905552+1.31012im

```

#### CHAPTER 83. RANDOM NUMBERS 1190

Random.randn!– Function.

```

randn!([rng=GLOBAL_RNG], A:: AbstractArray ) -> A

Fill the arrayAwith normally-distributed (mean 0, standard deviation 1) random numbers. Also see the  
randfunction.  
Examples

julia> rng = MersenneTwister (1234);

julia> randn!(rng, zeros(5))  
5-element Vector{Float64}:  
0.8673472019512456  
-0.9017438158568171  
-0.4944787535042339  
-0.9029142938652416  
0.8644013132535154

```
Random.randexp– Function.

```

randexp([rng=GLOBAL_RNG], [T= Float64 ], [dims...])

Generate a random number of typeTaccording to the exponential distribution with scale 1. Optionally  
generate an array of such random numbers. TheBasemodule currently provides an implementation for  
the typesFloat16,Float32, andFloat64(the default).  
Examples

julia> rng = MersenneTwister (1234);

julia> randexp(rng, Float32 )  
2.4835055f0

julia> randexp(rng,3, 3)  
3×3 Matrix{Float64}:  
1.5167 1.30652 0.344435  
0.604436 2.78029 0.418516  
0.695867 0.693292 0.643644

```
Random.randexp!– Function.

```

randexp!([rng=GLOBAL_RNG], A:: AbstractArray ) -> A

Fill the arrayAwith random numbers following the exponential distribution (with scale 1).  
Examples

julia> rng = MersenneTwister (1234);

julia> randexp!(rng, zeros(5))  
5-element Vector{Float64}:  
2.4835053723904896  
1.516703605376473  
0.6044364871025417  
0.6958665886385867  
1.3065196315496677

```

#### CHAPTER 83. RANDOM NUMBERS 1191

Random.randstring– Function.

```

randstring([rng=GLOBAL_RNG], [chars], [len=8])

Create a random string of lengthlen, consisting of characters fromchars, which defaults to the set of  
upper- and lower-case letters and the digits 0-9. The optionalrngargument specifies a random number  
generator, seeRandom Numbers.  
Examples

julia> Random.seed!(3); randstring()  
"Lxz5hUwn"

julia> randstring( MersenneTwister (3), 'a':'z', 6)  
"ocucay"

julia> randstring("ACGT")  
"TGCTCCTC"

Note  
charscan be any collection of characters, of typeCharorUInt8(more efficient), providedrand  
can randomly pick characters from it.

```
### 83.3 Subsequences, permutations and shuffling

Random.randsubseq– Function.

```

randsubseq([rng=GLOBAL_RNG,] A, p)-> Vector

Return a vector consisting of a random subsequence of the given arrayA, where each element ofAis  
included (in order) with independent probabilityp. (Complexity is linear inp*length(A), so this function  
is efficient even ifpis small andAis large.) Technically, this process is known as"Bernoulli sampling" ofA.  
Examples

julia> rng = MersenneTwister (1234);

julia> randsubseq(rng,1:8, 0.3)  
2-element Vector{Int64}:  
7  
8

```
Random.randsubseq!– Function.

```

randsubseq!([rng=GLOBAL_RNG,] S, A, p)

Likerandsubseq, but the results are stored inS(which is resized as needed).  
Examples

julia> rng = MersenneTwister (1234);

julia> S = Int64 [];

julia> randsubseq!(rng, S,1:8, 0.3)  
2-element Vector{Int64}:

```

#### CHAPTER 83. RANDOM NUMBERS 1192

```

7  
8

julia> S  
2-element Vector{Int64}:  
7  
8

```
Random.randperm– Function.

```

randperm([rng=GLOBAL_RNG,] n:: Integer )

Construct a random permutation of lengthn. The optionalrngargument specifies a random number  
generator (seeRandom Numbers). The element type of the result is the same as the type ofn.  
To randomly permute an arbitrary vector, seeshuffleorshuffle!.

Julia 1.1  
InJulia1.1randpermreturnsavectorvwitheltype(v) == typeof(n)whileinJulia1.0eltype(v)  
== Int.

Examples

julia> randperm( MersenneTwister (1234), 4)  
4-element Vector{Int64}:  
2  
1  
4  
3

```
Random.randperm!– Function.

```

randperm!([rng=GLOBAL_RNG,] A:: Array {<: Integer })

Construct inAa random permutation of lengthlength(A). The optionalrngargument specifies a random  
number generator (seeRandom Numbers). To randomly permute an arbitrary vector, seeshuffleor  
shuffle!.  
Examples

julia> randperm!( MersenneTwister (1234), Vector { Int }(undef,4))  
4-element Vector{Int64}:  
2  
1  
4  
3

```
Random.randcycle– Function.

```

randcycle([rng=GLOBAL_RNG,] n:: Integer )

Construct a random cyclic permutation of lengthn. The optionalrngargument specifies a random number  
generator, seeRandom Numbers. The element type of the result is the same as the type ofn.

```

#### CHAPTER 83. RANDOM NUMBERS 1193

```

Julia 1.1  
InJulia1.1randcyclereturnsavectorvwitheltype(v) == typeof(n)whileinJulia1.0eltype(v)  
== Int.

Examples

julia> randcycle( MersenneTwister (1234), 6)  
6-element Vector{Int64}:  
3 5 4 6 1 2

```
Random.randcycle!– Function.

```

randcycle!([rng=GLOBAL_RNG,] A:: Array {<: Integer })

Construct inAa random cyclic permutation of lengthlength(A). The optionalrngargument specifies a  
random number generator, seeRandom Numbers.  
Examples

julia> randcycle!( MersenneTwister (1234), Vector { Int }(undef,6))  
6-element Vector{Int64}:  
3 5 4 6 1 2

```
Random.shuffle– Function.

```

shuffle([rng=GLOBAL_RNG,] v:: AbstractArray )

Return a randomly permuted copy ofv. The optionalrngargument specifies a random number generator  
(see Random Numbers). To permutevin-place, seeshuffle!. To obtain randomly permuted indices, see  
randperm.  
Examples

julia> rng = MersenneTwister (1234);

julia> shuffle(rng, Vector (1:10))  
10-element Vector{Int64}:  
6  
1  
10  
2 3 9 5 7 4 8

```

#### CHAPTER 83. RANDOM NUMBERS 1194

Random.shuffle!– Function.

```

shuffle!([rng=GLOBAL_RNG,] v:: AbstractArray )

In-place version ofshuffle: randomly permutevin-place, optionally supplying the random-number gen-  
eratorrng.  
Examples

julia> rng = MersenneTwister (1234);

julia> shuffle!(rng, Vector (1:16))  
16-element Vector{Int64}:  
2  
15  
5  
14  
1  
9  
10  
6  
11  
3  
16  
7  
4  
12  
8  
13

```
### 83.4 Generators (creation and seeding)

Random.seed!– Function.

```

seed!([rng=GLOBAL_RNG], seed)-> rng  
seed!([rng=GLOBAL_RNG])-> rng

Reseed the random number generator:rngwill give a reproducible sequence of numbers if and only if  
aseedis provided. Some RNGs don't accept a seed, likeRandomDevice. After the call toseed!,rngis  
equivalent to a newly created object initialized with the same seed.  
Ifrngis not specified, it defaults to seeding the state of the shared task-local generator.  
Examples

julia> Random.seed!(1234);

julia> x1 = rand(2)  
2-element Array{Float64,1}:  
0.590845  
0.766797

julia> Random.seed!(1234);

julia> x2 = rand(2)  
2-element Array{Float64,1}:  
0.590845

```

#### CHAPTER 83. RANDOM NUMBERS 1195

```

0.766797

julia> x1 == x2  
true

julia> rng = MersenneTwister (1234); rand(rng,2) == x1  
true

julia>MersenneTwister (1) == Random.seed!(rng,1)  
true

julia> rand(Random.seed!(rng), Bool ) # not reproducible  
true

julia> rand(Random.seed!(rng), Bool )  
false

julia> rand( MersenneTwister (), Bool ) # not reproducible either  
true

```
Random.AbstractRNG– Type.

```

AbstractRNG

Supertype for random number generators such asMersenneTwisterandRandomDevice.

```
Random.TaskLocalRNG– Type.

```

TaskLocalRNG

TheTaskLocalRNGhas state that is local to its task, not its thread. It is seeded upon task creation, from  
the state of its parent task. Therefore, task creation is an event that changes the parent's RNG state.  
Asanupside, theTaskLocalRNGisprettyfast, andpermitsreproduciblemultithreadedsimulations(barring  
raceconditions), independentofschedulerdecisions. Aslongasthenumberofthreadsisnotusedtomake  
decisions on task creation, simulation results are also independent of the number of available threads /  
CPUs. The random stream should not depend on hardware specifics, up to endianness and possibly word  
size.  
Using or seeding the RNG of any other task than the one returned bycurrent_task()is undefined behav-  
ior: it will work most of the time, and may sometimes fail silently.

```
Random.Xoshiro– Type.

```

Xoshiro

Xoshiro256++ is a fast pseudorandom number generator originally developed by Sebastian Vigna. Refer-  
ence implementation is available at http://prng.di.unimi.it  
Apart from the high speed, Xoshiro has a small memory footprint, making it suitable for applications where  
many different random states need to be held for long time.  
Julia's Xoshiro implementation has a bulk-generation mode; this seeds new virtual PRNGs from the par-  
ent, and uses SIMD to generate in parallel (i.e. the bulk stream consists of multiple interleaved xoshiro  
instances). The virtual PRNGs are discarded once the bulk request has been serviced (and should cause  
no heap allocations).

```
Random.MersenneTwister– Type.


#### CHAPTER 83. RANDOM NUMBERS 1196

```

MersenneTwister (seed)  
MersenneTwister ()

Create aMersenneTwisterRNG object. Different RNG objects can have their own seeds, which may be  
useful for generating different streams of random numbers. Theseedmay be a non-negative integer or  
a vector ofUInt32integers. If no seed is provided, a randomly generated one is created (using entropy  
from the system). See theseed!function for reseeding an already existingMersenneTwisterobject.  
Examples

julia> rng = MersenneTwister (1234);

julia> x1 = rand(rng,2)  
2-element Vector{Float64}:  
0.5908446386657102  
0.7667970365022592

julia> rng = MersenneTwister (1234);

julia> x2 = rand(rng,2)  
2-element Vector{Float64}:  
0.5908446386657102  
0.7667970365022592

julia> x1 == x2  
true

```
Random.RandomDevice– Type.

```

RandomDevice ()

Create aRandomDeviceRNG object. Two such objects will always generate different streams of random  
numbers. The entropy is obtained from the operating system.

```
### 83.5 Hooking into theRandomAPI

There are two mostly orthogonal ways to extendRandomfunctionalities:

1. generating random values of custom types
2. creating new generators

The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases
of theRandommodule. For example, it's typically sufficient to implement onerandmethod in order to have all
other usual methods work automatically.

The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor,
in order to support usual types of generated values.

### Generating random values of custom types

Generating random values for some distributions may involve various trade-offs. Pre-computed values, such
as an alias tablefor discrete distributions, or“squeezing” functionsfor univariate distributions, can speed up
sampling considerably. How much information should be pre-computed can depend on the number of values


#### CHAPTER 83. RANDOM NUMBERS 1197

we plan to draw from a distribution. Also, some random number generators can have certain properties that
various algorithms may want to exploit.

TheRandommodule defines a customizable framework for obtaining random values that can address these
issues. Each invocation ofrandgenerates a sampler which can be customized with the above trade-offs in
mind, by adding methods toSampler, which in turn can dispatch on the random number generator, the object
that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter,
Val{1}(for a single sample) andVal{Inf}(for an arbitrary number) are used, withRandom.Repetitionan
alias for both.

The object returned bySampleris then used to generate the random values. When implementing the random
generation interface for a valueXthat can be sampled from, the implementor should define the method

```

rand(rng, sampler)

```
for the particularsamplerreturned bySampler(rng, X, repetition).

Samplers can be arbitrary values that implementrand(rng, sampler), but for most applications the following
predefined samplers may be sufficient:

1. SamplerType{T}()can be used for implementing samplers that draw from typeT(e.g.rand(Int)).
    This is the default returned bySamplerfor types.
2. SamplerTrivial(self)is a simple wrapper forself, which can be accessed with[]. This is the rec-
    ommended sampler when no pre-computed information is needed (e.g.rand(1:3)), and is the default
    returned bySamplerfor values.
3. SamplerSimple(self, data)also contains the additionaldatafield, which can be used to store arbi-
    trary pre-computed values, which should be computed in a custom method ofSampler.

We provide examples for each of these. We assume here that the choice of algorithm is independent of the
RNG, so we useAbstractRNGin our signatures.

Random.Sampler– Type.

```

Sampler(rng, x, repetition= Val (Inf))

Return a sampler object that can be used to generate random values fromrngforx.  
Whensp = Sampler(rng, x, repetition),rand(rng, sp)will be used to draw random values, and  
should be defined accordingly.  
repetitioncan beVal(1)orVal(Inf), and should be used as a suggestion for deciding the amount of  
precomputation, if applicable.  
Random.SamplerTypeandRandom.SamplerTrivialaredefaultfallbacksfortypesandvalues,respectively.  
Random.SamplerSimplecan be used to store pre-computed values without defining extra types for only  
this purpose.

```
Random.SamplerType– Type.

```

SamplerType{T}()

A sampler for types, containing no other information. The default fallback forSamplerwhen called with  
types.

```

#### CHAPTER 83. RANDOM NUMBERS 1198

Random.SamplerTrivial– Type.

```

SamplerTrivial(x)

Create a sampler that just wraps the given valuex. This is the default fall-back for values. Theeltypeof  
this sampler is equal toeltype(x).  
The recommended use case is sampling from values without precomputed data.

```
Random.SamplerSimple– Type.

```

SamplerSimple(x, data)

Create a sampler that wraps the given valuexand thedata. Theeltypeof this sampler is equal to  
eltype(x).  
The recommended use case is sampling from values with precomputed data.

```
Decoupling pre-computation from actually generating the values is part of the API, and is also available to the
user. As an example, assume thatrand(rng, 1:20)has to be called repeatedly in a loop: the way to take
advantage of this decoupling is as follows:

```

rng = MersenneTwister ()  
sp = Random.Sampler(rng,1:20) # or Random.Sampler(MersenneTwister, 1:20)  
for x in X  
n = rand(rng, sp)# similar to n = rand(rng, 1:20)

# use n

end

```
This is the mechanism that is also used in the standard library, e.g. by the default implementation of random
array generation (like inrand(1:20, 10)).

**Generating values from a type**

GivenatypeT,it 'scurrentlyassumedthatifrand(T)isdefined,anobjectoftypeTwillbeproduced.SamplerType
isthedefaultsamplerfortypes. InordertodefinerandomgenerationofvaluesoftypeT,therand(rng::AbstractRNG,
::Random.SamplerType{T})method should be defined, and should return values whatrand(rng, T)is ex-
pected to return.

Let 's take the following example: we implement aDietype, with a variable numbernof sides, numbered from
1 ton. We wantrand(Die)to produce aDiewith a random number of up to 20 sides (and at least 4):

```

struct Die  
nsides:: Int # number of sides  
end

Random.rand(rng:: AbstractRNG , ::Random.SamplerType{Die})= Die(rand(rng,4:20))

# output

```
Scalar and array methods forDienow work as expected:

```

julia> rand(Die)  
Die(5)

```

#### CHAPTER 83. RANDOM NUMBERS 1199

```

julia> rand( MersenneTwister (0), Die)  
Die(11)

julia> rand(Die,3)  
3-element Vector{Die}:  
Die(9)  
Die(15)  
Die(14)

julia> a = Vector {Die}(undef,3); rand!(a)  
3-element Vector{Die}:  
Die(19)  
Die(7)  
Die(17)

```
**A simple sampler without pre-computed data**

Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a
SamplerTrivialsampler, which is in fact the default fallback for values.

InordertodefinerandomgenerationoutofobjectsoftypeS,thefollowingmethodshouldbedefined:rand(rng::AbstractRNG,
sp::Random.SamplerTrivial{S}).Here,spsimplywrapsanobjectoftypeS,whichcanbeaccessedviasp[].
Continuing theDieexample, we want now to definerand(d::Die)to produce anIntcorresponding to one of
d's sides:

```

julia> Random.rand(rng:: AbstractRNG , d ::Random.SamplerTrivial{Die})= rand(rng,1:d[].nsides);

julia> rand(Die(4))  
1

julia> rand(Die(4), 3)  
3-element Vector{Any}:  
2  
3  
3

```
Given a collection typeS, it 's currently assumed that ifrand(::S)is defined, an object of typeeltype(S)will
be produced. In the last example, aVector{Any}is produced; the reason is thateltype(Die) == Any. The
remedy is to defineBase.eltype(::Type{Die}) = Int.

**Generating values for anAbstractFloattype**

AbstractFloattypes are special-cased, because by default random values are not produced in the whole
type domain, but rather in[0,1). The following method should be implemented forT <: AbstractFloat:
Random.rand(::AbstractRNG, ::Random.SamplerTrivial{Random.CloseOpen01{T}})

**An optimized sampler with pre-computed data**

Consider a discrete distribution, where numbers1:nare drawn with given probabilities that sum to one. When
many values are needed from this distribution, the fastest method is using analias table. We don't provide
the algorithm for building such a table here, but suppose it is available inmake_alias_table(probabilities)
instead, anddraw_number(rng, alias_table)can be used to draw a random number from it.

Suppose that the distribution is described by


#### CHAPTER 83. RANDOM NUMBERS 1200

```

struct DiscreteDistribution{V<: AbstractVector }  
probabilities::V  
end

```
and that we always want to build an alias table, regardless of the number of values needed (we learn how to
customize this below). The methods

```

Random.eltype(:: Type {<:DiscreteDistribution})= Int

function Random.Sampler(:: Type {<: AbstractRNG }, distribution::DiscreteDistribution,::Repetition)  
SamplerSimple(disribution, make_alias_table(distribution.probabilities))  
end

```
should be defined to return a sampler with pre-computed data, then

```

function rand(rng:: AbstractRNG , sp ::SamplerSimple{<:DiscreteDistribution})  
draw_number(rng, sp.data)  
end

```
will be used to draw the values.

**Custom sampler types**

TheSamplerSimpletype is sufficient for most use cases with precomputed data. However, in order to demon-
strate how to use custom sampler types, here we implement something similar toSamplerSimple.

Going back to ourDieexample:rand(::Die)uses random generation from a range, so there is an opportunity
for this optimization. We call our custom samplerSamplerDie.

```

import Random: Sampler, rand

struct SamplerDie<: Sampler{ Int } # generates values of type Int  
die::Die  
sp::Sampler{ Int } # this is an abstract type, so this could be improved  
end

Sampler(RNG:: Type {<: AbstractRNG }, die::Die, r::Random.Repetition)=  
SamplerDie(die, Sampler(RNG,1:die.nsides, r))

# the `r` parameter will be explained later on

rand(rng:: AbstractRNG , sp ::SamplerDie)= rand(rng, sp.sp)

```
It's now possible to get a sampler withsp = Sampler(rng, die), and usespinstead ofdiein anyrandcall
involvingrng. In the simplistic example above,diedoesn't need to be stored inSamplerDiebut this is often
the case in practice.

Of course, this pattern is so frequent that the helper type used above, namelyRandom.SamplerSimple, is
available, saving us the definition ofSamplerDie: we could have implemented our decoupling with:

```

Sampler(RNG:: Type {<: AbstractRNG }, die::Die, r::Random.Repetition)=  
SamplerSimple(die, Sampler(RNG,1:die.nsides, r))

rand(rng:: AbstractRNG , sp ::SamplerSimple{Die})= rand(rng, sp.data)

```

#### CHAPTER 83. RANDOM NUMBERS 1201

Here,sp.datarefers to the second parameter in the call to theSamplerSimpleconstructor (in this case equal
toSampler(rng, 1:die.nsides, r)), while theDieobject can be accessed viasp[].

LikeSamplerDie, any custom sampler must be a subtype ofSampler{T}whereTis the type of the generated
values. Note thatSamplerSimple(x, data) isa Sampler{eltype(x)}, so this constrains what the first ar-
gument toSamplerSimplecan be (it's recommended to useSamplerSimplelike in theDieexample, wherexis
simplyforwardedwhiledefiningaSamplermethod). Similarly,SamplerTrivial(x) isa Sampler{eltype(x)}.

Another helper type is currently available for other cases,Random.SamplerTag, but is considered as internal
API, and can break at any time without proper deprecations.

**Using distinct algorithms for scalar or array generation**

In some cases, whether one wants to generate only a handful of values or a large number of values will have
an impact on the choice of algorithm. This is handled with the third parameter of theSamplerconstructor.
Let 's assume we defined two helper types forDie, saySamplerDie1which should be used to generate only
few random values, andSamplerDieManyfor many values. We can use those types as follows:

```

Sampler(RNG:: Type {<: AbstractRNG }, die::Die,:: Val {1}) = SamplerDie1(...)  
Sampler(RNG:: Type {<: AbstractRNG }, die::Die,:: Val {Inf}) = SamplerDieMany(...)

```
Ofcourse,randmustalsobedefinedonthosetypes(i.e.rand(::AbstractRNG, ::SamplerDie1)andrand(::AbstractRNG,
::SamplerDieMany)). Note that, as usual,SamplerTrivialandSamplerSimplecan be used if custom types
are not necessary.

Note:Sampler(rng, x)is simply a shorthand forSampler(rng, x, Val(Inf)), andRandom.Repetitionis
an alias forUnion{Val{1}, Val{Inf}}.

### Creating new generators

The API is not clearly defined yet, but as a rule of thumb:

1. anyrandmethod producing"basic" types (isbitstypeinteger and floating types inBase) should be
    defined for this specific RNG, if they are needed;
2. other documentedrandmethods accepting anAbstractRNGshould work out of the box, (provided the
    methods from 1) what are relied on are implemented), but can of course be specialized for this RNG if
    there is room for optimization;
3. copyfor pseudo-RNGs should return an independent copy that generates the exact same random se-
    quence as the original from that point when called in the same way. When this is not feasible (e.g.
    hardware-based RNGs),copymust not be implemented.

Concerning 1), arandmethod may happen to work automatically, but it's not officially supported and may
break without warnings in a subsequent release.

To define a newrandmethod for an hypotheticalMyRNGgenerator, and a value specifications(e.g.s == Int,
ors == 1:10) of typeS==typeof(s)orS==Type{s}ifsis a type, the same two methods as we saw before
must be defined:

1. Sampler(::Type{MyRNG}, ::S, ::Repetition), which returns an object of type saySamplerS
2. rand(rng::MyRNG, sp::SamplerS)


#### CHAPTER 83. RANDOM NUMBERS 1202

It can happen thatSampler(rng::AbstractRNG, ::S, ::Repetition)is already defined in theRandommod-
ule. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular
RNG type), but the correspondingSamplerStype is considered as internal detail, and may be changed without
warning.

**Specializing array generation**

In some cases, for a given RNG type, generating an array of random values can be more efficient with a
specialized method than by merely using the decoupling technique explained before. This is for example the
case forMersenneTwister, which natively writes random values in an array.

To implement this specialization forMyRNGand for a specifications, producing elements of typeS, the following
method can be defined:rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS), whereSamplerSis the
type of the sampler returned bySampler(MyRNG, s, Val(Inf)). Instead ofAbstractArray, it 's possible to
implement the functionality only for a subtype, e.g.Array{S}. The non-mutating array method ofrandwill
automatically call this specialization internally.


**Chapter 84**

**Reproducibility**

By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom num-
ber sequence when running your program multiple times. However, a minor release of Julia (e.g. 1.3 to
1.4) may change the sequence of pseudorandom numbers generated from a specific seed, in particular if
MersenneTwisteris used. (Even if the sequence produced by a low-level function likeranddoes not change,
the output of higher-level functions likerandsubseqmay change due to algorithm updates.) Rationale: guar-
anteeing that pseudorandom streams never change prohibits many algorithmic improvements.

If you need to guarantee exact reproducibility of random data, it is advisable to simply save the data (e.g.
as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia
version and package manifest, especially if you require bit reproducibility.)

Software tests that rely on specific"random" data should also generally either save the data, embed it into the
test code, or use third-party packages likeStableRNGs.jl. On the other hand, tests that should pass for most
random data (e.g. testingA \ (A*x) ≈ xfor a random matrixA = randn(n,n)) can use an RNG with a fixed
seed to ensure that simply running the test many times does not encounter a failure due to very improbable
data (e.g. an extremely ill-conditioned matrix).

The statistical distribution from which random samples are drawn is guaranteed to be the same across any
minor Julia releases.

#### 1203


**Chapter 85**

**SHA**

Usage is very straightforward:

```

julia> using SHA

julia> bytes2hex(sha256("test"))  
"9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08"

```
Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256,
384 and 512 functions are implemented) takes in either anAbstractVector{UInt8}, anAbstractStringor
anIOobject. This makes it trivial to checksum a file:

```

shell> cat /tmp/test.txt  
test  
julia> using SHA

julia> open("/tmp/test.txt") do f  
sha2_256(f)  
end  
32-element Array { UInt8 ,1}:  
0x9f  
0x86  
0xd0  
0x81  
0x88  
0x4c  
0x7d  
0x65

0x5d  
0x6c  
0x15  
0xb0  
0xf0  
0x0a  
0x08

```
Due to the colloquial usage ofsha256to refer tosha2_256, convenience functions are provided, mapping
shaxxx()function calls tosha2_xxx(). For SHA-3, no such colloquialisms exist and the user must use the full
sha3_xxx()names.

#### 1204


#### CHAPTER 85. SHA 1205

shaxxx()takesAbstractStringand array-like objects (NTupleandArray) with elements of typeUInt8.

To create a hash from multiple items theSHAX_XXX_CTX()types can be used to create a stateful hash object
that is updated withupdate!and finalized withdigest!

```

julia> ctx = SHA2_256_CTX()  
SHA2256-bit hash state

julia> update!(ctx, b"some data")  
0x0000000000000009

julia> update!(ctx, b"some more data")  
0x0000000000000017

julia> digest!(ctx)  
32-element Vector { UInt8 }:  
0xbe  
0xcf  
0x23  
0xda  
0xaf  
0x02

0x25  
0x52  
0x19  
0xa0  
0x8b  
0xc5

```
Note that, at the time of this writing, the SHA3 code is not optimized, and as such is roughly an order of
magnitude slower than SHA2.


**Chapter 86**

**Serialization**

Serialization.serialize– Function.

```

serialize(stream:: IO , value)

Write an arbitrary value to a stream in an opaque format, such that it can be read back bydeserialize.  
The read-back value will be as identical as possible to the original. In general, this process will not work if  
the reading and writing are done by different versions of Julia, or an instance of Julia with a different system  
image.Ptrvalues are serialized as all-zero bit patterns (NULL).  
An 8-byte identifying header is written to the stream first. To avoid writing the header, construct a  
Serializeranduseitasthefirstargumenttoserializeinstead. SeealsoSerialization.writeheader.  
serialize(filename::AbstractString, value)

Open a file and serialize the given value to it.

Julia 1.1  
This method is available as of Julia 1.1.

```
Serialization.deserialize– Function.

```

deserialize(stream)

Readavaluewrittenbyserialize.deserializeassumesthebinarydatareadfromstreamiscorrectand  
has been serialized by a compatible implementation ofserialize. It has been designed with simplicity  
and performance as a goal and does not validate the data read. Malformed data can result in process  
termination. The caller has to ensure the integrity and correctness of data read fromstream.  
deserialize(filename::AbstractString)

Open a file and deserialize its contents.

Julia 1.1  
This method is available as of Julia 1.1.

```
Serialization.writeheader– Function.

```

Serialization.writeheader(s::AbstractSerializer)

Write an identifying header to the specified serializer. The header consists of 8 bytes as follows:

```
#### 1206


#### CHAPTER 86. SERIALIZATION 1207

```

Offset Description  
0 tag byte (0x37)  
1-2 signature bytes"JL"  
3 protocol version  
4 bits 0-1: endianness: 0 = little, 1 = big  
4 bits 2-3: platform: 0 = 32-bit, 1 = 64-bit  
5-7 reserved

```

**Chapter 87**

**Shared Arrays**

SharedArrays.SharedArray– Type.

```

SharedArray {T}(dims:: NTuple ; init= false , pids= Int [])  
SharedArray {T,N}(...)

Construct aSharedArrayof a bits typeTand sizedimsacrossthe processesspecified bypids- all of which  
have to be on the same host. IfNis specified by callingSharedArray{T,N}(dims), thenNmust match the  
length ofdims.  
Ifpidsis left unspecified, the shared array will be mapped across all processes on the current host, in-  
cluding the master. But,localindicesandindexpidswill only refer to worker processes. This facilitates  
work distribution code to use workers for actual computation with the master process acting as a driver.  
If aninitfunction of the typeinitfn(S::SharedArray)is specified, it is called on all the participating  
workers.  
ThesharedarrayisvalidaslongasareferencetotheSharedArrayobjectexistsonthenodewhichcreated  
the mapping.  
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids  
=Int[])  
SharedArray{T,N}(...)

Construct aSharedArraybacked by the filefilename, with element typeT(must be a bits type) and  
sizedims, across the processes specified bypids- all of which have to be on the same host. This file is  
mmapped into the host memory, with the following consequences:

```
- The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be sup-
    ported)
- Any changes you make to the array values (e.g.,A[3] = 0) will also change the values on disk

```

Ifpidsis left unspecified, the shared array will be mapped across all processes on the current host, in-  
cluding the master. But,localindicesandindexpidswill only refer to worker processes. This facilitates  
work distribution code to use workers for actual computation with the master process acting as a driver.  
modemust be one of"r","r+","w+", or"a+", and defaults to"r+"if the file specified byfilenamealready  
exists, or"w+"if not. If aninitfunction of the typeinitfn(S::SharedArray)is specified, it is called on  
all the participating workers. You cannot specify aninitfunction if the file is not writable.  
offsetallows you to skip the specified number of bytes at the beginning of the file.

```
#### 1208


#### CHAPTER 87. SHARED ARRAYS 1209

SharedArrays.SharedVector– Type.

```

SharedVector

A one-dimensionalSharedArray.

```
SharedArrays.SharedMatrix– Type.

```

SharedMatrix

A two-dimensionalSharedArray.

```
Distributed.procs– Method.

```

procs(S:: SharedArray )

Get the vector of processes mapping the shared array.

```
SharedArrays.sdata– Function.

```

sdata(S:: SharedArray )

Returns the actualArrayobject backingS.

```
SharedArrays.indexpids– Function.

```

indexpids(S:: SharedArray )

Returns the current worker's index in the list of workers mapping theSharedArray(i.e. in the same list  
returned byprocs(S)), or 0 if theSharedArrayis not mapped locally.

```
SharedArrays.localindices– Function.

```

localindices(S:: SharedArray )

Returnsarangedescribingthe"default"indicestobehandledbythecurrentprocess. Thisrangeshouldbe  
interpreted in the sense of linear indexing, i.e., as a sub-range of1:length(S). In multi-process contexts,  
returns an empty range in the parent process (or any process for whichindexpidsreturns 0).  
It's worth emphasizing thatlocalindicesexists purely as a convenience, and you can partition work on  
the array among workers any way you wish. For aSharedArray, all indices should be equally fast for each  
worker process.

```

**Chapter 88**

**Sockets**

Sockets.Sockets– Module.

```

Support for sockets. ProvidesIPAddrand subtypes,TCPSocket, andUDPSocket.

```
Sockets.connect– Method.

```

connect([host], port:: Integer ) -> TCPSocket

Connect to the hosthoston portport.

```
Sockets.connect– Method.

```

connect(path:: AbstractString ) -> PipeEndpoint

Connect to the named pipe / UNIX domain socket atpath.

```
Sockets.listen– Method.

```

listen([addr, ]port:: Integer ; backlog:: Integer =BACKLOG_DEFAULT)-> TCPServer

Listen on port on the address specified byaddr. By default this listens onlocalhostonly. To listen on  
all interfaces passIPv4(0)orIPv6(0)as appropriate.backlogdetermines how many connections can  
be pending (not having calledaccept) before the server will begin to reject them. The default value of  
backlogis 511.

```
Sockets.listen– Method.

```

listen(path:: AbstractString ) -> PipeServer

Create and listen on a named pipe / UNIX domain socket.

```
Sockets.getaddrinfo– Function.

```

getaddrinfo(host:: AbstractString , IPAddr= IPv4 ) -> IPAddr

Gets the first IP address of thehostof the specifiedIPAddrtype. Uses the operating system's underlying  
getaddrinfo implementation, which may do a DNS lookup.

```
Sockets.getipaddr– Function.

```

getipaddr()-> IPAddr

```
#### 1210


#### CHAPTER 88. SOCKETS 1211

```

Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.  
getipaddr(addr_type::Type{T}) where T<:IPAddr -> T

Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type  
are available.  
This function is a backwards-compatibility wrapper aroundgetipaddrs. New applications should use  
getipaddrsinstead.  
Examples

julia> getipaddr()  
ip"192.168.1.28"

julia> getipaddr( IPv6 )  
ip"fe80::9731:35af:e1c5:6e49"

See alsogetipaddrs.

```
Sockets.getipaddrs– Function.

```

getipaddrs(addr_type:: Type {T}=IPAddr; loopback:: Bool = false ) where T<:IPAddr-> Vector {T}

Get the IP addresses of the local machine.  
Setting the optionaladdr_typeparameter toIPv4orIPv6causes only addresses of that type to be re-  
turned.  
Theloopbackkeyword argument dictates whether loopback addresses (e.g. ip"127.0.0.1",ip"::1")  
are included.

Julia 1.2  
This function is available as of Julia 1.2.

Examples

julia> getipaddrs()  
5-element Array{IPAddr,1}:  
ip"198.51.100.17"  
ip"203.0.113.2"  
ip"2001:db8:8:4:445e:5fff:fe5d:5500"  
ip"2001:db8:8:4:c164:402e:7e3c:3668"  
ip"fe80::445e:5fff:fe5d:5500"

julia> getipaddrs( IPv6 )  
3-element Array{IPv6,1}:  
ip"2001:db8:8:4:445e:5fff:fe5d:5500"  
ip"2001:db8:8:4:c164:402e:7e3c:3668"  
ip"fe80::445e:5fff:fe5d:5500"

See alsoislinklocaladdr.

```
Sockets.islinklocaladdr– Function.

```

islinklocaladdr(addr::IPAddr)

```

#### CHAPTER 88. SOCKETS 1212

```

Tests if an IP address is a link-local address. Link-local addresses are not guaranteed to be unique beyond  
their network segment, therefore routers do not forward them. Link-local addresses are from the address  
blocks169.254.0.0/16orfe80::/10.  
Example

filter(!islinklocaladdr, getipaddrs())

```
Sockets.getalladdrinfo– Function.

```

getalladdrinfo(host:: AbstractString ) -> Vector {IPAddr}

Gets all of the IP addresses of thehost. Uses the operating system's underlyinggetaddrinfoimplemen-  
tation, which may do a DNS lookup.  
Example

julia> getalladdrinfo("google.com")  
2-element Array{IPAddr,1}:  
ip"172.217.6.174"  
ip"2607:f8b0:4000:804::200e"

```
Sockets.DNSError– Type.

```

DNSError

The type of exception thrown when an error occurs in DNS lookup. Thehostfield indicates the host URL  
string. Thecodefield indicates the error code based on libuv.

```
Sockets.getnameinfo– Function.

```

getnameinfo(host::IPAddr)-> String

Performs a reverse-lookup for IP address to return a hostname and service using the operating system's  
underlyinggetnameinfoimplementation.  
Examples

julia> getnameinfo(Sockets. IPv4 ("8.8.8.8"))  
"google-public-dns-a.google.com"

```
Sockets.getsockname– Function.

```

getsockname(sock:: Union {TCPServer, TCPSocket }) -> (IPAddr, UInt16 )

Get the IP address and port that the given socket is bound to.

```
Sockets.getpeername– Function.

```

getpeername(sock:: TCPSocket ) -> (IPAddr, UInt16 )

Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for  
connected TCP sockets.

```
Sockets.IPAddr– Type.

```

IPAddr

```

#### CHAPTER 88. SOCKETS 1213

```

Abstract supertype for IP addresses.IPv4andIPv6are subtypes of this.

```
Sockets.IPv4– Type.

```

IPv4 (host:: Integer ) -> IPv4

Returns an IPv4 object from ip addresshostformatted as anInteger.  
Examples

julia>IPv4 (3223256218)  
ip"192.30.252.154"

```
Sockets.IPv6– Type.

```

IPv6 (host:: Integer ) -> IPv6

Returns an IPv6 object from ip addresshostformatted as anInteger.  
Examples

julia>IPv6 (3223256218)  
ip"::c01e:fc9a"

```
Sockets.@ip_str– Macro.

```

@ip_strstr -> IPAddr

Parsestras an IP address.  
Examples

julia> ip"127.0.0.1"  
ip"127.0.0.1"

julia> @ip_str"2001:db8:0:0:0:0:2:1"  
ip"2001:db8::2:1"

```
Sockets.TCPSocket– Type.

```

TCPSocket (; delay= true )

Open a TCP socket using libuv. Ifdelayis true, libuv delays creation of the socket's file descriptor till the  
firstbindcall.TCPSockethas various fields to denote the state of the socket as well as its send/receive  
buffers.

```
Sockets.UDPSocket– Type.

```

UDPSocket ()

Open a UDP socket using libuv.UDPSockethas various fields to denote the state of the socket.

```
Sockets.accept– Function.

```

accept(server[, client])

Accepts a connection on the given server and returns a connection to the client. An uninitialized client  
stream may be provided, in which case it will be used instead of creating a new stream.

```

#### CHAPTER 88. SOCKETS 1214

Sockets.listenany– Function.

```

listenany([host::IPAddr,] port_hint)-> ( UInt16 , TCPServer)

Create aTCPServeron any port, using hint as a starting point. Returns a tuple of the actual port that the  
server was created on and the server itself.

```
Base.bind– Function.

```

bind(chnl:: Channel , task:: Task )

Associate the lifetime ofchnlwith a task.Channel chnlis automatically closed when the task terminates.  
Any uncaught exception in the task is propagated to all waiters onchnl.  
Thechnlobject can be explicitly closed independent of task termination. Terminating tasks have no effect  
on already closedChannelobjects.  
When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple  
channels are bound to the same task, termination of the task will close all of the bound channels.  
Examples

julia> c = Channel (0);

julia> task= @asyncforeach(i->put!(c, i),1:4);

julia> bind(c,task);

julia>for i in c  
@showi  
end ;  
i = 1  
i = 2  
i = 3  
i = 4

julia> isopen(c)  
false

julia> c = Channel (0);

julia> task= @async(put!(c,1); error("foo"));

julia> bind(c, task);

julia> take!(c)  
1

julia> put!(c,1);  
ERROR: TaskFailedException  
Stacktrace:  
[...]  
nested task error: foo  
[...]

source

```

#### CHAPTER 88. SOCKETS 1215

```

bind(socket::Union{TCPServer, UDPSocket, TCPSocket}, host::IPAddr, port::Integer; ipv6only=false,  
reuseaddr=false, kws...)

Bindsocketto the givenhost:port. Note that0.0.0.0will listen on all devices.

```
- Theipv6onlyparameter disables dual stack mode. Ifipv6only=true, only an IPv6 stack is created.
- Ifreuseaddr=true, multiple threads or processes can bind to the same address without error if they
    all setreuseaddr=true, but only the last to bind will receive any traffic.

Sockets.send– Function.

```

send(socket:: UDPSocket , host::IPAddr, port:: Integer , msg)

Sendmsgoversockettohost:port.

```
Sockets.recv– Function.

```

recv(socket:: UDPSocket )

Read a UDP packet from the specified socket, and return the bytes received. This call blocks.

```
Sockets.recvfrom– Function.

```

recvfrom(socket:: UDPSocket ) -> (host_port, data)

Read a UDP packet from the specified socket, returning a tuple of(host_port, data), wherehost_port  
will be an InetAddr{IPv4} or InetAddr{IPv6}, as appropriate.

Julia 1.3  
Prior to Julia version 1.3, the first returned value was an address (IPAddr). In version 1.3 it was  
changed to anInetAddr.

```
Sockets.setopt– Function.

```

setopt(sock:: UDPSocket ; multicast_loop=nothing, multicast_ttl=nothing, enable_broadcast=nothing,  
↪→ ttl=nothing)

Set UDP socket options.

```
- multicast_loop: loopback for multicast packets (default:true).
- multicast_ttl: TTL for multicast packets (default:nothing).
- enable_broadcast: flag must be set totrueif socket will be used for broadcast messages, or else
    the UDP system will return an access error (default:false).
- ttl: Time-to-live of packets sent on the socket (default:nothing).

Sockets.nagle– Function.

```

nagle(socket:: Union {TCPServer, TCPSocket }, enable:: Bool )

Enables or disables Nagle's algorithm on a given TCP server or socket.

Julia 1.3  
This function requires Julia 1.3 or later.

```
Sockets.quickack– Function.

```

quickack(socket:: Union {TCPServer, TCPSocket }, enable:: Bool )

On Linux systems, the TCP_QUICKACK is disabled or enabled onsocket.

```

**Chapter 89**

**Sparse Arrays**

Julia has support for sparse vectors andsparse matricesin theSparseArraysstdlib module. Sparse arrays are
arrays that contain enough zeros that storing them in a special data structure leads to savings in space and
execution time, compared to dense arrays.

### 89.1 Compressed Sparse Column (CSC) Sparse Matrix Storage

In Julia, sparse matrices are stored in theCompressed Sparse Column (CSC) format. Julia sparse matrices have
the typeSparseMatrixCSC{Tv,Ti}, whereTvis the type of the stored values, andTiis the integer type for
storing column pointers and row indices. The internal representation ofSparseMatrixCSCis as follows:

```

struct SparseMatrixCSC {Tv,Ti<: Integer } <: AbstractSparseMatrixCSC{Tv,Ti}  
m:: Int # Number of rows  
n:: Int # Number of columns  
colptr:: Vector {Ti} # Column j is in colptr[j]:(colptr[j+1]-1)  
rowval:: Vector {Ti} # Row indices of stored values  
nzval:: Vector {Tv} # Stored values, typically nonzeros  
end

```
The compressed sparse column storage makes it easy and quick to access the elements in the column of
a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as
insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all
elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.

All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance,
and to avoid expensive operations.

If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure
that you use 1-based indexing. The row indices in every column need to be sorted. If yourSparseMatrixCSC
object contains unsorted row indices, one quick way to sort them is by doing a double transpose.

In some applications, it is convenient to store explicit zero values in aSparseMatrixCSC. These are accepted
by functions inBase(but there is no guarantee that they will be preserved in mutating operations). Such
explicitly stored zeros are treated as structural nonzeros by many routines. Thennzfunction returns the
number of elements explicitly stored in the sparse data structure, including non-structural zeros. In order to
count the exact number of numerical nonzeros, usecount(!iszero, x), which inspects every stored element
of a sparse matrix.dropzeros, and the in-placedropzeros!, can be used to remove stored zeros from the
sparse matrix.

#### 1216


#### CHAPTER 89. SPARSE ARRAYS 1217

```

julia> A = sparse([1, 1, 2, 3], [ 1, 3, 2, 3], [ 0, 1, 2, 0])  
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:  
0 ⋅ 1  
⋅ 2 ⋅  
⋅ ⋅ 0

julia> dropzeros(A)  
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:  
⋅ ⋅ 1  
⋅ 2 ⋅  
⋅ ⋅ ⋅

```
### 89.2 Sparse Vector Storage.

Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia,
sparse vectors have the typeSparseVector{Tv,Ti}whereTvis the type of the stored values andTithe
integer type for the indices. The internal representation is as follows:

```

struct SparseVector{Tv,Ti<: Integer } <: AbstractSparseVector {Tv,Ti}  
n:: Int # Length of the sparse vector  
nzind:: Vector {Ti} # Indices of stored values  
nzval:: Vector {Tv} # Stored values, typically nonzeros  
end

```
As forSparseMatrixCSC, theSparseVectortype can also contain explicitly stored zeros. (SeeSparse Matrix
Storage.).

### 89.3 Sparse Vector and Matrix Constructors

The simplest way to create a sparse array is to use a function equivalent to thezerosfunction that Julia
provides for working with dense arrays. To produce a sparse array instead, you can use the same name with
anspprefix:

```

julia> spzeros(3)  
3-element SparseVector{Float64, Int64} with 0 stored entries

```
Thesparsefunction is oftena handy way to construct sparse arrays. For example, to construct a sparse matrix
we can input a vectorIof row indices, a vectorJof column indices, and a vectorVof stored values (this is also
known as theCOO (coordinate) format).sparse(I,J,V)then constructs a sparse matrix such thatS[I[k],
J[k]] = V[k]. The equivalent sparse vector constructor issparsevec, which takes the (row) index vectorI
and the vectorVwith the stored values and constructs a sparse vectorRsuch thatR[I[k]] = V[k].

```

julia> I = [1, 4, 3, 5]; J= [4, 7, 18, 9]; V= [1, 2, -5, 3];

julia> S = sparse(I,J,V)  
5×18 SparseMatrixCSC{Int64, Int64} with 4 stored entries:

julia> R = sparsevec(I,V)  
5-element SparseVector{Int64, Int64} with 4 stored entries:  
[1] = 1

```

#### CHAPTER 89. SPARSE ARRAYS 1218

```

[3] = -5  
[4] = 2  
[5] = 3

```
The inverse of thesparseandsparsevecfunctions isfindnz, which retrieves the inputs used to create the
sparse array. findall(!iszero, x)returns the cartesian indices of non-zero entries inx(including stored
entries equal to zero).

```

julia> findnz(S)  
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia> findall(!iszero, S)  
4-element Vector{CartesianIndex{2}}:  
CartesianIndex(1, 4)  
CartesianIndex(4, 7)  
CartesianIndex(5, 9)  
CartesianIndex(3, 18)

julia> findnz(R)  
([1, 3, 4, 5], [1, -5, 2, 3])

julia> findall(!iszero, R)  
4-element Vector{Int64}:  
1  
3  
4  
5

```
Another way to create a sparse array is to convert a dense array into a sparse array using thesparsefunction:

```

julia> sparse( Matrix (1.0I, 5, 5))  
5×5 SparseMatrixCSC{Float64, Int64} with 5 stored entries:  
1.0 ⋅ ⋅ ⋅ ⋅  
⋅ 1.0 ⋅ ⋅ ⋅  
⋅ ⋅ 1.0 ⋅ ⋅  
⋅ ⋅ ⋅ 1.0 ⋅  
⋅ ⋅ ⋅ ⋅ 1.0

julia> sparse([1.0, 0.0, 1.0])  
3-element SparseVector{Float64, Int64} with 2 stored entries:  
[1] = 1.0  
[3] = 1.0

```
You can go in the other direction using theArrayconstructor. Theissparsefunction can be used to query if
a matrix is sparse.

```

julia> issparse(spzeros(5))  
true

```
### 89.4 Sparse matrix operations

Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment
into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations,


#### CHAPTER 89. SPARSE ARRAYS 1219

especially assignment, are expensive, when carried out one element at a time. In many cases it may be better
to convert the sparse matrix into(I,J,V)format usingfindnz, manipulate the values or the structure in the
dense vectors(I,J,V), and then reconstruct the sparse matrix.

### 89.5 Correspondence of dense and sparse methods

Thefollowingtablegivesacorrespondencebetweenbuilt-inmethodsonsparsematricesandtheircorrespond-
ing methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense
counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrixS, or that
the resulting sparse matrix has densityd, i.e. each matrix element has a probabilitydof being non-zero.

Details can be found in theSparse Vectors and Matricessection of the standard library reference.

```

Sparse Dense Description  
spzeros(m,n)zeros(m,n)Creates a m-by-n matrix of zeros. (spzeros(m,n)is empty.)  
sparse(I,n,n)Matrix(I,n,n)Creates a n-by-n identity matrix.  
sparse(A) Array(S) Interconverts between dense and sparse formats.  
sprand(m,n,d)rand(m,n)Creates a m-by-n random matrix (of density d) with iid non-zero elements  
distributed uniformly on the half-open interval[0,1).  
sprandn(m,n,d)randn(m,n)Creates a m-by-n random matrix (of density d) with iid non-zero elements  
distributed according to the standard normal (Gaussian) distribution.  
sprandn(rng,m,n,d)randn(rng,m,n)Creates a m-by-n random matrix (of density d) with iid non-zero elements  
generated with therngrandom number generator

```

**Chapter 90**

**Sparse Arrays**

SparseArrays.AbstractSparseArray– Type.

```

AbstractSparseArray {Tv,Ti,N}

Supertype forN-dimensional sparse arrays (or array-like types) with elements of typeTvand index type  
Ti.SparseMatrixCSC,SparseVectorandSuiteSparse.CHOLMOD.Sparseare subtypes of this.

```
SparseArrays.AbstractSparseVector– Type.

```

AbstractSparseVector {Tv,Ti}

Supertype for one-dimensional sparse arrays (or array-like types) with elements of typeTvand index type  
Ti. Alias forAbstractSparseArray{Tv,Ti,1}.

```
SparseArrays.AbstractSparseMatrix– Type.

```

AbstractSparseMatrix {Tv,Ti}

Supertype for two-dimensional sparse arrays (or array-like types) with elements of typeTvand index type  
Ti. Alias forAbstractSparseArray{Tv,Ti,2}.

```
SparseArrays.SparseVector– Type.

```

SparseVector{Tv,Ti<: Integer } <: AbstractSparseVector {Tv,Ti}

Vector type for storing sparse vectors.

```
SparseArrays.SparseMatrixCSC– Type.

```

SparseMatrixCSC {Tv,Ti<: Integer } <: AbstractSparseMatrixCSC{Tv,Ti}

Matrix type for storing sparse matrices in theCompressed Sparse Columnformat. The standard way of  
constructing SparseMatrixCSC is through thesparsefunction. See alsospzeros,spdiagmandsprand.

```
SparseArrays.sparse– Function.

```

sparse(A)

Convert an AbstractMatrixAinto a sparse matrix.  
Examples

```
#### 1220


#### CHAPTER 90. SPARSE ARRAYS 1221

```

julia> A = Matrix (1.0I, 3, 3)  
3×3 Matrix{Float64}:  
1.0 0.0 0.0  
0.0 1.0 0.0  
0.0 0.0 1.0

julia> sparse(A)  
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:  
1.0 ⋅ ⋅  
⋅ 1.0 ⋅  
⋅ ⋅ 1.0

sparse(I, J, V,[ m, n, combine])

Create a sparse matrixSof dimensionsm x nsuch thatS[I[k], J[k]] = V[k]. Thecombinefunction  
is used to combine duplicates. Ifmandnare not specified, they are set tomaximum(I)andmaximum(J)  
respectively. If thecombinefunction is not supplied,combinedefaults to+unless the elements ofVare  
Booleans in which casecombinedefaults to|. All elements ofImust satisfy1 <= I[k] <= m, and all  
elementsofJmustsatisfy1 <= J[k] <= n. Numericalzerosin(I,J,V)areretainedasstructuralnonzeros;  
to drop numerical zeros, usedropzeros!.  
For additional documentation and an expert driver, seeSparseArrays.sparse!.  
Examples

julia> Is = [1; 2; 3];

julia> Js = [1; 2; 3];

julia> Vs = [1; 2; 3];

julia> sparse(Is, Js, Vs)  
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:  
1 ⋅ ⋅  
⋅ 2 ⋅  
⋅ ⋅ 3

```
SparseArrays.sparsevec– Function.

```

sparsevec(I, V, [m, combine])

CreateasparsevectorSoflengthmsuchthatS[I[k]] = V[k]. Duplicatesarecombinedusingthecombine  
function, which defaults to+if nocombineargument is provided, unless the elements ofVare Booleans in  
which casecombinedefaults to|.  
Examples

julia> II = [1, 3, 3, 5]; V= [0.1, 0.2, 0.3, 0.2];

julia> sparsevec(II, V)  
5-element SparseVector{Float64, Int64} with 3 stored entries:  
[1] = 0.1  
[3] = 0.5  
[5] = 0.2

julia> sparsevec(II, V,8, -)

```

#### CHAPTER 90. SPARSE ARRAYS 1222

```

8-element SparseVector{Float64, Int64} with 3 stored entries:  
[1] = 0.1  
[3] = -0.1  
[5] = 0.2

julia> sparsevec([1, 3, 1, 2, 2], [ true , true , false , false , false ])  
3-element SparseVector{Bool, Int64} with 3 stored entries:  
[1] = 1  
[2] = 0  
[3] = 1

sparsevec(d::Dict, [m])

Create a sparse vector of lengthmwhere the nonzero indices are keys from the dictionary, and the nonzero  
values are the values from the dictionary.  
Examples

julia> sparsevec( Dict (1 => 3, 2 => 2))  
2-element SparseVector{Int64, Int64} with 2 stored entries:  
[1] = 3  
[2] = 2

sparsevec(A)

Convert a vectorAinto a sparse vector of lengthm.  
Examples

julia> sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])  
6-element SparseVector{Float64, Int64} with 3 stored entries:  
[1] = 1.0  
[2] = 2.0  
[5] = 3.0

```
SparseArrays.issparse– Function.

```

issparse(S)

ReturnstrueifSis sparse, andfalseotherwise.  
Examples

julia> sv = sparsevec([1, 4], [ 2.3, 2.2], 10)  
10-element SparseVector{Float64, Int64} with 2 stored entries:  
[1 ] = 2.3  
[4 ] = 2.2

julia> issparse(sv)  
true

julia> issparse( Array (sv))  
false

```
SparseArrays.nnz– Function.

```

nnz(A)

```

#### CHAPTER 90. SPARSE ARRAYS 1223

```

Returns the number of stored (filled) elements in a sparse array.  
Examples

julia> A = sparse(2I, 3, 3)  
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:  
2 ⋅ ⋅  
⋅ 2 ⋅  
⋅ ⋅ 2

julia> nnz(A)  
3

```
SparseArrays.findnz– Function.

```

findnz(A:: SparseMatrixCSC )

Return a tuple(I, J, V)whereIandJare the row and column indices of the stored ("structurally non-  
zero ") values in sparse matrixA, andVis a vector of the values.  
Examples

julia> A = sparse([1 2 0; 0 0 3; 0 4 0])  
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:  
1 2 ⋅  
⋅ ⋅ 3  
⋅ 4 ⋅

julia> findnz(A)  
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])

```
SparseArrays.spzeros– Function.

```

spzeros([ type ,]m[,n])

Create a sparse vector of lengthmor sparse matrix of sizem x n. This sparse array will not contain any  
nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to  
Float64if not specified.  
Examples

julia> spzeros(3, 3)  
3×3 SparseMatrixCSC{Float64, Int64} with 0 stored entries:  
⋅ ⋅ ⋅  
⋅ ⋅ ⋅  
⋅ ⋅ ⋅

julia> spzeros( Float32 , 4)  
4-element SparseVector{Float32, Int64} with 0 stored entries

```
SparseArrays.spdiagm– Function.

```

spdiagm(kv:: Pair {<: Integer ,<: AbstractVector }...)  
spdiagm(m:: Integer , n :: Integer , kv :: Pair {<: Integer ,<: AbstractVector }...)

```

#### CHAPTER 90. SPARSE ARRAYS 1224

```

Construct a sparse diagonal matrix fromPairs of vectors and diagonals. Each vectorkv.secondwill be  
placed on thekv.firstdiagonal. By default, the matrix is square and its size is inferred fromkv, but a  
non-squaresizem×n(paddedwithzerosasneeded)canbespecifiedbypassingm,nasthefirstarguments.  
Examples

julia> spdiagm(-1 => [1,2,3,4], 1 => [4,3,2,1])  
5×5 SparseMatrixCSC{Int64, Int64} with 8 stored entries:  
⋅ 4 ⋅ ⋅ ⋅  
1 ⋅ 3 ⋅ ⋅  
⋅ 2 ⋅ 2 ⋅  
⋅ ⋅ 3 ⋅ 1  
⋅ ⋅ ⋅ 4 ⋅

spdiagm(v::AbstractVector)  
spdiagm(m::Integer, n::Integer, v::AbstractVector)

Construct a sparse matrix with elements of the vector as diagonal elements. By default (no givenmand  
n), the matrix is square and its size is given bylength(v), but a non-square sizem×ncan be specified by  
passingmandnas the first arguments.

Julia 1.6  
These functions require at least Julia 1.6.

Examples

julia> spdiagm([1,2,3])  
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:  
1 ⋅ ⋅  
⋅ 2 ⋅  
⋅ ⋅ 3

julia> spdiagm(sparse([1,0,3]))  
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:  
1 ⋅ ⋅  
⋅ ⋅ ⋅  
⋅ ⋅ 3

```
SparseArrays.blockdiag– Function.

```

blockdiag(A...)

Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.  
Examples

julia> blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))  
5×5 SparseMatrixCSC{Int64, Int64} with 5 stored entries:  
2 ⋅ ⋅ ⋅ ⋅  
⋅ 2 ⋅ ⋅ ⋅  
⋅ ⋅ 2 ⋅ ⋅  
⋅ ⋅ ⋅ 4 ⋅  
⋅ ⋅ ⋅ ⋅ 4

```
SparseArrays.sprand– Function.


#### CHAPTER 90. SPARSE ARRAYS 1225

```

sprand([rng],[ type ],m,[n],p:: AbstractFloat ,[rfn])

Create a random lengthmsparse vector ormbynsparse matrix, in which the probability of any element  
being nonzero is independently given byp(and hence the mean density of nonzeros is also exactlyp).  
Nonzero values are sampled from the distribution specified byrfnand have the typetype. The uniform  
distribution is used in caserfnis not specified. The optionalrngargument specifies a random number  
generator, seeRandom Numbers.  
Examples

julia> sprand( Bool , 2, 2, 0.5)  
2×2 SparseMatrixCSC{Bool, Int64} with 2 stored entries:  
1 1  
⋅ ⋅

julia> sprand( Float64 , 3, 0.75)  
3-element SparseVector{Float64, Int64} with 2 stored entries:  
[1] = 0.795547  
[2] = 0.49425

```
SparseArrays.sprandn– Function.

```

sprandn([rng][, Type ],m[,n],p:: AbstractFloat )

Create a random sparse vector of lengthmor sparse matrix of sizembynwith the specified (independent)  
probabilitypof any entry being nonzero, where nonzero values are sampled from the normal distribution.  
The optionalrngargument specifies a random number generator, seeRandom Numbers.

Julia 1.1  
Specifying the output element typeTyperequires at least Julia 1.1.

Examples

julia> sprandn(2, 2, 0.75)  
2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:  
-1.20577 ⋅  
0.311817 -0.234641

```
SparseArrays.nonzeros– Function.

```

nonzeros(A)

Return a vector of the structural nonzero values in sparse arrayA. This includes zeros that are explicitly  
stored in the sparse array. The returned vector points directly to the internal nonzero storage ofA, and any  
modifications to the returned vector will mutateAas well. Seerowvalsandnzrange.  
Examples

julia> A = sparse(2I, 3, 3)  
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:  
2 ⋅ ⋅  
⋅ 2 ⋅  
⋅ ⋅ 2

julia> nonzeros(A)

```

#### CHAPTER 90. SPARSE ARRAYS 1226

```

3-element Vector{Int64}:  
2  
2  
2

```
SparseArrays.rowvals– Function.

```

rowvals(A::AbstractSparseMatrixCSC)

Return a vector of the row indices ofA. Any modifications to the returned vector will mutateAas well.  
Providing access to how the row indices are stored internally can be useful in conjunction with iterating  
over structural nonzero values. See alsononzerosandnzrange.  
Examples

julia> A = sparse(2I, 3, 3)  
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:  
2 ⋅ ⋅  
⋅ 2 ⋅  
⋅ ⋅ 2

julia> rowvals(A)  
3-element Vector{Int64}:  
1  
2  
3

```
SparseArrays.nzrange– Function.

```

nzrange(A::AbstractSparseMatrixCSC, col:: Integer )

Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with  
nonzerosandrowvals, this allows for convenient iterating over a sparse matrix :  
A = sparse(I,J,V)  
rows = rowvals(A)  
vals = nonzeros(A)  
m, n = size(A)  
for j = 1:n  
for i in nzrange(A, j)  
row = rows[i]  
val = vals[i]

# perform sparse wizardry...

end  
end

nzrange(x::SparseVectorUnion, col)

Give the range of indices to the structural nonzero values of a sparse vector. The column indexcolis  
ignored (assumed to be 1 ).

```
SparseArrays.droptol!– Function.

```

droptol!(A::AbstractSparseMatrixCSC, tol)

Removes stored values fromAwhose absolute value is less than or equal totol.

```

#### CHAPTER 90. SPARSE ARRAYS 1227

```

droptol!(x::SparseVector, tol)

Removes stored values fromxwhose absolute value is less than or equal totol.

```
SparseArrays.dropzeros!– Function.

```

dropzeros!(A::AbstractSparseMatrixCSC;)

Removes stored numerical zeros fromA.  
For an out-of-place version, seedropzeros. For algorithmic information, seefkeep!.  
dropzeros!(x::SparseVector)

Removes stored numerical zeros fromx.  
For an out-of-place version, seedropzeros. For algorithmic information, seefkeep!.

```
SparseArrays.dropzeros– Function.

```

dropzeros(A::AbstractSparseMatrixCSC;)

Generates a copy ofAand removes stored numerical zeros from that copy.  
For an in-place version and algorithmic information, seedropzeros!.  
Examples

julia> A = sparse([1, 2, 3], [ 1, 2, 3], [ 1.0, 0.0, 1.0])  
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:  
1.0 ⋅ ⋅  
⋅ 0.0 ⋅  
⋅ ⋅ 1.0

julia> dropzeros(A)  
3×3 SparseMatrixCSC{Float64, Int64} with 2 stored entries:  
1.0 ⋅ ⋅  
⋅ ⋅ ⋅  
⋅ ⋅ 1.0

dropzeros(x::SparseVector)

Generates a copy ofxand removes numerical zeros from that copy.  
For an in-place version and algorithmic information, seedropzeros!.  
Examples

julia> A = sparsevec([1, 2, 3], [ 1.0, 0.0, 1.0])  
3-element SparseVector{Float64, Int64} with 3 stored entries:  
[1] = 1.0  
[2] = 0.0  
[3] = 1.0

julia> dropzeros(A)  
3-element SparseVector{Float64, Int64} with 2 stored entries:  
[1] = 1.0  
[3] = 1.0

```

#### CHAPTER 90. SPARSE ARRAYS 1228

SparseArrays.permute– Function.

```

permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p:: AbstractVector {<: Integer },  
q:: AbstractVector {<: Integer }) where {Tv,Ti}

Bilaterally permuteA, returningPAQ(A[p,q]). Column-permutationq's length must matchA's column  
count (length(q) == size(A, 2)). Row-permutationp's length must matchA's row count (length(p)  
== size(A, 1)).  
For expert drivers and additional information, seepermute!.  
Examples

julia> A = spdiagm(0 => [1, 2, 3, 4], 1 => [5, 6, 7])  
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:  
1 5 ⋅ ⋅  
⋅ 2 6 ⋅  
⋅ ⋅ 3 7  
⋅ ⋅ ⋅ 4

julia> permute(A, [4, 3, 2, 1], [ 1, 2, 3, 4])  
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:  
⋅ ⋅ ⋅ 4  
⋅ ⋅ 3 7  
⋅ 2 6 ⋅  
1 5 ⋅ ⋅

julia> permute(A, [1, 2, 3, 4], [ 4, 3, 2, 1])  
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:  
⋅ ⋅ 5 1  
⋅ 6 2 ⋅  
7 3 ⋅ ⋅  
4 ⋅ ⋅ ⋅

```
Base.permute!– Method.

```

permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},  
p:: AbstractVector {<: Integer }, q :: AbstractVector {<: Integer },  
[C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}

BilaterallypermuteA,storingresultPAQ(A[p,q])inX.Storesintermediateresult(AQ)^T(transpose(A[:,q]))  
in optional argumentCif present. Requires that none ofX,A, and, if present,Calias each other; to store  
resultPAQback intoA, use the following method lackingX:  
permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{<:Integer},  
q::AbstractVector{<:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},  
[workcolptr::Vector{Ti}]]) where {Tv,Ti}

X's dimensions must match those ofA(size(X, 1) == size(A, 1)andsize(X, 2) == size(A, 2)),  
andXmust have enough storage to accommodate all allocated entries inA(length(rowvals(X)) >=  
nnz(A)andlength(nonzeros(X)) >= nnz(A)). Column-permutationq's length must matchA's column  
count (length(q) == size(A, 2)). Row-permutationp's length must matchA's row count (length(p)  
== size(A, 1)).  
C's dimensions must match those oftranspose(A)(size(C, 1) == size(A, 2)andsize(C, 2) ==  
size(A, 1)),andCmusthaveenoughstoragetoaccommodateallallocatedentriesinA(length(rowvals(C))

> = nnz(A)andlength(nonzeros(C)) >= nnz(A)).

```

#### CHAPTER 90. SPARSE ARRAYS 1229

```

For additional (algorithmic) information, and for versions of these methods that forgo argument checking,  
see (unexported) parent methodsunchecked_noalias_permute!andunchecked_aliasing_permute!.  
See alsopermute.

```

**Chapter 91**

**Statistics**

The Statistics standard library module contains basic statistics functionality.

Statistics.std– Function.

```

std(itr; corrected:: Bool = true , mean=nothing[, dims])

Compute the sample standard deviation of collectionitr.  
The algorithm returns an estimator of the generative distribution's standard deviation under the assump-  
tion that each entry ofitris a sample drawn from the same unknown distribution, with the samples un-  
correlated. For arrays, this computation is equivalent to calculatingsqrt(sum((itr .- mean(itr)).^2)  
/ (length(itr) - 1)). Ifcorrectedistrue, then the sum is scaled withn-1, whereas the sum is scaled  
withnifcorrectedisfalsewithnthe number of elements initr.  
Ifitris anAbstractArray,dimscan be provided to compute the standard deviation over dimensions,  
andmeansmay contain means for each dimension ofitr.  
A pre-computedmeanmay be provided. Whendimsis specified,meanmust be an array with the same  
shape asmean(itr, dims=dims)(additional trailing singleton dimensions are allowed).

Note  
If array containsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
dence if array contains both). Use theskipmissingfunction to omitmissingentries and com-  
pute the standard deviation of non-missing values.

```
Statistics.stdm– Function.

```

stdm(itr, mean; corrected:: Bool = true )

Compute the sample standard deviation of collectionitr, with known mean(s)mean.  
The algorithm returns an estimator of the generative distribution's standard deviation under the assump-  
tion that each entry ofitris a sample drawn from the same unknown distribution, with the samples un-  
correlated. For arrays, this computation is equivalent to calculatingsqrt(sum((itr .- mean(itr)).^2)  
/ (length(itr) - 1)). Ifcorrectedistrue, then the sum is scaled withn-1, whereas the sum is scaled  
withnifcorrectedisfalsewithnthe number of elements initr.  
Ifitris anAbstractArray,dimscan be provided to compute the standard deviation over dimensions.  
In that case,meanmust be an array with the same shape asmean(itr, dims=dims)(additional trailing  
singleton dimensions are allowed).

```
#### 1230


#### CHAPTER 91. STATISTICS 1231

```

Note  
If array containsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
dence if array contains both). Use theskipmissingfunction to omitmissingentries and com-  
pute the standard deviation of non-missing values.

```
Statistics.var– Function.

```

var(itr; corrected:: Bool = true , mean=nothing[, dims])

Compute the sample variance of collectionitr.  
The algorithm returns an estimator of the generative distribution's variance under the assumption that  
each entry ofitris a sample drawn from the same unknown distribution, with the samples uncorrelated.  
For arrays, this computation is equivalent to calculatingsum((itr .- mean(itr)).^2) / (length(itr)

```
- 1)). Ifcorrectedistrue, thenthesumisscaledwithn-1, whereasthesumisscaledwithnifcorrected
isfalsewherenis the number of elements initr.
Ifitris anAbstractArray,dimscan be provided to compute the variance over dimensions.
A pre-computedmeanmay be provided. Whendimsis specified,meanmust be an array with the same
shape asmean(itr, dims=dims)(additional trailing singleton dimensions are allowed).

```

Note  
If array containsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
dence if array contains both). Use theskipmissingfunction to omitmissingentries and com-  
pute the variance of non-missing values.

```
Statistics.varm– Function.

```

varm(itr, mean; dims, corrected:: Bool = true )

Compute the sample variance of collectionitr, with known mean(s)mean.  
The algorithm returns an estimator of the generative distribution's variance under the assumption that  
each entry ofitris a sample drawn from the same unknown distribution, with the samples uncorrelated.  
For arrays, this computation is equivalent to calculatingsum((itr .- mean(itr)).^2) / (length(itr)

```
- 1). Ifcorrectedistrue, then the sum is scaled withn-1, whereas the sum is scaled withnifcorrected
isfalsewithnthe number of elements initr.
Ifitris anAbstractArray,dimscan be provided to compute the variance over dimensions. In that
case,meanmust be an array with the same shape asmean(itr, dims=dims)(additional trailing singleton
dimensions are allowed).

```

Note  
If array containsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
dence if array contains both). Use theskipmissingfunction to omitmissingentries and com-  
pute the variance of non-missing values.

```
Statistics.cor– Function.

```

cor(x:: AbstractVector )

Return the number one.  
cor(X::AbstractMatrix; dims::Int=1)

```

#### CHAPTER 91. STATISTICS 1232

```

Compute the Pearson correlation matrix of the matrixXalong the dimensiondims.  
cor(x::AbstractVector, y::AbstractVector)

Compute the Pearson correlation between the vectorsxandy.  
cor(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims=1)

Compute the Pearson correlation between the vectors or matricesXandYalong the dimensiondims.

```
Statistics.cov– Function.

```

cov(x:: AbstractVector ; corrected:: Bool = true )

Compute the variance of the vectorx. Ifcorrectedistrue(the default) then the sum is scaled withn-1,  
whereas the sum is scaled withnifcorrectedisfalsewheren = length(x).  
cov(X::AbstractMatrix; dims::Int=1, corrected::Bool=true)

Compute the covariance matrix of the matrixXalong the dimensiondims. Ifcorrectedistrue(the  
default) then the sum is scaled withn-1, whereas the sum is scaled withnifcorrectedisfalsewheren  
= size(X, dims).  
cov(x::AbstractVector, y::AbstractVector; corrected::Bool=true)

Compute the covariance between the vectorsxandy. Ifcorrectedistrue(the default), computes  
1  
n− 1

∑n  
i=1(xi−x ̄)(yi−y ̄)

∗where∗denotes the complex conjugate andn = length(x) = length(y).  
Ifcorrectedisfalse, computes^1 n

∑n  
i=1(xi− ̄x)(yi− ̄y)

```
#### ∗.

```

cov(X::AbstractVecOrMat, Y::AbstractVecOrMat; dims::Int=1, corrected::Bool=true)

Compute the covariance between the vectors or matricesXandYalong the dimensiondims. Ifcorrected  
istrue(the default) then the sum is scaled withn-1, whereas the sum is scaled withnifcorrectedis  
falsewheren = size(X, dims) = size(Y, dims).

```
Statistics.mean!– Function.

```

mean!(r, v)

Compute the mean ofvover the singleton dimensions ofr, and write results tor.  
Examples

julia>using Statistics

julia> v = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> mean!([1., 1.], v)  
2-element Vector{Float64}:  
1.5  
3.5

julia> mean!([1. 1.], v)  
1×2 Matrix{Float64}:  
2.0 3.0

```

#### CHAPTER 91. STATISTICS 1233

Statistics.mean– Function.

```

mean(itr)

Compute the mean of all elements in a collection.

Note  
IfitrcontainsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
dence if array contains both). Use theskipmissingfunction to omitmissingentries and com-  
pute the mean of non-missing values.

Examples

julia>using Statistics

julia> mean(1:20)  
10.5

julia> mean([1, missing,3])  
missing

julia> mean(skipmissing([1, missing,3]))  
2.0

mean(f::Function, itr)

Apply the functionfto each element of collectionitrand take the mean.

julia>using Statistics

julia> mean(√, [ 1, 2, 3])  
1.3820881233139908

julia> mean([√1, √2, √3])  
1.3820881233139908

mean(f::Function, A::AbstractArray; dims)

Apply the functionfto each element of arrayAand take the mean over dimensionsdims.

Julia 1.3  
This method requires at least Julia 1.3.

julia>using Statistics

julia> mean(√, [ 1, 2, 3])  
1.3820881233139908

julia> mean([√1, √2, √3])  
1.3820881233139908

julia> mean(√, [ 1 2 3; 4 5 6], dims=2)  
2×1 Matrix{Float64}:  
1.3820881233139908  
2.2285192400943226

```

#### CHAPTER 91. STATISTICS 1234

```

mean(A::AbstractArray; dims)

Compute the mean of an array over the given dimensions.

Julia 1.1  
meanfor empty arrays requires at least Julia 1.1.

Examples

julia>using Statistics

julia> A = [1 2; 3 4]  
2×2 Matrix{Int64}:  
1 2  
3 4

julia> mean(A, dims=1)  
1×2 Matrix{Float64}:  
2.0 3.0

julia> mean(A, dims=2)  
2×1 Matrix{Float64}:  
1.5  
3.5

```
Statistics.median!– Function.

```

median!(v)

Likemedian, but may overwrite the input vector.

```
Statistics.median– Function.

```

median(itr)

Compute the median of all elements in a collection. For an even number of elements no exact median  
element exists, so the result is equivalent to calculating mean of two median elements.

Note  
IfitrcontainsNaNormissingvalues, the result is alsoNaNormissing(missingtakes prece-  
denceifitrcontainsboth). Usetheskipmissingfunctiontoomitmissingentriesandcompute  
the median of non-missing values.

Examples

julia>using Statistics

julia> median([1, 2, 3])  
2.0

julia> median([1, 2, 3, 4])  
2.5

julia> median([1, 2, missing,4])  
missing

```

#### CHAPTER 91. STATISTICS 1235

```

julia> median(skipmissing([1, 2, missing,4]))  
2.0

median(A::AbstractArray; dims)

Compute the median of an array along the given dimensions.  
Examples  
julia> using Statistics

julia> median([1 2; 3 4], dims=1)  
1×2 Matrix{Float64}:  
2.0 3.0

```
Statistics.middle– Function.

```

middle(x)

Compute the middle of a scalar value, which is equivalent toxitself, but of the type ofmiddle(x, x)for  
consistency.  
middle(x, y)

Compute the middle of two numbersxandy, which is equivalent in both value and type to computing their  
mean ((x + y) / 2).  
middle(range)

Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is  
sorted, the mean is performed with the first and last element.

julia>using Statistics

julia> middle(1:10)  
5.5

middle(a)

Compute the middle of an arraya, which consists of finding its extrema and then computing their mean.

julia>using Statistics

julia> a = [1,2,3.6,10.9]  
4-element Vector{Float64}:  
1.0  
2.0  
3.6  
10.9

julia> middle(a)  
5.95

```
Statistics.quantile!– Function.

```

quantile!([q:: AbstractArray , ] v:: AbstractVector , p; sorted= false , alpha:: Real =1.0,  
↪→ beta:: Real =alpha)

```

#### CHAPTER 91. STATISTICS 1236

```

Compute the quantile(s) of a vectorvat a specified probability or vector or tuple of probabilitiespon the  
interval [0,1]. Ifpis a vector, an optional output arrayqmay also be specified. (If not provided, a new  
output array is created.) The keyword argumentsortedindicates whethervcan be assumed to be sorted;  
iffalse(the default), then the elements ofvwill be partially sorted in-place.  
Bydefault(alpha = beta = 1),quantilesarecomputedvialinearinterpolationbetweenthepoints((k-1)/(n-1),  
v[k]), fork = 1:nwheren = length(v). This corresponds to Definition 7 of Hyndman and Fan (1996),  
and is the same as the R and NumPy default.  
The keyword argumentsalphaandbetacorrespond to the same parameters in Hyndman and Fan, setting  
them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:

```
- Def. 4:alpha=0,beta=1
- Def. 5:alpha=0.5,beta=0.5
- Def. 6:alpha=0,beta=0(ExcelPERCENTILE.EXC, Python default, Stataaltdef)
- Def. 7:alpha=1,beta=1(Julia, RandNumPydefault, ExcelPERCENTILEandPERCENTILE.INC,Python
    'inclusive')
- Def. 8:alpha=1/3,beta=1/3
- Def. 9:alpha=3/8,beta=3/8

```

Note  
AnArgumentErroris thrown ifvcontainsNaNormissingvalues.

References

```
- Hyndman,R.JandFan,Y.(1996)"SampleQuantilesinStatisticalPackages",TheAmericanStatistician,
    Vol. 50, No. 4, pp. 361-365
- Quantile on Wikipediadetails the different quantile definitions

```

Examples

julia>using Statistics

julia> x = [3, 2, 1];

julia> quantile!(x,0.5)  
2.0

julia> x  
3-element Vector{Int64}:  
1  
2  
3

julia> y = zeros(3);

julia> quantile!(y, x, [0.1, 0.5, 0.9]) === y  
true

julia> y  
3-element Vector{Float64}:  
1.2000000000000002  
2.0  
2.8000000000000003

```

#### CHAPTER 91. STATISTICS 1237

Statistics.quantile– Function.

```

quantile(itr, p; sorted= false , alpha:: Real =1.0, beta:: Real =alpha)

Compute the quantile(s) of a collectionitrat a specified probability or vector or tuple of probabilitiesp  
on the interval [0,1]. The keyword argumentsortedindicates whetheritrcan be assumed to be sorted.  
Samples quantile are defined byQ(p) = (1-γ)_x[j] + γ_x[j+1], wherex[j]is the j-th order statistic,  
andγis a function ofj = floor(n_p + m),m = alpha + p_(1 - alpha - beta)andg = n*p + m - j.  
Bydefault(alpha = beta = 1),quantilesarecomputedvialinearinterpolationbetweenthepoints((k-1)/(n-1),  
v[k]), fork = 1:nwheren = length(itr). This corresponds to Definition 7 of Hyndman and Fan (1996),  
and is the same as the R and NumPy default.  
The keyword argumentsalphaandbetacorrespond to the same parameters in Hyndman and Fan, setting  
them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:

```
- Def. 4:alpha=0,beta=1
- Def. 5:alpha=0.5,beta=0.5
- Def. 6:alpha=0,beta=0(ExcelPERCENTILE.EXC, Python default, Stataaltdef)
- Def. 7:alpha=1,beta=1(Julia, RandNumPydefault, ExcelPERCENTILEandPERCENTILE.INC,Python
    'inclusive')
- Def. 8:alpha=1/3,beta=1/3
- Def. 9:alpha=3/8,beta=3/8

```

Note  
AnArgumentErroristhrownifvcontainsNaNormissingvalues. Usetheskipmissingfunction  
to omitmissingentries and compute the quantiles of non-missing values.

References

```
- Hyndman,R.JandFan,Y.(1996)"SampleQuantilesinStatisticalPackages",TheAmericanStatistician,
    Vol. 50, No. 4, pp. 361-365
- Quantile on Wikipediadetails the different quantile definitions

```

Examples

julia>using Statistics

julia> quantile(0:20, 0.5)  
10.0

julia> quantile(0:20, [ 0.1, 0.5, 0.9])  
3-element Vector{Float64}:  
2.0  
10.0  
18.000000000000004

julia> quantile(skipmissing([1, 10, missing]),0.5)  
5.5

```

**Chapter 92**

**Sparse Linear Algebra**

Sparse matrix solvers call functions fromSuiteSparse. The following factorizations are available:

```

Type Description  
SuiteSparse.CHOLMOD.Factor Cholesky factorization  
SuiteSparse.UMFPACK.UmfpackLU LU factorization  
SuiteSparse.SPQR.QRSparse QR factorization

```
OthersolverssuchasPardiso.jlareasexternalpackages.Arpack.jlprovideseigsandsvdsforiterativesolution
of eigensystems and singular value decompositions.

These factorizations are described in theLinear Algebrasection of the manual:

1. cholesky
2. ldlt
3. lu
4. qr

SuiteSparse.CHOLMOD.lowrankupdate– Function.

```

lowrankupdate(F::CHOLMOD.Factor, C:: AbstractArray ) -> FF::CHOLMOD.Factor

Get anLDLtFactorization ofA + C*C'given anLDLtorLLtfactorizationFofA.  
The returned factor is always anLDLtfactorization.  
See alsolowrankupdate!,lowrankdowndate,lowrankdowndate!.

```
SuiteSparse.CHOLMOD.lowrankupdate!– Function.

```

lowrankupdate!(F::CHOLMOD.Factor, C:: AbstractArray )

Update anLDLtorLLtFactorizationFofAto a factorization ofA + C*C'.  
LLtfactorizations are converted toLDLt.  
See alsolowrankupdate,lowrankdowndate,lowrankdowndate!.

```
SuiteSparse.CHOLMOD.lowrankdowndate– Function.

#### 1238


#### CHAPTER 92. SPARSE LINEAR ALGEBRA 1239

```

lowrankupdate(F::CHOLMOD.Factor, C:: AbstractArray ) -> FF::CHOLMOD.Factor

Get anLDLtFactorization ofA + C*C'given anLDLtorLLtfactorizationFofA.  
The returned factor is always anLDLtfactorization.  
See alsolowrankdowndate!,lowrankupdate,lowrankupdate!.

```
SuiteSparse.CHOLMOD.lowrankdowndate!– Function.

```

lowrankdowndate!(F::CHOLMOD.Factor, C:: AbstractArray )

Update anLDLtorLLtFactorizationFofAto a factorization ofA - C*C'.  
LLtfactorizations are converted toLDLt.  
See alsolowrankdowndate,lowrankupdate,lowrankupdate!.

```
SuiteSparse.CHOLMOD.lowrankupdowndate!– Function.

```

lowrankupdowndate!(F::CHOLMOD.Factor, C::Sparse, update:: Cint )

Update anLDLtorLLtFactorizationFofAto a factorization ofA ± C_C'.  
If sparsity preserving factorization is used, i.e. L_L' == P_A_P'then the new factor will beL_L' ==  
P_A_P' + C'_C  
update:Cint(1)forA + CC',Cint(0)forA - CC'

```

**Chapter 93**

**TOML**

TOML.jl is a Julia standard library for parsing and writingTOML v1.0files.

### 93.1 Parsing TOML data.

```

julia>using TOML

julia> data= """  
[database]  
server = "192.168.1.1"  
ports = [ 8001, 8001, 8002 ]  
""";

julia> TOML.parse(data)  
Dict{String, Any} with 1 entry:  
"database" => Dict{String, Any}("server"=>"192.168.1.1", "ports"=>[8001, 8001...

```
To parse a file, useTOML.parsefile. If the file has a syntax error, an exception is thrown:

```

julia>using TOML

julia> TOML.parse("""  
value = 0.0.0  
""")  
ERROR: TOML Parser error:  
none:1:16 error: failed to parse value  
value = 0.0.0  
^  
[...]

```
There are other versions of the parse functions (TOML.tryparseand [TOML.tryparsefile]) that instead of
throwing exceptions on parser error returns aTOML.ParserErrorwith information:

```

julia>using TOML

julia> err = TOML.tryparse("""  
value = 0.0.0  
""");

```
#### 1240


#### CHAPTER 93. TOML 1241

```

julia> err. type  
ErrGenericValueError::ErrorType = 14

julia> err.line  
1

julia> err.column  
16

```
### 93.2 Exporting data to TOML file

TheTOML.printfunction is used to print (or serialize) data into TOML format.

```

julia>using TOML

julia> data= Dict (  
"names"=> ["Julia", "Julio"],  
"age"=> [10, 20],  
);

julia> TOML.print(data)  
names = ["Julia", "Julio"]  
age = [10, 20]

julia> fname= tempname();

julia> open(fname,"w") do io  
TOML.print(io, data)  
end

julia> TOML.parsefile(fname)  
Dict{String, Any} with 2 entries:  
"names" => ["Julia", "Julio"]  
"age" => [10, 20]

```
Keys can be sorted according to some value

```

julia>using TOML

julia> TOML.print( Dict (  
"abc" => 1,  
"ab" => 2,  
"abcd"=> 3,  
); sorted= true , by =length)  
ab = 2  
abc = 1  
abcd = 3

```
For custom structs, pass a function that converts the struct to a supported type

```

julia>using TOML

julia> struct MyStruct

```

#### CHAPTER 93. TOML 1242

```

a:: Int  
b::String  
end

julia> TOML.print( Dict ("foo"=> MyStruct(5, "bar"))) do x  
x isa MyStruct&& return [x.a, x .b]  
error("unhandled type $ (typeof(x))")  
end  
foo = [5, "bar"]

```
### 93.3 References.

TOML.parse– Function.

```

parse(x:: Union { AbstractString , IO })  
parse(p::Parser, x:: Union { AbstractString , IO })

Parse the string or streamx, and return the resulting table (dictionary). Throw aParserErrorupon failure.  
See alsoTOML.tryparse.

```
TOML.parsefile– Function.

```

parsefile(f:: AbstractString )  
parsefile(p::Parser, f:: AbstractString )

Parse filefand return the resulting table (dictionary). Throw aParserErrorupon failure.  
See alsoTOML.tryparsefile.

```
TOML.tryparse– Function.

```

tryparse(x:: Union { AbstractString , IO })  
tryparse(p::Parser, x:: Union { AbstractString , IO })

Parsethestringorstreamx, andreturntheresultingtable(dictionary). ReturnaParserErroruponfailure.  
See alsoTOML.parse.

```
TOML.tryparsefile– Function.

```

tryparsefile(f:: AbstractString )  
tryparsefile(p::Parser, f:: AbstractString )

Parse filefand return the resulting table (dictionary). Return aParserErrorupon failure.  
See alsoTOML.parsefile.

```
TOML.print– Function.

```

print([to_toml:: Function ], io:: IO [=stdout], data::AbstractDict; sorted= false , by =identity)

Writedataas TOML syntax to the streamio. If the keyword argumentsortedis set totrue, sort tables  
according to the function given by the keyword argumentby.  
The following data types are supported:AbstractDict,Integer,AbstractFloat,Bool,Dates.DateTime,  
Dates.Time,Dates.Date. Note that the integers and floats need to be convertible toFloat64andInt64  
respectively. For other data types, pass the functionto_tomlthat takes the data types and returns a value  
of a supported type.

```

#### CHAPTER 93. TOML 1243

TOML.Parser– Type.

```

Parser()

Constructor for a TOMLParser. Note that in most cases one does not need to explicitly create aParser  
but instead one directly use useTOML.parsefileorTOML.parse. Using an explicit parser will however  
reuse some internal data structures which can be beneficial for performance if a larger number of small  
files are parsed.

```
TOML.ParserError– Type.

```

ParserError

Type that is returned fromtryparseandtryparsefilewhen parsing fails. It contains (among others) the  
following fields:

```
- pos, the position in the string when the error happened
- table, the result that so far was successfully parsed
- type, an error type, different for different types of errors


**Chapter 94**

**Unit Testing**

### 94.1 Testing Base Julia

Juliaisunderrapiddevelopmentandhasanextensivetestsuitetoverifyfunctionalityacrossmultipleplatforms.
If you build Julia from source, you can run this test suite withmake test. In a binary install, you can run the
test suite usingBase.runtests().

Base.runtests– Function.

```

Base.runtests(tests=["all"]; ncores=ceil( Int , Sys.CPU_THREADS/ 2),  
exit_on_error= false , revise= false , [seed])

Run the Julia unit tests listed intests, which can be either a string or an array of strings, usingncores  
processors. Ifexit_on_errorisfalse, when one test fails, all remaining tests in other files will still be  
run; they are otherwise discarded, whenexit_on_error == true. Ifreviseistrue, theRevisepackage  
is used to load any modifications toBaseor to the standard libraries before running the tests. If a seed is  
provided via the keyword argument, it is used to seed the global RNG in the context where the tests are  
run; otherwise the seed is chosen randomly.  
source

```
### 94.2 Basic Unit Tests

TheTestmodule provides simple unit testing functionality. Unit testing is a way to see if your code is correct
by checking that the results are what you expect. It can be helpful to ensure your code still works after you
make changes, and can be used when developing as a way of specifying the behaviors your code should have
when complete.

Simple unit testing can be performed with the@testand@test_throwsmacros:

Test.@test– Macro.

```

@testex  
@testf(args...) key=val ...  
@testex broken= true  
@testex skip= true

Tests that the expressionexevaluates totrue. Returns aPass Resultif it does, aFail Resultif it is  
false, and anError Resultif it could not be evaluated.  
Examples

```
#### 1244


#### CHAPTER 94. UNIT TESTING 1245

```

julia> @test true  
Test Passed  
Expression: true

julia> @test[1, 2] + [2, 1] == [3, 3]  
Test Passed  
Expression: [1, 2] + [2, 1] == [3, 3]  
Evaluated: [3, 3] == [3, 3]

The@test f(args...) key=val...formisequivalenttowriting@test f(args..., key=val...)which  
can be useful when the expression is a call using infix syntax such as approximate comparisons:

julia> @testπ ≈ 3.14atol=0.01  
Test Passed  
Expression: ≈(π, 3.14, atol = 0.01)  
Evaluated: ≈(π, 3.14; atol = 0.01)

This is equivalent to the uglier test@test ≈(π, 3.14, atol=0.01). It is an error to supply more than one  
expression unless the first is a call expression and the rest are assignments (k=v).  
You can use any key for thekey=valarguments, except forbrokenandskip, which have special meanings  
in the context of@test:

```
- broken=condindicates a test that should pass but currently consistently fails whencond==true.
    Tests that the expressionexevaluates tofalseor causes an exception. Returns aBroken Resultif
    it does, or anError Resultif the expression evaluates totrue. Regular@test exis evaluated when
    cond==false.
- skip=condmarksatestthatshouldnotbeexecutedbutshouldbeincludedintestsummaryreporting
    asBroken, whencond==true. This can be useful for tests that intermittently fail, or tests of not-yet-
    implemented functionality. Regular@test exis evaluated whencond==false.

```

Examples

julia> @test2 + 2 ≈ 6 atol=1 broken= true  
Test Broken  
Expression: ≈(2 + 2, 6, atol = 1)

julia> @test2 + 2 ≈ 5 atol=1 broken= false  
Test Passed  
Expression: ≈(2 + 2, 5, atol = 1)  
Evaluated: ≈(4, 5; atol = 1)

julia> @test2 + 2 == 5 skip= true  
Test Broken  
Skipped: 2 + 2 == 5

julia> @test2 + 2 == 4 skip= false  
Test Passed  
Expression: 2 + 2 == 4  
Evaluated: 4 == 4

Julia 1.7  
Thebrokenandskipkeyword arguments require at least Julia 1.7.

```
Test.@test_throws– Macro.


#### CHAPTER 94. UNIT TESTING 1246

```

@test_throwsexception expr

Tests that the expressionexprthrowsexception. The exception may specify either a type, or a value  
(which will be tested for equality by comparing fields). Note that@test_throwsdoes not support a trailing  
keyword form.  
Examples

julia> @test_throws BoundsError [1, 2, 3][4]  
Test Passed  
Expression: ([1, 2, 3])[4]  
Thrown: BoundsError

julia> @test_throws DimensionMismatch [1, 2, 3] + [1, 2]  
Test Passed  
Expression: [1, 2, 3] + [1, 2]  
Thrown: DimensionMismatch

```
For example, suppose we want to check our new functionfoo(x)works as expected:

```

julia>using Test

julia> foo(x)= length(x)^2  
foo (generic function with 1 method)

```
If the condition is true, aPassis returned:

```

julia> @testfoo("bar") == 9  
Test Passed  
Expression: foo("bar") == 9  
Evaluated: 9 == 9

julia> @testfoo("fizz") >= 10  
Test Passed  
Expression: foo("fizz") >= 10  
Evaluated: 16 >= 10

```
If the condition is false, then aFailis returned and an exception is thrown:

```

julia> @testfoo("f") == 20  
Test Failed at none:1  
Expression: foo("f") == 20  
Evaluated: 1 == 20  
ERROR: There was an error during testing

```
If the condition could not be evaluated because an exception was thrown, which occurs in this case because
lengthis not defined for symbols, anErrorobject is returned and an exception is thrown:

```

julia> @testfoo(:cat)== 1  
Error During Test  
Test threw an exception of type MethodError  
Expression: foo(:cat) == 1  
MethodError: no method matching length(::Symbol)

```

#### CHAPTER 94. UNIT TESTING 1247

```

Closest candidates are:  
length(::SimpleVector) at essentials.jl:256  
length(::Base.MethodList) at reflection.jl:521  
length(::MethodTable) at reflection.jl:597

Stacktrace:  
[...]  
ERROR: There was an error during testing

```
If we expect that evaluating an expression should throw an exception, then we can use@test_throwsto check
that this occurs:

```

julia> @test_throws MethodError foo(:cat)  
Test Passed  
Expression: foo(:cat)  
Thrown: MethodError

```
### 94.3 Working with Test Sets.

Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the
event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable
to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.

```

Note  
The@testsetwill create a local scope of its own when running the tests in it.

```
The@testsetmacro can be used to group tests into sets. All the tests in a test set will be run, and at the end
of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error,
the test set will then throw aTestSetException.

Test.@testset– Macro.

```

@testset[CustomTestSet] [option=val ...] [ "description"] begin ... end  
@testset[CustomTestSet] [option=val ...] [ "description $v "] for v in (...) ... end  
@testset[CustomTestSet] [option=val ...] [ "description $v , $w "] for v in (...), w in (...) ...  
↪→ end

Starts a new test set, or multiple test sets if aforloop is provided.  
IfnocustomtestsettypeisgivenitdefaultstocreatingaDefaultTestSet.DefaultTestSetrecordsallthe  
results and, if there are anyFails orErrors, throws an exception at the end of the top-level (non-nested)  
test set, along with a summary of the test results.  
Any custom testset type (subtype ofAbstractTestSet) can be given and it will also be used for any nested  
@testsetinvocations. The given options are only applied to the test set where they are given. The default  
test set type accepts theverboseboolean option: iftrue, the result summary of the nested testsets is  
shown even when they all pass (the default isfalse).  
The description string accepts interpolation from the loop indices. If no description is provided, one is  
constructed based on the variables.  
By default the@testsetmacro will return the testset object itself, though this behavior can be customized  
in other testset types. If aforloop is used then the macro collects and returns a list of the return values  
of thefinishmethod, which by default will return a list of the testset objects used in each iteration.

```

#### CHAPTER 94. UNIT TESTING 1248

```

Before the execution of the body of a@testset, there is an implicit call toRandom.seed!(seed)where  
seedis the current seed of the global RNG. Moreover, after the execution of the body, the state of the  
global RNG is restored to what it was before the@testset. This is meant to ease reproducibility in case of  
failure, and to allow seamless re-arrangements of@testsets regardless of their side-effect on the global  
RNG state.  
Examples

julia> @testset"trigonometric identities" begin  
θ = 2/3_π  
@testsin(-θ) ≈-sin(θ)  
@testcos(-θ) ≈ cos(θ)  
@testsin(2θ) ≈2_sin(θ)*cos(θ)  
@testcos(2θ) ≈ cos(θ)^2 - sin(θ)^2  
end ;  
Test Summary: | Pass Total  
trigonometric identities | 4 4

```
Test.TestSetException– Type.

```

TestSetException

Thrown when a test set finishes and not all tests passed.

```
We can put our tests for thefoo(x)function in a test set:

```

julia> @testset"Foo Tests" begin  
@testfoo("a") == 1  
@testfoo("ab") == 4  
@testfoo("abc") == 9  
end ;  
Test Summary: | Pass Total  
Foo Tests | 3 3

```
Test sets can also be nested:

```

julia> @testset"Foo Tests" begin  
@testset"Animals" begin  
@testfoo("cat") == 9  
@testfoo("dog") == foo("cat")  
end  
@testset"Arrays $i " for i in 1:3  
@testfoo(zeros(i))== i^2  
@testfoo(fill(1.0, i))== i^2  
end  
end ;  
Test Summary: | Pass Total  
Foo Tests | 8 8

```
In the event that a nested test set has no failures, as happened here, it will be hidden in the summary, unless
theverbose=trueoption is passed:


#### CHAPTER 94. UNIT TESTING 1249

```

julia> @testsetverbose= true "Foo Tests" begin  
@testset"Animals" begin  
@testfoo("cat") == 9  
@testfoo("dog") == foo("cat")  
end  
@testset"Arrays $i " for i in 1:3  
@testfoo(zeros(i))== i^2  
@testfoo(fill(1.0, i))== i^2  
end  
end ;  
Test Summary: | Pass Total  
Foo Tests | 8 8  
Animals | 2 2  
Arrays 1 | 2 2  
Arrays 2 | 2 2  
Arrays 3 | 2 2

```
If we do have a test failure, only the details for the failed test sets will be shown:

```

julia> @testset"Foo Tests" begin  
@testset"Animals" begin  
@testset"Felines" begin  
@testfoo("cat") == 9  
end  
@testset"Canines" begin  
@testfoo("dog") == 9  
end  
end  
@testset"Arrays" begin  
@testfoo(zeros(2)) == 4  
@testfoo(fill(1.0, 4)) == 15  
end  
end

Arrays: Test Failed  
Expression: foo(fill(1.0, 4)) == 15  
Evaluated: 16 == 15  
[...]  
Test Summary: | Pass Fail Total  
Foo Tests | 3 1 4  
Animals | 2 2  
Arrays | 1 1 2  
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.

```
### 94.4 Other Test Macros

As calculations on floating-point values can be imprecise, you can perform approximate equality checks using
either@test a ≈ b(where≈, typed via tab completion of\approx, is theisapproxfunction) or useisapprox
directly.

```

julia> @test1 ≈ 0.999999999  
Test Passed  
Expression: 1 ≈ 0.999999999  
Evaluated: 1 ≈ 0.999999999

```

#### CHAPTER 94. UNIT TESTING 1250

```

julia> @test1 ≈ 0.999999  
Test Failed at none:1  
Expression: 1 ≈ 0.999999  
Evaluated: 1 ≈ 0.999999  
ERROR: There was an error during testing

```
Youcanspecifyrelativeandabsolutetolerancesbysettingthertolandatolkeywordargumentsofisapprox,
respectively, after the≈comparison:

```

julia> @test1 ≈ 0.999999 rtol=1e-5  
Test Passed  
Expression: ≈(1, 0.999999, rtol = 1.0e-5)  
Evaluated: ≈(1, 0.999999; rtol = 1.0e-5)

```
Note that this is not a specific feature of the≈but rather a general feature of the@testmacro:@test a <op>
b key=valis transformed by the macro into@test op(a, b, key=val). It is, however, particularly useful for
≈tests.

Test.@inferred– Macro.

```

@inferred[AllowedType] f(x)

Tests that the call expressionf(x)returns a value of the same type inferred by the compiler. It is useful  
to check for type stability.  
f(x)can be any call expression. Returns the result off(x)if the types match, and anError Resultif it  
finds different types.  
Optionally,AllowedTyperelaxes the test, by making it pass when either the type off(x)matches the in-  
ferredtype moduloAllowedType, or when the returntype is a subtype ofAllowedType. This is useful when  
testing type stability of functions returning a small union such asUnion{Nothing, T}orUnion{Missing,  
T}.

julia> f(a)= a > 1? 1 : 1.0  
f (generic function with 1 method)

julia> typeof(f(2))  
Int64

julia> @code_warntypef(2)  
MethodInstance for f(::Int64)  
from f(a) in Main at none:1  
Arguments  
#self#::Core.Const(f)  
a::Int64  
Body::UNION{FLOAT64, INT64}  
1 ─ %1 = (a > 1)::Bool  
└── goto #3 if not %1  
2 ─ return 1  
3 ─ return 1.0

julia> @inferredf(2)  
ERROR: return type Int64 does not match inferred return type Union{Float64, Int64}  
[...]

```

#### CHAPTER 94. UNIT TESTING 1251

```

julia> @inferredmax(1, 2)  
2

julia> g(a)= a < 10? missing: 1.0  
g (generic function with 1 method)

julia> @inferredg(20)  
ERROR: return type Float64 does not match inferred return type Union{Missing, Float64}  
[...]

julia> @inferredMissing g(20)  
1.0

julia> h(a)= a < 10? missing: f(a)  
h (generic function with 1 method)

julia> @inferredMissing h(20)  
ERROR: return type Int64 does not match inferred return type Union{Missing, Float64, Int64}  
[...]

```
Test.@test_logs– Macro.

```

@test_logs[log_patterns...] [keywords] expression

Collect a list of log records generated byexpressionusingcollect_test_logs, check that they match  
the sequencelog_patterns, and return the value ofexpression. Thekeywordsprovide some simple  
filtering of log records: themin_levelkeyword controls the minimum log level which will be collected for  
the test, thematch_modekeyword defines how matching will be performed (the default:allchecks that  
all logs and patterns match pairwise; use:anyto check that the pattern matches at least once somewhere  
in the sequence.)  
The most useful log pattern is a simple tuple of the form(level,message). A different number of tu-  
ple elements may be used to match other log metadata, corresponding to the arguments to passed to  
AbstractLoggervia thehandle_messagefunction:(level,message,module,group,id,file,line). El-  
ements which are present will be matched pairwise with the log record fields using==by default, with the  
special cases thatSymbols may be used for the standard log levels, andRegexs in the pattern will match  
string or Symbol fields usingoccursin.  
Examples  
Consider a function which logs a warning, and several debug messages:  
function foo(n)  
@info "Doing foo with n=$n"  
for i=1:n  
@debug "Iteration $i"  
end  
42  
end

We can test the info message using  
@test_logs (:info,"Doing foo with n=2") foo(2)

If we also wanted to test the debug messages, these need to be enabled with themin_levelkeyword:

```

#### CHAPTER 94. UNIT TESTING 1252

```

@test_logs (:info,"Doing foo with n=2") (:debug,"Iteration 1") (:debug,"Iteration 2") min_level=  
Logging.Debug foo(2)

If you want to test that some particular messages are generated while ignoring the rest, you can set the  
keywordmatch_mode=:any:  
@test_logs (:info,) (:debug,"Iteration 42") min_level=Logging.Debug match_mode=:any foo(100)

The macro may be chained with@testto also test the returned value:  
@test (@test_logs (:info,"Doing foo with n=2") foo(2)) == 42

If you want to test for the absence of warnings, you can omit specifying log patterns and set themin_level  
accordingly:

# test that the expression logs no messages when the logger level is warn:

@test_logs min_level=Logging.Warn @info("Some information") # passes  
@test_logs min_level=Logging.Warn @warn("Some information") # fails

If you want to test the absence of warnings (or error messages) instderrwhich are not generated by  
@warn, see@test_nowarn.

```
Test.@test_deprecated– Macro.

```

@test_deprecated[pattern] expression

When--depwarn=yes,testthatexpressionemitsadeprecationwarningandreturnthevalueofexpression.  
The log message string will be matched againstpatternwhich defaults tor"deprecated"i.  
When--depwarn=no, simply return the result of executingexpression. When--depwarn=error, check  
that an ErrorException is thrown.  
Examples

# Deprecated in julia 0.7

@test_deprecated num2hex(1)

# The returned value can be tested by chaining with @test:

@test (@test_deprecated num2hex(1)) == "0000000000000001"

```
Test.@test_warn– Macro.

```

@test_warnmsg expr

Test whether evaluatingexprresults instderroutput that contains themsgstring or matches themsg  
regular expression. Ifmsgis a boolean function, tests whethermsg(output)returnstrue. Ifmsgis a tuple  
or array, checks that the error output contains/matches each item inmsg. Returns the result of evaluating  
expr.  
See also@test_nowarnto check for the absence of error output.  
Note: Warnings generated by@warncannot be tested with this macro. Use@test_logsinstead.

```
Test.@test_nowarn– Macro.

```

@test_nowarnexpr

Test whether evaluatingexprresults in emptystderroutput (no warnings or other messages). Returns  
the result of evaluatingexpr.  
Note: The absence of warnings generated by@warncannot be tested with this macro. Use@test_logs  
instead.

```

#### CHAPTER 94. UNIT TESTING 1253

### 94.5 Broken Tests.

Ifatestfailsconsistentlyitcanbechangedtousethe@test_brokenmacro. ThiswilldenotethetestasBroken
if the test continues to fail and alerts the user via anErrorif the test succeeds.

Test.@test_broken– Macro.

```

@test_brokenex  
@test_brokenf(args...) key=val ...

Indicates a test that should pass but currently consistently fails. Tests that the expressionexevaluates to  
falseor causes an exception. Returns aBroken Resultif it does, or anError Resultif the expression  
evaluates totrue. This is equivalent to@test ex broken=true.  
The@test_broken f(args...) key=val...form works as for the@testmacro.  
Examples

julia> @test_broken1 == 2  
Test Broken  
Expression: 1 == 2

julia> @test_broken1 == 2 atol=0.1  
Test Broken  
Expression: ==(1, 2, atol = 0.1)

```
@test_skipis also available to skip a test without evaluation, but counting the skipped test in the test set
reporting. The test will not run but gives aBroken Result.

Test.@test_skip– Macro.

```

@test_skipex  
@test_skipf(args...) key=val ...

Marks a test that should not be executed but should be included in test summary reporting asBroken.  
This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality. This is  
equivalent to@test ex skip=true.  
The@test_skip f(args...) key=val...form works as for the@testmacro.  
Examples

julia> @test_skip1 == 2  
Test Broken  
Skipped: 1 == 2

julia> @test_skip1 == 2 atol=0.1  
Test Broken  
Skipped: ==(1, 2, atol = 0.1)

```
### 94.6 Creating CustomAbstractTestSetTypes

Packages can create their ownAbstractTestSetsubtypes by implementing therecordandfinishmethods.
The subtype should have a one-argument constructor taking a description string, with any options passed in
as keyword arguments.

Test.record– Function.


#### CHAPTER 94. UNIT TESTING 1254

```

record(ts::AbstractTestSet, res::Result)

Record a result to a testset. This function is called by the@testsetinfrastructure each time a contained  
@testmacro completes, and is given the test result (which could be anError). This will also be called  
with anErrorif an exception is thrown inside the test block but outside of a@testcontext.

```
Test.finish– Function.

```

finish(ts::AbstractTestSet)

Do any final processing necessary for the given testset. This is called by the@testsetinfrastructure after  
a test block executes.  
CustomAbstractTestSetsubtypes should callrecordon their parent (if there is one) to add themselves  
to the tree of test results. This might be implemented as:

if get_testset_depth()!= 0

# Attach this test set to the parent test set

parent_ts= get_testset()  
record(parent_ts, self)  
return self  
end

```
Testtakes responsibility for maintaining a stack of nested testsets as they are executed, but any result accu-
mulationistheresponsibilityoftheAbstractTestSetsubtype. Youcanaccessthisstackwiththeget_testset
andget_testset_depthmethods. Note that these functions are not exported.

Test.get_testset– Function.

```

get_testset()

Retrieve the active test set from the task's local storage. If no test set is active, use the fallback default  
test set.

```
Test.get_testset_depth– Function.

```

get_testset_depth()

Returns the number of active test sets, not including the default test set

```
Testalsomakessurethatnested@testsetinvocationsusethesameAbstractTestSetsubtypeastheirparent
unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can
be implemented by packages using the stack infrastructure thatTestprovides.

Defining a basicAbstractTestSetsubtype might look like:

```

import Test: Test, record, finish  
using Test: AbstractTestSet, Result, Pass, Fail, Error  
using Test: get_testset_depth, get_testset  
struct CustomTestSet<: Test.AbstractTestSet  
description:: AbstractString  
foo:: Int  
results:: Vector

# constructor takes a description string and options keyword arguments

CustomTestSet(desc; foo=1) = new(desc, foo, [])  
end

```

#### CHAPTER 94. UNIT TESTING 1255

```

record(ts::CustomTestSet, child::AbstractTestSet)= push!(ts.results, child)  
record(ts::CustomTestSet, res::Result)= push!(ts.results, res)  
function finish(ts::CustomTestSet)

# just record if we're not the top-level parent

if get_testset_depth()> 0  
record(get_testset(), ts)  
end  
ts  
end

```
And using that testset looks like:

```

@testsetCustomTestSet foo=4 "custom testset inner 2" begin

# this testset should inherit the type, but not the argument.

@testset"custom testset inner" begin  
@test true  
end  
end

```
### 94.7 Test utilities

Test.GenericArray– Type.

```

TheGenericArraycan be used to test generic array APIs that program to theAbstractArrayinterface, in  
order to ensure that functions can work with array types besides the standardArraytype.

```
Test.GenericDict– Type.

```

TheGenericDictcan be used to test generic dict APIs that program to theAbstractDictinterface, in  
order to ensure that functions can work with associative types besides the standardDicttype.

```
Test.GenericOrder– Type.

```

TheGenericOrdercan be used to test APIs for their support of generic ordered types.

```
Test.GenericSet– Type.

```

TheGenericSetcan be used to test generic set APIs that program to theAbstractSetinterface, in order  
to ensure that functions can work with set types besides the standardSetandBitSettypes.

```
Test.GenericString– Type.

```

TheGenericStringcan be used to test generic string APIs that program to theAbstractStringinterface,  
in order to ensure that functions can work with string types besides the standardStringtype.

```
Test.detect_ambiguities– Function.

```

detect_ambiguities(mod1, mod2...; recursive= false , ambiguous_bottom= false )

Returns a vector of(Method,Method)pairs of ambiguous methods defined in the specified modules. Use  
recursive=trueto test in all submodules.  
ambiguous_bottomcontrols whether ambiguities triggered only byUnion{}type parameters are included;  
in most cases you probably want to set this tofalse. SeeBase.isambiguous.

```
Test.detect_unbound_args– Function.


#### CHAPTER 94. UNIT TESTING 1256

```

detect_unbound_args(mod1, mod2...; recursive= false )

Returns a vector ofMethods which may have unbound type parameters. Userecursive=trueto test in  
all submodules.

```

**Chapter 95**

**UUIDs**

UUIDs.uuid1– Function.

```

uuid1([rng:: AbstractRNG ]) -> UUID

Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note  
that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.  
The default rng used byuuid1is notGLOBAL_RNGand every invocation ofuuid1()without an argument  
should be expected to return a unique identifier. Importantly, the outputs ofuuid1do not repeat even  
whenRandom.seed!(seed)is called. Currently (as of Julia 1.6),uuid1usesRandom.RandomDeviceas the  
default rng. However, this is an implementation detail that may change in the future.

Julia 1.6  
The output ofuuid1does not depend onGLOBAL_RNGas of Julia 1.6.

Examples

julia> rng = MersenneTwister (1234);

julia> uuid1(rng)  
UUID("cfc395e8-590f-11e8-1f13-43a2532b2fa8")

```
UUIDs.uuid4– Function.

```

uuid4([rng:: AbstractRNG ]) -> UUID

Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by  
RFC 4122.  
The default rng used byuuid4is notGLOBAL_RNGand every invocation ofuuid4()without an argument  
should be expected to return a unique identifier. Importantly, the outputs ofuuid4do not repeat even  
whenRandom.seed!(seed)is called. Currently (as of Julia 1.6),uuid4usesRandom.RandomDeviceas the  
default rng. However, this is an implementation detail that may change in the future.

Julia 1.6  
The output ofuuid4does not depend onGLOBAL_RNGas of Julia 1.6.

Examples

```
#### 1257


#### CHAPTER 95. UUIDS 1258

```

julia> rng = MersenneTwister (1234);

julia> uuid4(rng)  
UUID("7a052949-c101-4ca3-9a7e-43a2532b2fa8")

```
UUIDs.uuid5– Function.

```

uuid5(ns::UUID, name::String)-> UUID

Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified  
by RFC 4122.

Julia 1.1  
This function requires at least Julia 1.1.

Examples

julia> rng = MersenneTwister (1234);

julia> u4 = uuid4(rng)  
UUID("7a052949-c101-4ca3-9a7e-43a2532b2fa8")

julia> u5 = uuid5(u4,"julia")  
UUID("086cc5bb-2461-57d8-8068-0aed7f5b5cd1")

```
UUIDs.uuid_version– Function.

```

uuid_version(u::UUID)-> Int

Inspects the given UUID and returns its version (seeRFC 4122).  
Examples

julia> uuid_version(uuid4())  
4

```

**Chapter 96**

**Unicode**

Unicode.isassigned– Function.

```

Unicode.isassigned(c)-> Bool

Returnstrueif the given char or integer is an assigned Unicode code point.  
Examples

julia> Unicode.isassigned(101)  
true

julia> Unicode.isassigned('\x01')  
true

```
Unicode.normalize– Function.

```

Unicode.normalize(s:: AbstractString ; keywords...)  
Unicode.normalize(s:: AbstractString , normalform:: Symbol )

Normalize the strings. By default, canonical composition (compose=true) is performed without ensuring  
Unicode versioning stability (compat=false), which produces the shortest possible equivalent string but  
may introduce composition characters not present in earlier Unicode versions.  
Alternatively, one of the four"normal forms" of the Unicode standard can be specified:normalformcan  
be:NFC,:NFD,:NFKC, or:NFKD. Normal forms C (canonical composition) and D (canonical decomposition)  
convert different visually identical representations of the same abstract string into a single canonical form,  
with form C being more compact. Normal forms KC and KD additionally canonicalize"compatibility equiva-  
lents": theyconvertcharactersthatareabstractlysimilarbutvisuallydistinctintoasinglecanonicalchoice  
(e.g. they expand ligatures into the individual characters), with form KC being more compact.  
Alternatively,finercontrolandadditionaltransformationsmaybeobtainedbycallingUnicode.normalize(s;  
keywords...), where any number of the following boolean keywords options (which all default tofalse  
except forcompose) are specified:

```
- compose=false: do not perform canonical composition
- decompose=true: do canonical decomposition instead of canonical composition (compose=trueis
    ignored if present)
- compat=true: compatibility equivalents are canonicalized
- casefold=true: perform Unicode case folding, e.g. for case-insensitive string comparison

#### 1259


#### CHAPTER 96. UNICODE 1260

- newline2lf=true,newline2ls=true, ornewline2ps=true: convert various newline sequences (LF,
    CRLF, CR, NEL) into a linefeed (LF), line-separation (LS), or paragraph-separation (PS) character,
    respectively
- stripmark=true: strip diacritical marks (e.g. accents)
- stripignore=true: strip Unicode's "default ignorable" characters (e.g. the soft hyphen or the left-
    to-right marker)
- stripcc=true: strip control characters; horizontal tabs and form feeds are converted to spaces;
    newlines are also converted to spaces unless a newline-conversion flag was specified
- rejectna=true: throw an error if unassigned code points are found
- stable=true: enforce Unicode versioning stability (never introduce characters missing from earlier
    Unicode versions)

```

For example, NFKC corresponds to the optionscompose=true, compat=true, stable=true.  
Examples

julia> "é" == Unicode.normalize("é " ) #LHS: Unicode U+00e9, RHS: U+0065 & U+0301  
true

julia> "μ" == Unicode.normalize("μ", compat= true ) #LHS: Unicode U+03bc, RHS: Unicode U+00b5  
true

julia> Unicode.normalize("JuLiA", casefold= true )  
"julia"

julia> Unicode.normalize("JúLiA", stripmark= true )  
"JuLiA"

```
Unicode.graphemes– Function.

```

graphemes(s:: AbstractString ) -> GraphemeIterator

Returnsaniteratoroversubstringsofsthatcorrespondtotheextendedgraphemesinthestring,asdefined  
by Unicode UAX #29. (Roughly, these are what users would perceive as single characters, even though  
they may contain more than one codepoint; for example a letter combined with an accent mark is a single  
grapheme.)

```

**Part IV**

**Developer Documentation**

#### 1261


**Chapter 97**

**Reflection and introspection**

Julia provides a variety of runtime reflection capabilities.

### 97.1 Module bindings.

The exported names for aModuleare available usingnames(m::Module), which will return an array ofSymbol
elements representing the exported bindings.names(m::Module, all = true)returns symbols for all bind-
ings inm, regardless of export status.

### 97.2 DataType fields

The names ofDataTypefields may be interrogated usingfieldnames. For example, given the following type,
fieldnames(Point)returns a tuple ofSymbols representing the field names:

```

julia> struct Point  
x:: Int  
y  
end

julia> fieldnames(Point)  
(:x, :y)

```
The type of each field in aPointobject is stored in thetypesfield of thePointvariable itself:

```

julia> Point.types  
svec(Int64, Any)

```
Whilexis annotated as anInt,ywas unannotated in the type definition, thereforeydefaults to theAnytype.

Types are themselves represented as a structure calledDataType:

```

julia> typeof(Point)  
DataType

```
Note thatfieldnames(DataType)gives the names for each field ofDataTypeitself, and one of these fields is
thetypesfield observed in the example above.

#### 1262


#### CHAPTER 97. REFLECTION AND INTROSPECTION 1263

### 97.3 Subtypes.

The direct subtypes of anyDataTypemay be listed usingsubtypes. For example, the abstractDataType
AbstractFloathas four (concrete) subtypes:

```

julia> subtypes( AbstractFloat )  
4-element Vector{Any}:  
BigFloat  
Float16  
Float32  
Float64

```
Anyabstractsubtypewillalsobeincludedinthislist, butfurthersubtypesthereofwillnot; recursiveapplication
ofsubtypesmay be used to inspect the full type tree.

### 97.4 DataType layout.

The internal representation of aDataTypeis critically important when interfacing with C code and several func-
tions are available to inspect these details.isbits(T::DataType)returns true ifTis stored with C-compatible
alignment.fieldoffset(T::DataType, i::Integer)returns the (byte) offset for field i relative to the start
of the type.

### 97.5 Function methods

Themethodsofanygenericfunctionmaybelistedusingmethods. Themethoddispatchtablemaybesearched
for methods accepting a given type usingmethodswith.

### 97.6 Expansion and lowering.

As discussed in theMetaprogrammingsection, themacroexpandfunction gives the unquoted and interpolated
expression (Expr) form for a given macro. To usemacroexpand,quotethe expression block itself (otherwise,
the macro will be evaluated and the result will be passed instead!). For example:

```

julia> macroexpand(@**MODULE**, :(@editprintln("")) )  
:(InteractiveUtils.edit(println, (Base.typesof)("")))

```
The functionsBase.Meta.show_sexpranddumpare used to display S-expr style views and depth-nested detail
views for any expression.

Finally, theMeta.lowerfunction gives theloweredform of any expression and is of particular interest for
understandinghowlanguageconstructsmaptoprimitiveoperationssuchasassignments, branches, andcalls:

```

julia> Meta.lower(@**MODULE**, :( [ 1+2, sin(0.5)] ))  
:($(Expr(:thunk, CodeInfo(  
@ none within `top-level scope`  
1 ─ %1 = 1 + 2  
│ %2 = sin(0.5)  
│ %3 = Base.vect(%1, %2)  
└── return %3  
))))

```

#### CHAPTER 97. REFLECTION AND INTROSPECTION 1264

### 97.7 Intermediate and compiled representations.

Inspecting the lowered form for functions requires selection of the specific method to display, because generic
functions may have many methods with different type signatures. For this purpose, method-specific code-
loweringisavailableusingcode_lowered,andthetype-inferredformisavailableusingcode_typed.code_warntype
adds highlighting to the output ofcode_typed.

Closer to the machine, the LLVM intermediate representation of a function may be printed using bycode_llvm,
and finally the compiled machine code is available usingcode_native(this will trigger JIT compilation/code
generation for any function which has not previously been called).

Forconvenience,therearemacroversionsoftheabovefunctionswhichtakestandardfunctioncallsandexpand
argument types automatically:

```

julia> @code_llvm+(1,1)

define i64 @"julia_+_130862"(i64, i64) {  
top:  
%2 = add i64 %1, %0  
ret i64 %2  
}

```
For more informations see@code_lowered,@code_typed,@code_warntype,@code_llvm, and@code_native.

### Printing of debug information

Theaforementionedfunctionsandmacrostakethekeywordargumentdebuginfothatcontrolstheleveldebug
information printed.

```

julia> @code_typed debuginfo=:source +(1,1)  
CodeInfo(  
@ int.jl:53 within `+'  
1 ─ %1 = Base.add_int(x, y)::Int64└──  
return %1  
) => Int64

```
Possiblevaluesfordebuginfoare::none,:source, and:default. Perdefaultdebuginformationisnotprinted,
but that can be changed by settingBase.IRShow.default_debuginfo[] = :source.


**Chapter 98**

**Documentation of Julia’s Internals**

### 98.1 Initialization of the Julia runtime.

How does the Julia runtime executejulia -e 'println("Hello World!")'?

### main()

Execution starts atmain()incli/loader_exe.c, which callsjl_load_repl()incli/loader_lib.cwhich
loads a few libraries, eventually callingrepl_entrypoint()insrc/jlapi.c.

repl_entrypoint()callslibsupport_init()to set the C library locale and to initialize the"ios" library (see
ios_init_stdstreams()and Legacyios.clibrary).

Nextjl_parse_opts()is called to process command line options. Note thatjl_parse_opts()only deals with
optionsthataffectcodegenerationorearlyinitialization. Otheroptionsarehandledlaterbyprocess_options()
inbase/client.jl.

jl_parse_opts()stores command line options in theglobaljl_optionsstruct.

### julia_init()

julia_init()intask.cis called bymain()and calls_julia_init()ininit.c.

_julia_init()begins by callinglibsupport_init()again (it does nothing the second time).

restore_signals()is called to zero the signal handler mask.

jl_resolve_sysimg_location()searches configured paths for the base system image. SeeBuilding the Julia
system image.

jl_gc_init()sets up allocation pools and lists for weak refs, preserved values and finalization.

jl_init_frontend()loads and initializes a pre-compiled femtolisp image containing the scanner/parser.

jl_init_types()createsjl_datatype_ttype description objects for thebuilt-in types defined injulia.h.
e.g.

```

jl_any_type = jl_new_abstracttype(jl_symbol("Any"), core, NULL, jl_emptysvec);  
jl_any_type->super = jl_any_type;

jl_type_type = jl_new_abstracttype(jl_symbol("Type"), core, jl_any_type, jl_emptysvec);

jl_int32_type = jl_new_primitivetype(jl_symbol("Int32"), core,  
jl_any_type, jl_emptysvec, 32);

```
#### 1265


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1266

jl_init_tasks()createsthejl_datatype_t* jl_task_typeobject;initializestheglobaljl_root_taskstruct;
and setsjl_current_taskto the root task.

jl_init_codegen()initializes theLLVM library.

jl_init_serializer()initializes 8-bit serialization tags for builtinjl_value_tvalues.

If there is no sysimg file (!jl_options.image_file) then theCoreandMainmodules are created andboot.jl
is evaluated:

jl_core_module = jl_new_module(jl_symbol("Core"))creates the JuliaCoremodule.

jl_init_intrinsic_functions()createsanewJuliamoduleIntrinsicscontainingconstantjl_intrinsic_type
symbols. Thesedefineanintegercodeforeachintrinsicfunction.emit_intrinsic()translatesthesesymbols
into LLVM instructions during code generation.

jl_init_primitives()hooks C functions up to Julia function symbols. e.g. the symbolCore.:(===)()is
bound to C function pointerjl_f_is()by callingadd_builtin_func("===", jl_f_is).

jl_new_main_module()creates the global"Main" module and setsjl_current_task->current_module =
jl_main_module.

Note:_julia_init()then setsjl_root_task->current_module = jl_core_module. jl_root_taskis an
alias ofjl_current_taskat this point, so thecurrent_moduleset byjl_new_main_module()above is over-
written.

jl_load("boot.jl", sizeof("boot.jl"))callsjl_parse_eval_allwhichrepeatedlycallsjl_toplevel_eval_flex()
to executeboot.jl. <!– TODO – drill down into eval? –>

jl_get_builtin_hooks()initializes global C pointers to Julia globals defined inboot.jl.

jl_init_box_caches()pre-allocates global boxed integer value objects for values up to 1024. This speeds
up allocation of boxed ints later on. e.g.:

```

jl_value_t *jl_box_uint8(uint32_t x)  
{  
return boxed_uint8_cache[(uint8_t)x];  
}

```
_julia_init()iteratesover thejl_core_module->bindings.tablelooking forjl_datatype_tvalues and
sets the type name's module prefix tojl_core_module.

jl_add_standard_imports(jl_main_module)does "using Base" in the "Main" module.

Note:_julia_init()now reverts tojl_root_task->current_module = jl_main_moduleas it was before
being set tojl_core_moduleabove.

Platform specific signal handlers are initialized forSIGSEGV(OSX, Linux), andSIGFPE(Windows).

Other signals (SIGINFO, SIGBUS, SIGILL, SIGTERM, SIGABRT, SIGQUIT, SIGSYSandSIGPIPE) are hooked
up tosigdie_handler()which prints a backtrace.

jl_init_restored_modules()callsjl_module_run_initializer()for each deserialized module to run the
__init__()function.

Finallysigint_handler()is hooked up toSIGINTand callsjl_throw(jl_interrupt_exception).

_julia_init()then returnsback tomain()incli/loader_exe.candmain()callsrepl_entrypoint(argc,
(char**)argv).

```

sysimg

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1267

```

If there is a sysimg file, it contains a pre-cooked image of theCoreandMainmodules (and what-  
ever else is created byboot.jl). See Building the Julia system image.  
jl_restore_system_image()deserializes the saved sysimg into the current Julia runtime envi-  
ronment and initialization continues afterjl_init_box_caches()below...  
Note: jl_restore_system_image()(andstaticdata.cin general)uses theLegacyios.cli-  
brary.

```
### repl_entrypoint()

repl_entrypoint()loads the contents ofargv[]intoBase.ARGS.

If a.jl"program" file was supplied on the command line, thenexec_program()callsjl_load(program,len)
which callsjl_parse_eval_allwhich repeatedly callsjl_toplevel_eval_flex()to execute the program.

However,inourexample(julia -e 'println("Hello World!")'),jl_get_global(jl_base_module, jl_symbol("_start"))
looks upBase._startandjl_apply()executes it.

### Base._start

Base._startcallsBase.process_optionswhichcallsjl_parse_input_line("println("Hello World!")")
to create an expression object andBase.eval()to execute it.

### Base.eval

Base.eval()was mapped tojl_f_top_evalbyjl_init_primitives().

jl_f_top_eval()callsjl_toplevel_eval_in(jl_main_module, ex),whereexistheparsedexpressionprintln("Hello
World!").

jl_toplevel_eval_in()callsjl_toplevel_eval_flex()which callseval()ininterpreter.c.

The stack dump below shows how the interpreter works its way through various methods ofBase.println()
andBase.print()beforearrivingatwrite(s::IO, a::Array{T}) where Twhichdoesccall(jl_uv_write()).

jl_uv_write()callsuv_write()to write"Hello World!" toJL_STDOUT. See Libuv wrappers for stdio.:

```

Hello World!

```
Since our example has just one function call, which has done its job of printing"Hello World!", the stack now
rapidly unwinds back tomain().

### jl_atexit_hook()

main()callsjl_atexit_hook(). ThiscallsBase._atexit,thencallsjl_gc_run_all_finalizers()andcleans
up libuv handles.

### julia_save()

Finally,main()callsjulia_save(), which if requested on the command line, saves the runtime state to a new
system image. Seejl_compile_all()andjl_save_system_image().

### 98.2 Julia ASTs.

Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the
Meta.parsefunction), and manipulated by macros. It is a structured representation of code as it is written,


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1268

```

Stack frame Source code Notes  
jl_uv_write() jl_uv.c called thoughccall  
julia_write_282942 stream.jl functionwrite!(s::IO, a::Array{T}) where T  
julia_print_284639 ascii.jl print(io::IO, s::String) = (write(io, s);  
nothing)  
jlcall_print_284639  
jl_apply() julia.h  
jl_trampoline() builtins.c  
jl_apply() julia.h  
jl_apply_generic() gf.c Base.print(Base.TTY, String)  
jl_apply() julia.h  
jl_trampoline() builtins.c  
jl_apply() julia.h  
jl_apply_generic() gf.c Base.print(Base.TTY, String, Char, Char...)  
jl_apply() julia.h  
jl_f_apply() builtins.c  
jl_apply() julia.h  
jl_trampoline() builtins.c  
jl_apply() julia.h  
jl_apply_generic() gf.c Base.println(Base.TTY, String, String...)  
jl_apply() julia.h  
jl_trampoline() builtins.c  
jl_apply() julia.h  
jl_apply_generic() gf.c Base.println(String,)  
jl_apply() julia.h  
do_call() interpreter.c  
eval() interpreter.c  
jl_interpret_toplevel_expr()interpreter.c  
jl_toplevel_eval_flex() toplevel.c  
jl_toplevel_eval() toplevel.c  
jl_toplevel_eval_in() builtins.c  
jl_f_top_eval() builtins.c

```
constructed byjulia-parser.scmfrom a character stream. Next there is a lowered form, or IR (intermediate
representation), which is used by type inference and code generation. In the lowered form there are fewer
types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences
of statements. The lowered form is constructed byjulia-syntax.scm.

First we will focus on the AST, since it is needed to write macros.

### Surface syntax AST

Front end ASTs consist almost entirely ofExprs and atoms (e.g. symbols, numbers). There is generally a
different expression head for each visually distinct syntactic form. Examples will be given in s-expression
syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example
(call f x)corresponds toExpr(:call, :f, :x)in Julia.

**Calls**

dosyntax:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1269

```

Input AST  
f(x) (call f x)  
f(x, y=1, z=2) (call f x (kw y 1) (kw z 2))  
f(x; y=1) (call f (parameters (kw y 1)) x)  
f(x...) (call f (... x))

f(x) do a,b  
body  
end

```
parses as(do (call f x) (-> (tuple a b) (block body))).

**Operators**

Most uses of operators are just function calls, so they are parsed with the headcall. However some operators
are special forms (not necessarily function calls), and in those cases the operator itself is the expression head.
In julia-parser.scm these are referred to as"syntactic operators". Some operators (+and*) use N-ary parsing;
chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special
expression structure.

```

Input AST  
x+y (call + x y)  
a+b+c+d (call + a b c d)  
2x (call * 2 x)  
a&&b (&& a b)  
x += 1 (+= x 1)  
a? 1 : 2 (if a 1 2)  
a:b (: a b)  
a:b:c (: a b c)  
a,b (tuple a b)  
a==b (call == a b)  
1<i<=n (comparison 1 < i <= n)  
a.b (. a (quote b))  
a.(b) (. a (tuple b))

```
**Bracketed forms**

**Macros**

**Strings**

Doc string syntax:

```

"some docs"  
f(x)= x

```
parses as(macrocall (|.| Core '@doc) (line) "some docs" (= (call f x) (block x))).

**Imports and such**

usinghas the same representation asimport, but with expression head:usinginstead of:import.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1270

```

Input AST  
a[i] (ref a i)  
t[i;j] (typed_vcat t i j)  
t[i j] (typed_hcat t i j)  
t[a b; c d] (typed_vcat t (row a b) (row c d))  
t[a b;;; c d] (typed_ncat t 3 (row a b) (row c d))  
a{b} (curly a b)  
a{b;c} (curly a (parameters c) b)  
[x] (vect x)  
[x,y] (vect x y)  
[x;y] (vcat x y)  
[x y] (hcat x y)  
[x y; z t] (vcat (row x y) (row z t))  
[x;y;; z;t;;;] (ncat 3 (nrow 2 (nrow 1 x y) (nrow 1 z t)))  
[x for y in z, a in b] (comprehension x (= y z) (= a b))  
T[x for y in z] (typed_comprehension T x (= y z))  
(a, b, c) (tuple a b c)  
(a; b; c) (block a (block b c))

Input AST  
@m x y (macrocall @m (line) x y)  
Base.@m x y (macrocall (. Base (quote @m)) (line) x y)  
@Base.m x y (macrocall (. Base (quote @m)) (line) x y)

Input AST  
"a" "a"  
x"y" (macrocall @x_str (line) "y")  
x"y"z (macrocall @x_str (line) "y" "z")  
"x = $x" (string "x = " x)  
`a b c` (macrocall @cmd (line) "a b c")

```
**Numbers**

Julia supports more number types than many scheme implementations, so not all numbers are represented
directly as scheme numbers in the AST.

**Block forms**

A block of statements is parsed as(block stmt1 stmt2 ...).

If statement:

```

if a  
b  
elseif c  
d  
else  
e  
end

```
parses as:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1271

```

Input AST  
import a (import (. a))  
import a.b.c (import (. a b c))  
import ...a (import (.... a))  
import a.b, c.d (import (. a b) (. c d))  
import Base: x (import (: (. Base) (. x)))  
import Base: x, y (import (: (. Base) (. x) (. y)))  
export a, b (export a b)

Input AST  
11111111111111111111 (macrocall @int128_str (null) "11111111111111111111")  
0xfffffffffffffffff (macrocall @uint128_str (null) "0xfffffffffffffffff")  
1111...many digits... (macrocall @big_str (null) "1111....")

(if a (block (line 2) b)  
(elseif (block (line 3) c) (block (line 4) d)  
(block (line 5 e))))

```
Awhileloop parses as(while condition body).

Aforloop parses as(for (= var iter) body). If there is more than one iteration specification, they are
parsed as a block:(for (block (= v1 iter1) (= v2 iter2)) body).

breakandcontinueare parsed as 0-argument expressions(break)and(continue).

letis parsed as(let (= var val) body)or(let (block (= var1 val1) (= var2 val2) ...) body),
likeforloops.

A basic function definition is parsed as(function (call f x) body). A more complex example:

```

function f(x::T; k= 1) where T  
return x+1  
end

```
parses as:

```

(function (where (call f (parameters (kw k 1))  
(:: x T))  
T)  
(block (line 2) (return (call + x 1))))

```
Type definition:

```

mutable struct Foo{T<:S}  
x::T  
end

```
parses as:

```

(struct true (curly Foo (<: T S))  
(block (line 2) (:: x T)))

```
The first argument is a boolean telling whether the type is mutable.

tryblocksparseas(try try_block var catch_block finally_block). Ifnovariableispresentaftercatch,
varis#f. If there is nofinallyclause, then the last argument is not present.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1272

**Quote expressions**

Julia source syntax forms for code quoting (quoteand:( )) support interpolation with$. In Lisp terminology,
thismeanstheyareactually"backquote"or"quasiquote"forms. Internally,thereisalsoaneedforcodequoting
without interpolation. In Julia's scheme code, non-interpolating quote is represented with the expression head
inert.

inertexpressions are converted to JuliaQuoteNodeobjects. These objects wrap a single value of any type,
and when evaluated simply return that value.

Aquoteexpression whose argument is an atom also gets converted to aQuoteNode.

**Line numbers**

Source location information is represented as(line line_num file_name)where the third component is
optional (and omitted when the current line number, but not file name, changes).

These expressions are represented asLineNumberNodes in Julia.

**Macros**

Macro hygiene is represented through the expression head pairescapeandhygienic-scope. The result of
a macro expansion is automatically wrapped in(hygienic-scope block module), to represent the result of
the new scope. The user can insert(escape block)inside to interpolate code from the caller.

### Lowered form

Lowered form (IR) is more important to the compiler, since it is used for type inference, optimizations like inlin-
ing, and code generation. It is also less obvious to the human, since it results from a significant rearrangement
of the input syntax.

In addition toSymbols and some number types, the following data types exist in lowered form:

- Expr
    Hasanodetypeindicatedbytheheadfield, andanargsfieldwhichisaVector{Any}ofsubexpressions.
    While almost every part of a surface AST is represented by anExpr, the IR uses only a limited number
    ofExprs, mostly for calls and some top-level-only forms.
- Slot
    Identifies arguments and local variables by consecutive numbering.Slotis an abstract type with sub-
    typesSlotNumberandTypedSlot. Both types have an integer-valuedidfield giving the slot index. Most
    slots have the same type at all uses, and so are represented withSlotNumber. The types of these slots
    are found in theslottypesfield of theirCodeInfoobject. Slots that require per-use type annotations
    are represented withTypedSlot, which has atypfield.
- Argument
    The same asSlotNumber, but appears only post-optimization. Indicates that the referenced slot is an
    argument of the enclosing function.
- CodeInfo
    Wraps the IR of a group of statements. Itscodefield is an array of expressions to execute.
- GotoNode
    Unconditional branch. The argument is the branch target, represented as an index in the code array to
    jump to.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1273

- GotoIfNot
    Conditional branch. If thecondfield evaluates to false, goes to the index identified by thedestfield.
- ReturnNode
    Returns its argument (thevalfield) as the value of the enclosing function. If thevalfield is undefined,
    then this represents an unreachable statement.
- QuoteNode
    Wrapsanarbitraryvaluetoreferenceasdata. Forexample, thefunctionf() = :acontainsaQuoteNode
    whosevaluefield is the symbola, in order to return the symbol itself instead of evaluating it.
- GlobalRef
    Refers to global variablenamein modulemod.
- SSAValue
    Refers to a consecutively-numbered (starting at 1) static single assignment (SSA) variable inserted by
    the compiler. The number (id) of anSSAValueis the code array index of the expression whose value it
    represents.
- NewvarNode
    Marks a point where a variable (slot) is created. This has the effect of resetting a variable to undefined.

**Exprtypes**

These symbols appear in theheadfield ofExprs in lowered form.

- call
    Function call (dynamic dispatch).args[1]is the function to call,args[2:end]are the arguments.
- invoke
    Function call (static dispatch).args[1]is the MethodInstance to call,args[2:end]are the arguments
    (including the function that is being called, atargs[2]).
- static_parameter
    Reference a static parameter by index.
- =
    Assignment. In the IR, the first argument is always a Slot or a GlobalRef.
- method
    Adds a method to a generic function and assigns the result if necessary.
    Has a 1-argument form and a 3-argument form. The 1-argument form arises from the syntaxfunction
    foo end. In the 1-argument form, the argument is a symbol. If this symbol already names a function in
    the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned
    to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is
    raised. The definition of"names a function" is that the binding is constant, and refers to an object of
    singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type
    to add the method to. When the type has fields, it wouldn't be clear whether the method was being
    added to the instance or its type.
    The 3-argument form has the following arguments:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1274

**-** args[1]
    A function name, ornothingif unknown or unneeded. If a symbol, then the expression first be-
    haves like the 1-argument form above. This argument is ignored from then on. It can benothing
    when methods are added strictly by type,(::T)(x) = x, or when a method is being added to an
    existing function,MyModule.f(x) = x.
**-** args[2]
    ASimpleVectorofargumenttypedata.args[2][1]isaSimpleVectoroftheargumenttypes,and
    args[2][2]is aSimpleVectorof type variables corresponding to the method's static parameters.
**-** args[3]
    ACodeInfoof the method itself. For"out of scope" method definitions (adding a method to a
    function that also has methods defined in different scopes) this is an expression that evaluates to
    a:lambdaexpression.
- struct_type
A 7-argument expression that defines a newstruct:
**-** args[1]
The name of thestruct
**-** args[2]
Acallexpression that creates aSimpleVectorspecifying its parameters
**-** args[3]
Acallexpression that creates aSimpleVectorspecifying its fieldnames
**-** args[4]
ASymbol,GlobalRef, orExprspecifying the supertype (e.g.,:Integer,GlobalRef(Core, :Any),
or:(Core.apply_type(AbstractArray, T, N)))
**-** args[5]
Acallexpression that creates aSimpleVectorspecifying its fieldtypes
**-** args[6]
A Bool, true ifmutable
**-** args[7]
The number of arguments to initialize. This will be the number of fields, or the minimum number
of fields called by an inner constructor'snewstatement.
- abstract_type
A 3-argument expression that defines a new abstract type. The arguments are the same as arguments
1, 2, and 4 ofstruct_typeexpressions.
- primitive_type
A 4-argument expression that defines a new primitive type. Arguments 1, 2, and 4 are the same as
struct_type. Argument 3 is the number of bits.

```

Julia 1.5  
struct_type,abstract_type, andprimitive_typewere removed in Julia 1.5 and replaced  
by calls to new builtins.

```
- global
    Declares a global binding.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1275

- const
    Declares a (global) variable as constant.
- new
    Allocates a new struct-like object. First argument is the type. Thenewpseudo-function is lowered to this,
    and the type is always inserted by the compiler. This is very much an internal-only feature, and does no
    checking. Evaluating arbitrarynewexpressions can easily segfault.
- splatnew
    Similar tonew, except field values are passed as a single tuple. Works similarly toBase.splat(new)if
    newwere a first-class function, hence the name.
- isdefined
    Expr(:isdefined, :x)returns a Bool indicating whetherxhas already been defined in the current
    scope.
- the_exception
    Yields the caught exception inside acatchblock, as returned byjl_current_exception().
- enter
    Enters an exception handler (setjmp).args[1]is the label of the catch block to jump to on error. Yields
    a token which is consumed bypop_exception.
- leave
    Pop exception handlers.args[1]is the number of handlers to pop.
- pop_exception
    Popthestackofcurrentexceptionsbacktothestateattheassociatedenterwhenleavingacatchblock.
    args[1]contains the token from the associatedenter.

```

Julia 1.1  
pop_exceptionis new in Julia 1.1.

```
- inbounds
    Controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is
    true or false (truemeans bounds checks are disabled), it is pushed onto the stack. If the first argument
    is:pop, the stack is popped.
- boundscheck
    Has the valuefalseif inlined into a section of code marked with@inbounds, otherwise has the value
    true.
- loopinfo
    Marks the end of the a loop. Contains metadata that is passed toLowerSimdLoopto either mark the
    inner loop of@simdexpression, or to propagate information to LLVM loop passes.
- copyast
    Part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied
    recursively and returned at run time.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1276

- meta
    Metadata.args[1]is typically a symbol specifying the kind of metadata, and the rest of the arguments
    are free-form. The following kinds of metadata are commonly used:
       **-** :inlineand:noinline: Inlining hints.
- foreigncall
    Statically-computed container forccallinformation. The fields are:
       **-** args[1]: name
          The expression that'll be parsed for the foreign function.
       **-** args[2]::Type: RT
          The (literal) return type, computed statically when the containing method was defined.
       **-** args[3]::SimpleVector(of Types) : AT
          The (literal) vector of argument types, computed statically when the containing method was de-
          fined.
       **-** args[4]::Int: nreq
          The number of required arguments for a varargs function definition.
       **-** args[5]::QuoteNode{Symbol}: calling convention
          The calling convention for the call.
       **-** args[6:length(args[3])]: arguments
          The values for all the arguments (with types of each given in args[3]).
       **-** args[(length(args[3]) + 1):end]: gc-roots
          The additional objects that may need to be gc-rooted for the duration of the call. SeeWorking with
          LLVM for where these are derived from and how they get handled.

**Method**

A unique'd container describing the shared metadata for a single method.

- name,module,file,line,sig
    Metadata to uniquely identify the method for the computer and the human.
- ambig
    Cache of other methods that may be ambiguous with this one.
- specializations
    Cache of all MethodInstance ever created for this Method, used to ensure uniqueness. Uniqueness is
    required for efficiency, especially for incremental precompile and tracking of method invalidation.
- source
    The original source code (if available, usually compressed).
- generator
    A callable object which can be executed to get specialized source for a specific method signature.
- roots
    Pointers to non-AST things that have been interpolated into the AST, required by compression of the
    AST, type-inference, or the generation of native code.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1277

- nargs,isva,called,isstaged,pure
    Descriptive bit-fields for the source code of this Method.
- primary_world
    The world age that"owns" this Method.

**MethodInstance**

A unique'd container describing a single callable signature for a Method. See especiallyProper maintenance
and care of multi-threading locksfor important details on how to modify these fields safely.

- specTypes
    The primary key for this MethodInstance. Uniqueness is guaranteed through adef.specializations
    lookup.
- def
    TheMethodthat this function describes a specialization of. Or aModule, if this is a top-level Lambda
    expanded in Module, and which is not part of a Method.
- sparam_vals
    ThevaluesofthestaticparametersinspecTypesindexedbydef.sparam_syms. FortheMethodInstance
    atMethod.unspecialized, this is the emptySimpleVector. But for a runtimeMethodInstancefrom
    theMethodTablecache, this will always be defined and indexable.
- uninferred
    The uncompressed source code for a toplevel thunk. Additionally, for a generated function, this is one
    of many places that the source code might be found.
- backedges
    We store the reverse-list of cache dependencies for efficient tracking of incremental reanalysis/recompi-
    lation work that may be needed after a new method definitions. This works by keeping a list of the other
    MethodInstancethat have been inferred or optimized to contain a possible call to thisMethodInstance.
    Those optimization results might be stored somewhere in thecache, or it might have been the result of
    somethingwedidn'twanttocache, suchasconstantpropagation. Thuswemergeallofthosebackedges
    to various cache entries here (there's almost always only the one applicable cache entry with a sentinel
    value for max_world anyways).
- cache
    Cache ofCodeInstanceobjects that share this template instantiation.

**CodeInstance**

- def
    TheMethodInstancethat this cache entry is derived from.
- rettype/rettype_const
    The inferred return type for thespecFunctionObjectfield, which (in most cases) is also the computed
    return type for the function in general.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1278

- inferred
    May contain a cache of the inferred source for this function, or it could be set tonothingto just indicate
    rettypeis inferred.
- ftpr
    The generic jlcall entry point.
- jlcall_api
    The ABI to use when callingfptr. Some significant ones include:
       **-** 0 - Not compiled yet
       **-** 1 - JLCALLABLE ‘jlvaluet ()(jlfunctiont *f, jlvaluet *args[nargs], uint32t nargs)‘
       **-** 2 - Constant (value stored inrettype_const)
       **-** 3 - With Static-parameters forwardedjl_value_t *(*)(jl_svec_t *sparams, jl_function_t
          *f, jl_value_t *args[nargs], uint32_t nargs)
       **-** 4-Runininterpreterjl_value_t *(*)(jl_method_instance_t *meth, jl_function_t *f, jl_value_t
          *args[nargs], uint32_t nargs)
- min_world/max_world
    The range of world ages for which this method instance is valid to be called. If max_world is the special
    token value-1, the value is not yet known. It may continue to be used until we encounter a backedge
    that requires us to reconsider.

**CodeInfo**

A (usually temporary) container for holding lowered source code.

- code
    AnAnyarray of statements
- slotnames
    An array of symbols giving names for each slot (argument or local variable).
- slotflags
    AUInt8array of slot properties, represented as bit flags:
       **-** 2 - assigned (only false if there are no assignment statements with this var on the left)
       **-** 8 - const (currently unused for local variables)
       **-** 16 - statically assigned once
       **-** 32 - might be used before assigned. This flag is only valid after type inference.
- ssavaluetypes
    Either an array or anInt.
    If anInt, it gives the number of compiler-inserted temporary locations in the function (the length of
    codearray). If an array, specifies a type for each location.
- ssaflags
    Statement-level flags for each expression in the function. Many of these are reserved, but not yet
    implemented:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1279

**-** 0 = inbounds
**-** 1,2 = <reserved> inlinehint,always-inline,noinline
**-** 3 = <reserved> strict-ieee (strictfp)
**-** 4-6 = <unused>
**-** 7 = <reserved> has out-of-band info
- linetable
An array of source location objects
- codelocs
An array of integer indices into thelinetable, giving the location associated with each statement.

Optional Fields:

- slottypes
    An array of types for the slots.
- rettype
    The inferred return type of the lowered form (IR). Default value isAny.
- method_for_inference_limit_heuristics
    Themethod_for_inference_heuristicswill expand the given method's generator if necessary during
    inference.
- parent
    TheMethodInstancethat "owns" this object (if applicable).
- min_world/max_world
    The range of world ages for which this code was valid at the time when it had been inferred.

Boolean properties:

- inferred
    Whether this has been produced by type inference.
- inlineable
    Whether this should be eligible for inlining.
- propagate_inbounds
    Whether this should propagate@inboundswhen inlined for the purpose of eliding@boundscheckblocks.
- pure
    Whether this is known to be a pure function of its arguments, without respect to the state of the method
    caches or other mutable global state.

### 98.3 More about types

If you 've used Julia for a while, you understand the fundamental role that types play. Here we try to get under
the hood, focusing particularly onParametric Types.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1280

### Types and sets (andAnyandUnion{}/Bottom)

It's perhaps easiest to conceive of Julia's type system in terms of sets. While programs manipulate individual
values, a type refers to a set of values. This is not the same thing as a collection; for example aSetof values is
itself a singleSetvalue. Rather, a type describes a set of possible values, expressing uncertainty about which
value we have.

A concrete typeTdescribes the set of values whose direct tag, as returned by thetypeoffunction, isT. An
abstract type describes some possibly-larger set of values.

Anydescribes the entire universe of possible values.Integeris a subset ofAnythat includesInt,Int8, and
other concrete types. Internally, Julia also makes heavy use of another type known asBottom, which can also
be written asUnion{}. This corresponds to the empty set.

Julia's types support the standard operations of set theory: you can ask whetherT1is a "subset" (subtype) of
T2withT1 <: T2. Likewise, you intersect two types usingtypeintersect, take their union withUnion, and
compute a type that contains their union withtypejoin:

```

julia> typeintersect( Int , Float64 )  
Union{}

julia>Union { Int , Float64 }  
Union{Float64, Int64}

julia> typejoin( Int , Float64 )  
Real

julia> typeintersect( Signed , Union { UInt8 , Int8 })  
Int8

julia>Union { Signed , Union { UInt8 , Int8 }}  
Union{UInt8, Signed}

julia> typejoin( Signed , Union { UInt8 , Int8 })  
Integer

julia> typeintersect( Tuple { Integer , Float64 }, Tuple { Int , Real })  
Tuple{Int64, Float64}

julia>Union { Tuple { Integer , Float64 }, Tuple { Int , Real }}  
Union{Tuple{Int64, Real}, Tuple{Integer, Float64}}

julia> typejoin( Tuple { Integer , Float64 }, Tuple { Int , Real })  
Tuple{Integer, Real}

```
While these operations may seem abstract, they lie at the heart of Julia. For example, method dispatch is
implemented by stepping through the items in a method list until reaching one for which the type of the
argument tuple is a subtype of the method signature. For this algorithm to work, it's important that methods
be sorted by their specificity, and that the search begins with the most specific methods. Consequently,
Julia also implements a partial order on types; this is achieved by functionality that is similar to<:, but with
differences that will be discussed below.

### UnionAll types

Julia'stypesystemcanalsoexpressaniteratedunionoftypes: aunionoftypesoverallvaluesofsomevariable.
This is needed to describe parametric types where the values of some parameters are not known.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1281

For example,Arrayhas two parameters as inArray{Int,2}. If we did not know the element type, we could
writeArray{T,2} where T, which is the union ofArray{T,2}for all values ofT:Union{Array{Int8,2},
Array{Int16,2}, ...}.

SuchatypeisrepresentedbyaUnionAllobject,whichcontainsavariable(Tinthisexample,oftypeTypeVar),
and a wrapped type (Array{T,2}in this example).

Consider the following methods:

```

f1(A:: Array ) = 1  
f2(A:: Array { Int }) = 2  
f3(A:: Array {T}) where {T<: Any } = 3  
f4(A:: Array { Any }) = 4

```
Thesignature-asdescribedinFunctioncalls-off3isaUnionAlltypewrappingatupletype:Tuple{typeof(f3),
Array{T}} where T. All butf4can be called witha = [1,2]; all butf2can be called withb = Any[1,2].

Let 's look at these types a little more closely:

```

julia> dump( Array )  
UnionAll  
var: TypeVar  
name: Symbol T  
lb: Union{}  
ub: Any  
body: UnionAll  
var: TypeVar  
name: Symbol N  
lb: Union{}  
ub: Any  
body: Array{T, N} <: DenseArray{T, N}

```
This indicates thatArrayactually names aUnionAlltype. There is oneUnionAlltype for each parameter,
nested. The syntaxArray{Int,2}is equivalent toArray{Int}{2}; internally eachUnionAllis instantiated
with a particular variable value, one at a time, outermost-first. This gives a natural meaning to the omission
of trailing type parameters;Array{Int}gives a type equivalent toArray{Int,N} where N.

ATypeVaris not itself a type, but rather should be considered part of the structure of aUnionAlltype. Type
variables have lower and upper bounds on their values (in the fieldslbandub). The symbolnameis purely
cosmetic. Internally,TypeVars are compared by address, so they are defined as mutable types to ensure that
"different" type variables can be distinguished. However, by convention they should not be mutated.

One can constructTypeVars manually:

```

julia>TypeVar (:V, Signed , Real )  
Signed<:V<:Real

```
There are convenience versions that allow you to omit any of these arguments except thenamesymbol.

The syntaxArray{T} where T<:Integeris lowered to

```

let T = TypeVar (:T, Integer )  
UnionAll(T, Array {T})  
end

```
so it is seldom necessary to construct aTypeVarmanually (indeed, this is to be avoided).


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1282

### Free variables

The concept of a free type variable is extremely important in the type system. We say that a variableVis free
in typeTifTdoes not contain theUnionAllthat introduces variableV. For example, the typeArray{Array{V}
where V<:Integer}has no free variables, but theArray{V}part inside of it does have a free variable,V.

A type with free variables is, in some sense, not really a type at all. Consider the typeArray{Array{T}} where
T, which refers to all homogeneous arrays of arrays. The inner typeArray{T}, seen by itself, might seem to
refer to any kind of array. However, every element of the outer array must have the same array type, so
Array{T}cannot refer to just any old array. One could say thatArray{T}effectively"occurs" multiple times,
andTmust have the same value each"time".

For this reason, the functionjl_has_free_typevarsin the C API is very important. Types for which it returns
true will not give meaningful answers in subtyping and other type functions.

### TypeNames

The following twoArraytypes are functionally equivalent, yet print differently:

```

julia> TV, NV= TypeVar (:T), TypeVar (:N)  
(T, N)

julia>Array  
Array

julia>Array {TV, NV}  
Array{T, N}

```
These can be distinguished by examining thenamefield of the type, which is an object of typeTypeName:

```

julia> dump( Array { Int ,1}.name)  
TypeName  
name: Symbol Array  
module: Module Core  
names: empty SimpleVector  
wrapper: UnionAll  
var: TypeVar  
name: Symbol T  
lb: Union{}  
ub: Any  
body: UnionAll  
var: TypeVar  
name: Symbol N  
lb: Union{}  
ub: Any  
body: Array{T, N} <: DenseArray{T, N}  
cache: SimpleVector  
...

linearcache: SimpleVector  
...

hash: Int64 -7900426068641098781  
mt: MethodTable  
name: Symbol Array

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1283

```

defs: Nothing nothing  
cache: Nothing nothing  
max_args: Int64 0  
kwsorter: #undef  
module: Module Core  
: Int64 0  
: Int64 0

```
In this case, the relevant field iswrapper, which holds a reference to the top-level type used to make new
Arraytypes.

```

julia> pointer_from_objref( Array )  
Ptr{Cvoid} @0x00007fcc7de64850

julia> pointer_from_objref( Array .body.body.name.wrapper)  
Ptr{Cvoid} @0x00007fcc7de64850

julia> pointer_from_objref( Array {TV,NV})  
Ptr{Cvoid} @0x00007fcc80c4d930

julia> pointer_from_objref( Array {TV,NV}.name.wrapper)  
Ptr{Cvoid} @0x00007fcc7de64850

```
Thewrapperfield ofArraypoints to itself, but forArray{TV,NV}it points back to the original definition of the
type.

What about the other fields?hashassigns an integer to each type. To examine thecachefield, it's helpful to
pick a type that is less heavily used than Array. Let's first create our own type:

```

julia> struct MyType{T,N} end

julia> MyType{ Int ,2}  
MyType{Int64, 2}

julia> MyType{ Float32 , 5}  
MyType{Float32, 5}

```
Whenyouinstantiateaparametrictype,eachconcretetypegetssavedinatypecache(MyType.body.body.name.cache).
However, instances containing free type variables are not cached.

### Tuple types

Tuple types constitute an interesting special case. For dispatch to work on declarations likex::Tuple, the type
has to be able to accommodate any tuple. Let's check the parameters:

```

julia>Tuple  
Tuple

julia>Tuple .parameters  
svec(Vararg{Any})

```
Unlike other types, tuple types are covariant in their parameters, so this definition permitsTupleto match any
type of tuple:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1284

```

julia> typeintersect( Tuple , Tuple { Int , Float64 })  
Tuple{Int64, Float64}

julia> typeintersect( Tuple { Vararg { Any }}, Tuple { Int , Float64 })  
Tuple{Int64, Float64}

```
However, if a variadic (Vararg) tuple type has free variables it can describe different kinds of tuples:

```

julia> typeintersect( Tuple { Vararg {T} where T}, Tuple { Int , Float64 })  
Tuple{Int64, Float64}

julia> typeintersect( Tuple { Vararg {T}} where T, Tuple { Int , Float64 })  
Union{}

```
Notice that whenTis free with respect to theTupletype (i.e. its bindingUnionAlltype is outside theTuple
type), only oneTvalue must work over the whole type. Therefore a heterogeneous tuple does not match.

Finally, it's worth noting thatTuple{}is distinct:

```

julia>Tuple {}  
Tuple{}

julia>Tuple {}.parameters  
svec()

julia> typeintersect( Tuple {}, Tuple { Int })  
Union{}

```
What is the"primary" tuple-type?

```

julia> pointer_from_objref( Tuple )  
Ptr{Cvoid} @0x00007f5998a04370

julia> pointer_from_objref( Tuple {})  
Ptr{Cvoid} @0x00007f5998a570d0

julia> pointer_from_objref( Tuple .name.wrapper)  
Ptr{Cvoid} @0x00007f5998a04370

julia> pointer_from_objref( Tuple {}.name.wrapper)  
Ptr{Cvoid} @0x00007f5998a04370

```
soTuple == Tuple{Vararg{Any}}is indeed the primary type.

### Diagonal types

Consider the typeTuple{T,T} where T. A method with this signature would look like:

```

f(x::T, y ::T) where {T}= ...

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1285

According to the usual interpretation of aUnionAlltype, thisTranges over all types, includingAny, so this
type should be equivalent toTuple{Any,Any}. However, this interpretation causes some practical problems.

First, a value ofTneeds to be available inside the method definition. For a call likef(1, 1.0), it 's not clear
whatTshould be. It could beUnion{Int,Float64}, or perhapsReal. Intuitively, we expect the declaration
x::Tto meanT === typeof(x). To make sure that invariant holds, we needtypeof(x) === typeof(y) ===
Tin this method. That implies the method should only be called for arguments of the exact same type.

It turns out that being able to dispatch on whether two values have the same type is very useful (this is
used by the promotion system for example), so we have multiple reasons to want a different interpretation of
Tuple{T,T} where T. To make this work we add the following rule to subtyping: if a variable occurs more than
once in covariant position, it is restricted to ranging over only concrete types. ("Covariant position" means that
onlyTupleandUniontypes occur between an occurrence of a variable and theUnionAlltype that introduces
it.) Such variables are called"diagonal variables" or "concrete variables".

Soforexample,Tuple{T,T} where TcanbeseenasUnion{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...},
whereTranges over all concrete types. This gives rise to some interesting subtyping results. For example
Tuple{Real,Real}isnotasubtypeofTuple{T,T} where T,becauseitincludessometypeslikeTuple{Int8,Int16}
where the two elements have different types. Tuple{Real,Real}andTuple{T,T} where Thave the non-
trivial intersectionTuple{T,T} where T<:Real. However,Tuple{Real}is a subtype ofTuple{T} where T,
because in that caseToccurs only once and so is not diagonal.

Next consider a signature like the following:

```

f(a:: Array {T}, x::T, y ::T) where {T}= ...

```
In this case,Toccurs in invariant position insideArray{T}. That means whatever type of array is passed
unambiguously determines the value ofT– we sayThas an equality constraint on it. Therefore in this case
the diagonal rule is not really necessary, since the array determinesTand we can then allowxandyto be of
any subtypes ofT. So variables that occur in invariant position are never considered diagonal. This choice of
behavior is slightly controversial – some feel this definition should be written as

```

f(a:: Array {T}, x::S, y ::S) where {T, S<:T} = ...

```
to clarify whetherxandyneed to have the same type. In this version of the signature they would, or we could
introduce a third variable for the type ofyifxandycan have different types.

The next complication is the interaction of unions and diagonal variables, e.g.

```

f(x:: Union {Nothing,T}, y::T) where {T}= ...

```
Consider what this declaration means.yhas typeT.xthen can have either the same typeT, or else be of type
Nothing. So all of the following calls should match:

```

f(1, 1)  
f("", "")  
f(2.0, 2.0)  
f(nothing, 1)  
f(nothing, "")  
f(nothing, 2.0)

```
These examples are telling us something: whenxisnothing::Nothing, there are no extra constraints ony.
It is as if the method signature hady::Any. Indeed, we have the following type equivalence:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1286

```

( Tuple { Union {Nothing,T},T} where T)== Union { Tuple {Nothing, Any }, Tuple {T,T} where T}

```
Thegeneralruleis: aconcretevariableincovariantpositionactslikeit'snotconcreteifthesubtypingalgorithm
only uses it once. Whenxhas typeNothing, we don't need to use theTinUnion{Nothing,T}; we only use it in
the second slot. This arises naturally from the observation that inTuple{T} where TrestrictingTto concrete
types makes no difference; the type is equal toTuple{Any}either way.

However, appearing in invariant position disqualifies a variable from being concrete whether that appearance
of the variable is used or not. Otherwise types can behave differently depending on which other types they
are compared to, making subtyping not transitive. For example, consider

```

Tuple { Int , Int8 , Vector { Integer }} <: Tuple {T,T, Vector { Union { Integer ,T}}} where T

```
If theTinside theUnionis ignored, thenTis concrete and the answer is"false" since the first two types aren't
the same. But consider instead

```

Tuple { Int , Int8 , Vector { Any }} <: Tuple {T,T, Vector { Union { Integer ,T}}} where T

```
Now we cannot ignore theTin theUnion(we must haveT == Any), soTis not concrete and the answer is
"true". That would make the concreteness ofTdepend on the other type, which is not acceptable since a type
must have a clear meaning on its own. Therefore the appearance ofTinsideVectoris considered in both
cases.

### Subtyping diagonal variables

The subtyping algorithm for diagonal variables has two components: (1) identifying variable occurrences, and
(2) ensuring that diagonal variables range over concrete types only.

The first task is accomplished by keeping countersoccurs_invandoccurs_cov(insrc/subtype.c) for each
variable in the environment, tracking the number of invariant and covariant occurrences, respectively. A vari-
able is diagonal whenoccurs_inv == 0 && occurs_cov > 1.

The second task is accomplished by imposing a condition on a variable's lower bound. As the subtyping
algorithm runs, it narrows the bounds of each variable (raising lower bounds and lowering upper bounds) to
keep track of the range of variable values for which the subtype relation would hold. When we are done
evaluating the body of aUnionAlltype whose variable is diagonal, we look at the final values of the bounds.
Since the variable must be concrete, a contradiction occurs if its lower bound could not be a subtype of a
concrete type. For example, an abstract type likeAbstractArraycannot be a subtype of a concrete type, but
a concrete type likeIntcan be, and the empty typeBottomcan be as well. If a lower bound fails this test the
algorithm stops with the answerfalse.

For example, in the problemTuple{Int,String} <: Tuple{T,T} where T, we derive that this would be true
ifTwereasupertypeofUnion{Int,String}. However,Union{Int,String}isanabstracttype, sotherelation
does not hold.

This concreteness test is done by the functionis_leaf_bound. Note that this test is slightly different from
jl_is_leaf_type, since it also returnstrueforBottom. Currently this function is heuristic, and does not catch
allpossibleconcretetypes. Thedifficultyisthatwhetheralowerboundisconcretemightdependonthevalues
of other type variable bounds. For example,Vector{T}is equivalent to the concrete typeVector{Int}only
if both the upper and lower bounds ofTequalInt. We have not yet worked out a complete algorithm for this.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1287

### Introduction to the internal machinery

Most operations for dealing with types are found in the filesjltypes.candsubtype.c. A good way to start is
to watch subtyping in action. Build Julia withmake debugand fire up Julia within a debugger.gdb debugging
tips has some tips which may be useful.

BecausethesubtypingcodeisusedheavilyintheREPLitself–andhencebreakpointsinthiscodegettriggered
often – it will be easiest if you make the following definition:

```

julia>function mysubtype(a,b)  
ccall (:jl_breakpoint, Cvoid, ( Any ,), nothing)  
a <: b  
end

```
and then set a breakpoint injl_breakpoint. Once this breakpoint gets triggered, you can set breakpoints in
other functions.

As a warm-up, try the following:

```

mysubtype( Tuple { Int , Float64 }, Tuple { Integer , Real })

```
We can make it more interesting by trying a more complex case:

```

mysubtype( Tuple { Array { Int ,2}, Int8 }, Tuple { Array {T}, T} where T)

```
### Subtyping and method sorting

Thetype_morespecificfunctions are used for imposing a partial order on functions in method tables (from
most-to-least specific). Specificity is strict; ifais more specific thanb, thenadoes not equalbandbis not
more specific thana.

Ifais a strict subtype ofb, then it is automatically considered more specific. From there,type_morespecific
employssomelessformalrules. Forexample,subtypeissensitivetothenumberofarguments,buttype_morespecific
may not be. In particular,Tuple{Int,AbstractFloat}is more specific thanTuple{Integer}, even though
it is not a subtype. (OfTuple{Int,AbstractFloat}andTuple{Integer,Float64}, neither is more specific
than the other.) Likewise,Tuple{Int,Vararg{Int}}is not a subtype ofTuple{Integer}, but it is considered
more specific. However,morespecificdoes get a bonus for length: in particular,Tuple{Int,Int}is more
specific thanTuple{Int,Vararg{Int}}.

If you 're debugging how methods get sorted, it can be convenient to define the function:

```

type_morespecific(a, b)= ccall (:jl_type_morespecific, Cint , ( Any , Any ), a, b)

```
which allows you to test whether tuple typeais more specific than tuple typeb.

### 98.4 Memory layout of Julia Objects

### Object layout (jl_value_t)

Thejl_value_tstruct is the name for a block of memory owned by the Julia Garbage Collector, representing
the data associated with a Julia object in memory. Absent any type information, it is simply an opaque pointer:

```

typedef struct jl_value_t* jl_pvalue_t;

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1288

Eachjl_value_tstruct is contained in ajl_typetag_tstruct that contains metadata information about the
Julia object, such as its type and garbage collector (gc) reachability:

```

typedef struct {  
opaque metadata;  
jl_value_t value;  
} jl_typetag_t;

```
The type of any Julia object is an instance of a leafjl_datatype_tobject. Thejl_typeof()function can be
used to query for it:

```

jl_value_t *jl_typeof(jl_value_t *v);

```
The layout of the object depends on its type. Reflection methods can be used to inspect that layout. A field
can be accessed by calling one of the get-field methods:

```

jl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);  
jl_value_t *jl_get_field(jl_value_t *o, char *fld);

```
If the field types are known, a priori, to be all pointers, the values can also be extracted directly as an array
access:

```

jl_value_t *v = value->fieldptr[n];

```
As an example, a"boxed "uint16_tis stored as follows:

```

struct {  
opaque metadata;  
struct {  
uint16_t data; // -- 2 bytes  
} jl_value_t;  
};

```
This object is created byjl_box_uint16(). Note that thejl_value_tpointer references the data portion, not
the metadata at the top of the struct.

A value may be stored"unboxed" in many circumstances (just the data, without the metadata, and possibly
not even stored but just kept in registers), so it is unsafe to assume that the address of a box is a unique
identifier. The"egal" test (corresponding to the===function in Julia), should instead be used to compare two
unknown objects for equivalence:

```

int jl_egal(jl_value_t *a, jl_value_t *b);

```
This optimization should be relatively transparent to the API, since the object will be"boxed " on-demand,
whenever ajl_value_tpointer is needed.

Notethatmodificationofajl_value_tpointerinmemoryispermittedonlyiftheobjectismutable. Otherwise,
modification of the value may corrupt the program and the result will be undefined. The mutability property
of a value can be queried for with:

```

int jl_is_mutable(jl_value_t *v);

```
If the object being stored is ajl_value_t, the Julia garbage collector must be notified also:

```

void jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);

```
However, theEmbedding Juliasection of the manual is also required reading at this point, for covering other
details of boxing and unboxing various types, and understanding the gc interactions.

Mirror structs for some of the built-in types aredefined injulia.h. The corresponding globaljl_datatype_t
objects are created byjl_init_typesinjltypes.c.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1289

### Garbage collector mark bits

The garbage collector uses several bits from the metadata portion of thejl_typetag_tto track each object
in the system. Further details about this algorithm can be found in the comments of thegarbage collector
implementation ingc.c.

### Object allocation

Most new objects are allocated byjl_new_structv():

```

jl_value_t *jl_new_struct(jl_datatype_t *type, ...);  
jl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);

```
Although,isbitsobjects can be also constructed directly from memory:

```

jl_value_t *jl_new_bits(jl_value_t *bt, void *data)

```
And some objects have special constructors that must be used instead of the above functions:

Types:

```

jl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);  
jl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);

```
While these are the most commonly used options, there are more low-level constructors too, which you can
find declared injulia.h. These are used injl_init_types()to create the initial types needed to bootstrap
the creation of the Julia system image.

Tuples:

```

jl_tuple_t *jl_tuple(size_t n, ...);  
jl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);  
jl_tuple_t *jl_alloc_tuple(size_t n);

```
The representation of tuples is highly unique in the Julia object representation ecosystem. In some cases, a
Base.tuple()object may be an array of pointers to the objects contained by the tuple equivalent to:

```

typedef struct {  
size_t length;  
jl_value_t *data[length];  
} jl_tuple_t;

```
However, in other cases, the tuple may be converted to an anonymousisbitstype and stored unboxed, or it
may not stored at all (if it is not being used in a generic context as ajl_value_t*).

Symbols:

```

jl_sym_t *jl_symbol(const char *str);

```
Functions and MethodInstance:

```

jl_function_t *jl_new_generic_function(jl_sym_t *name);  
jl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);

```
Arrays:

```

jl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);  
jl_array_t *jl_new_arrayv(jl_value_t *atype, ...);  
jl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);  
jl_array_t *jl_alloc_array_2d(jl_value_t *atype, size_t nr, size_t nc);  
jl_array_t *jl_alloc_array_3d(jl_value_t *atype, size_t nr, size_t nc, size_t z);  
jl_array_t *jl_alloc_vec_any(size_t n);

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1290

Notethatmanyofthesehavealternativeallocationfunctionsforvariousspecial-purposes. Thelistherereflects
the more common usages, but a more complete list can be found by reading thejulia.hheader file.

Internal to Julia, storage is typically allocated bynewstruct()(ornewobj()for the special types):

```

jl_value_t *newstruct(jl_value_t *type);  
jl_value_t *newobj(jl_value_t *type, size_t nfields);

```
And at the lowest level, memory is getting allocated by a call to the garbage collector (ingc.c), then tagged
with its type:

```

jl_value_t *jl_gc_allocobj(size_t nbytes);  
void jl_set_typeof(jl_value_t *v, jl_datatype_t *type);

```
Note that all objects are allocated in multiples of 4 bytes and aligned to the platform pointer size. Memory is
allocated from a pool for smaller objects, or directly withmalloc()for large objects.

```

Singleton Types  
Singleton types have only one instance and no data fields. Singleton instances have a size of 0  
bytes, and consist only of their metadata. e.g.nothing::Nothing.  
See Singleton Typesand Nothingness and missing values

```
### 98.5 Eval of Julia code

One of the hardest parts about learning how the Julia Language runs code is learning how all of the pieces work
together to execute a block of code.

Each chunk of code typically makes a trip through many steps with potentially unfamiliar names, such as (in
no particular order): flisp, AST, C++, LLVM,eval,typeinf,macroexpand, sysimg (or system image), boot-
strapping, compile, parse, execute, JIT, interpret, box, unbox, intrinsic function, and primitive function, before
turning into the desired result (hopefully).

```

Definitions

```
- REPL
    REPL stands for Read-Eval-Print Loop. It's just what we call the command line environment
    for short.
- AST
    Abstract Syntax Tree The AST is the digital representation of the code structure. In this form
    the code has been tokenized for meaning so that it is more suitable for manipulation and
    execution.

### Julia Execution

The 10,000 foot view of the whole process is as follows:

1. The user startsjulia.
2. The C functionmain()fromcli/loader_exe.cgets called. This function processes the command line
    arguments,fillinginthejl_optionsstructandsettingthevariableARGS.IttheninitializesJulia(bycalling
    julia_initintask.c, which may load a previously compiledsysimg). Finally, it passes off control to
    Julia by callingBase._start().


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1291

3. When_start()takes over control, the subsequent sequence of commands depends on the command
    line arguments given. For example, if a filename was supplied, it will proceed to execute that file.
    Otherwise, it will start an interactive REPL.
4. Skipping the details about how the REPL interacts with the user, let's just say the program ends up with
    a block of code that it wants to run.
5. If the block of code to run is in a file,jl_load(char *filename)gets invoked to load the file andparse
    it. Each fragment of code is then passed toevalto execute.
6. Each fragment of code (or AST), is handed off toeval()to turn into results.
7. eval()takes each code fragment and tries to run it injl_toplevel_eval_flex().
8. jl_toplevel_eval_flex()decides whether the code is a"toplevel" action (such asusingormodule),
    which would be invalid inside a function. If so, it passes off the code to the toplevel interpreter.
9. jl_toplevel_eval_flex()then expandsthe code to eliminate any macros and to"lower" the AST to
    make it simpler to execute.
10. jl_toplevel_eval_flex()then uses some simple heuristics to decide whether to JIT compiler the AST
or to interpret it directly.
11. The bulk of the work to interpret code is handled byevalininterpreter.c.
12. If instead, the code is compiled, the bulk of the work is handled bycodegen.cpp. Whenever a Julia
function is called for the first time with a given set of argument types,type inferencewill be run on that
function. This information is used by thecodegenstep to generate faster code.
13. Eventually, the user quits the REPL, or the end of the program is reached, and the_start()method
returns.
14. Just before exiting,main()callsjl_atexit_hook(exit_code). This callsBase._atexit()(which calls
any functions registered toatexit()inside Julia). Then it callsjl_gc_run_all_finalizers(). Finally,
it gracefully cleans up alllibuvhandles and waits for them to flush and close.

### Parsing

The Julia parser is a small lisp program written in femtolisp, the source-code for which is distributed inside Julia
in src/flisp.

The interface functions for this are primarily defined injlfrontend.scm. The code inast.chandles this
handoff on the Julia side.

The other relevant files at this stage arejulia-parser.scm, which handles tokenizing Julia code and turning
it into an AST, andjulia-syntax.scm, which handles transforming complex AST representations into simpler,
"lowered" AST representations which are more suitable for analysis and execution.

If you want to test the parser without re-building Julia in its entirety, you can run the frontend on its own as
follows:

```

$ cd src  
$ flisp/flisp

> (load "jlfrontend.scm")  
> (jl-parse-file "")

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1292

### Macro Expansion

Wheneval()encounters a macro, it expands that AST node before attempting to evaluate the expression.
Macro expansion involves a handoff fromeval()(in Julia), to the parser functionjl_macroexpand()(written
inflisp) to the Julia macro itself (written in - what else - Julia) viafl_invoke_julia_macro(), and back.

Typically, macro expansion is invoked as a first step during a call toMeta.lower()/jl_expand(), although it
can also be invoked directly by a call tomacroexpand()/jl_macroexpand().

### Type Inference

Type inference is implemented in Julia bytypeinf()incompiler/typeinfer.jl. Type inference is the process
of examining a Julia function and determining bounds for the types of each of its variables, as well as bounds
on the type of the return value from the function. This enables many future optimizations, such as unboxing
of known immutable values, and compile-time hoisting of various run-time operations such as computing field
offsets and function pointers. Type inference may also include other steps such as constant propagation and
inlining.

```

More Definitions

```
- JIT
    Just-In-Time Compilation The process of generating native-machine code into memory right
    when it is needed.
- LLVM
    Low-Level Virtual Machine (a compiler) The Julia JIT compiler is a program/library called li-
    bLLVM. Codegen in Julia refers both to the process of taking a Julia AST and turning it into
    LLVM instructions, and the process of LLVM optimizing that and turning it into native assem-
    bly instructions.
- C++
    The programming language that LLVM is implemented in, which means that codegen is also
    implemented in this language. The rest of Julia's library is implemented in C, in part because
    its smaller feature set makes it more usable as a cross-language interface layer.
- box
    This term is used to describe the process of taking a value and allocating a wrapper around
    the data that is tracked by the garbage collector (gc) and is tagged with the object's type.
- unbox
    The reverse of boxing a value. This operation enables more efficient manipulation of data
    when the type of that data is fully known at compile-time (through type inference).
- generic function
    A Julia function composed of multiple"methods" that are selected for dynamic dispatch
    based on the argument type-signature
- anonymous function or"method"
    A Julia function without a name and without type-dispatch capabilities
- primitive function
    A function implemented in C but exposed in Julia as a named function"method" (albeit
    without generic function dispatch capabilities, similar to a anonymous function)
- intrinsic function
    A low-level operation exposed as a function in Julia. These pseudo-functions implement
    operations on raw bits such as add and sign extend that cannot be expressed directly in any


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1293

```

other way. Since they operate on bits directly, they must be compiled into a function and  
surrounded by a call toCore.Intrinsics.box(T, ...)to reassign type information to the  
value.

```
### JIT Code Generation

Codegen is the process of turning a Julia AST into native machine code.

The JIT environment is initialized by an early call tojl_init_codegenincodegen.cpp.

Ondemand,aJuliamethodisconvertedintoanativefunctionbythefunctionemit_function(jl_method_instance_t*).
(note, when using the MCJIT (in LLVM v3.4+), each function must be JIT into a new module.) This function re-
cursively callsemit_expr()until the entire function has been emitted.

Much of the remaining bulk of this file is devoted to various manual optimizations of specific code patterns. For
example,emit_known_call()knows how to inline many of the primitive functions (defined inbuiltins.c) for
various combinations of argument types.

Other parts of codegen are handled by various helper files:

- debuginfo.cpp
    Handles backtraces for JIT functions
- ccall.cpp
    Handles the ccall and llvmcall FFI, along with variousabi_*.cppfiles
- intrinsics.cpp
    Handles the emission of various low-level intrinsic functions

```

Bootstrapping  
The process of creating a new system image is called"bootstrapping".  
The etymology of this word comes from the phrase"pulling oneself up by the bootstraps", and  
refers to the idea of starting from a very limited set of available functions and definitions and  
ending with the creation of a full-featured environment.

```
### System Image

The system image is a precompiled archive of a set of Julia files. Thesys.jifile distributed with Julia is one
such system image, generated by executing the filesysimg.jl, and serializing the resulting environment (in-
cluding Types, Functions, Modules, and all other defined values) into a file. Therefore, it contains a frozen
version of theMain,Core, andBasemodules (and whatever else was in the environment at the end of boot-
strapping). This serializer/deserializer is implemented byjl_save_system_image/jl_restore_system_image
instaticdata.c.

If there is no sysimg file (jl_options.image_file == NULL), this also implies that--buildwas given on the
command line, so the final result should be a new sysimg file. During Julia initialization, minimalCoreandMain
modules are created. Then a file namedboot.jlis evaluated from the current directory. Julia then evaluates
any file given as a command line argument until it reaches the end. Finally, it saves the resulting environment
to a "sysimg" file for use as a starting point for a future Julia run.

### 98.6 Calling Conventions

Julia uses three calling conventions for four distinct purposes:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1294

```

Name Prefix Purpose  
Native julia_ Speed via specialized signatures  
JL Call jlcall_ Wrapper for generic calls  
JL Call jl_ Builtins  
C ABI jlcapi_ Wrapper callable from C

```
### Julia Native Calling Convention

The native calling convention is designed for fast non-generic calls. It usually uses a specialized signature.

- LLVM ghosts (zero-length types) are omitted.
- LLVM scalars and vectors are passed by value.
- LLVM aggregates (arrays and structs) are passed by reference.

A small return values is returned as LLVM return values. A large return values is returned via the"structure
return " (sret) convention, where the caller provides a pointer to a return slot.

AnargumentorreturnvaluesthatisahomogeneoustupleissometimesrepresentedasanLLVMvectorinstead
of an LLVM array.

### JL Call Convention

The JL Call convention is for builtins and generic dispatch. Hand-written functions using this convention are
declared via the macroJL_CALLABLE. The convention uses exactly 3 parameters:

- F- Julia representation of function that is being applied
- args- pointer to array of pointers to boxes
- nargs- length of the array

The return value is a pointer to a box.

### C ABI

C ABI wrappers enable calling Julia from C. The wrapper calls a function using the native calling convention.

Tuples are always represented as C arrays.

### 98.7 High-level Overview of the Native-Code Generation Process

### Representation of Pointers

Whenemittingcodetoanobjectfile,pointerswillbeemittedasrelocations. Thedeserializationcodewillensure
any object that pointed to one of these constants gets recreated and contains the right runtime pointer.

Otherwise, they will be emitted as literal constants.

To emit one of these objects, callliteral_pointer_val. It 'll handle tracking the Julia value and the LLVM
global, ensuring they are valid both for the current runtime and after deserialization.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1295

When emitted into the object file, these globals are stored as references in a largegvalstable. This allows
the deserializer to reference them by index, and implement a custom manual mechanism similar to a Global
Offset Table (GOT) to restore them.

Function pointers are handled similarly. They are stored as values in a largefvalstable. Like globals, this
allows the deserializer to reference them by index.

Note thatexternfunctions are handled separately, with names, via the usual symbol resolution mechanism
in the linker.

Note too thatccallfunctions are also handled separately, via a manual GOT and Procedure Linkage Table
(PLT).

### Representation of Intermediate Values

Values are passed around in ajl_cgval_tstruct. This represents an R-value, and includes enough information
to determine how to assign or pass it somewhere.

They are created via one of the helper constructors, usually:mark_julia_type(for immediate values) and
mark_julia_slot(for pointers to values).

Thefunctionconvert_julia_typecantransformbetweenanytwotypes. ItreturnsanR-valuewithcgval.typ
set totyp. It 'll cast the object to the requested representation, making heap boxes, allocating stack copies,
and computing tagged unions as needed to change the representation.

By contrastupdate_julia_typewill changecgval.typtotyp, only if it can be done at zero-cost (i.e. without
emitting any code).

### Union representation

Inferred union types may be stack allocated via a tagged type representation.

The primitive routines that need to be able to handle tagged unions are:

- mark-type
- load-local
- store-local
- isa
- is
- emit_typeof
- emit_sizeof
- boxed
- unbox
- specialized cc-ret

Everythingelseshouldbepossibletohandleininferencebyusingtheseprimitivestoimplementunion-splitting.

The representation of the tagged-union is as a pair of< void* union, byte selector >. The selector is
fixed-size asbyte & 0x7f, and will union-tag the first 126 isbits. It records the one-based depth-first count
into the type-union of the isbits objects inside. An index of zero indicates that theunion*is actually a tagged


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1296

heap-allocatedjl_value_t*, and needs to be treated as normal for a boxed object rather than as a tagged
union.

The high bit of the selector (byte & 0x80) can be tested to determine if thevoid*is actually a heap-allocated
(jl_value_t*) box, thus avoiding the cost of re-allocating a box, while maintaining the ability to efficiently
handle union-splitting based on the low bits.

It is guaranteed thatbyte & 0x7fis an exact test for the type, if the value can be represented by a tag – it
will never be markedbyte = 0x80. It is not necessary to also test the type-tag when testingisa.

Theunion*memory region may be allocated at any size. The only constraint is that it is big enough to contain
the data currently specified byselector. It might not be big enough to contain the union of all types that
could be stored there according to the associated Union type field. Use appropriate care when copying.

### Specialized Calling Convention Signature Representation

Ajl_returninfo_tobject describes the calling convention details of any callable.

If any of the arguments or returntype of a method can be represented unboxed, and the method is not varargs,
it'll be given an optimized calling convention signature based on itsspecTypesandrettypefields.

The general principles are that:

- Primitive types get passed in int/float registers.
- Tuples of VecElement types get passed in vector registers.
- Structs get passed on the stack.
- Return values are handle similarly to arguments, with a size-cutoff at which they will instead be returned
    via a hidden sret argument.

The total logic for this is implemented byget_specsig_functionanddeserves_sret.

Additionally, if the return type is a union, it may be returned as a pair of values (a pointer and a tag). If the
union values can be stack-allocated, then sufficient space to store them will also be passed as a hidden first
argument. It is up to the callee whether the returned pointer will point to this space, a boxed object, or even
other constant memory.

### 98.8 Julia Functions

This document will explain how functions, method definitions, and method tables work.

### Method Tables

Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of
many definitions, or methods. The methods of a generic function are stored in a method table. Method tables
(typeMethodTable) are associated withTypeNames. ATypeNamedescribes a family of parameterized types.
For exampleComplex{Float32}andComplex{Float64}share the sameComplextype name object.

All objects in Julia are potentially callable, because every object has a type, which in turn has aTypeName.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1297

### Function calls

Given the callf(x,y), the following steps are performed: first, the method table to use is accessed as
typeof(f).name.mt. Second,anargumenttupletypeisformed,Tuple{typeof(f), typeof(x), typeof(y)}.
Note that the type of the function itself is the first element. This is because the type might have parameters,
and so needs to take part in dispatch. This tuple type is looked up in the method table.

This dispatch process is performed byjl_apply_generic, which takes two arguments: a pointer to an array
of the values f, x, and y, and the number of values (in this case 3).

Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept
the function and arguments separately, and those that accept a single argument structure. In the first kind of
API, the"arguments" part does not contain information about the function, since that is passed separately. In
the second kind of API, the function is the first element of the argument structure.

For example, the following function for performing a call accepts just anargspointer, so the first element of
the args array will be the function to call:

```

jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)

```
This entry point for the same functionality accepts the function separately, so theargsarray does not contain
the function:

```

jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);

```
### Adding methods

Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and
(2)codeforthebodyofthemethod.jl_method_defimplementsthisoperation.jl_first_argument_datatype
is called to extract the relevant method table from what would be the type of the first argument. This is much
more complicated than the corresponding procedure during dispatch, since the argument tuple type might be
abstract. For example, we can define:

```

(:: Union {Foo{ Int },Foo{ Int8 }})(x)= 0

```
which works since all possible matching methods would belong to the same method table.

### Creating generic functions

Sinceeveryobjectiscallable,nothingspecialisneededtocreateagenericfunction. Thereforejl_new_generic_function
simply creates a new singleton (0 size) subtype ofFunctionand returns its instance. A function can have a
mnemonic"display name" which is used in debug info and when printing objects. For example the name of
Base.sinissin. By convention, the name of the created type is the same as the function name, with a#
prepended. Sotypeof(sin)isBase.#sin.

### Closures

A closure is simply a callable object with field names corresponding to captured variables. For example, the
following code:

```

function adder(x)  
return y->x+y  
end

```
is lowered to (roughly):


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1298

```

struct##1{T}  
x::T  
end

(_::##1)(y) = _.x + y

function adder(x)  
return ##1(x)  
end

```
### Constructors

A constructor call is just a call to a type. The method table forTypecontains all constructor definitions. All
subtypes ofType(Type,UnionAll,Union, andDataType) currently share a method table via special arrange-
ment.

### Builtins

The "builtin" functions, defined in theCoremodule, are:

```

=== typeof sizeof <: isa typeassert throw tuple getfield setfield! fieldtype  
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply  
_expr svec

```
These are all singleton objects whose types are subtypes ofBuiltin, which is a subtype ofFunction. Their
purpose is to expose entry points in the run time that use the"jlcall" calling convention:

```

jl_value_t _(jl_value_t_, jl_value_t**, uint32_t)

```
Themethodtablesofbuiltinsareempty. Instead,theyhaveasinglecatch-allmethodcacheentry(Tuple{Vararg{Any}})
whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.

### Keyword arguments

Keywordargumentsworkbyassociatingaspecial, hiddenfunctionobjectwitheachmethodtablethathasdefi-
nitions with keyword arguments. This function is called the"keyword argument sorter" or "keyword sorter", or
"kwsorter", and is stored in thekwsorterfield ofMethodTableobjects. Every definition in the kwsorter func-
tion has the same arguments as some definition in the normal method table, except with a singleNamedTuple
argument prepended, which gives the names and values of passed keyword arguments. The kwsorter's job is
to move keyword arguments into their canonical positions based on name, plus evaluate and substitute any
needed default value expressions. The result is a normal positional argument list, which is then passed to yet
another compiler-generated function.

The easiest way to understand the process is to look at how a keyword argument method definition is lowered.
The code:

```

function circle(center, radius; color= black, fill:: Bool = true , options...)

# draw

end

```
actuallyproducesthreemethoddefinitions. Thefirstisafunctionthatacceptsallarguments(includingkeyword
arguments) as positional arguments, and includes the code for the method body. It has an auto-generated
name:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1299

```

function #circle#1(color, fill::Bool, options, circle, center, radius)

# draw

end

```
The second method is an ordinary definition for the originalcirclefunction, which handles the case where no
keyword arguments are passed:

```

function circle(center, radius)  
#circle#1(black, true, pairs(NamedTuple()), circle, center, radius)  
end

```
This simply dispatches to the first method, passing along default values.pairsis applied to the named tuple
of rest arguments to provide key-value pair iteration. Note that if the method doesn't accept rest keyword
arguments then this argument is absent.

Finally there is the kwsorter definition:

```

function (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)  
if haskey(kws, :color)  
color = kws.color  
else  
color = black  
end

# etc.

# put remaining kwargs in `options`

options = structdiff(kws, NamedTuple{(:color, :fill)})

# if the method doesn't accept rest keywords, throw an error

# unless `options` is empty

#circle#1(color, fill, pairs(options), circle, center, radius)  
end

```
The functionCore.kwftype(t)creates the fieldt.name.mt.kwsorter(if it hasn't been created yet), and re-
turns the type of that function.

This design has the feature that call sites that don't use keyword arguments require no special handling;
everything works as if they were not part of the language at all. Call sites that do use keyword arguments are
dispatched directly to the called function's kwsorter. For example the call:

```

circle((0,0), 1.0, color= red; other...)

```
is lowered to:

```

kwfunc(circle)(merge((color= red,), other), circle, (0,0), 1.0)

```
kwfunc(also inCore) fetches the kwsorter for the called function. The keyword splatting operation (written
asother...) calls the named tuplemergefunction. This function further unpacks each element ofother,
expecting each one to contain two values (a symbol and a value). Naturally, a more efficient implementation
is available if all splatted arguments are named tuples. Notice that the originalcirclefunction is passed
through, to handle closures.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1300

### Compiler efficiency issues

Generating a new type for every function has potentially serious consequences for compiler resource use when
combined with Julia's "specialize on all arguments by default" design. Indeed, the initial implementation of this
design suffered from much longer build and test times, higher memory use, and a system image nearly 2x
larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly
unusable. Several significant optimizations were needed to make the design practical.

The first issue is excessive specialization of functions for different values of function-valued arguments. Many
functions simply"pass through" an argument to somewhere else, e.g. to another function or to a storage
location. Such functions do not need to be specialized for every closure that might be passed in. Fortu-
nately this case is easy to distinguish by simply considering whether a function calls one of its arguments (i.e.
the argument appears in"head position" somewhere). Performance-critical higher-order functions likemap
certainly call their argument function and so will still be specialized as expected. This optimization is imple-
mented by recording which arguments are called during theanalyze-variablespass in the front end. When
cache_methodsees an argument in theFunctiontype hierarchy passed to a slot declared asAnyorFunction,
it behaves as if the@nospecializeannotation were applied. This heuristic seems to be extremely effective in
practice.

The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast
majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be
resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised
by this at all. However, this argument means"multiple dispatch is easy to optimize in practice", and that we
should therefore use it, not"we should use single dispatch"!) So the method cache uses the type of the first
argument as its primary key. Note, however, that this corresponds to the second element of the tuple type for
a function call (the first element being the type of the function itself). Typically, type variation in head position
is extremely low – indeed, the majority of functions belong to singleton types with no parameters. However,
this is not the case for constructors, where a single method table holds constructors for every type. Therefore
theTypemethod table is special-cased to use the first tuple type element instead of the second.

Thefrontendgeneratestypedeclarationsforallclosures. Initially, thiswasimplementedbygeneratingnormal
type declarations. However, this produced an extremely large number of constructors, all of which were trivial
(simply passing all arguments through tonew). Since methods are partially ordered, inserting all of these
methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating
struct_typeexpressions directly (bypassing default constructor generation), and usingnewdirectly to create
closure instances. Not the prettiest thing ever, but you do what you gotta do.

The next problem was the@testmacro, which generated a 0-argument closure for each test case. This is not
really necessary, since each test case is simply run once in place. Therefore,@testwas modified to expand to
a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler
on it.

### 98.9 Base.Cartesian.

The(non-exported)Cartesianmoduleprovidesmacrosthatfacilitatewritingmultidimensionalalgorithms. Most
often you can write such algorithms withstraightforward techniques; however, there are a few cases where
Base.Cartesianis still useful or necessary.

### Principles of usage

A simple example of usage is:

```

@nloops3 i A begin  
s += @nref3 A i  
end

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1301

which generates the following code:

```

for i_3 = axes(A,3)  
for i_2 = axes(A,2)  
for i_1 = axes(A,1)  
s += A[i_1, i_2, i_3]  
end  
end  
end

```
In general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops
in this example. Other applications include repeated expressions (e.g., loop unwinding) or creating function
calls with variable numbers of arguments without using the"splat" construct (i...).

### Basic syntax

The (basic) syntax of@nloopsis as follows:

- The first argument must be an integer (not a variable) specifying the number of loops.
- The second argument is the symbol-prefix used for the iterator variable. Here we usedi, and variables
    i_1, i_2, i_3were generated.
- The third argument specifies the range for each iterator variable. If you use a variable (symbol) here, it's
    takenasaxes(A, dim). Moreflexibly,youcanusetheanonymous-functionexpressionsyntaxdescribed
    below.
- The last argument is the body of the loop. Here, that's what appears between thebegin...end.

There are some additional features of@nloopsdescribed in thereference section.

@nreffollows a similar pattern, generatingA[i_1,i_2,i_3]from@nref 3 A i. The general practice is to
read from left to right, which is why@nloopsis@nloops 3 i A expr(as infor i_2 = axes(A, 2), where
i_2is to the left and the range is to the right) whereas@nrefis@nref 3 A i(as inA[i_1,i_2,i_3], where
the array comes first).

If you 're developing code with Cartesian, you may find that debugging is easier when you examine the gener-
ated code, using@macroexpand:

```

julia> @macroexpand@nref2 A i  
:(A[i_1, i_2])

```
**Supplying the number of expressions**

The first argument to both of these macros is the number of expressions, which must be an integer. When
you're writing a function that you intend to work in multiple dimensions, this may not be something you want
to hard-code. The recommended approach is to use a@generated function. Here 's an example:

```

@generated function mysum(A:: Array {T,N}) where {T,N}  
quote  
s = zero(T)  
@nloops$N i A begin  
s += @nref$N A i  
end

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1302

```

s  
end  
end

```
Naturally, you can also prepare expressions or perform calculations before thequoteblock.

**Anonymous-function expressions as macro arguments**

Perhaps the single most powerful feature inCartesianis the ability to supply anonymous-function expressions
that get evaluated at parsing time. Let's consider a simple example:

```

@nexprs2 j->(i_j= 1)

```
@nexprsgeneratesnexpressions that follow a pattern. This code would generate the following statements:

```

i_1 = 1  
i_2 = 1

```
In each generated statement, an"isolated"j(the variable of the anonymous function) gets replaced by values
in the range1:2. Generally speaking, Cartesian employs a LaTeX-like syntax. This allows you to do math on
the indexj. Here 's an example computing the strides of an array:

```

s_1 = 1  
@nexprs3 j->(s_{j+1} = s_j * size(A, j))

```
would generate expressions

```

s_1 = 1  
s_2 = s_1 * size(A,1)  
s_3 = s_2 * size(A,2)  
s_4 = s_3 * size(A,3)

```
Anonymous-function expressions have many uses in practice.

**Macro reference** Base.Cartesian.@nloops– Macro.

```

@nloopsN itersym rangeexpr bodyexpr  
@nloopsN itersym rangeexpr preexpr bodyexpr  
@nloopsN itersym rangeexpr preexpr postexpr bodyexpr

GenerateNnested loops, usingitersymas the prefix for the iteration variables.rangeexprmay be an  
anonymous-function expression, or a simple symbolvarin which case the range isaxes(var, d)for  
dimensiond.  
Optionally, you can provide"pre " and "post" expressions. These get executed first and last, respectively,  
in the body of each loop. For example:  
@nloops 2 i A d -> j_d = min(i_d, 5) begin  
s += @nref 2 A j  
end

would generate:

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1303

```

for i_2 = axes(A, 2)  
j_2 = min(i_2, 5)  
for i_1 = axes(A, 1)  
j_1 = min(i_1, 5)  
s += A[j_1, j_2]  
end  
end

If you want just a post-expression, supplynothingfor the pre-expression. Using parentheses and semi-  
colons, you can supply multi-statement expressions.  
source

```
Base.Cartesian.@nref– Macro.

```

@nrefN A indexexpr

Generate expressions likeA[i_1, i_2, ...].indexexprcan either be an iteration-symbol prefix, or an  
anonymous-function expression.  
Examples

julia> @macroexpandBase.Cartesian.@nref3 A i  
:(A[i_1, i_2, i_3])

source

```
Base.Cartesian.@nextract– Macro.

```

@nextractN esym isym

GenerateNvariablesesym_1,esym_2, ...,esym_Nto extract values fromisym.isymcan be either aSymbol  
or anonymous-function expression.  
@nextract 2 x ywould generate  
x_1 = y[1]  
x_2 = y[2]

while@nextract 3 x d->y[2d-1]yields  
x_1 = y[1]  
x_2 = y[3]  
x_3 = y[5]

source

```
Base.Cartesian.@nexprs– Macro.

```

@nexprsN expr

GenerateNexpressions.exprshould be an anonymous-function expression.  
Examples

julia> @macroexpandBase.Cartesian.@nexprs4 i -> y[i]= A[i+j]  
quote  
y[1] = A[1 + j]  
y[2] = A[2 + j]  
y[3] = A[3 + j]  
y[4] = A[4 + j]  
end

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1304

```

source

```
Base.Cartesian.@ncall– Macro.

```

@ncallN f sym...

Generate a function call expression.symrepresents any number of function arguments, the last of which  
may be an anonymous-function expression and is expanded intoNarguments.  
For example,@ncall 3 func agenerates  
func(a_1, a_2, a_3)

while@ncall 2 func a b i->c[i]yields  
func(a, b, c[1], c[2])

source

```
Base.Cartesian.@ntuple– Macro.

```

@ntupleN expr

Generates anN-tuple.@ntuple 2 iwould generate(i_1, i_2), and@ntuple 2 k->k+1would generate  
(2,3).  
source

```
Base.Cartesian.@nall– Macro.

```

@nallN expr

Check whether all of the expressions generated by the anonymous-function expressionexprevaluate to  
true.  
@nall 3 d->(i_d > 1)would generate the expression(i_1 > 1 && i_2 > 1 && i_3 > 1). This can be  
convenient for bounds-checking.  
source

```
Base.Cartesian.@nany– Macro.

```

@nanyN expr

Check whether any of the expressions generated by the anonymous-function expressionexprevaluate to  
true.  
@nany 3 d->(i_d > 1)would generate the expression(i_1 > 1 || i_2 > 1 || i_3 > 1).  
source

```
Base.Cartesian.@nif– Macro.

```

@nifN conditionexpr expr  
@nifN conditionexpr expr elseexpr

Generates a sequence ofif ... elseif ... else ... endstatements. For example:  
@nif 3 d->(i_d >= size(A,d)) d->(error("Dimension ", d, " too big")) d->println("All OK")

would generate:

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1305

```

if i_1 > size(A, 1)  
error("Dimension ", 1, " too big")  
elseif i_2 > size(A, 2)  
error("Dimension ", 2, " too big")  
else  
println("All OK")  
end

source

```
### 98.10Talking to the compiler (the:metamechanism).

In some circumstances, one might wish to provide hints or instructions that a given block of code has special
properties: you might always want to inline it, or you might want to turn on special compiler optimization
passes. Starting with version 0.4, Julia has a convention that these instructions can be placed inside a:meta
expression, which is typically (but not necessarily) the first expression in the body of a function.

:metaexpressions are created with macros. As an example, consider the implementation of the@inline
macro:

```

macro inline(ex)  
esc(isa(ex, Expr )? pushmeta!(ex,:inline): ex)  
end

```
Here,exis expected to be an expression defining a function. A statement like this:

```

@inline function myfunction(x)  
x*(x+3)  
end

```
gets turned into an expression like this:

```

quote  
function myfunction(x)  
Expr (:meta,:inline)  
x*(x+3)  
end  
end

```
Base.pushmeta!(ex, :symbol, args...)appends:symbolto the end of the:metaexpression, creating a
new:metaexpression if necessary. Ifargsis specified, a nested expression containing:symboland these
arguments is appended instead, which can be used to specify additional information.

To use the metadata, you have to parse these:metaexpressions. If your implementation can be performed
within Julia,Base.popmeta! is very handy:Base.popmeta!(body, :symbol)will scan a function body ex-
pression (one without the function signature) for the first:metaexpression containing:symbol, extract any
arguments, and return a tuple(found::Bool, args::Array{Any}). If the metadata did not have any argu-
ments, or:symbolwas not found, theargsarray will be empty.

Not yet provided is a convenient infrastructure for parsing:metaexpressions from C++.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1306

### 98.11SubArrays

Julia'sSubArraytype is a container encoding a"view" of a parentAbstractArray. This page documents some
of the design principles and implementation ofSubArrays.

OneofthemajordesigngoalsistoensurehighperformanceforviewsofbothIndexLinearandIndexCartesian
arrays. Furthermore, views ofIndexLineararrays should themselves beIndexLinearto the extent that it is
possible.

### Index replacement

Consider making 2d slices of a 3d array:

```

julia> A = rand(2,3,4);

julia> S1 = view(A,:, 1, 2:3)  
2×2 view(::Array{Float64, 3}, :, 1, 2:3) with eltype Float64:  
0.839622 0.711389  
0.967143 0.103929

julia> S2 = view(A,1, :, 2:3)  
3×2 view(::Array{Float64, 3}, 1, :, 2:3) with eltype Float64:  
0.839622 0.711389  
0.789764 0.806704  
0.566704 0.962715

```
viewdrops "singleton" dimensions (ones that are specified by anInt), so bothS1andS2are two-dimensional
SubArrays. Consequently, the natural way to index these is withS1[i,j]. To extract the value from the parent
arrayA,thenaturalapproachistoreplaceS1[i,j]withA[i,1,(2:3)[j]]andS2[i,j]withA[1,i,(2:3)[j]].

ThekeyfeatureofthedesignofSubArraysisthatthisindexreplacementcanbeperformedwithoutanyruntime
overhead.

### SubArray design

**Type parameters and fields**

The strategy adopted is first and foremost expressed in the definition of the type:

```

struct SubArray {T,N,P,I,L} <: AbstractArray {T,N}  
parent::P  
indices::I  
offset1:: Int # for linear indexing and pointer, only valid when L==true  
stride1:: Int # used only for linear indexing  
...  
end

```
SubArrayhas 5 type parameters. The first two are the standard element type and dimensionality. The next is
the type of the parentAbstractArray. The most heavily-used is the fourth parameter, aTupleof the types of
the indices for each dimension. The final one,L, is only provided as a convenience for dispatch; it's a boolean
that represents whether the index types support fast linear indexing. More on that later.

IfinourexampleaboveAisaArray{Float64, 3},ourS1caseabovewouldbeaSubArray{Float64,2,Array{Float64,3},Tuple{Base.Slice{Base.OneTo{Int64}},Int64,UnitRange{Int64}},false}.
Note in particular the tuple parameter, which stores the types of the indices used to createS1. Likewise,


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1307

```

julia> S1.indices  
(Base.Slice(Base.OneTo(2)), 1, 2:3)

```
Storing these values allows index replacement, and having the types encoded as parameters allows one to
dispatch to efficient algorithms.

**Index translation**

Performing index translation requires that you do different things for different concreteSubArraytypes. For
example, forS1, one needs to apply thei,jindices to the first and third dimensions of the parent array,
whereas forS2one needs to apply them to the second and third. The simplest approach to indexing would be
to do the type-analysis at runtime:

```

parentindices= Vector { Any }()  
for thisindex in S.indices  
...  
if isa(thisindex, Int )

# Don't consume one of the input indices

push!(parentindices, thisindex)  
elseif isa(thisindex, AbstractVector )

# Consume an input index

push!(parentindices, thisindex[inputindex[j]])  
j += 1  
elseif isa(thisindex, AbstractMatrix )

# Consume two input indices

push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])  
j += 2  
elseif ...  
end  
S.parent[parentindices...]

```
Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory,
and involves the running of a lot of poorly-typed code.

Thebetterapproachistodispatchtospecificmethodstohandleeachtypeofstoredindex. That'swhatreindex
does: it dispatches on the type of the first stored index and consumes the appropriate number of input indices,
and then it recurses on the remaining indices. In the case ofS1, this expands to

```

Base.reindex(S1, S1.indices, (i, j))== (i, S1.indices[2], S1.indices[3][j])

```
for any pair of indices(i,j)(exceptCartesianIndexs and arrays thereof, see below).

ThisisthecoreofaSubArray; indexingmethodsdependuponreindextodothisindextranslation. Sometimes,
though, we can avoid the indirection and make it even faster.

**Linear indexing**

Linear indexing can be implemented efficiently when the entire array has a single stride that separates suc-
cessive elements, starting from some offset. This means that we can pre-compute these values and represent
linear indexing simply as an addition and multiplication, avoiding the indirection ofreindexand (more impor-
tantly) the slow computation of the cartesian coordinates entirely.

ForSubArraytypes, the availability of efficient linear indexing is based purely on the types of the indices, and
does not depend on values like the size of the parent array. You can ask whether a given set of indices supports
fast linear indexing with the internalBase.viewindexingfunction:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1308

```

julia> Base.viewindexing(S1.indices)  
IndexCartesian()

julia> Base.viewindexing(S2.indices)  
IndexLinear()

```
This is computed during construction of theSubArrayand stored in theLtype parameter as a boolean that
encodesfastlinearindexingsupport. Whilenotstrictlynecessary, itmeansthatwecandefinedispatchdirectly
onSubArray{T,N,A,I,true}without any intermediaries.

Since this computation doesn't depend on runtime values, it can miss some cases in which the stride happens
to be uniform:

```

julia> A = reshape(1:4*2, 4, 2)  
4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:  
1 5  
2 6  
3 7  
4 8

julia> diff(A[2:2:4,:][:])  
3-element Vector{Int64}:  
2  
2  
2

```
A view constructed asview(A, 2:2:4, :) happens to have uniform stride, and therefore linear indexing
indeed could be performed efficiently. However, success in this case depends on the size of the array: if the
first dimension instead were odd,

```

julia> A = reshape(1:5*2, 5, 2)  
5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:  
1 6  
2 7  
3 8  
4 9  
5 10

julia> diff(A[2:2:4,:][:])  
3-element Vector{Int64}:  
2  
3  
2

```
thenA[2:2:4,:]does not have uniform stride, so we cannot guarantee efficient linear indexing. Since we
have to base this decision based purely on types encoded in the parameters of theSubArray,S = view(A,
2:2:4, :)cannot implement efficient linear indexing.

**A few details**

- Note that theBase.reindexfunction is agnostic to the types of the input indices; it simply determines
    how and where the stored indices should be reindexed. It not only supports integer indices, but it
    supports non-scalar indexing, too. This means that views of views don't need two levels of indirection;
    they can simply re-compute the indices into the original parent array!


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1309

- Hopefully by now it's fairly clear that supporting slices means that the dimensionality, given by the
    parameterN, is not necessarily equal to the dimensionality of the parent array or the length of the
    indicestuple. Neither do user-supplied indices necessarily line up with entries in theindicestuple
    (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and
    the third element in theindicestuple).
    What might be less obvious is that the dimensionality of the stored parent array must be equal to the
    number of effective indices in theindicestuple. Some examples:

```

A = reshape(1:35, 5, 7) # A 2d parent Array  
S = view(A,2:7) # A 1d view created by linear indexing  
S = view(A,:, :, 1:1) # Appending extra indices is supported

Naively, you'd think you could just setS.parent = AandS.indices = (:,:,1:1), but supporting this  
dramatically complicates the reindexing process, especially for views of views. Not only do you need to  
dispatch on the types of the stored indices, but you need to examine whether a given index is the final  
one and"merge " any remaining stored indices together. This is not an easy task, and even worse: it's  
slow since it implicitly depends upon linear indexing.  
Fortunately, this is precisely the computation thatReshapedArrayperforms, and it does so linearly if  
possible. Consequently,viewensures that the parent array is the appropriate dimensionality for the  
given indices by reshaping it if needed. The innerSubArrayconstructor ensures that this invariant is  
satisfied.

```
- CartesianIndexandarraysthereofthrowanastywrenchintothereindexscheme. Recallthatreindex
    simply dispatches on the type of the stored indices in order to determine how many passed indices
    should be used and where they should go. But withCartesianIndex, there's no longer a one-to-one
    correspondence between the number of passed arguments and the number of dimensions that they
    index into. If we return to the above example ofBase.reindex(S1, S1.indices, (i, j)), you can
    see that the expansion is incorrect fori, j = CartesianIndex(), CartesianIndex(2,1). It should
    skip theCartesianIndex()entirely and return:

```

( CartesianIndex (2,1)[1], S1.indices[2], S1.indices[3][ CartesianIndex (2,1)[2]])

Instead, though, we get:

( CartesianIndex (), S1.indices[2], S1.indices[3][ CartesianIndex (2,1)])

Doing this correctly would require combined dispatch on both the stored and passed indices across all  
combinations of dimensionalities in an intractable manner. As such,reindexmust never be called  
withCartesianIndexindices. Fortunately, the scalar case is easily handled by first flattening the  
CartesianIndexarguments to plain integers. Arrays ofCartesianIndex, however, cannot be split  
apart into orthogonal pieces so easily. Before attempting to usereindex,viewmust ensure that there  
are no arrays ofCartesianIndexin the argument list. If there are, it can simply"punt" by avoiding the  
reindexcalculation entirely, constructing a nestedSubArraywith two levels of indirection instead.

```
### 98.12isbits Union Optimizations.

In Julia, theArraytype holds both"bits" values as well as heap-allocated"boxed " values. The distinction is
whether the value itself is stored inline (in the direct allocated memory of the array), or if the memory of
the array is simply a collection of pointers to objects allocated elsewhere. In terms of performance, accessing
valuesinlineisclearlyanadvantageoverhavingtofollowapointertotheactualvalue. Thedefinitionof"isbits"
generally means any Julia type with a fixed, determinate size, meaning no"pointer" fields, see?isbitstype.

Julia also supports Union types, quite literally the union of a set of types. Custom Union type definitions can
be extremely handy for applications wishing to"cut across" the nominal type system (i.e. explicit subtype


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1310

relationships) and define methods or functionality on these, otherwise unrelated, set of types. A compiler
challenge, however, is in determining how to treat these Union types. The naive approach (and indeed, what
Julia itself did pre-0.7), is to simply make a"box " and then a pointer in the box to the actual value, similar
to the previously mentioned"boxed " values. This is unfortunate, however, because of the number of small,
primitive"bits" types (thinkUInt8,Int32,Float64, etc.) that would easily fit themselves inline in this"box "
without needing any indirection for value access. There are two main ways Julia can take advantage of this
optimization as of 0.7: isbits Union fields in types, and isbits Union Arrays.

### isbits Union Structs

Julia now includes an optimization wherein"isbits Union" fields in types (mutable struct,struct, etc.) will
be stored inline. This is accomplished by determining the"inline size" of the Union type (e.g.Union{UInt8,
Int16}will have a size of two bytes, which represents the size needed of the largest Union typeInt16), and in
addition, allocating an extra"type tag byte" (UInt8), whose value signals the type of the actual value stored
inline of the"Union bytes". The type tag byte value is the index of the actual value's type in the Union type's
order of types. For example, a type tag value of0x02for a field with typeUnion{Nothing, UInt8, Int16}
would indicate that anInt16value is stored in the 16 bits of the field in the structure's memory; a0x01value
would indicate that aUInt8value was stored in the first 8 bits of the 16 bits of the field's memory. Lastly, a
value of0x00signals that thenothingvalue will be returned for this field, even though, as a singleton type
with a single type instance, it technically has a size of 0. The type tag byte for a type's Union field is stored
directly after the field's computed Union memory.

### isbits Union Arrays

Julia can now also store"isbits Union" values inline in an Array, as opposed to requiring an indirection box.
The optimization is accomplished by storing an extra"type tag array" of bytes, one byte per array element,
alongside the bytes of the actual array data. This type tag array serves the same function as the type field
case: itsvaluesignalsthetypeoftheactualstoredUnionvalueinthearray. Intermsoflayout, aJuliaArraycan
include extra"buffer" space before and after its actual data values, which are tracked in thea->offsetand
a->maxsizefields of thejl_array_t*type. The"type tag array" is treated exactly as anotherjl_array_t*,
but which shares the samea->offset,a->maxsize, anda->lenfields. So the formula to access an isbits
Union Array's type tag bytes isa->data + (a->maxsize - a->offset) * a->elsize + a->offset; i.e. the
Array 'sa->datapointer is already shifted bya->offset, so correcting for that, we follow the data all the way
to the max of what it can holda->maxsize, then adjust bya->offsetmore bytes to account for any present
"front buffering" the array might be doing. This layout in particular allows for very efficient resizing operations
as the type tag data only ever has to move when the actual array's data has to move.

### 98.13System Image Building

### Building the Julia system image

Julia ships with a preparsed system image containing the contents of theBasemodule, namedsys.ji. This
file is also precompiled into a shared library calledsys.{so,dll,dylib}on as many platforms as possible, so
as to give vastly improved startup times. On systems that do not ship with a precompiled system image file,
one can be generated from the source files shipped in Julia'sDATAROOTDIR/julia/basefolder.

This operation is useful for multiple reasons. A user may:

- Build a precompiled shared library system image on a platform that did not ship with one, thereby
    improving startup times.
- ModifyBase, rebuild the system image and use the newBasenext time Julia is started.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1311

- Include auserimg.jlfile that includes packages into the system image, thereby creating a system
    image that has packages embedded into the startup environment.

ThePackageCompiler.jlpackagecontains convenient wrapper functions to automate this process.

### System image optimized for multiple microarchitectures

The system image can be compiled simultaneously for multiple CPU microarchitectures under the same in-
struction set architecture (ISA). Multiple versions of the same function may be created with minimum dispatch
point inserted into shared functions in order to take advantage of different ISA extensions or other microarchi-
tecture features. The version that offers the best performance will be selected automatically at runtime based
on available CPU features.

**Specifying multiple system image targets**

A multi-microarchitecture system image can be enabled by passing multiple targets during system image
compilation. This can be done either with theJULIA_CPU_TARGETmake option or with the-Ccommand line
option when running the compilation command manually. Multiple targets are separated by;in the option
string. The syntax for each target is a CPU name followed by multiple features separated by,. All features
supported by LLVM are supported and a feature can be disabled with a-prefix. (+prefix is also allowed and
ignored to be consistent with LLVM syntax). Additionally, a few special features are supported to control the
function cloning behavior.

1. clone_all
    By default, only functions that are the most likely to benefit from the microarchitecture features will be
    cloned. Whenclone_allis specified for a target, however, **all** functions in the system image will be
    cloned for the target. The negative form-clone_allcan be used to prevent the built-in heuristic from
    cloning all functions.
2. base(<n>)
    Where<n>is a placeholder for a non-negative number (e.g.base(0),base(1)). By default, a partially
    cloned (i.e. notclone_all) target will use functions from the default target (first one specified) if a
    function is not cloned. This behavior can be changed by specifying a different base with thebase(<n>)
    option. Thenth target (0-based) will be used as the base target instead of the default ( 0 th) one. The
    base target has to be either 0 or anotherclone_alltarget. Specifying a non-clone_alltarget as the
    base target will cause an error.
3. opt_size
    This causes the function for the target to be optimized for size when there isn't a significant runtime
    performance impact. This corresponds to-OsGCC and Clang option.
4. min_size
    This causes the function for the target to be optimized for size that might have a significant runtime
    performance impact. This corresponds to-OzClang option.

As an example, at the time of this writing, the following string is used in the creation of the officialx86_64Julia
binaries downloadable from julialang.org:

```

generic;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1312

This creates a system image with three separate targets; one for a genericx86_64processor, one with a
sandybridgeISA (explicitly excludingxsaveopt) that explicitly clones all functions, and one targeting the
haswellISA, based off of thesandybridgesysimg version, and also excludingrdrnd. When a Julia implemen-
tation loads the generated sysimg, it will check the host processor for matching CPU capability flags, enabling
the highest ISA level possible. Note that the base level (generic) requires thecx16instruction, which is dis-
abled in some virtualization software and must be enabled for thegenerictarget to be loaded. Alternatively,
a sysimg could be generated with the targetgeneric,-cx16for greater compatibility, however note that this
may cause performance and stability problems in some code.

**Implementation overview**

This is a brief overview of different part involved in the implementation. See code comments for each compo-
nents for more implementation details.

1. System image compilation
    The parsing and cloning decision are done insrc/processor*. We currently support cloning of function
    based on the present of loops, simd instructions, or other math operations (e.g. fastmath, fma, muladd).
    This information is passed on tosrc/llvm-multiversioning.cppwhich does the actual cloning. In ad-
    dition to doing the cloning and insert dispatch slots (see comments inMultiVersioning::runOnModule
    for how this is done), the pass also generates metadata so that the runtime can load and initialize the
    system image correctly. A detail description of the metadata is available insrc/processor.h.
2. System image loading
    The loading and initialization of the system image is done insrc/processor*by parsing the meta-
    data saved during system image generation. Host feature detection and selection decision are done in
    src/processor_*.cppdepending on the ISA. The target selection will prefer exact CPU name match,
    largervectorregistersize,andlargernumberoffeatures. Anoverviewofthisprocessisinsrc/processor.cpp.

### 98.14Working with LLVM.

This is not a replacement for the LLVM documentation, but a collection of tips for working on LLVM for Julia.

### Overview of Julia to LLVM Interface

Julia dynamically links against LLVM by default. Build withUSE_LLVM_SHLIB=0to link statically.

The code for lowering Julia AST to LLVM IR or interpreting it directly is in directorysrc/.

```

File Description  
builtins.c Builtin functions  
ccall.cpp Loweringccall  
cgutils.cpp Lowering utilities, notably for array and tuple accesses  
codegen.cpp Top-level of code generation, pass list, lowering builtins  
debuginfo.cpp Tracks debug information for JIT code  
disasm.cpp Handles native object file and JIT code diassembly  
gf.c Generic functions  
intrinsics.cpp Lowering intrinsics  
llvm-simdloop.cpp Custom LLVM pass for@simd  
sys.c I/O and operating system utility functions

```
Some of the.cppfiles form a group that compile to a single object.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1313

The difference between an intrinsic and a builtin is that a builtin is a first class function that can be used like
any other Julia function. An intrinsic can operate only on unboxed data, and therefore its arguments must be
statically typed.

**Alias Analysis**

Julia currently uses LLVM's Type Based Alias Analysis. To find the comments that document the inclusion
relationships, look forstatic MDNode*insrc/codegen.cpp.

The-Ooption enables LLVM's Basic Alias Analysis.

### Building Julia with a different version of LLVM

The default version of LLVM is specified indeps/Versions.make. You can override it by creating a file called
Make.userin the top-level directory and adding a line to it such as:

```

LLVM_VER = 12.0.1

```
Besides the LLVM release numerals, you can also useLLVM_VER = svnto build against the latest development
version of LLVM.

You can also specify to build a debug version of LLVM, by setting eitherLLVM_DEBUG = 1orLLVM_DEBUG =
Releasein yourMake.userfile. The former will be a fully unoptimized build of LLVM and the latter will produce
an optimized build of LLVM. Depending on your needs the latter will suffice and it quite a bit faster. If you
useLLVM_DEBUG = Releaseyou will also want to setLLVM_ASSERTIONS = 1to enable diagnostics for different
passes. OnlyLLVM_DEBUG = 1implies that option by default.

### Passing options to LLVM

You can pass options to LLVM via the environment variableJULIA_LLVM_ARGS. Here are example settings using
bashsyntax:

- export JULIA_LLVM_ARGS=-print-after-alldumps IR after each pass.
- export JULIA_LLVM_ARGS=-debug-only=loop-vectorizedumpsLLVMDEBUG(...)diagnosticsforloop
    vectorizer. Ifyougetwarningsabout"Unknowncommandlineargument",rebuildLLVMwithLLVM_ASSERTIONS
    = 1.

### Debugging LLVM transformations in isolation

On occasion, it can be useful to debug LLVM's transformations in isolation from the rest of the Julia system, e.g.
because reproducing the issue insidejuliawould take too long, or because one wants to take advantage of
LLVM 's tooling (e.g. bugpoint). To get unoptimized IR for the entire system image, pass the--output-unopt-
bc unopt.bcoption to the system image build process, which will output the unoptimized IR to anunopt.bc
file. This file can then be passed to LLVM tools as usual.libjuliacan function as an LLVM pass plugin and can
be loaded into LLVM tools, to make julia-specific passes available in this environment. In addition, it exposes
the-juliameta-pass, which runs the entire Julia pass-pipeline over the IR. As an example, to generate a
system image, one could do:

```

opt -load libjulia-internal.so -julia -o opt.bc unopt.bc  
llc -o sys.o opt.bc  
cc -shared -o sys.so sys.o

```
This system image can then be loaded byjuliaas usual.

It is also possible to dump an LLVM IR module for just one Julia function, using:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1314

```

fun, T= +, Tuple { Int , Int } # Substitute your function of interest here  
optimize= false  
open("plus.ll", "w") do file  
println(file, InteractiveUtils._dump_function(fun, T, false , false , false , true , :att, optimize,  
↪→ :default))  
end

```
These files can be processed the same way as the unoptimized sysimg IR shown above.

### Improving LLVM optimizations for Julia

Improving LLVM code generation usually involves either changing Julia lowering to be more friendly to LLVM's
passes, or improving a pass.

If you are planning to improve a pass, be sure to read theLLVM developer policy. The best strategy is to create
a code example in a form where you can use LLVM'sopttool to study it and the pass of interest in isolation.

1. Create an example Julia code of interest.
2. UseJULIA_LLVM_ARGS=-print-after-allto dump the IR.
3. Pick out the IR at the point just before the pass of interest runs.
4. Strip the debug metadata and fix up the TBAA metadata by hand.

The last step is labor intensive. Suggestions on a better way would be appreciated.

### The jlcall calling convention

Julia has a generic calling convention for unoptimized code, which looks somewhat as follows:

```

jl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);

```
where the first argument is the boxed function object, the second argument is an on-stack array of arguments
and the third is the number of arguments. Now, we could perform a straightforward lowering and emit an
alloca for the argument array. However, this would betray the SSA nature of the uses at the call site, making
optimizations (including GC root placement), significantly harder. Instead, we emit it as follows:

```

%bitcast = bitcast @any_unoptimized_call to %jl_value_t _(_)(%jl_value_t *, %jl_value_t *)  
call cc 37 %jl_value_t *%bitcast(%jl_value_t *%arg1, %jl_value_t *%arg2)

```
The specialcc 37annotation marks the fact that this call site is really using the jlcall calling convention. This
allows us to retain the SSA-ness of the uses throughout the optimizer. GC root placement will later lower
this call to the original C ABI. In the code the calling convention number is represented by theJLCALL_F_CC
constant. In addition, there is theJLCALL_CCcalling convention which functions similarly, but omits the first
argument.

### GC root placement

GC root placement is done by an LLVM pass late in the pass pipeline. Doing GC root placement this late
enables LLVM to make more aggressive optimizations around code that requires GC roots, as well as allowing
us to reduce the number of required GC roots and GC root store operations (since LLVM doesn't understand
our GC, it wouldn't otherwise know what it is and is not allowed to do with values stored to the GC frame, so
it'll conservatively do very little). As an example, consider an error path


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1315

```

if some_condition()  
#= Use some variables maybe =#  
error("An error occurred")  
end

```
During constant folding, LLVM may discover that the condition is always false, and can remove the basic block.
However, if GC root lowering is done early, the GC root slots used in the deleted block, as well as any values
kept alive in those slots only because they were used in the error path, would be kept alive by LLVM. By doing
GC root lowering late, we give LLVM the license to do any of its usual optimizations (constant folding, dead
code elimination, etc.), without having to worry (too much) about which values may or may not be GC tracked.

However, in order to be able to do late GC root placement, we need to be able to identify a) which pointers are
GC tracked and b) all uses of such pointers. The goal of the GC placement pass is thus simple:

Minimize the number of needed GC roots/stores to them subject to the constraint that at every safepoint, any
live GC-tracked pointer (i.e. for which there is a path after this point that contains a use of this pointer) is in
some GC slot.

**Representation**

The primary difficulty is thus choosing an IR representation that allows us to identify GC-tracked pointers and
their uses, even after the program has been run through the optimizer. Our design makes use of three LLVM
features to achieve this:

- Custom address spaces
- Operand Bundles
- Non-integral pointers

Custom address spaces allow us to tag every point with an integer that needs to be preserved through opti-
mizations. The compiler may not insert casts between address spaces that did not exist in the original program
and it must never change the address space of a pointer on a load/store/etc operation. This allows us to an-
notate which pointers are GC-tracked in an optimizer-resistant way. Note that metadata would not be able
to achieve the same purpose. Metadata is supposed to always be discardable without altering the semantics
of the program. However, failing to identify a GC-tracked pointer alters the resulting program behavior dra-
matically - it'll probably crash or return wrong results. We currently use three different address spaces (their
numbers are defined insrc/codegen_shared.cpp):

- GC Tracked Pointers (currently 10): These are pointers to boxed values that may be put into a GC frame.
    It is loosely equivalent to ajl_value_t*pointer on the C side. N.B. It is illegal to ever have a pointer in
    this address space that may not be stored to a GC slot.
- Derived Pointers (currently 11): These are pointers that are derived from some GC tracked pointer. Uses
    of these pointers generate uses of the original pointer. However, they need not themselves be known
    to the GC. The GC root placement pass MUST always find the GC tracked pointer from which this pointer
    is derived and use that as the pointer to root.
- Callee Rooted Pointers (currently 12): This is a utility address space to express the notion of a callee
    rooted value. All values of this address space MUST be storable to a GC root (though it is possible to
    relax this condition in the future), but unlike the other pointers need not be rooted if passed to a call
    (they do still need to be rooted if they are live across another safepoint between the definition and the
    call).


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1316

- Pointers loaded from tracked object (currently 13): This is used by arrays, which themselves contain a
    pointer to the managed data. This data area is owned by the array, but is not a GC-tracked object by
    itself. The compiler guarantees that as long as this pointer is live, the object that this pointer was loaded
    from will keep being live.

**Invariants**

The GC root placement pass makes use of several invariants, which need to be observed by the frontend and
are preserved by the optimizer.

First, only the following address space casts are allowed:

- 0->{Tracked,Derived,CalleeRooted}: It is allowable to decay an untracked pointer to any of the others.
    However, do note that the optimizer has broad license to not root such a value. It is never safe to have
    a value in address space 0 in any part of the program if it is (or is derived from) a value that requires a
    GC root.
- Tracked->Derived: This is the standard decay route for interior values. The placement pass will look for
    these to identify the base pointer for any use.
- Tracked->CalleeRooted: Addrspace CalleeRooted serves merely as a hint that a GC root is not required.
    However, do note that the Derived->CalleeRooted decay is prohibited, since pointers should generally
    be storable to a GC slot, even in this address space.

Now let us consider what constitutes a use:

- Loads whose loaded values is in one of the address spaces
- Stores of a value in one of the address spaces to a location
- Stores to a pointer in one of the address spaces
- Calls for which a value in one of the address spaces is an operand
- Calls in jlcall ABI, for which the argument array contains a value
- Return instructions.

We explicitly allow load/stores and simple calls in address spaces Tracked/Derived. Elements of jlcall argument
arrays must always be in address space Tracked (it is required by the ABI that they are validjl_value_t*
pointers). The same is true for return instructions (though note that struct return arguments are allowed to
have any of the address spaces). The only allowable use of an address space CalleeRooted pointer is to pass
it to a call (which must have an appropriately typed operand).

Further, we disallowgetelementptrin addrspace Tracked. This is because unless the operation is a noop, the
resulting pointer will not be validly storable to a GC slot and may thus not be in this address space. If such a
pointer is required, it should be decayed to addrspace Derived first.

Lastly, we disallowinttoptr/ptrtointinstructions in these address spaces. Having these instructions would
mean that somei64values are really GC tracked. This is problematic, because it breaks that stated require-
ment that we're able to identify GC-relevant pointers. This invariant is accomplished using the LLVM"non-
integral pointers" feature, which is new in LLVM 5.0. It prohibits the optimizer from making optimizations that
would introduce these operations. Note we can still insert static constants at JIT time by usinginttoptrin
address space 0 and then decaying to the appropriate address space afterwards.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1317

**Supportingccall**

One important aspect missing from the discussion so far is the handling ofccall. ccallhas the peculiar
feature that the location and scope of a use do not coincide. As an example consider:

```

A = randn(1024)  
ccall (:foo, Cvoid, ( Ptr { Float64 },), A)

```
In lowering, the compiler will insert a conversion from the array to the pointer which drops the reference to
the array value. However, we of course need to make sure that the array does stay alive while we're doing the
ccall. To understand how this is done, first recall the lowering of the above code:

```

return $( Expr (:foreigncall,:(:foo), Cvoid, svec( Ptr { Float64 }), 0, :(: ccall ), Expr (:foreigncall,  
↪→ :(:jl_array_ptr), Ptr { Float64 }, svec( Any ), 0, :(: ccall ), :(A)),:(A)))

```
The last:(A), is an extra argument list inserted during lowering that informs the code generator which Julia
level values need to be kept alive for the duration of thisccall. We then take this information and represent
it in an"operand bundle" at the IR level. An operand bundle is essentially a fake use that is attached to the
call site. At the IR level, this looks like so:

```

call void inttoptr (i64 ... to void (double_)_)(double* %5) [ "jl_roots"(%jl_value_t addrspace(10)*  
%A) ]

```
The GC root placement pass will treat thejl_rootsoperand bundle as if it were a regular operand. However,
as a final step, after the GC roots are inserted, it will drop the operand bundle to avoid confusing instruction
selection.

**Supportingpointer_from_objref**

pointer_from_objrefis special because it requires the user to take explicit control of GC rooting. By our
above invariants, this function is illegal, because it performs an address space cast from 10 to 0. However, it
can be useful, in certain situations, so we provide a special intrinsic:

```

declared %jl_value_t _julia.pointer_from_objref(%jl_value_t addrspace(10)_)

```
which is lowered to the corresponding address space cast after GC root lowering. Do note however that by
using this intrinsic, the caller assumes all responsibility for making sure that the value in question is rooted.
Further this intrinsic is not considered a use, so the GC root placement pass will not provide a GC root for the
function. As a result, the external rooting must be arranged while the value is still tracked by the system. I.e.
it is not valid to attempt to use the result of this operation to establish a global root - the optimizer may have
already dropped the value.

**Keeping values alive in the absence of uses**

In certain cases it is necessary to keep an object alive, even though there is no compiler-visible use of said
object. This may be case for low level code that operates on the memory-representation of an object directly
or code that needs to interface with C code. In order to allow this, we provide the following intrinsics at the
LLVM level:

```

token @llvm.julia.gc_preserve_begin(...)  
void @llvm.julia.gc_preserve_end(token)

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1318

(Thellvm. in the name is required in order to be able to use thetokentype). The semantics of these
intrinsics are as follows: At any safepoint that is dominated by agc_preserve_begincall, but that is not not
dominated by a correspondinggc_preserve_endcall (i.e. a call whose argument is the token returned by a
gc_preserve_begincall), the values passed as arguments to thatgc_preserve_beginwill be kept live. Note
that thegc_preserve_beginstill counts as a regular use of those values, so the standard lifetime semantics
will ensure that the values will be kept alive before entering the preserve region.

### 98.15printf() and stdio in the Julia runtime

### Libuv wrappers for stdio

julia.hdefineslibuv wrappers for thestdio.hstreams:

```

uv_stream_t *JL_STDIN;  
uv_stream_t *JL_STDOUT;  
uv_stream_t *JL_STDERR;

```
... and corresponding output functions:

```

int jl_printf(uv_stream_t *s, const char *format, ...);  
int jl_vprintf(uv_stream_t *s, const char *format, va_list args);

```
Theseprintffunctions are used by the.cfiles in thesrc/andcli/directories wherever stdio is needed to
ensure that output buffering is handled in a unified way.

In special cases, like signal handlers, where the full libuv infrastructure is too heavy,jl_safe_printf()can
be used towrite(2)directly toSTDERR_FILENO:

```

void jl_safe_printf(const char *str, ...);

```
### Interface between JL_STD* and Julia code

Base.stdin,Base.stdoutandBase.stderrare bound to theJL_STD*libuv streams defined in the runtime.

Julia's__init__()function (inbase/sysimg.jl) callsreinit_stdio()(inbase/stream.jl) to create Julia
objects forBase.stdin,Base.stdoutandBase.stderr.

reinit_stdio()usesccallto retrieve pointers toJL_STD*and callsjl_uv_handle_type()to inspect the
type of each stream. It then creates a JuliaBase.IOStream,Base.TTYorBase.PipeEndpointobject to repre-
sent each stream, e.g.:

```

$ julia -e 'println(typeof((stdin, stdout, stderr)))'  
Tuple{Base.TTY,Base.TTY,Base.TTY}

$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null  
Tuple{IOStream,Base.TTY,IOStream}

$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat  
Tuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}

```
TheBase.readandBase.writemethods for these streams useccallto call libuv wrappers insrc/jl_uv.c,
e.g.:

```

stream.jl: function write(s::IO, p::Ptr, nb::Integer)  
-> ccall(:jl_uv_write, ...)  
jl_uv.c: -> int jl_uv_write(uv_stream_t *stream, ...)  
-> uv_write(uvw, stream, buf, ...)

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1319

### printf() during initialization

The libuv streams relied upon byjl_printf()etc., are not available until midway through initialization of
the runtime (seeinit.c,init_stdio()). Error messages or warnings that need to be printed before this are
routed to the standard C libraryfwrite()function by the following mechanism:

Insys.c, theJL_STD*stream pointers are statically initialized to integer constants:STD*_FILENO (0, 1 and
2). Injl_uv.cthejl_uv_puts()function checks itsuv_stream_t* streamargument and callsfwrite()if
stream is set toSTDOUT_FILENOorSTDERR_FILENO.

This allows for uniform use ofjl_printf()throughout the runtime regardless of whether or not any particular
piece of code is reachable before initialization is complete.

### Legacyios.clibrary

Thesrc/support/ios.clibrary is inherited fromfemtolisp. It provides cross-platform buffered file IO and
in-memory temporary buffers.

ios.cis still used by:

- src/flisp/*.c
- src/dump.c– for serialization file IO and for memory buffers.
- src/staticdata.c– for serialization file IO and for memory buffers.
- base/iostream.jl– for file IO (seebase/fs.jlfor libuv equivalent).

Use ofios.cin these modules is mostly self-contained and separated from the libuv I/O system. However,
there isone placewhere femtolisp calls through tojl_printf()with a legacyios_tstream.

Thereisahackinios.hthatmakestheios_t.bmfieldlineupwiththeuv_stream_t.typeandensuresthatthe
values used forios_t.bmto not overlap with validUV_HANDLE_TYPEvalues. This allowsuv_stream_tpointers
to point toios_tstreams.

This is needed becausejl_printf()callerjl_static_show()is passed anios_tstream by femtolisp's
fl_print()function. Julia'sjl_uv_puts()function has special handling for this:

```

if (stream->type > UV_HANDLE_TYPE_MAX) {  
return ios_write((ios_t*)stream, str, n);  
}

```
### 98.16Bounds checking

Like many modern programming languages, Julia uses bounds checking to ensure program safety when ac-
cessing arrays. In tight inner loops or other performance critical situations, you may wish to skip these bounds
checks to improve runtime performance. For instance, in order to emit vectorized (SIMD) instructions, your
loop body cannot contain branches, and thus cannot contain bounds checks. Consequently, Julia includes an
@inbounds(...)macro to tell the compiler to skip such bounds checks within the given block. User-defined
array types can use the@boundscheck(...)macro to achieve context-sensitive code selection.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1320

### Eliding bounds checks

The@boundscheck(...)macro marks blocks of code that perform bounds checking. When such blocks are
inlined into an@inbounds(...) block, the compiler may remove these blocks. The compiler removes the
@boundscheckblock only if it is inlined into the calling function. For example, you might write the methodsum
as:

```

function sum(A:: AbstractArray )  
r = zero(eltype(A))  
for i in eachindex(A)  
@inboundsr += A[i]  
end  
return r  
end

```
With a custom array-like typeMyArrayhaving:

```

@inlinegetindex(A::MyArray, i:: Real ) = (@boundscheckcheckbounds(A,i); A.data[to_index(i)])

```
Then whengetindexis inlined intosum, the call tocheckbounds(A,i)will be elided. If your function contains
multiple layers of inlining, only@boundscheckblocks at most one level of inlining deeper are eliminated. The
rule prevents unintended changes in program behavior from code further up the stack.

### Propagating inbounds

There may be certain scenarios where for code-organization reasons you want more than one layer between
the@inboundsand@boundscheckdeclarations. For instance, the defaultgetindexmethods have the chain
getindex(A::AbstractArray, i::Real)callsgetindex(IndexStyle(A), A, i)calls_getindex(::IndexLinear,
A, i).

To override the"one layer of inlining" rule, a function may be marked withBase.@propagate_inboundsto
propagate an inbounds context (or out of bounds context) through one additional layer of inlining.

### The bounds checking call hierarchy

The overall hierarchy is:

- checkbounds(A, I...)which calls
    **-** checkbounds(Bool, A, I...)which calls
       ∗checkbounds_indices(Bool, axes(A), I)which recursively calls
          ·checkindexfor each dimension

HereAis the array, andIcontains the"requested" indices.axes(A)returns a tuple of"permitted" indices of
A.

checkbounds(A, I...) throws an error if the indices are invalid, whereascheckbounds(Bool, A, I...)
returnsfalsein that circumstance. checkbounds_indicesdiscards any information about the array other
than itsaxestuple, and performs a pure indices-vs-indices comparison: this allows relatively few compiled
methods to serve a huge variety of array types. Indices are specified as tuples, and are usually compared in a
1-1 fashion with individual dimensions handled by calling another important function,checkindex: typically,


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1321

```

checkbounds_indices( Bool , (IA1, IA...), (I1,I...)) = checkindex( Bool , IA1, I1)&  
checkbounds_indices( Bool , IA,I)

```
socheckindexchecksasingledimension. Allofthesefunctions,includingtheunexportedcheckbounds_indices
have docstrings accessible with?.

If you have to customize bounds checking for a specific array type, you should specializecheckbounds(Bool,
A, I...). However, in most cases you should be able to rely oncheckbounds_indicesas long as you supply
usefulaxesfor your array type.

If you have novel index types, first consider specializingcheckindex, which handles a single index for a par-
ticular dimension of an array. If you have a custom multidimensional index type (similar toCartesianIndex),
then you may have to consider specializingcheckbounds_indices.

Note this hierarchy has been designed to reduce the likelihood of method ambiguities. We try to make
checkboundsthe place to specialize on array type, and try to avoid specializations on index types; conversely,
checkindexis intended to be specialized only on index type (especially, the last argument).

### Emit bounds checks

Julia can be launched with--check-bounds={yes|no|auto}to emit bounds checks always, never, or respect
@inbounds declarations.

### 98.17Proper maintenance and care of multi-threading locks

The following strategies are used to ensure that the code is dead-lock free (generally by addressing the 4th
Coffman condition: circular wait).

1. structure code such that only one lock will need to be acquired at a time
2. always acquire shared locks in the same order, as given by the table below
3. avoid constructs that expect to need unrestricted recursion

### Locks

Below are all of the locks that exist in the system and the mechanisms for using them that avoid the potential
for deadlocks (no Ostrich algorithm allowed here):

The following are definitely leaf locks (level 1), and must not try to acquire any other lock:

- safepoint
    Note that this lock is acquired implicitly byJL_LOCKandJL_UNLOCK. use the_NOGC
    variants to avoid that for level 1 locks.
    While holding this lock, the code must not do any allocation or hit any safepoints.
    Note that there are safepoints when doing allocation, enabling / disabling GC, en-
    tering / restoring exception frames, and taking / releasing locks.
- shared_map
- finalizers
- pagealloc
- gcpermlock
- flisp


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1322

- jlinstackwalk (Win32)
    flispitselfisalreadythreadsafe,thislockonlyprotectsthejl_ast_context_list_t
    pool

The following is a leaf lock (level 2), and only acquires level 1 locks (safepoint) internally:

- typecache
- Module->lock

The following is a level 3 lock, which can only acquire level 1 or level 2 locks internally:

- Method->writelock

The following is a level 4 lock, which can only recurse to acquire level 1, 2, or 3 locks:

- MethodTable->writelock

No Julia code may be called while holding a lock above this point.

The following are a level 6 lock, which can only recurse to acquire locks at lower levels:

- codegen
- jlmodulesmutex

The following is an almost root lock (level end-1), meaning only the root look may be held when trying to
acquire it:

- typeinf
    thisoneisperhapsoneofthemosttrickyones,sincetype-inferencecanbeinvoked
    from many points
    currently the lock is merged with the codegen lock, since they call each other
    recursively

The following lock synchronizes IO operation. Be aware that doing any I/O (for example, printing warning
messages or debug information) while holding any other lock listed above may result in pernicious and hard-
to-find deadlocks. BE VERY CAREFUL!

- iolock
- Individual ThreadSynchronizers locks
    this may continue to be held after releasing the iolock, or acquired without it, but
    be very careful to never attempt to acquire the iolock while holding it

The following is the root lock, meaning no other lock shall be held when trying to acquire it:

- toplevel
    this should be held while attempting a top-level action (such as making a new type
    or defining a new method): trying to obtain this lock inside a staged function will
    cause a deadlock condition!
    additionally, it's unclear if any code can safely run in parallel with an arbitrary
    toplevel expression, so it may require all threads to get to a safepoint first


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1323

### Broken Locks

The following locks are broken:

- toplevel

```

doesn't exist right now  
fix: create it

```
- Module->lock

```

This is vulnerable to deadlocks since it can't be certain it is acquired in sequence. Some  
operations (such asimport_module) are missing a lock.  
fix: replace withjl_modules_mutex?

```
- loading.jl:requireandregister_root_module

```

This file potentially has numerous problems.  
fix: needs locks

```
### Shared Global Data Structures

These data structures each need locks due to being shared mutable global state. It is the inverse list for the
above lock priority list. This list does not include level 1 leaf resources due to their simplicity.

MethodTable modifications (def, cache, kwsorter type) : MethodTable->writelock

Type declarations : toplevel lock

Type application : typecache lock

Global variable tables : Module->lock

Module serializer : toplevel lock

JIT & type-inference : codegen lock

MethodInstance/CodeInstance updates : Method->writelock, codegen lock

- These are set at construction and immutable:
    **-** specTypes
    **-** sparam_vals
    **-** def
- These are set byjl_type_infer(while holding codegen lock):
    **-** cache
    **-** rettype
    **-** inferred

```

-   valid ages

```
- inInferenceflag:
    **-** optimization to quickly avoid recurring intojl_type_inferwhile it is already running


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1324

**-** actual state (of settinginferred, thenfptr) is protected by codegen lock
- Function pointers:
**-** these transition once, fromNULLto a value, while the codegen lock is held
- Code-generator cache (the contents offunctionObjectsDecls):
**-** these can transition multiple times, but only while the codegen lock is held
**-** it is valid to use old version of this, or block for new versions of this, so races are benign,
as long as the code is careful not to reference other data in the method instance (such
asrettype) and assume it is coordinated, unless also holding the codegen lock

LLVMContext : codegen lock

Method : Method->writelock

- roots array (serializer and codegen)
- invoke / specializations / tfunc modifications

### 98.18Arrays with custom indices

Conventionally, Julia's arrays are indexed starting at 1, whereas some other languages start numbering at 0,
andyetothers(e.g., Fortran)allowyoutospecifyarbitrarystartingindices. Whilethereismuchmeritinpicking
a standard (i.e., 1 for Julia), there are some algorithms which simplify considerably if you can index outside
the range1:size(A,d)(and not just0:size(A,d)-1, either). To facilitate such computations, Julia supports
arrays with arbitrary indices.

The purpose of this page is to address the question,"what do I have to do to support such arrays in my own
code?" First, let's address the simplest case: if you know that your code will never need to handle arrays
with unconventional indexing, hopefully the answer is"nothing." Old code, on conventional arrays, should
function essentially without alteration as long as it was using the exported interfaces of Julia. If you find it
more convenient to just force your users to supply traditional arrays where indexing starts at one, you can add

```

Base.require_one_based_indexing(arrays...)

```
wherearrays...isalistofthearrayobjectsthatyouwishtocheckforanythingthatviolates1-basedindexing.

### Generalizing existing code

As an overview, the steps are:

- replace many uses ofsizewithaxes
- replace1:length(A)witheachindex(A), or in some casesLinearIndices(A)
- replace explicit allocations likeArray{Int}(undef, size(B))withsimilar(Array{Int}, axes(B))

These are described in more detail below.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1325

**Things to watch out for**

Becauseunconventionalindexingbreaksmanypeople'sassumptionsthatallarraysstartindexingwith1, there
is always the chance that using such arrays will trigger errors. The most frustrating bugs would be incorrect
results or segfaults (total crashes of Julia). For example, consider the following function:

```

function mycopy!(dest:: AbstractVector , src:: AbstractVector )  
length(dest)== length(src)|| throw( DimensionMismatch ("vectors must match"))

# OK, now we're safe to use @inbounds, right? (not anymore!)

for i = 1:length(src)  
@inboundsdest[i]= src[i]  
end  
dest  
end

```
This code implicitly assumes that vectors are indexed from 1; ifdeststarts at a different index thansrc, there
is a chance that this code would trigger a segfault. (If you do get segfaults, to help locate the cause try running
julia with the option--check-bounds=yes.)

**Usingaxesfor bounds checks and loop iteration**

axes(A)(reminiscent ofsize(A)) returns a tuple ofAbstractUnitRange{<:Integer}objects, specifying the
range of valid indices along each dimension ofA. WhenAhas unconventional indexing, the ranges may not
start at 1. If you just want the range for a particular dimensiond, there isaxes(A, d).

Base implements a custom range type,OneTo, whereOneTo(n)means the same thing as1:nbut in a form
that guarantees (via the type system) that the lower index is 1. For any newAbstractArraytype, this is the
default returned byaxes, and it indicates that this array type uses"conventional" 1-based indexing.

For bounds checking, note that there are dedicated functionscheckboundsandcheckindexwhich can some-
times simplify such tests.

**Linear indexing (LinearIndices)**

Some algorithms are most conveniently (or efficiently) written in terms of a single linear index,A[i]even ifA
is multi-dimensional. Regardless of the array's native indices, linear indices always range from1:length(A).
However, thisraisesanambiguityforone-dimensionalarrays(a.k.a.,AbstractVector): doesv[i]meanlinear
indexing , or Cartesian indexing with the array's native indices?

For this reason, your best option may be to iterate over the array witheachindex(A), or, if you require the
indices to be sequential integers, to get the index range by callingLinearIndices(A). This will returnaxes(A,
1)if A is an AbstractVector, and the equivalent of1:length(A)otherwise.

By this definition, 1-dimensional arrays always use Cartesian indexing with the array's native indices. To help
enforce this, it's worth noting that the index conversion functions will throw an error if shape indicates a
1-dimensional array with unconventional indexing (i.e., is aTuple{UnitRange}rather than a tuple ofOneTo).
For arrays with conventional indexing, these functions continue to work the same as always.

UsingaxesandLinearIndices, here is one way you could rewritemycopy!:

```

function mycopy!(dest:: AbstractVector , src:: AbstractVector )  
axes(dest)== axes(src)|| throw( DimensionMismatch ("vectors must match"))  
for i in LinearIndices(src)  
@inboundsdest[i]= src[i]  
end  
dest  
end

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1326

**Allocating storage using generalizations ofsimilar**

StorageisoftenallocatedwithArray{Int}(undef, dims)orsimilar(A, args...). Whentheresultneedsto
matchtheindicesofsomeotherarray,thismaynotalwayssuffice. Thegenericreplacementforsuchpatternsis
tousesimilar(storagetype, shape).storagetypeindicatesthekindofunderlying"conventional"behavior
you'd like, e.g.,Array{Int}orBitArrayor evendims->zeros(Float32, dims)(which would allocate an all-
zeros array).shapeis a tuple ofIntegerorAbstractUnitRangevalues, specifying the indices that you want
the result to use. Note that a convenient way of producing an all-zeros array that matches the indices of A is
simplyzeros(A).

Let 'swalkthroughacoupleofexplicitexamples. First,ifAhasconventionalindices,thensimilar(Array{Int},
axes(A))wouldendupcallingArray{Int}(undef, size(A)),andthusreturnanarray. IfAisanAbstractArray
type with unconventional indexing, thensimilar(Array{Int}, axes(A))should return something that"be-
haves like" anArray{Int}but with a shape (including indices) that matchesA. (The most obvious implemen-
tation is to allocate anArray{Int}(undef, size(A))and then"wrap" it in a type that shifts the indices.)

Notealsothatsimilar(Array{Int}, (axes(A, 2),))wouldallocateanAbstractVector{Int}(i.e.,1-dimensional
array) that matches the indices of the columns ofA.

### Writing custom array types with non-1 indexing

Most of the methods you'll need to define are standard for anyAbstractArraytype, seeAbstract Arrays. This
page focuses on the steps needed to define unconventional indexing.

**CustomAbstractUnitRangetypes**

If you 're writing a non-1 indexed array type, you will want to specializeaxesso it returns aUnitRange, or (per-
haps better) a customAbstractUnitRange. The advantage of a custom type is that it"signals" the allocation
type for functions likesimilar. If we 're writing an array type for which indexing will start at 0, we likely want
to begin by creating a newAbstractUnitRange,ZeroRange, whereZeroRange(n)is equivalent to0:n-1.

In general, you should probably not exportZeroRangefrom your package: there may be other packages
that implement their ownZeroRange, and having multiple distinctZeroRangetypes is (perhaps counterin-
tuitively) an advantage:ModuleA.ZeroRangeindicates thatsimilarshould create aModuleA.ZeroArray,
whereasModuleB.ZeroRangeindicates aModuleB.ZeroArraytype. This design allows peaceful coexistence
among many different custom array types.

Note that the Julia packageCustomUnitRanges.jlcan sometimes be used to avoid the need to write your own
ZeroRangetype.

**Specializingaxes**

Once you have yourAbstractUnitRangetype, then specializeaxes:

```

Base.axes(A::ZeroArray)= map(n->ZeroRange(n), A.size)

```
where here we imagine thatZeroArrayhas a field calledsize(there would be other ways to implement this).

In some cases, the fallback definition foraxes(A, d):

```

axes(A:: AbstractArray {T,N}, d) where {T,N}= d <= N? axes(A)[d]: OneTo(1)

```
may not be what you want: you may need to specialize it to return something other thanOneTo(1)whend >
ndims(A). Likewise, inBasethere is a dedicated functionaxes1which is equivalent toaxes(A, 1)but which
avoids checking (at runtime) whetherndims(A) > 0. (This is purely a performance optimization.) It is defined
as:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1327

```

axes1(A:: AbstractArray {T,0}) where {T}= OneTo(1)  
axes1(A:: AbstractArray ) = axes(A)[1]

```
If the first of these (the zero-dimensional case) is problematic for your custom array type, be sure to specialize
it appropriately.

**Specializingsimilar**

Given your customZeroRangetype, then you should also add the following two specializations forsimilar:

```

function Base.similar(A:: AbstractArray , T :: Type , shape:: Tuple {ZeroRange, Vararg {ZeroRange}})

# body

end

function Base.similar(f:: Union { Function , DataType }, shape:: Tuple {ZeroRange, Vararg {ZeroRange}})

# body

end

```
Both of these should allocate your custom array type.

**Specializingreshape**

Optionally, define a method

```

Base.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...

```
and you canreshapean array so that the result has custom indices.

**For objects that mimic AbstractArray but are not subtypes**

has_offset_axesdepends on havingaxesdefined for the objects you call it on. If there is some reason you
don't have anaxesmethod defined for your object, consider defining a method

```

Base.has_offset_axes(obj::MyNon1IndexedArraylikeObject)= true

```
This will allow code that assumes 1-based indexing to detect a problem and throw a helpful error, rather than
returning incorrect results or segfaulting julia.

**Catching errors**

If your new array type triggers errors in other code, one helpful debugging step can be to comment out
@boundscheckin yourgetindexandsetindex!implementation. This will ensure that every element access
checks bounds. Or, restart julia with--check-bounds=yes.

In some cases it may also be helpful to temporarily disablesizeandlengthfor your new array type, since
code that makes incorrect assumptions frequently uses these functions.

### 98.19Module loading

Base.requireis responsible for loading modules and it also manages the precompilation cache. It is the
implementation of theimportstatement.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1328

### Experimental features

The features below are experimental and not part of the stable Julia API. Before building upon them inform
yourself about the current thinking and whether they might change soon.

**Module loading callbacks**

It is possible to listen to the modules loaded byBase.require, by registering a callback.

```

loaded_packages= Channel { Symbol }()  
callback= (mod:: Symbol ) -> put!(loaded_packages, mod)  
push!(Base.package_callbacks, callback)

```
Please note that the symbol given to the callback is a non-unique identifier and it is the responsibility of the
callback provider to walk the module chain to determine the fully qualified name of the loaded binding.

The callback below is an example of how to do that:

```

# Get the fully-qualified name of a module.

function module_fqn(name:: Symbol )  
fqn = fullname(Base.root_module(name))  
return join(fqn,'.')  
end

```
### 98.20Inference.

### How inference works

Type inferencerefers to the process of deducing the types of later values from the types of input values. Julia's
approach to inference has been described in blog posts (1, 2).

### Debugging compiler.jl

You can start a Julia session, editcompiler/*.jl(for example to insertprintstatements), and then replace
Core.Compilerinyourrunningsessionbynavigatingtobaseandexecutinginclude("compiler/compiler.jl").
This trick typically leads to much faster development than if you rebuild Julia for each change.

Alternatively,youcanusetheRevise.jlpackagetotrackthecompilerchangesbyusingthecommandRevise.track(Core.Compiler)
at the beginning of your Julia session. As explained in theRevise documentation, the modifications to the com-
piler will be reflected when the modified files are saved.

A convenient entry point into inference istypeinf_code. Here 's a demo running inference onconvert(Int,
UInt(1)):

```

# Get the method

atypes= Tuple { Type { Int }, UInt } # argument types  
mths= methods(convert, atypes) # worth checking that there is only one  
m = first(mths)

# Create variables needed to call `typeinf_code`

interp= Core.Compiler.NativeInterpreter()  
sparams= Core.svec() # this particular method doesn't have type-parameters  
optimize= true # run all inference optimizations  
types= Tuple {typeof(convert), atypes.parameters...} # Tuple{typeof(convert), Type{Int}, UInt}  
Core.Compiler.typeinf_code(interp, m, types, sparams, optimize)

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1329

IfyourdebuggingadventuresrequireaMethodInstance,youcanlookitupbycallingCore.Compiler.specialize_method
using many of the variables above. ACodeInfoobject may be obtained with

```

# Returns the CodeInfo object for `convert(Int, ::UInt)`:

ci = (@code_typedconvert( Int , UInt (1)))[1]

```
### The inlining algorithm (inline_worthy)

Much of the hardest work for inlining runs ininlining_pass. However, if your question is"why didn't my
functioninline?"thenyouwillmostlikelybeinterestedinisinlineableanditsprimarycallee,inline_worthy.
isinlineablehandles a number of special cases (e.g., critical functions likenextanddone, incorporating a
bonus for functions that return tuples, etc.). The main decision-making happens ininline_worthy, which
returnstrueif the function should be inlined.

inline_worthyimplements a cost-model, where"cheap" functions get inlined; more specifically, we inline
functions if their anticipated run-time is not large compared to the time it would take toissue a callto them if
they were not inlined. The cost-model is extremely simple and ignores many important details: for example,
allforloops are analyzed as if they will be executed once, and the cost of anif...else...endincludes the
summed cost of all branches. It's also worth acknowledging that we currently lack a suite of functions suitable
for testing how well the cost model predicts the actual run-time cost, althoughBaseBenchmarksprovides a
great deal of indirect information about the successes and failures of any modification to the inlining algorithm.

The foundation of the cost-model is a lookup table, implemented inadd_tfuncand its callers, that assigns
an estimated cost (measured in CPU cycles) to each of Julia's intrinsic functions. These costs are based on
standard ranges for common architectures(see Agner Fog's analysisfor more detail).

Wesupplementthislow-levellookuptablewithanumberofspecialcases. Forexample, an:invokeexpression
(a call for which all input and output types were inferred in advance) is assigned a fixed cost (currently 20
cycles). In contrast, a:callexpression, for functions other than intrinsics/builtins, indicates that the call will
require dynamic dispatch, in which case we assign a cost set byParams.inline_nonleaf_penalty(currently
set at 1000). Note that this is not a"first-principles" estimate of the raw cost of dynamic dispatch, but a mere
heuristic indicating that dynamic dispatch is extremely expensive.

Each statement gets analyzed for its total cost in a function calledstatement_cost. You can display the cost
associated with each statement as follows:

```

julia> Base.print_statement_costs(stdout, map, (typeof(sqrt), Tuple { Int },))# map(sqrt, (2,))  
map(f, t::Tuple{Any}) in Base at tuple.jl:179  
0 1 ─ %1 = Base.getfield(_3, 1, true)::Int64  
1 │ %2 = Base.sitofp(Float64, %1)::Float64  
2 │ %3 = Base.lt_float(%2, 0.0)::Bool  
0 └── goto #3 if not %3  
0 2 ─ invoke Base.Math.throw_complex_domainerror(:sqrt::Symbol, %2::Float64)::Union{}  
0 └── unreachable  
20 3 ─ %7 = Base.Math.sqrt_llvm(%2)::Float64  
0 └── goto #4  
0 4 ─ goto #5  
0 5 ─ %10 = Core.tuple(%7)::Tuple{Float64}  
0 └── return %10

```
Thelinecostsareintheleftcolumn. Thisincludestheconsequencesofinliningandotherformsofoptimization.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1330

### 98.21Julia SSA-form IR.

### Background

Beginning in Julia 0.7, parts of the compiler use a newSSA-formintermediate representation. Historically,
the compiler used to directly generate LLVM IR, from a lowered form of the Julia AST. This form had most
syntactic abstractions removed, but still looked a lot like an abstract syntax tree. Over time, in order to
facilitate optimizations, SSA values were introduced to this IR and the IR was linearized (i.e. a form where
function arguments may only be SSA values or constants). However, non-SSA values (slots) remained in the
IR due to the lack of Phi nodes in the IR (necessary for back-edges and re-merging of conditional control flow),
negating much of the usefulness of the SSA form representation to perform middle end optimizations. Some
heroic effort was put into making these optimizations work without a complete SSA form representation, but
the lack of such a representation ultimately proved prohibitive.

### New IR nodes

With the new IR representation, the compiler learned to handle four new IR nodes, Phi nodes, Pi nodes as well
as PhiC nodes and Upsilon nodes (the latter two are only used for exception handling).

**Phi nodes and Pi nodes**

Phi nodes are part of generic SSA abstraction (see the link above if you're not familiar with the concept). In
the Julia IR, these nodes are represented as:

```

struct PhiNode  
edges::Vector{Int}  
values::Vector{Any}  
end

```
where we ensure that both vectors always have the same length. In the canonical representation (the one
handled by codegen and the interpreter), the edge values indicate come-from statement numbers (i.e. if edge
has an entry of 15 , there must be agoto,gotoifnotor implicit fall through from statement 15 that targets
this phi node). Values are either SSA values or constants. It is also possible for a value to be unassigned if the
variable was not defined on this path. However, undefinedness checks get explicitly inserted and represented
as booleans after middle end optimizations, so code generators may assume that any use of a Phi node will
have an assigned value in the corresponding slot. It is also legal for the mapping to be incomplete, i.e. for a Phi
node to have missing incoming edges. In that case, it must be dynamically guaranteed that the corresponding
value will not be used.

PiNodes encode statically proven information that may be implicitly assumed in basic blocks dominated by a
given pi node. They are conceptually equivalent to the technique introduced in the paperABCD: Eliminating
Array Bounds Checks on Demandor the predicate info nodes in LLVM. To see how they work, consider, e.g.

```

%x:: Union { Int , Float64 } # %x is some Union{Int, Float64} typed ssa value  
if isa(x, Int )

# use x

else

# use x

end

```
We can perform predicate insertion and turn this into:

```

%x:: Union { Int , Float64 } # %x is some Union{Int, Float64} typed ssa value  
if isa(x, Int )

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1331

```

%x_int= PiNode(x, Int )

# use %x_int

else  
%x_float= PiNode(x, Float64 )

# use %x_float

end

```
Pi nodes are generally ignored in the interpreter, since they don't have any effect on the values, but they may
sometimes lead to code generation in the compiler (e.g. to change from an implicitly union split representation
to a plain unboxed representation). The main usefulness of PiNodes stems from the fact that path conditions of
the values can be accumulated simply by def-use chain walking that is generally done for most optimizations
that care about these conditions anyway.

**PhiC nodes and Upsilon nodes**

Exception handling complicates the SSA story moderately, because exception handling introduces additional
control flow edges into the IR across which values must be tracked. One approach to do so, which is followed
by LLVM is to make calls which may throw exceptions into basic block terminators and add an explicit control
flow edge to the catch handler:

```

invoke @function_that_may_throw() to label %regular unwind to %catch

regular:

# Control flow continues here

catch:

# Exceptions go here

```
However, this is problematic in a language like julia where at the start of the optimization pipeline, we do
not know which calls throw. We would have to conservatively assume that every call (which in julia is every
statement) throws. This would have several negative effects. On the one hand, it would essentially reduce the
scopeofeverybasicblocktoasinglecall,defeatingthepurposeofhavingoperationsbeperformedatthebasic
block level. On the other hand, every catch basic block would haven*mphi node arguments (n, the number of
statements in the critical region,mthe number of live values through the catch block). To work around this, we
use a combination ofUpsilonandPhiC(the C standing forcatch, writtenφᶜin the IR pretty printer, because
unicode subscript c is not available) nodes. There are several ways to think of these nodes, but perhaps the
easiest is to think of eachPhiCas a load from a unique store-many, read-once slot, withUpsilonbeing the
corresponding store operation. ThePhiChas an operand list of all the upsilon nodes that store to its implicit
slot. TheUpsilonnodes however, do not record whichPhiCnode they store to. This is done for more natural
integration with the rest of the SSA IR. E.g. if there are no more uses of aPhiCnode, it is safe to delete it, and
the same is true of anUpsilonnode. In most IR passes,PhiCnodes can be treated likePhinodes. One can
follow use-def chains through them, and they can be lifted to newPhiCnodes and newUpsilonnodes (in the
same places as the originalUpsilonnodes). The result of this scheme is that the number ofUpsilonnodes
(andPhiCarguments) is proportional to the number of assigned values to a particular variable (before SSA
conversion), rather than the number of statements in the critical region.

To see this scheme in action, consider the function

```

@noinlineopaque()= invokelatest(identity,nothing) # Something opaque  
function foo()  
local y  
x = 1  
try  
y = 2

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1332

```

opaque()  
y = 3  
error()  
catch  
end  
(x, y)  
end

```
The corresponding IR (with irrelevant types stripped) is:

```

1 ─ nothing::Nothing  
2 ─ %2 = $(Expr(:enter, #4))  
3 ─ %3 = Υ (false)│  
%4 = Υ (#undef)│  
%5 = Υ (1)│  
%6 = Υ (true)│  
%7 = Υ (2)│  
invoke Main.opaque()::Any│  
%9 = Υ (true)│  
%10 = Υ (3)│  
invoke Main.error()::Union{}└──  
$(Expr(:unreachable))::Union{}  
4 ┄ %13 = φᶜ (%3, %6, %9)::Bool│  
%14 = φᶜ (%4, %7, %10)::Core.Compiler.MaybeUndef(Int64)│  
%15 = φᶜ (%5)::Core.Const(1)└──  
$(Expr(:leave, 1))  
5 ─ $(Expr(:pop_exception, :(%2)))::Any│  
$(Expr(:throw_undef_if_not, :y, :(%13)))::Any│  
%19 = Core.tuple(%15, %14)└──  
return %19

```
Note in particular that every value live into the critical region gets an upsilon node at the top of the critical
region. This is because catch blocks are considered to have an invisible control flow edge from outside the
function. As a result, no SSA value dominates the catch blocks, and all incoming values have to come through
aφᶜnode.

### Main SSA data structure

The mainSSAIRdata structure is worthy of discussion. It draws inspiration from LLVM and Webkit's B3 IR. The
core of the data structure is a flat vector of statements. Each statement is implicitly assigned an SSA value
based on its position in the vector (i.e. the result of the statement at idx 1 can be accessed usingSSAValue(1)
etc). For each SSA value, we additionally maintain its type. Since, SSA values are definitionally assigned
only once, this type is also the result type of the expression at the corresponding index. However, while this
representationisratherefficient(sincetheassignmentsdon'tneedtobeexplicitlyencoded),itofcoursecarries
the drawback that order is semantically significant, so reorderings and insertions change statement numbers.
Additionally, we do not keep use lists (i.e. it is impossible to walk from a def to all its uses without explicitly
computing this map–def lists however are trivial since you can look up the corresponding statement from the
index), so the LLVM-style RAUW (replace-all-uses-with) operation is unavailable.

Instead, we do the following:

- We keep a separate buffer of nodes to insert (including the position to insert them at, the type of the
    corresponding value and the node itself). These nodes are numbered by their occurrence in the insertion
    buffer, allowing their values to be immediately used elsewhere in the IR (i.e. if there are 12 statements
    in the original statement list, the first new statement will be accessible asSSAValue(13)).


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1333

- RAUW style operations are performed by setting the corresponding statement index to the replacement
    value.
- Statements are erased by setting the corresponding statement tonothing(this is essentially just a
    special-case convention of the above.
- If there are any uses of the statement being erased, they will be set tonothing.

There is acompact!function that compacts the above data structure by performing the insertion of nodes in
the appropriate place, trivial copy propagation, and renaming of uses to any changed SSA values. However,
the clever part of this scheme is that this compaction can be done lazily as part of the subsequent pass. Most
optimization passes need to walk over the entire list of statements, performing analysis or modifications along
the way. We provide anIncrementalCompactiterator that can be used to iterate over the statement list. It
will perform any necessary compaction and return the new index of the node, as well as the node itself. It is
legal at this point to walk def-use chains, as well as make any modifications or deletions to the IR (insertions
are disallowed however).

The idea behind this arrangement is that, since the optimization passes need to touch the corresponding
memory anyway and incur the corresponding memory access penalty, performing the extra housekeeping
should have comparatively little overhead (and save the overhead of maintaining these data structures during
IR modification).

### 98.22 Static analyzer annotations for GC correctness in C code

### Running the analysis

The analyzer plugin that drives the anlysis ships with julia. Its source code can be found insrc/clangsa.
Running it requires the clang dependency to be build. Set theBUILD_LLVM_CLANGvariable in your Make.user
in order to build an appropriate version of clang. You may also want to use the prebuilt binaries using the
USE_BINARYBUILDER_LLVMoptions. Afterwards, running the analysis over the source tree is as simple as run-
ningmake -C src analyzegc.

### General Overview

SinceJulia'sGCisprecise, itneedstomaintaincorrectrootinginformationforanyvaluethatmaybereferenced
at any time GC may occur. These places are known assafepointsand in the function local context, we extend
this designation to any function call that may recursively end up at a safepoint.

In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC
rooting in the LLVM codegen devdocs). However, in C code, we need to inform the runtime of any GC roots
manually. This is done using the following macros:

```

// The value assigned to any slot passed as an argument to these  
// is rooted for the duration of this GC frame.  
JL_GC_PUSH{1,...,6}(args...)  
// The values assigned into the size `n` array `rts` are rooted  
// for the duration of this GC frame.  
JL_GC_PUSHARGS(rts, n)  
// Pop a GC frame  
JL_GC_POP

```
If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory
corruption. As such it is very important that they are placed correctly in all applicable code.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1334

Assuch, weemploystaticanalysis(andinparticulartheclangstaticanalyzer)tohelpensurethatthesemacros
are used correctly. The remainder of this document gives an overview of this static analysis and describes the
support needed in the julia code base to make things work.

### GC Invariants

There is two simple invariants correctness:

- AllGC_PUSHcallsneedtobefollowedbyanappropriateGC_POP(inpracticeweenforcethisatthefunction
    level)
- If a value was previously not rooted at any safepoint, it may no longer be referenced afterwards

Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need
to know:

- Which calls are safepoints and which are not
- Which values are rooted at any given safepoint and which are not
- When is a value referenced

For the second point in particular, we need to know which memory locations will be considered rooting at
runtime (i.e. values assigned to such locations are rooted). This includes locations explicitly designated as
such by passing them to one of theGC_PUSHmacros, globally rooted locations and values, as well as any
location recursively reachable from one of those locations.

### Static Analysis Algorithm

The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a
large number of special cases and intricacies of C and C++). In essence, we keep track of all locations that are
rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness
of any rootable values. Then, at any safepoint, we perform a"symbolic GC" and poison any values that are
not rooted at said location. If these values are later referenced, we emit an error.

The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors.
Severalnodesinthisgrapharegeneratedbytheanalyzeritself(e.g. forcontrolflow), butthedefinitionsabove
augment this graph with our own state.

The static analyzer is interprocedural and can analyze control flow across function boundaries. However, the
static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally
some calls are cross-translation unit and invisible to the analyzer). In our case, our definition of correctness
requires total information. As such, we need to annotate the prototypes of all function calls with whatever
information the analysis required, even if that information would otherwise be available by interprocedural
static analysis.

Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a
given function are indeed correct given the implementation of said function.

### The analyzer annotations

These annotations are found in src/support/analyzer_annotations.h. The are only active when the analyzer is
beingusedandexpandeithertonothing(forprototypeannotations)ortono-ops(forfunctionlikeannotations).


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1335

#### JL_NOTSAFEPOINT

This is perhaps the most common annotation, and should be placed on any function that is known not to
possibly lead to reaching a GC safepoint. In general, it is only safe for such a function to perform arithmetic,
memory accesses and calls to functions either annotatedJL_NOTSAFEPOINTor otherwise known not to be
safepoints (e.g. function in the C standard library, which are hardcoded as such in the analyzer)

It is valid to keep values unrooted across calls to any function annotated with this attribute:

Usage Example:

```

void jl_get_one() JL_NOTSAFEPOINT {  
return 1;  
}

jl_value_t *example() {  
jl_value_t *val = jl_alloc_whatever();  
// This is valid, even though `val` is unrooted, because  
// jl_get_one is not a safepoint  
jl_get_one();  
return val;  
}

```
#### JL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY

WhenJL_MAYBE_UNROOTEDis annotated as an argument on a function, indicates that said argument may be
passed, even if it is not rooted. In the ordinary course of events, the julia ABI guarantees that callers root
values before passing them to callees. However, some functions do not follow this ABI and allow values to be
passed to them even though they are not rooted. Note however, that this does not automatically imply that
said argument will be preserved. TheROOTS_TEMPORARILYannotation provides the stronger guarantee that,
not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by
the callee.

NotethatJL_NOTSAFEPOINTessentiallyimpliesJL_MAYBE_UNROOTED/JL_ROOTS_TEMPORARILY,becausetheroot-
edness of an argument is irrelevant if the function contains no safepoints.

One additional point to note is that these annotations apply on both the caller and the callee side. On the caller
side, they lift rootedness restrictions that are normally required for julia ABI functions. On the callee side, they
have the reverse effect of preventing these arguments from being considered implicitly rooted.

If either of these annotations is applied to the function as a whole, it applies to all arguments of the function.
This should generally only be necessary for varargs functions.

Usage example:

```

JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);  
jl_value_t *jl_alloc_error();

void example() {  
// The return value of the allocation is unrooted. This would normally  
// be an error, but is allowed because of the above annotation.  
jl_throw(jl_alloc_error());  
}

```
#### JL_PROPAGATES_ROOT

This annotation is commonly found on accessor functions that return one rootable object stored within another.
When annotated on a function argument, it tells the analyzer that the root for that argument also applies to
the value returned by the function.


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1336

Usage Example:

```

jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;

size_t example(jl_svec_t *svec) {  
jl_value_t *val = jl_svecref(svec, 1)  
// This is valid, because, as annotated by the PROPAGATES_ROOT annotation,  
// jl_svecref propagates the rooted-ness from `svec` to `val`  
jl_gc_safepoint();  
return jl_unbox_long(val);  
}

```
#### JL_ROOTING_ARGUMENT/JL_ROOTED_ARGUMENT

This is essentially the assignment counterpart toJL_PROPAGATES_ROOT. When assigning a value to a field of
another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.

Usage Example:

```

void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT

size_t example(jl_svec_t *svec) {  
jl_value_t *val = jl_box_long(10000);  
jl_svecset(svec, val);  
// This is valid, because the annotations imply that the  
// jl_svecset propagates the rooted-ness from `svec` to `val`  
jl_gc_safepoint();  
return jl_unbox_long(val);  
}

```
#### JL_GC_DISABLED

This annotation implies that this function is only called with the GC runtime-disabled. Functions of this kind are
most often encountered during startup and in the GC code itself. Note that this annotation is checked against
the runtime enable/disable calls, so clang will know if you lie. This is not a good way to disable processing of
a given function if the GC is not actually disabled (useifdef __clang_analyzer__for that if you must).

Usage example:

```

void jl_do_magic() JL_GC_DISABLED {  
// Wildly allocate here with no regard for roots  
}

void example() {  
int en = jl_gc_enable(0);  
jl_do_magic();  
jl_gc_enable(en);  
}

```
#### JL_REQUIRE_ROOTED_SLOT

Thisannotationrequiresthecallertopassinaslotthatisrooted(i.e. valuesassignedtothisslotwillberooted).

Usage example:


#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1337

```

void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {  
*slot = jl_box_long(1);  
// Ok, only, because the slot was annotated as rooting  
jl_gc_safepoint();  
}

void example() {  
jl_value_t *slot = NULL;  
JL_GC_PUSH1(&slot);  
jl_do_processing(&slot);  
JL_GC_POP();  
}

```
#### JL_GLOBALLY_ROOTED

This annotation implies that a given value is always globally rooted. It can be applied to global variable decla-
rations, in which case it will apply to the value of those variables (or values if the declaration if for an array),
or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always
return some private, globally rooted value).

Usage example:

```

extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;  
jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;

```
#### JL_ALWAYS_LEAFTYPE

This annotations is essentially equivalent toJL_GLOBALLY_ROOTED, except that is should only be used if those
values are globally rooted by virtue of being a leaftype. The rooting of leaftypes is a bit complicated. They are
generally rooted throughcachefield of the correspondingTypeName, which itself is rooted by the containing
module (so they're rooted as long as the containing module is ok) and we can generally assume that leaftypes
are rooted where they are used, but we may refine this property in the future, so the separate annotation helps
split out the reason for being globally rooted.

The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots
on these paths.

```

JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;

```
#### JL_GC_PROMISE_ROOTED

This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope
of the current function. It is designed as an escape hatch for analyzer inadequacy or complicated situations.
However, it should be used sparingly, in favor of improving the analyzer itself.

```

void example() {  
jl_value_t *val = jl_alloc_something();  
if (some_condition) {  
// We happen to know for complicated external reasons  
// that val is rooted under these conditions  
JL_GC_PROMISE_ROOTED(val);  
}  
}

```

#### CHAPTER 98. DOCUMENTATION OF JULIA’S INTERNALS 1338

### Completeness of analysis

The analyzer only looks at local information. In particular, e.g. in thePROPAGATES_ROOTcase above, it assumes
that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide
to consider them in its analysis) and not in any concurrently running threads. As such, it may miss a few
problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to
handle more such cases may be an interesting topic for future work.


**Chapter 99**

**Developing/debugging Julia’s C code**

### 99.1 Reporting and analyzing crashes (segfaults)

So you managed to break Julia. Congratulations! Collected here are some general procedures you can un-
dergo for common symptoms encountered when something goes awry. Including the information from these
debugging steps can greatly help the maintainers when tracking down a segfault or trying to figure out why
your script is running slower than expected.

If you 've been directed to this page, find the symptom that best matches what you're experiencing and follow
the instructions to generate the debugging information requested. Table of symptoms:

- Segfaults during bootstrap (sysimg.jl)
- Segfaults when running a script
- Errors during Julia startup
- Other generic segfaults or unreachables reached

### Version/Environment info

No matter the error, we will always need to know what version of Julia you are running. When Julia first starts
up, a header is printed out with a version number and date. Please also include the output ofversioninfo()
(exported from theInteractiveUtilsstandard library) in any report you create:

```

julia>using InteractiveUtils

julia> versioninfo()  
Julia Version 1.7.2  
Commit bf53498635 (2022-02-06 15:21 UTC)  
Platform Info:  
OS: Linux (x86_64-pc-linux-gnu)  
CPU: Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz  
WORD_SIZE: 64  
LIBM: libopenlibm  
LLVM: libLLVM-12.0.1 (ORCJIT, skylake-avx512)  
Environment:  
JULIA_DOCS = /home/runner/work/docs.julialang.org/docs.julialang.org/pdf/build/docs.julialang.org

```
#### 1339


#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1340

```

JULIA_EXECUTABLE =  
/home/runner/work/docs.julialang.org/docs.julialang.org/pdf/build/julia-1.7.2-linux-  
x86_64/bin/julia

↪→  
↪→  
JULIA_SOURCE = /home/runner/work/docs.julialang.org/docs.julialang.org/pdf/build/julia

```
### Segfaults during bootstrap (sysimg.jl)

Segfaults toward the end of themakeprocess of building Julia are a common symptom of something going
wrong while Julia is preparsing the corpus of code in thebase/folder. Many factors can contribute toward this
process dying unexpectedly, however it is as often as not due to an error in the C-code portion of Julia, and as
such must typically be debugged with a debug build inside ofgdb. Explicitly:

Create a debug build of Julia:

```

$ cd <julia_root>  
$ make debug

```
Notethat this processwill likelyfailwith the same erroras a normalmakeincantation, howeverthis will createa
debugexecutablethatwilloffergdbthedebuggingsymbolsneededtogetaccuratebacktraces. Next,manually
run the bootstrap process inside ofgdb:

```

$ cd base/  
$ gdb -x ../contrib/debug_bootstrap.gdb

```
Thiswillstartgdb, attempttorunthebootstrapprocessusingthedebugbuildofJulia, andprintoutabacktrace
if (when) it segfaults. You may need to hit<enter>a few times to get the full backtrace. Create agist with
the backtrace, theversion info, and any other pertinent information you can think of and open a newissue on
Github with a link to the gist.

### Segfaults when running a script

The procedure is very similar toSegfaults during bootstrap (sysimg.jl). Create a debug build of Julia, and run
your script inside of a debugged Julia process:

```

$ cd <julia_root>  
$ make debug  
$ gdb --args usr/bin/julia-debug <path_to_your_script>

```
Note thatgdbwill sit there, waiting for instructions. Typerto run the process, andbtto generate a backtrace
once it segfaults:

```

(gdb) r  
Starting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl  
...  
(gdb) bt

```
Create agist with the backtrace, theversion info, and any other pertinent information you can think of and
open a newissue on Github with a link to the gist.

### Errors during Julia startup

Occasionally errors occur during Julia's startup process (especially when using binary distributions, as opposed
to compiling from source) such as the following:

```

$ julia  
exec: error-5

```

#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1341

These errors typically indicate something is not getting loaded properly very early on in the bootup phase, and
our best bet in determining what's going wrong is to use external tools to audit the disk activity of thejulia
process:

- On Linux, usestrace:
    $ strace julia
- On OSX, usedtruss:
    $ dtruss -f julia

Create agist with thestrace/dtrussoutput, theversion info, and any other pertinent information and open
a new issue on Github with a link to the gist.

### Other generic segfaults or unreachables reached

As mentioned elsewhere,juliahas good integration withrrfor generating traces; this includes, on Linux, the
ability to automatically runjuliaunderrrand share the trace after a crash. This can be immensely helpful
when debugging such crashes and is strongly encouraged when reporting crash issues to the JuliaLang/julia
repo. To runjuliaunderrrautomatically, do:

```

julia--bug-report=rr

```
To generate therrtrace locally, but not share, you can do:

```

julia--bug-report=rr- local

```
Note that this is only works on Linux. The blog post onTime Travelling Bug Reportinghas many more details.

### Glossary

A few terms have been used as shorthand in this guide:

- <julia_root>refers to the root directory of the Julia source tree; e.g. it should contain folders such as
    base,deps,src,test, etc.....

### 99.2 gdb debugging tips

### Displaying Julia variables

Withingdb, anyjl_value_t*objectobjcan be displayed using

```

(gdb) call jl_(obj)

```
The object will be displayed in thejuliasession, not in the gdb session. This is a useful way to discover the
types and values of objects being manipulated by Julia's C code.

Similarly, if you're debugging some of Julia's internals (e.g.,compiler.jl), you can printobjusing

```

ccall (:jl_, Cvoid, ( Any ,), obj)

```

#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1342

This is a good way to circumvent problems that arise from the order in which julia's output streams are initial-
ized.

Julia'sflispinterpreterusesvalue_tobjects;thesecanbedisplayedwithcall fl_print(fl_ctx, ios_stdout,
obj).

### Useful Julia variables for Inspecting

While the addresses of many variables, like singletons, can be useful to print for many failures, there are a
number of additional variables (seejulia.hfor a complete list) that are even more useful.

- (when injl_apply_generic)mfuncandjl_uncompress_ast(mfunc->def, mfunc->code):: for figur-
    ing out a bit about the call-stack
- jl_linenoandjl_filename:: for figuring out what line in a test to go start debugging from (or figure
    out how far into a file has been parsed)
- $1:: not really a variable, but still a useful shorthand for referring to the result of the last gdb command
    (such asprint)
- jl_options:: sometimes useful, since it lists all of the command line options that were successfully
    parsed
- jl_uv_stderr:: because who doesn't like to be able to interact with stdio

### Useful Julia functions for Inspecting those variables

- jl_gdblookup($rip):: For looking up the current function and line. (use$eipon i686 platforms)
- jlbacktrace():: FordumpingthecurrentJuliabacktracestacktostderr. Onlyusableafterrecord_backtrace()
    has been called.
- jl_dump_llvm_value(Value*):: ForinvokingValue->dump()ingdb,whereitdoesn'tworknatively. For
    example,f->linfo->functionObject,f->linfo->specFunctionObject,andto_function(f->linfo).
- Type->dump():: only works in lldb. Note: add something like;1to prevent lldb from printing its prompt
    over the output
- jl_eval_string("expr"):: for invoking side-effects to modify the current state or to lookup symbols
- jl_typeof(jl_value_t*):: for extracting the type tag of a Julia value (in gdb, callmacro define
    jl_typeof jl_typeoffirst, or pick something short liketyfor the first arg to define a shorthand)

### Inserting breakpoints for inspection from gdb

In yourgdbsession, set a breakpoint injl_breakpointlike so:

```

(gdb) break jl_breakpoint

```
Then within your Julia code, insert a call tojl_breakpointby adding

```

ccall (:jl_breakpoint, Cvoid, ( Any ,), obj)

```
whereobjcan be any variable or tuple you want to be accessible in the breakpoint.

It's particularly helpful to back up to thejl_applyframe, from which you can display the arguments to a
function using, e.g.,


#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1343

```

(gdb) call jl_(args[0])

```
Anotherusefulframeisto_function(jl_method_instance_t *li, bool cstyle). Thejl_method_instance_t*
argument is a struct with a reference to the final AST sent into the compiler. However, the AST at this point
will usually be compressed; to view the AST, calljl_uncompress_astand then pass the result tojl_:

```

#2 0x00007ffff7928bf7 in to_function (li=0x2812060, cstyle=false) at codegen.cpp:584  
584 abort();  
(gdb) p jl_(jl_uncompress_ast(li, li->ast))

```
### Inserting breakpoints upon certain conditions

**Loading a particular file**

Let 's say the file issysimg.jl:

```

(gdb) break jl_load if strcmp(fname, "sysimg.jl")==0

```
**Calling a particular method**

```

(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), "  
method_to_break")==0

```
Since this function is used for every call, you will make everything 1000x slower if you do this.

### Dealing with signals

Juliarequiresafewsignaltofunctionproperty. TheprofilerusesSIGUSR2forsamplingandthegarbagecollector
usesSIGSEGVfor threads synchronization. If you are debugging some code that uses the profiler or multiple
threads, you may want to let the debugger ignore these signals since they can be triggered very often during
normal operations. The command to do this in GDB is (replaceSIGSEGVwithSIGUSRSor other signals you want
to ignore):

```

(gdb) handle SIGSEGV noprint nostop pass

```
The corresponding LLDB command is (after the process is started):

```

(lldb) pro hand -p true -s false -n false SIGSEGV

```
Ifyouaredebuggingasegfaultwiththreadedcode,youcansetabreakpointonjl_critical_error(sigdie_handler
shouldalsoworkonLinuxandBSD)inordertoonlycatchtheactualsegfaultratherthantheGCsynchronization
points.

### Debugging during Julia's build process (bootstrap)

Errors that occur duringmakeneed special handling. Julia is built in two stages, constructingsys0andsys.ji.
To see what commands are running at the time of failure, usemake VERBOSE=1.

At the time of this writing, you can debug build errors during thesys0phase from thebasedirectory using:

```

julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl

```
You might need to delete all the files inusr/lib/julia/to get this to work.

You can debug thesys.jiphase using:

```

julia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/  
julia/sys0.ji sysimg.jl

```

#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1344

By default, any errors will cause Julia to exit, even under gdb. To catch an error"in the act", set a breakpoint
injl_error(there are several other useful spots, for specific kinds of failures, including:jl_too_few_args,
jl_too_many_args, andjl_throw).

Once an error is caught, a useful technique is to walk up the stack and examine the function by inspecting the
related call tojl_apply. To take a real-world example:

```

Breakpoint 1, jl_throw (e=0x7ffdf42de400) at task.c:802  
802 {  
(gdb) p jl_(e)  
ErrorException("auto_unbox: unable to determine argument type")  
$2 = void  
(gdb) bt 10  
#0 jl_throw (e=0x7ffdf42de400) at task.c:802  
#1 0x00007ffff65412fe in jl_error (str=0x7ffde56be000 <_j_str267> "auto_unbox:  
unable to determine argument type")  
at builtins.c:39  
#2 0x00007ffde56bd01a in julia_convert_16886 ()  
#3 0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281  
...

```
The most recentjl_applyis at frame #3, so we can go back there and look at the AST for the function
julia_convert_16886. Thisistheuniquednameforsomemethodofconvert.finthisframeisajl_function_t*,
so we can look at the type signature, if any, from thespecTypesfield:

```

(gdb) f 3  
#3 0x00007ffff6541154 in jl_apply (f=0x7ffdf367f630, args=0x7fffffffc2b0, nargs=2) at julia.h:1281  
1281 return f->fptr((jl_value_t*)f, args, nargs);  
(gdb) p f->linfo->specTypes  
$4 = (jl_tupletype_t *) 0x7ffdf39b1030  
(gdb) p jl_( f->linfo->specTypes )  
Tuple{Type{Float32}, Float64} # <-- type signature for julia_convert_16886

```
Then, we can look at the AST for this function:

```

(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )  
Expr(:lambda, Array{Any, 1}[:#s29, :x], Array{Any, 1}[Array{Any, 1}[], Array{Any, 1}[Array{Any,  
1}[:#s29, :Any, 0], Array{Any, 1}[:x, :Any, 0]], Array{Any, 1}[], 0], Expr(:body,  
Expr(:line, 90, :float.jl)::Any,  
Expr(:return, Expr(:call, :box, :Float32, Expr(:call, :fptrunc, :Float32, :x)::Any)::Any)::Any)::Any  
)::Any

```
Finally, and perhaps most usefully, we can force the function to be recompiled in order to step through the
codegen process. To do this, clear the cachedfunctionObjectfrom thejl_lamdbda_info_t*:

```

(gdb) p f->linfo->functionObject  
$8 = (void *) 0x1289d070  
(gdb) set f->linfo->functionObject = NULL

```
Then,setabreakpointsomewhereuseful(e.g.emit_function,emit_expr,emit_call,etc.),andruncodegen:

```

(gdb) p jl_compile(f)  
... # your breakpoint here

```
### Debugging precompilation errors

Module precompilation spawns a separate Julia process to precompile each module. Setting a breakpoint or
catching failures in a precompile worker requires attaching a debugger to the worker. The easiest approach is
to set the debugger watch for new process launches matching a given name. For example:


#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1345

```

(gdb) attach -w -n julia-debug

```
or:

```

(lldb) process attach -w -n julia-debug

```
Then run a script/command to start precompilation. As described earlier, use conditional breakpoints in the
parent process to catch specific file-loading events and narrow the debugging window. (some operating sys-
tems may require alternative approaches, such as following eachforkfrom the parent process)

### Mozilla's Record and Replay Framework (rr)

Julia now works out of the box withrr , the lightweight recording and deterministic debugging framework from
Mozilla. This allows you to replay the trace of an execution deterministically. The replayed execution's address
spaces, register contents, syscall data etc are exactly the same in every run.

A recent version of rr (3.1.0 or higher) is required.

**Reproducing concurrency bugs with rr**

rr simulates a single-threaded machine by default. In order to debug concurrent code you can userr record
--chaoswhich will cause rr to simulate between one to eight cores, chosen randomly. You might therefore
want to setJULIA_NUM_THREADS=8and rerun your code under rr until you have caught your bug.

### 99.3 Using Valgrind with Julia.

Valgrindis a tool for memory debugging, memory leak detection, and profiling. This section describes things
to keep in mind when using Valgrind to debug memory issues with Julia.

### General considerations

By default, Valgrind assumes that there is no self modifying code in the programs it runs. This assumption
works fine in most instances but fails miserably for a just-in-time compiler likejulia. For this reason it is
crucial to pass--smc-check=all-non-filetovalgrind, else code may crash or behave unexpectedly (often
in subtle ways).

In some cases, to better detect memory errors using Valgrind it can help to compilejuliawith memory pools
disabled. The compile-time flagMEMDEBUGdisables memory pools in Julia, andMEMDEBUG2disables memory
pools in FemtoLisp. To buildjuliawith both flags, add the following line toMake.user:

```

CFLAGS= -DMEMDEBUG-DMEMDEBUG2

```
Another thing to note: if your program uses multiple workers processes, it is likely that you want all such
worker processes to run under Valgrind, not just the parent process. To do this, pass--trace-children=yes
tovalgrind.

### Suppressions

Valgrind will typically display spurious warnings as it runs. To reduce the number of such warnings, it helps to
provide asuppressions fileto Valgrind. A sample suppressions file is included in the Julia source distribution at
contrib/valgrind-julia.supp.

The suppressions file can be used from thejulia/source directory as follows:

```

$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl

```

#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1346

Any memory errors that are displayed should either be reported as bugs or contributed as additional suppres-
sions. Note that some versions of Valgrind areshipped with insufficient default suppressions, so that may be
one thing to consider before submitting any bugs.

### Running the Julia test suite under Valgrind

It is possible to run the entire Julia test suite under Valgrind, but it does take quite some time (typically several
hours). To do so, run the following command from thejulia/test/directory:

```

valgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia  
.supp ../julia runtests.jl all

```
If you would like to see a report of"definite" memory leaks, pass the flags--leak-check=full --show-leak-
kinds=definitetovalgrindas well.

### Caveats

Valgrind currentlydoes not support multiple rounding modes, so code that adjusts the rounding mode will
behave differently when run under Valgrind.

In general, if after setting--smc-check=all-non-fileyou find that your program behaves differently when
run under Valgrind, it may help to pass--tool=nonetovalgrindas you investigate further. This will enable
the minimal Valgrind machinery but will also run much faster than when the full memory checker is enabled.

### 99.4 Sanitizer support

### General considerations

Using Clang's sanitizers obviously require you to use Clang (USECLANG=1), but there's another catch: most
sanitizers require a run-time library, provided by the host compiler, while the instrumented code generated
by Julia's JIT relies on functionality from that library. This implies that the LLVM version of your host compiler
matches that of the LLVM library used within Julia.

An easy solution is to have an dedicated build folder for providing a matching toolchain, by building with
BUILD_LLVM_CLANG=1. You can then refer to this toolchain from another build folder by specifyingUSECLANG=1
while overriding theCCandCXXvariables.

To use one of of the sanitizers setSANITIZE=1and then the appropriate flag for the sanitizer you want to use.

On macOS, this might need some extra flags also to work. Altogether, it might look like this, plus one or more
of theSANITIZE_*flags listed below:

```

make -C deps USE_BINARYBUILDER_LLVM=0 LLVM_VER=svn stage-llvm

make -C src SANITIZE=1 USECLANG=1  
CC=~+/deps/scratch/llvm-svn/build_Release/bin/clang  
CXX=~+/deps/scratch/llvm-svn/build_Release/bin/clang++  
CPPFLAGS="-isysroot $(xcode-select -p)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk"  
CXXFLAGS="-isystem $(xcode-select -p)/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1"

```
(or put these into yourMake.user, so you don't need to remember them every time).

### Address Sanitizer (ASAN)

For detecting or debugging memory bugs, you can use Clang's address sanitizer (ASAN). By compiling with
SANITIZE_ADDRESS=1you enable ASAN for the Julia compiler and its generated code. In addition, you can


#### CHAPTER 99. DEVELOPING/DEBUGGING JULIA’S C CODE 1347

specifyLLVM_SANITIZE=1tosanitizetheLLVMlibraryaswell. Notethattheseoptionsincurahighperformance
and memory cost. For example, using ASAN for Julia and LLVM makestestall1takes 8-10 times as long while
using 20 times as much memory (this can be reduced to respectively a factor of 3 and 4 by using the options
described below).

By default, Julia sets theallow_user_segv_handler=1ASAN flag, which is required for signal delivery to work
properly. You can define other options using theASAN_OPTIONSenvironment flag, in which case you'll need
to repeat the default option mentioned before. For example, memory usage can be reduced by specifying
fast_unwind_on_malloc=0andmalloc_context_size=2, at the cost of backtrace accuracy. For now, Julia
also setsdetect_leaks=0, but this should be removed in the future.

### Memory Sanitizer (MSAN)

For detecting use of uninitialized memory, you can use Clang's memory sanitizer (MSAN)by compiling with
SANITIZE_MEMORY=1.

### Thread Sanitizer (TSAN)

For debugging data-races and other threading related issues you can use Clang's thread sanitizer (TSAN)by
compiling withSANITIZE_THREAD=1.


**Part V**

**Julia v1.7 Release Notes**

#### 1348


**Chapter 100**

**New language features**

- (; a, b) = xcan now be used to destructure propertiesaandbofx. This syntax is equivalent toa =
    getproperty(x, :a); b = getproperty(x, :b)(#39285).
- Implicit multiplication by juxtaposition is now allowed for radical symbols (e.g.x√yandx∛y) ( #40173).
- The short-circuiting operators&&and||can now be dotted to participate in broadcast fusion as.&&and
    .||(#39594).
- (U+2AEA,\Top,\downvDash) and (U+2AEB,\Bot,\upvDash,\indep) may now be used as binary
    operators with comparison precedence (#39403).
- Repeated semicolons can now be used inside array concatenation expressions to separate dimensions
    of an array, with the number of semicolons specifying the dimension. Just as a single semicolon in[A;
    B]has always described concatenating in the first dimension (vertically), now two semicolons[A;; B]
    do so in the second dimension (horizontally), three semicolons;;;in the third, and so on (#33697).
- A backslash (\) before a newline inside a string literal now removes the newline while also respect-
    ing indentation. This can be used to split up long strings without newlines into multiple lines of code
    (#40753).
- A backslash before a newline in command literals now always removes the newline, similar to standard
    string literals, whereas the result was not well-defined before (#40753).
- Thedefaultbehaviorofobserving@inboundsdeclarationsisnowanoptionviaautoin--check-bounds=yes|no|auto
    (#41551)

#### 1349


**Chapter 101**

**Language changes**

- macroexpand,@macroexpand, and@macroexpand1no longer wrap errors in aLoadError. To reduce
    breakage,@test_throwshas been modified so that many affected tests will still pass (#38379).
- The middle dot·(\cdotpU+00b7) and the Greek interpunct·(U+0387) are now treated as equivalent
    to the dot operator⋅(\cdotU+22c5) (#25157).
- The minus sign−(\minusU+2212) is now treated as equivalent to the hyphen-minus sign-(U+002d)
    (#40948).
- Destructuring will no longer mutate values on the left-hand side while iterating through values on the
    right-hand side. In the example of an arrayx,x[2], x[1] = xwill now swap the first and second
    elements ofx, whereas it used to fill both entries withx[1]becausex[2]was mutated during the
    iteration ofx(#40737).
- The default random number generator has changed, so all random numbers will be different (even with
    the same seed) unless an explicit RNG object is used. See the section on theRandomstandard library
    below (#40546).
- Iterators.peel(itr)now returnsnothingwhenitris empty instead of throwing aBoundsError
    (#39607).
- Multiple successive semicolons in an array expresion were previously ignored (e.g.,[1 ;; 2] == [1 ;
    2]). This syntax is now used to separate dimensions (see **New language features** ).
- UnbalancedUnicodebidirectionalformattingdirectivesarenowdisallowedwithinstringsandcomments,
    to mitigate the"trojan source" vulnerability (#42918).

#### 1350


**Chapter 102**

**Compiler/Runtime improvements**

#### 1351


**Chapter 103**

**Command-line option changes**

- The Julia--projectoption and theJULIA_PROJECTenvironment variable now support selecting shared
    environments like.julia/environments/myenvthe same way the package management console does:
    usejulia --project=@myenvresp.export JULIA_PROJECT="@myenv"(#40025).

#### 1352


**Chapter 104**

**Multi-threading changes**

- Intrinsics for atomic pointer operations are now defined for certain byte sizes (#37847).
- Support for declaring and using individual fields of a mutable struct as atomic has been added; see the
    new@atomicmacro (#37847).
- If theJULIA_NUM_THREADSenvironment variable is set toauto, then the number of threads will be set
    to the number of CPU threads (#38952).
- EveryTaskobjecthasalocalrandomnumbergeneratorstate,providingreproducible(schedule-independent)
    execution of parallel simulation code by default. The default generator is also significantly faster in par-
    allel than in previous versions (#40546).
- Tasks can now migrate among threads when they are re-scheduled. Previously, a Task would always run
    on whichever thread executed it first (#40715).

#### 1353


**Chapter 105**

**Build system changes**

#### 1354


**Chapter 106**

**New library functions**

- Two argument methodsfindmax(f, domain),argmax(f, domain)and the correspondingminversions
    (#35316).
- isunordered(x)returnstrueifxisavaluethatisnormallyunordered,suchasNaNormissing(#35316).
- Newkeepat!(vector, inds)function which is the inplace equivalent ofvector[inds]for a listinds
    of integers (#36229).
- Two arguments methodlock(f, lck)now accepts aChannelas the second argument (#39312).
- New functorReturns(value), which returnsvaluefor any arguments (#39794).
- Newmacros@somethingand@coalescewhichareshort-circuitingversionsofsomethingandcoalesce,
    respectively (#40729).
- New functionredirect_stdiofor redirectingstdin,stdoutandstderr(#37978).
- NewmacroBase.@invoke f(arg1::T1, arg2::T2; kwargs...)providesaneasiersyntaxtocallinvoke(f,
    Tuple{T1,T2}, arg1, arg2; kwargs...)(#38438).
- NewmacroBase.@invokelatest f(args...; kwargs...)providingaconvenientwaytocallBase.invokelatest(f,
    args...; kwargs...)(#37971).

#### 1355


**Chapter 107**

**New library features**

- The optional keyword argumentcontextofsprintcan now be set to a tuple of:key => valuepairs to
    specify multiple attributes (#39381).
- bytes2hexandhex2bytesarenolongerlimitedtoargumentsoftypeUnion{String,AbstractVector{UInt8}}
    and now only require that they're iterable and have a length (#39710).
- stat(file)now has a more detailed and user-friendlyshowmethod (#39463).

#### 1356


**Chapter 108**

**Standard library changes**

- countandfindallnowacceptanAbstractCharargumenttosearchforacharacterinastring(#38675).
- New methodsrange(start, stop)andrange(start, stop, length)(#39228).
- rangenow supportsstartas an optional keyword argument (#38041).
- Some operations on ranges will return aStepRangeLeninstead of aStepRange, to allow the resulting
    step to be zero. Previously,λ .* (1:9)gave an error whenλ = 0(#40320).
- islowercaseandisuppercasearenowcompliantwiththeUnicodelower/uppercasecategories(#38574).
- isevenandisoddfunctions now support non-Integernumeric types (#38976).
- escape_stringnow accepts a collection of characters via the keywordkeepthat are to be kept as they
    are ( #38597).
- getindexforNamedTuples now accepts a tuple of symbols in order to index multiple values (#38878).
- Subtypes ofAbstractRangenow correctly follow the general array indexing behavior when indexed
    byBools, erroring for scalarBools and treating arrays (including ranges) ofBoolas logical indices
    (#31829).
- keys(::RegexMatch)is now defined to return the capture's keys, by name if named, or by index if not
    (#37299).
- keys(::Generator)is now defined to return the iterator's keys (#34678).
- RegexMatchis now iterable, giving the captured substrings (#34355).
- lpad/rpadare now defined in terms oftextwidth(#39044).
- Test.@testnowacceptsbrokenandskipbooleankeywordarguments,whichmimicTest.@test_broken
    andTest.@test_skipbehavior, but allows skipping tests failing only under certain conditions. For ex-
    ample

```

if T == Float64  
@test_brokenisequal(complex(one(T))/ complex(T(Inf), T(-Inf)), complex(zero(T),  
↪→ zero(T)))  
else  
@testisequal(complex(one(T))/ complex(T(Inf), T(-Inf)), complex(zero(T), zero(T)))  
end

can be replaced by

```
#### 1357


#### CHAPTER 108. STANDARD LIBRARY CHANGES 1358

```

@testisequal(complex(one(T))/ complex(T(Inf), T(-Inf)), complex(zero(T), zero(T))) broken=(T  
↪→ == Float64 )

(#39322).

```
- @lockis now exported from Base (#39588).
- The experimental functionBase.catch_stack()has been renamed tocurrent_exceptions(), ex-
    ported from Base and given a more specific return type (#29901).
- Some degree trigonometric functions,sind,cosd,tand,asind,acosd,asecd,acscd,acotd,atandnow
    accept a square matrix (#39758).
- replace(::String)now accepts multiple patterns, which will be applied left-to-right simultaneously,
    so only one pattern will be applied to any character, and the patterns will only be applied to the input
    text, not the replacements (#40484).
- Thelengthfunctiononcertainrangesofcertainspecificelementtypesnolongerchecksforintegerover-
    flow in most cases. The new functionchecked_lengthis now available, which will try to use checked
    arithmetic to error if the result may be wrapping. Or use a package such as SaferIntegers.jl when con-
    structing the range. (#40382)
- Newreplacemethods to replace elements of aTuple(#38216).

### Package Manager

- Ifapackageisusingorimportedfromthejulia>promptthatisn'tfoundbutisavailablefromaregistry,
    apkg> addprompt now offers to install the package into the current environment, precompile it, and
    continue to load it (#39026).
- A newManifest.tomlformat is now used that captures extensible metadata fields, including the julia
    version that generated the manifest. Old format manifests are still supported and will be maintained
    in their original format, unless the user runsPkg.upgrade_manifest()to upgrade the format of the
    current environment's manifest without re-resolving (#40765).
- pkg> precompilewill now precompile new versions of packages that are already loaded, rather than
    postponing to the next session (the?-marked dependencies) (#40345).
- pkg> rm,pin, andfreenow accept the--allargument to call the action on all packages.
- Registries downloaded from the Pkg Server (not git) are no longer uncompressed into files but instead
    read directly from the compressed tarball into memory. This improves performance on filesystems
    which do not handle a large number of files well. To turn this feature off, set the environment variable
    JULIA_PKG_UNPACK_REGISTRY=true.
- Itisnowpossibletouseanexternalgitexecutableinsteadofthedefaultlibgit2libraryforthedownloads
    that happen via the Git protocol by setting the environment variableJULIA_PKG_USE_CLI_GIT=true.
- Registries downloaded from the Pkg Server (not git) is now assumed to be immutable. Manual changes
    to their files might not be picked up by a running Pkg session.
- Adding packages by directory name in the REPL mode now requires prepending./to the name if the
    package is in the current directory; e.g.add ./Packageis required instead ofadd Package. This is to
    avoid confusion between the package namePackageand the local directoryPackage.
- Themodekeyword forPackageSpechas been removed.


#### CHAPTER 108. STANDARD LIBRARY CHANGES 1359

### LinearAlgebra

- Use Libblastrampolineto pick a BLAS and LAPACK at runtime. By default it forwards to OpenBLAS in the
    Julia distribution. The forwarding mechanism can be used by packages to replace the BLAS and LAPACK
    with user preferences (#39455).
- On aarch64, OpenBLAS now uses an ILP64 BLAS like all other 64-bit platforms (#39436).
- OpenBLAS is updated to 0.3.13 (#39216).
- SuiteSparse is updated to 5.8.1 (#39455).
- The shape of anUpperHessenbergmatrix is preserved under certain arithmetic operations, e.g. when
    multiplying or dividing by anUpperTriangularmatrix (#40039).
- Real quasitriangular Schur factorizationsScan now be efficiently converted to complex upper-triangular
    form withSchur{Complex}(S)(#40573).
- cis(A)now supports matrix arguments (#40194).
- dotnow supportsUniformScalingwithAbstractMatrix(#40250).
- qr[!] andlu[!] now supportLinearAlgebra.PivotingStrategy(singleton type) values as their
    optionalpivotargument: defaults areqr(A, NoPivot())(vs.qr(A, ColumnNorm())for pivoting) and
    lu(A, RowMaximum())(vs.lu(A, NoPivot())without pivoting); the formerVal{true/false}-based
    calls are deprecated (#40623).
- det(M::AbstractMatrix{BigInt})now callsdet_bareiss(M), which uses theBareissalgorithm to cal-
    culate precise values (#40868).

### Markdown

### Printf

### Random

- The default random number generator has been changed from Mersenne Twister toXoshiro256++. The
    new generator has smaller state, better performance, and superior statistical properties. This generator
    is the one used for reproducible Task-local randomness (#40546).

### REPL

- Long strings are now elided using the syntax"head" ⋯ 12345 bytes ⋯ "tail"when displayed in the
    REPL ( #40736).
- Pasting repl examples into the repl (prompt pasting) now supports all repl modes (julia,pkg,shell,
    help?) and switches mode automatically (#40604).
- help?>for modules without docstrings now returns a list of exported names and prints the contents of
    an associatedREADME.mdif found (#39093).


#### CHAPTER 108. STANDARD LIBRARY CHANGES 1360

### SparseArrays

- newsizehint!(::SparseMatrixCSC, ::Integer)method (#30676).
- cholesky()now fully preserves the user-specified permutation (#40560).
- issparsenow applies consistently to all wrapper arrays, including nested, by checkingissparseon the
    wrapped parent array (#37644).

### Dates

- TheDates.periodsfunction can be used to get theVectorofPeriods that comprise aCompoundPeriod
    (#39169).

### Downloads

- If a cookie header is set in a redirected request, the cookie will now be sent in following requests
    (https://github.com/JuliaLang/Downloads.jl/pull/98).
- If a~/.netrcfile exists, it is used to get passwords for authenticated websites (https://github.com/Ju-
    liaLang/Downloads.jl/pull/98).
- Server Name Indicationis now sent with all TLS connections, even when the server's identity is not
    verified (seeNetworkOptions; https://github.com/JuliaLang/Downloads.jl/pull/114).
- When verifying TLS connections on Windows, if the certificate revocation server cannot be reached, the
    connection is allowed; this matches what other applications do and how revocation is performed on
    macOS (https://github.com/JuliaLang/Downloads.jl/pull/115).
- There is now a 30-second connection timeout and a 20-second timeout if no data is sent; in combination,
    this guarantees that connections must make some progress or they will timeout in under a minute
    (https://github.com/JuliaLang/Downloads.jl/pull/126).

### Statistics

### Sockets

### Tar

- Tar.extractnowignorestheexactpermissionmodeinatarballandnormalizesmodesinthesameway
    thatTar.createdoes, which is, in turn the same way thatgitnormalizes them (https://github.com/Ju-
    liaIO/Tar.jl/pull/99).
- Functions that consume tarballs now handle hard links: the link target must be a previously seen file;
    Tar.listlists the entry with:hardlinktype and.linkfield giving the path to the target; other func-
    tions —Tar.extract,Tar.rewrite,Tar.tree_hash— treat a hard link as a copy of the target file
    (https://github.com/JuliaIO/Tar.jl/pull/102).
- The standard format generated byTar.createandTar.rewritenow includes entries for non-empty
    directories; this shouldn't be neccessary, but some tools that consume tarballs (including docker) are
    confused by the absence of these directory entries (https://github.com/JuliaIO/Tar.jl/pull/106).
- Tarnow accepts tarballs with leading spaces in octal integer header fields: this is technically not a valid
    format according to the POSIX spec, but old Solaristarcommands produced tarballs like this so this for-
    mat does occur in the wild, and it seems harmless to accept it (https://github.com/JuliaIO/Tar.jl/pull/116).


#### CHAPTER 108. STANDARD LIBRARY CHANGES 1361

- Tar.extractnow takes aset_permissionskeyword argument, which defaults totrue; iffalseis
    passed instead, the permissions of extracted files are not modified on extraction (https://github.com/Ju-
    liaIO/Tar.jl/pull/113).

### Distributed

### UUIDs

### Mmap

- mmapis now exported (#39816).

### DelimitedFiles

- readdlmnow defaults touse_mmap=falseon all OSes for consistent reliability in abnormal filesystem
    situations (#40415).


**Chapter 109**

**Deprecated or removed**

#### 1362


**Chapter 110**

**External dependencies**

#### 1363


**Chapter 111**

**Tooling Improvements**

#### 1364


```

---

1.  Numbered footnote text. [↩](https://pdf2md.morethan.io/#fnref1)
    

This is a offline tool, your data stays locally and is not send to any server!

[Feedback & Bug Reports](https://github.com/jzillmann/pdf-to-markdown/issues)